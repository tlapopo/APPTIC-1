webpackJsonp([132],[
/* 0 */,
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__sites_factory__ = __webpack_require__(420);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__configconstants__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_ts_md5_dist_md5__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__angular_common__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};















/*
 * Service to manage and interact with sites.
 * It allows creating tables in the databases of all sites. Each service or component should be responsible of creating
 * their own database tables. Example:
 *
 * constructor(sitesProvider: CoreSitesProvider) {
 *     this.sitesProvider.createTableFromSchema(this.tableSchema);
 *
 * This provider will automatically create the tables in the databases of all the instantiated sites, and also to the
 * databases of sites instantiated from now on.
*/
var CoreSitesProvider = /** @class */ (function () {
    function CoreSitesProvider(logger, http, sitesFactory, appProvider, translate, urlUtils, eventsProvider, textUtils, location, utils) {
        this.http = http;
        this.sitesFactory = sitesFactory;
        this.appProvider = appProvider;
        this.translate = translate;
        this.urlUtils = urlUtils;
        this.eventsProvider = eventsProvider;
        this.textUtils = textUtils;
        this.location = location;
        this.utils = utils;
        // Variables for the database.
        this.SITES_TABLE = 'sites';
        this.CURRENT_SITE_TABLE = 'current_site';
        this.SCHEMA_VERSIONS_TABLE = 'schema_versions';
        this.appTablesSchema = [
            {
                name: this.SITES_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'siteUrl',
                        type: 'TEXT',
                        notNull: true
                    },
                    {
                        name: 'token',
                        type: 'TEXT'
                    },
                    {
                        name: 'info',
                        type: 'TEXT'
                    },
                    {
                        name: 'privateToken',
                        type: 'TEXT'
                    },
                    {
                        name: 'config',
                        type: 'TEXT'
                    },
                    {
                        name: 'loggedOut',
                        type: 'INTEGER'
                    }
                ]
            },
            {
                name: this.CURRENT_SITE_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'siteId',
                        type: 'TEXT',
                        notNull: true,
                        unique: true
                    }
                ]
            }
        ];
        // Constants to validate a site version.
        this.VALID_VERSION = 1;
        this.LEGACY_APP_VERSION = 0;
        this.INVALID_VERSION = -1;
        this.services = {};
        this.sessionRestored = false;
        this.sites = {};
        this.siteSchemasMigration = {};
        // Schemas for site tables. Other providers can add schemas in here.
        this.siteSchemas = {};
        this.siteTablesSchemas = [
            {
                name: this.SCHEMA_VERSIONS_TABLE,
                columns: [
                    {
                        name: 'name',
                        type: 'TEXT',
                        primaryKey: true,
                    },
                    {
                        name: 'version',
                        type: 'INTEGER'
                    }
                ]
            }
        ];
        // Site schema for this provider.
        this.siteSchema = {
            name: 'CoreSitesProvider',
            version: 1,
            canBeCleared: [__WEBPACK_IMPORTED_MODULE_12__classes_site__["a" /* CoreSite */].WS_CACHE_TABLE],
            tables: [
                {
                    name: __WEBPACK_IMPORTED_MODULE_12__classes_site__["a" /* CoreSite */].WS_CACHE_TABLE,
                    columns: [
                        {
                            name: 'id',
                            type: 'TEXT',
                            primaryKey: true
                        },
                        {
                            name: 'data',
                            type: 'TEXT'
                        },
                        {
                            name: 'key',
                            type: 'TEXT'
                        },
                        {
                            name: 'expirationTime',
                            type: 'INTEGER'
                        }
                    ]
                },
                {
                    name: __WEBPACK_IMPORTED_MODULE_12__classes_site__["a" /* CoreSite */].CONFIG_TABLE,
                    columns: [
                        {
                            name: 'name',
                            type: 'TEXT',
                            unique: true,
                            notNull: true
                        },
                        {
                            name: 'value'
                        }
                    ]
                }
            ]
        };
        this.logger = logger.getInstance('CoreSitesProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTablesFromSchema(this.appTablesSchema);
        this.registerSiteSchema(this.siteSchema);
    }
    /**
     * Get the demo data for a certain "name" if it is a demo site.
     *
     * @param {string} name Name of the site to check.
     * @return {any} Site data if it's a demo site, undefined otherwise.
     */
    CoreSitesProvider.prototype.getDemoSiteData = function (name) {
        var demoSites = __WEBPACK_IMPORTED_MODULE_11__configconstants__["a" /* CoreConfigConstants */].demo_sites;
        if (typeof demoSites != 'undefined' && typeof demoSites[name] != 'undefined') {
            return demoSites[name];
        }
    };
    /**
     * Check if a site is valid and if it has specifics settings for authentication (like force to log in using the browser).
     * It will test both protocols if the first one fails: http and https.
     *
     * @param {string} siteUrl URL of the site to check.
     * @param {string} [protocol=https://] Protocol to use first.
     * @return {Promise<CoreSiteCheckResponse>} A promise resolved when the site is checked.
     */
    CoreSitesProvider.prototype.checkSite = function (siteUrl, protocol) {
        var _this = this;
        if (protocol === void 0) { protocol = 'https://'; }
        // The formatURL function adds the protocol if is missing.
        siteUrl = this.urlUtils.formatURL(siteUrl);
        if (!this.urlUtils.isHttpURL(siteUrl)) {
            return Promise.reject(this.translate.instant('core.login.invalidsite'));
        }
        else if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        else {
            return this.checkSiteWithProtocol(siteUrl, protocol).catch(function (error) {
                // Do not continue checking if a critical error happened.
                if (error.critical) {
                    return Promise.reject(error.error);
                }
                // Retry with the other protocol.
                protocol = protocol == 'https://' ? 'http://' : 'https://';
                return _this.checkSiteWithProtocol(siteUrl, protocol).catch(function (secondError) {
                    if (secondError.critical) {
                        return Promise.reject(secondError.error);
                    }
                    // Site doesn't exist. Return the error message.
                    return Promise.reject(_this.textUtils.getErrorMessageFromError(error) ||
                        _this.textUtils.getErrorMessageFromError(secondError) ||
                        _this.translate.instant('core.cannotconnect'));
                });
            });
        }
    };
    /**
     * Helper function to check if a site is valid and if it has specifics settings for authentication.
     *
     * @param {string} siteUrl URL of the site to check.
     * @param {string} protocol Protocol to use.
     * @return {Promise<CoreSiteCheckResponse>} A promise resolved when the site is checked.
     */
    CoreSitesProvider.prototype.checkSiteWithProtocol = function (siteUrl, protocol) {
        var _this = this;
        var publicConfig;
        // Now, replace the siteUrl with the protocol.
        siteUrl = siteUrl.replace(/^http(s)?\:\/\//i, protocol);
        return this.siteExists(siteUrl).catch(function (error) {
            // Do not continue checking if WS are not enabled.
            if (error.errorcode == 'enablewsdescription') {
                return rejectWithCriticalError(error.error, error.errorcode);
            }
            // Site doesn't exist. Try to add or remove 'www'.
            var treatedUrl = _this.urlUtils.addOrRemoveWWW(siteUrl);
            return _this.siteExists(treatedUrl).then(function () {
                // Success, use this new URL as site url.
                siteUrl = treatedUrl;
            }).catch(function (secondError) {
                // Do not continue checking if WS are not enabled.
                if (secondError.errorcode == 'enablewsdescription') {
                    return rejectWithCriticalError(secondError.error, secondError.errorcode);
                }
                // Return the error message.
                return Promise.reject(_this.textUtils.getErrorMessageFromError(error) ||
                    _this.textUtils.getErrorMessageFromError(secondError));
            });
        }).then(function () {
            // Create a temporary site to check if local_mobile is installed.
            var temporarySite = _this.sitesFactory.makeSite(undefined, siteUrl);
            return temporarySite.checkLocalMobilePlugin().then(function (data) {
                data.service = data.service || __WEBPACK_IMPORTED_MODULE_11__configconstants__["a" /* CoreConfigConstants */].wsservice;
                _this.services[siteUrl] = data.service; // No need to store it in DB.
                if (data.coreSupported ||
                    (data.code != __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].LOGIN_SSO_CODE && data.code != __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].LOGIN_SSO_INAPP_CODE)) {
                    // SSO using local_mobile not needed, try to get the site public config.
                    return temporarySite.getPublicConfig().then(function (config) {
                        publicConfig = config;
                        // Check that the user can authenticate.
                        if (!config.enablewebservices) {
                            return rejectWithCriticalError(_this.translate.instant('core.login.webservicesnotenabled'));
                        }
                        else if (!config.enablemobilewebservice) {
                            return rejectWithCriticalError(_this.translate.instant('core.login.mobileservicesnotenabled'));
                        }
                        else if (config.maintenanceenabled) {
                            var message = _this.translate.instant('core.sitemaintenance');
                            if (config.maintenancemessage) {
                                message += config.maintenancemessage;
                            }
                            return rejectWithCriticalError(message);
                        }
                        // Everything ok.
                        if (data.code === 0) {
                            data.code = config.typeoflogin;
                        }
                        return data;
                    }, function (error) {
                        // Error, check if not supported.
                        if (error.available === 1) {
                            // Service supported but an error happened. Return error.
                            return Promise.reject({ error: error.error });
                        }
                        return data;
                    });
                }
                return data;
            }).then(function (data) {
                siteUrl = temporarySite.getURL();
                return { siteUrl: siteUrl, code: data.code, warning: data.warning, service: data.service, config: publicConfig };
            });
        });
        // Return a rejected promise with a "critical" error.
        function rejectWithCriticalError(message, errorCode) {
            return Promise.reject({
                error: message,
                errorcode: errorCode,
                critical: true
            });
        }
    };
    /**
     * Check if a site exists.
     *
     * @param  {string} siteUrl URL of the site to check.
     * @return {Promise} A promise to be resolved if the site exists.
     */
    CoreSitesProvider.prototype.siteExists = function (siteUrl) {
        var _this = this;
        return this.http.post(siteUrl + '/login/token.php', {}).timeout(__WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise().catch(function () {
            // Default error messages are kinda bad, return our own message.
            return Promise.reject({ error: _this.translate.instant('core.cannotconnect') });
        }).then(function (data) {
            if (data.errorcode && (data.errorcode == 'enablewsdescription' || data.errorcode == 'requirecorrectaccess')) {
                return Promise.reject({ errorcode: data.errorcode, error: data.error });
            }
            else if (data.error && data.error == 'Web services must be enabled in Advanced features.') {
                return Promise.reject({ errorcode: 'enablewsdescription', error: data.error });
            }
            // Other errors are not being checked because invalid login will be always raised and we cannot differ them.
        });
    };
    /**
     * Gets a user token from the server.
     *
     * @param {string} siteUrl The site url.
     * @param {string} username User name.
     * @param {string} password Password.
     * @param {string} [service] Service to use. If not defined, it will be searched in memory.
     * @param {boolean} [retry] Whether we are retrying with a prefixed URL.
     * @return {Promise<CoreSiteUserTokenResponse>} A promise resolved when the token is retrieved.
     */
    CoreSitesProvider.prototype.getUserToken = function (siteUrl, username, password, service, retry) {
        var _this = this;
        if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        if (!service) {
            service = this.determineService(siteUrl);
        }
        var params = {
            username: username,
            password: password,
            service: service
        }, loginUrl = siteUrl + '/login/token.php', promise = this.http.post(loginUrl, params).timeout(__WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
        return promise.then(function (data) {
            if (typeof data == 'undefined') {
                return Promise.reject(_this.translate.instant('core.cannotconnect'));
            }
            else {
                if (typeof data.token != 'undefined') {
                    return { token: data.token, siteUrl: siteUrl, privateToken: data.privatetoken };
                }
                else {
                    if (typeof data.error != 'undefined') {
                        // We only allow one retry (to avoid loops).
                        if (!retry && data.errorcode == 'requirecorrectaccess') {
                            siteUrl = _this.urlUtils.addOrRemoveWWW(siteUrl);
                            return _this.getUserToken(siteUrl, username, password, service, true);
                        }
                        else if (data.errorcode == 'missingparam') {
                            // It seems the server didn't receive all required params, it could be due to a redirect.
                            return _this.utils.checkRedirect(loginUrl).then(function (redirect) {
                                if (redirect) {
                                    return Promise.reject({ error: _this.translate.instant('core.login.sitehasredirect') });
                                }
                                else {
                                    return Promise.reject({ error: data.error, errorcode: data.errorcode });
                                }
                            });
                        }
                        else if (typeof data.errorcode != 'undefined') {
                            return Promise.reject({ error: data.error, errorcode: data.errorcode });
                        }
                        else {
                            return Promise.reject(data.error);
                        }
                    }
                    else {
                        return Promise.reject(_this.translate.instant('core.login.invalidaccount'));
                    }
                }
            }
        }, function () {
            return Promise.reject(_this.translate.instant('core.cannotconnect'));
        });
    };
    /**
     * Add a new site to the site list and authenticate the user in this site.
     *
     * @param {string} siteUrl The site url.
     * @param {string} token User's token.
     * @param {string} [privateToken=''] User's private token.
     * @param {boolean} [login=true] Whether to login the user in the site. Defaults to true.
     * @return {Promise<string>} A promise resolved with siteId when the site is added and the user is authenticated.
     */
    CoreSitesProvider.prototype.newSite = function (siteUrl, token, privateToken, login) {
        var _this = this;
        if (privateToken === void 0) { privateToken = ''; }
        if (login === void 0) { login = true; }
        if (typeof login != 'boolean') {
            login = true;
        }
        // Create a "candidate" site to fetch the site info.
        var candidateSite = this.sitesFactory.makeSite(undefined, siteUrl, token, undefined, privateToken), isNewSite = true;
        return candidateSite.fetchSiteInfo().then(function (info) {
            var result = _this.isValidMoodleVersion(info);
            if (result == _this.VALID_VERSION) {
                var siteId_1 = _this.createSiteID(info.siteurl, info.username);
                // Check if the site already exists.
                return _this.getSite(siteId_1).catch(function () {
                    // Not exists.
                }).then(function (site) {
                    if (site) {
                        // Site already exists, update its data and use it.
                        isNewSite = false;
                        candidateSite = site;
                        candidateSite.setToken(token);
                        candidateSite.setPrivateToken(privateToken);
                        candidateSite.setInfo(info);
                    }
                    else {
                        // New site, set site ID and info.
                        isNewSite = true;
                        candidateSite.setId(siteId_1);
                        candidateSite.setInfo(info);
                        // Create database tables before login and before any WS call.
                        return _this.migrateSiteSchemas(candidateSite);
                    }
                }).then(function () {
                    // Try to get the site config.
                    return _this.getSiteConfig(candidateSite).catch(function (error) {
                        // Ignore errors if it's not a new site, we'll use the config already stored.
                        if (isNewSite) {
                            return Promise.reject(error);
                        }
                    }).then(function (config) {
                        if (typeof config != 'undefined') {
                            candidateSite.setConfig(config);
                        }
                        // Add site to sites list.
                        _this.addSite(siteId_1, siteUrl, token, info, privateToken, config);
                        _this.sites[siteId_1] = candidateSite;
                        if (login) {
                            // Turn candidate site into current site.
                            _this.currentSite = candidateSite;
                            // Store session.
                            _this.login(siteId_1);
                        }
                        _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SITE_ADDED, info, siteId_1);
                        return siteId_1;
                    });
                });
            }
            else if (result == _this.LEGACY_APP_VERSION) {
                var errorKey = 'core.login.legacymoodleversion', params = void 0;
                if (_this.appProvider.isDesktop()) {
                    errorKey += 'desktop';
                    params = { $a: siteUrl };
                }
                var error = _this.translate.instant(errorKey, params);
                if (_this.appProvider.isWindows() || _this.appProvider.isLinux()) {
                    error += _this.translate.instant('core.login.legacymoodleversiondesktopdownloadold');
                }
                return Promise.reject({
                    error: error,
                    errorcode: 'legacymoodleversion'
                });
            }
            else {
                return Promise.reject({
                    error: _this.translate.instant('core.login.invalidmoodleversion'),
                    errorcode: 'invalidmoodleversion'
                });
            }
        });
    };
    /**
     * Create a site ID based on site URL and username.
     *
     * @param {string} siteUrl The site url.
     * @param {string} username Username.
     * @return {string} Site ID.
     */
    CoreSitesProvider.prototype.createSiteID = function (siteUrl, username) {
        return __WEBPACK_IMPORTED_MODULE_13_ts_md5_dist_md5__["Md5"].hashAsciiStr(siteUrl + username);
    };
    /**
     * Function for determine which service we should use (default or extended plugin).
     *
     * @param {string} siteUrl The site URL.
     * @return {string} The service shortname.
     */
    CoreSitesProvider.prototype.determineService = function (siteUrl) {
        // We need to try siteUrl in both https or http (due to loginhttps setting).
        // First http://
        siteUrl = siteUrl.replace('https://', 'http://');
        if (this.services[siteUrl]) {
            return this.services[siteUrl];
        }
        // Now https://
        siteUrl = siteUrl.replace('http://', 'https://');
        if (this.services[siteUrl]) {
            return this.services[siteUrl];
        }
        // Return default service.
        return __WEBPACK_IMPORTED_MODULE_11__configconstants__["a" /* CoreConfigConstants */].wsservice;
    };
    /**
     * Check for the minimum required version.
     *
     * @param {any} info Site info.
     * @return {number} Either VALID_VERSION, LEGACY_APP_VERSION or INVALID_VERSION.
     */
    CoreSitesProvider.prototype.isValidMoodleVersion = function (info) {
        if (!info) {
            return this.INVALID_VERSION;
        }
        var version24 = 2012120300, // Moodle 2.4 version.
        release24 = '2.4', version31 = 2016052300, release31 = '3.1';
        // Try to validate by version.
        if (info.version) {
            var version = parseInt(info.version, 10);
            if (!isNaN(version)) {
                if (version >= version31) {
                    return this.VALID_VERSION;
                }
                else if (version >= version24) {
                    return this.LEGACY_APP_VERSION;
                }
                else {
                    return this.INVALID_VERSION;
                }
            }
        }
        // We couldn't validate by version number. Let's try to validate by release number.
        var release = this.getReleaseNumber(info.release || '');
        if (release) {
            if (release >= release31) {
                return this.VALID_VERSION;
            }
            if (release >= release24) {
                return this.LEGACY_APP_VERSION;
            }
        }
        // Couldn't validate it.
        return this.INVALID_VERSION;
    };
    /**
     * Returns the release number from site release info.
     *
     * @param  {string}  rawRelease Raw release info text.
     * @return {string}   Release number or empty.
     */
    CoreSitesProvider.prototype.getReleaseNumber = function (rawRelease) {
        var matches = rawRelease.match(/^\d(\.\d(\.\d+)?)?/);
        if (matches) {
            return matches[0];
        }
        return '';
    };
    /**
     * Check if site info is valid. If it's not, return error message.
     *
     * @param {any} info Site info.
     * @return {any} True if valid, object with error message to show and its params if not valid.
     */
    CoreSitesProvider.prototype.validateSiteInfo = function (info) {
        if (!info.firstname || !info.lastname) {
            var moodleLink = "<a core-link href=\"" + info.siteurl + "\">" + info.siteurl + "</a>";
            return { error: 'core.requireduserdatamissing', params: { $a: moodleLink } };
        }
        return true;
    };
    /**
     * Saves a site in local DB.
     *
     * @param {string} id Site ID.
     * @param {string} siteUrl Site URL.
     * @param {string} token User's token in the site.
     * @param {any} info Site's info.
     * @param {string} [privateToken=''] User's private token.
     * @param {any} [config] Site config (from tool_mobile_get_config).
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitesProvider.prototype.addSite = function (id, siteUrl, token, info, privateToken, config) {
        if (privateToken === void 0) { privateToken = ''; }
        var entry = {
            id: id,
            siteUrl: siteUrl,
            token: token,
            info: info ? JSON.stringify(info) : info,
            privateToken: privateToken,
            config: config ? JSON.stringify(config) : config,
            loggedOut: 0
        };
        return this.appDB.insertRecord(this.SITES_TABLE, entry);
    };
    /**
     * Login a user to a site from the list of sites.
     *
     * @param {string} siteId ID of the site to load.
     * @param {string} [pageName] Name of the page to go once authenticated if logged out. If not defined, site initial page.
     * @param {any} [params] Params of the page to go once authenticated if logged out.
     * @return {Promise<boolean>} Promise resolved with true if site is loaded, resolved with false if cannot login.
     */
    CoreSitesProvider.prototype.loadSite = function (siteId, pageName, params) {
        var _this = this;
        this.logger.debug("Load site " + siteId);
        return this.getSite(siteId).then(function (site) {
            _this.currentSite = site;
            if (site.isLoggedOut()) {
                // Logged out, trigger session expired event and stop.
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {
                    pageName: pageName,
                    params: params
                }, site.getId());
                return false;
            }
            // Check if local_mobile was installed to Moodle.
            return site.checkIfLocalMobileInstalledAndNotUsed().then(function () {
                // Local mobile was added. Throw invalid session to force reconnect and create a new token.
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {
                    pageName: pageName,
                    params: params
                }, siteId);
                return false;
            }, function () {
                _this.login(siteId);
                // Update site info. We don't block the UI.
                _this.updateSiteInfo(siteId);
                return true;
            });
        });
    };
    /**
     * Get current site.
     *
     * @return {CoreSite} Current site.
     */
    CoreSitesProvider.prototype.getCurrentSite = function () {
        return this.currentSite;
    };
    /**
     * Get the site home ID of the current site.
     *
     * @return {number} Current site home ID.
     */
    CoreSitesProvider.prototype.getCurrentSiteHomeId = function () {
        if (this.currentSite) {
            return this.currentSite.getSiteHomeId();
        }
        else {
            return 1;
        }
    };
    /**
     * Get current site ID.
     *
     * @return {string} Current site ID.
     */
    CoreSitesProvider.prototype.getCurrentSiteId = function () {
        if (this.currentSite) {
            return this.currentSite.getId();
        }
        else {
            return '';
        }
    };
    /**
     * Get current site User ID.
     *
     * @return {number} Current site User ID.
     */
    CoreSitesProvider.prototype.getCurrentSiteUserId = function () {
        if (this.currentSite) {
            return this.currentSite.getUserId();
        }
        else {
            return 0;
        }
    };
    /**
     * Check if the user is logged in a site.
     *
     * @return {boolean} Whether the user is logged in a site.
     */
    CoreSitesProvider.prototype.isLoggedIn = function () {
        return typeof this.currentSite != 'undefined' && typeof this.currentSite.token != 'undefined' &&
            this.currentSite.token != '';
    };
    /**
     * Delete a site from the sites list.
     *
     * @param {string} siteId ID of the site to delete.
     * @return {Promise<any>} Promise to be resolved when the site is deleted.
     */
    CoreSitesProvider.prototype.deleteSite = function (siteId) {
        var _this = this;
        this.logger.debug("Delete site " + siteId);
        if (typeof this.currentSite != 'undefined' && this.currentSite.id == siteId) {
            this.logout();
        }
        return this.getSite(siteId).then(function (site) {
            return site.deleteDB().then(function () {
                // Site DB deleted, now delete the app from the list of sites.
                delete _this.sites[siteId];
                return _this.appDB.deleteRecords(_this.SITES_TABLE, { id: siteId }).then(function () {
                    // Site deleted from sites list, now delete the folder.
                    return site.deleteFolder();
                }, function () {
                    // DB remove shouldn't fail, but we'll go ahead even if it does.
                    return site.deleteFolder();
                }).then(function () {
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SITE_DELETED, site, siteId);
                });
            });
        });
    };
    /**
     * Check if there are sites stored.
     *
     * @return {Promise<boolean>} Promise resolved with true if there are sites and false if there aren't.
     */
    CoreSitesProvider.prototype.hasSites = function () {
        return this.appDB.countRecords(this.SITES_TABLE).then(function (count) {
            return count > 0;
        });
    };
    /**
     * Returns a site object.
     *
     * @param {string} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise<CoreSite>} Promise resolved with the site.
     */
    CoreSitesProvider.prototype.getSite = function (siteId) {
        var _this = this;
        if (!siteId) {
            return this.currentSite ? Promise.resolve(this.currentSite) : Promise.reject(null);
        }
        else if (this.currentSite && this.currentSite.getId() == siteId) {
            return Promise.resolve(this.currentSite);
        }
        else if (typeof this.sites[siteId] != 'undefined') {
            return Promise.resolve(this.sites[siteId]);
        }
        else {
            // Retrieve and create the site.
            return this.appDB.getRecord(this.SITES_TABLE, { id: siteId }).then(function (data) {
                return _this.makeSiteFromSiteListEntry(data);
            });
        }
    };
    /**
     * Create a site from an entry of the sites list DB. The new site is added to the list of "cached" sites: this.sites.
     *
     * @param {any} entry Site list entry.
     * @return {Promise<CoreSite>} Promised resolved with the created site.
     */
    CoreSitesProvider.prototype.makeSiteFromSiteListEntry = function (entry) {
        var _this = this;
        var site, info = entry.info, config = entry.config;
        // Parse info and config.
        info = info ? this.textUtils.parseJSON(info) : info;
        config = config ? this.textUtils.parseJSON(config) : config;
        site = this.sitesFactory.makeSite(entry.id, entry.siteUrl, entry.token, info, entry.privateToken, config, entry.loggedOut == 1);
        return this.migrateSiteSchemas(site).then(function () {
            // Set site after migrating schemas, or a call to getSite could get the site while tables are being created.
            _this.sites[entry.id] = site;
            return site;
        });
    };
    /**
     * Returns if the site is the current one.
     *
     * @param {string|CoreSite} [site] Site object or siteId to be compared. If not defined, use current site.
     * @return {boolean} Whether site or siteId is the current one.
     */
    CoreSitesProvider.prototype.isCurrentSite = function (site) {
        if (!site || !this.currentSite) {
            return !!this.currentSite;
        }
        var siteId = typeof site == 'object' ? site.getId() : site;
        return this.currentSite.getId() === siteId;
    };
    /**
     * Returns the database object of a site.
     *
     * @param {string} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise<SQLiteDB>} Promise resolved with the database.
     */
    CoreSitesProvider.prototype.getSiteDb = function (siteId) {
        return this.getSite(siteId).then(function (site) {
            return site.getDb();
        });
    };
    /**
     * Returns the site home ID of a site.
     *
     * @param  {number} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise}         Promise resolved with site home ID.
     */
    CoreSitesProvider.prototype.getSiteHomeId = function (siteId) {
        return this.getSite(siteId).then(function (site) {
            return site.getSiteHomeId();
        });
    };
    /**
     * Get the list of sites stored.
     *
     * @param {String[]} [ids] IDs of the sites to get. If not defined, return all sites.
     * @return {Promise<CoreSiteBasicInfo[]>} Promise resolved when the sites are retrieved.
     */
    CoreSitesProvider.prototype.getSites = function (ids) {
        var _this = this;
        return this.appDB.getAllRecords(this.SITES_TABLE).then(function (sites) {
            var formattedSites = [];
            sites.forEach(function (site) {
                if (!ids || ids.indexOf(site.id) > -1) {
                    // Parse info.
                    var siteInfo = site.info ? _this.textUtils.parseJSON(site.info) : site.info, basicInfo = {
                        id: site.id,
                        siteUrl: site.siteUrl,
                        fullName: siteInfo && siteInfo.fullname,
                        siteName: __WEBPACK_IMPORTED_MODULE_11__configconstants__["a" /* CoreConfigConstants */].sitename ? __WEBPACK_IMPORTED_MODULE_11__configconstants__["a" /* CoreConfigConstants */].sitename : siteInfo && siteInfo.sitename,
                        avatar: siteInfo && siteInfo.userpictureurl
                    };
                    formattedSites.push(basicInfo);
                }
            });
            return formattedSites;
        });
    };
    /**
     * Get the list of sites stored, sorted by URL and full name.
     *
     * @param {String[]} [ids] IDs of the sites to get. If not defined, return all sites.
     * @return {Promise<CoreSiteBasicInfo[]>} Promise resolved when the sites are retrieved.
     */
    CoreSitesProvider.prototype.getSortedSites = function (ids) {
        return this.getSites(ids).then(function (sites) {
            // Sort sites by url and ful lname.
            sites.sort(function (a, b) {
                // First compare by site url without the protocol.
                var compareA = a.siteUrl.replace(/^https?:\/\//, '').toLowerCase(), compareB = b.siteUrl.replace(/^https?:\/\//, '').toLowerCase();
                var compare = compareA.localeCompare(compareB);
                if (compare !== 0) {
                    return compare;
                }
                // If site url is the same, use fullname instead.
                compareA = a.fullName.toLowerCase().trim();
                compareB = b.fullName.toLowerCase().trim();
                return compareA.localeCompare(compareB);
            });
            return sites;
        });
    };
    /**
     * Get the list of IDs of sites stored and not logged out.
     *
     * @return {Promise<string[]>} Promise resolved when the sites IDs are retrieved.
     */
    CoreSitesProvider.prototype.getLoggedInSitesIds = function () {
        return this.appDB.getRecords(this.SITES_TABLE, { loggedOut: 0 }).then(function (sites) {
            return sites.map(function (site) {
                return site.id;
            });
        });
    };
    /**
     * Get the list of IDs of sites stored.
     *
     * @return {Promise<string[]>} Promise resolved when the sites IDs are retrieved.
     */
    CoreSitesProvider.prototype.getSitesIds = function () {
        return this.appDB.getAllRecords(this.SITES_TABLE).then(function (sites) {
            return sites.map(function (site) {
                return site.id;
            });
        });
    };
    /**
     * Login the user in a site.
     *
     * @param {string} siteid ID of the site the user is accessing.
     * @return {Promise<void>} Promise resolved when current site is stored.
     */
    CoreSitesProvider.prototype.login = function (siteId) {
        var _this = this;
        var entry = {
            id: 1,
            siteId: siteId
        };
        return this.appDB.insertRecord(this.CURRENT_SITE_TABLE, entry).then(function () {
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].LOGIN, {}, siteId);
        });
    };
    /**
     * Logout the user.
     *
     * @return {Promise<any>} Promise resolved when the user is logged out.
     */
    CoreSitesProvider.prototype.logout = function () {
        var _this = this;
        if (!this.currentSite) {
            // Already logged out.
            return Promise.resolve();
        }
        var siteId = this.currentSite.getId(), siteConfig = this.currentSite.getStoredConfig(), promises = [];
        this.currentSite = undefined;
        if (siteConfig && siteConfig.tool_mobile_forcelogout == '1') {
            promises.push(this.setSiteLoggedOut(siteId, true));
        }
        promises.push(this.appDB.deleteRecords(this.CURRENT_SITE_TABLE, { id: 1 }));
        return Promise.all(promises).finally(function () {
            // Due to DeepLinker, we need to remove the path from the URL, otherwise some pages are re-created when they shouldn't.
            _this.location.replaceState('');
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].LOGOUT, {}, siteId);
        });
    };
    /**
     * Restores the session to the previous one so the user doesn't has to login everytime the app is started.
     *
     * @return {Promise<any>} Promise resolved if a session is restored.
     */
    CoreSitesProvider.prototype.restoreSession = function () {
        var _this = this;
        if (this.sessionRestored) {
            return Promise.reject(null);
        }
        this.sessionRestored = true;
        return this.appDB.getRecord(this.CURRENT_SITE_TABLE, { id: 1 }).then(function (currentSite) {
            var siteId = currentSite.siteId;
            _this.logger.debug("Restore session in site " + siteId);
            return _this.loadSite(siteId);
        }).catch(function () {
            // No current session.
        });
    };
    /**
     * Mark or unmark a site as logged out so the user needs to authenticate again.
     *
     * @param {string} siteId ID of the site.
     * @param {boolean} loggedOut True to set the site as logged out, false otherwise.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitesProvider.prototype.setSiteLoggedOut = function (siteId, loggedOut) {
        var _this = this;
        return this.getSite(siteId).then(function (site) {
            var newValues = {
                token: '',
                loggedOut: loggedOut ? 1 : 0
            };
            site.setLoggedOut(loggedOut);
            return _this.appDB.updateRecords(_this.SITES_TABLE, newValues, { id: siteId });
        });
    };
    /**
     * Unset current site.
     */
    CoreSitesProvider.prototype.unsetCurrentSite = function () {
        this.currentSite = undefined;
    };
    /**
     * Updates a site's token.
     *
     * @param {string} siteUrl Site's URL.
     * @param {string} username Username.
     * @param {string} token User's new token.
     * @param {string} [privateToken=''] User's private token.
     * @return {Promise<any>} A promise resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteToken = function (siteUrl, username, token, privateToken) {
        var _this = this;
        if (privateToken === void 0) { privateToken = ''; }
        var siteId = this.createSiteID(siteUrl, username);
        return this.updateSiteTokenBySiteId(siteId, token, privateToken).then(function () {
            return _this.login(siteId);
        });
    };
    /**
     * Updates a site's token using siteId.
     *
     * @param {string} siteId Site Id.
     * @param {string} token User's new token.
     * @param {string} [privateToken=''] User's private token.
     * @return {Promise<any>} A promise resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteTokenBySiteId = function (siteId, token, privateToken) {
        var _this = this;
        if (privateToken === void 0) { privateToken = ''; }
        return this.getSite(siteId).then(function (site) {
            var newValues = {
                token: token,
                privateToken: privateToken,
                loggedOut: 0
            };
            site.token = token;
            site.privateToken = privateToken;
            site.setLoggedOut(false); // Token updated means the user authenticated again, not logged out anymore.
            return _this.appDB.updateRecords(_this.SITES_TABLE, newValues, { id: siteId });
        });
    };
    /**
     * Updates a site's info.
     *
     * @param {string} siteid Site's ID.
     * @return {Promise<any>} A promise resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteInfo = function (siteId) {
        var _this = this;
        return this.getSite(siteId).then(function (site) {
            return site.fetchSiteInfo().then(function (info) {
                site.setInfo(info);
                if (_this.isLegacyMoodleByInfo(info)) {
                    // The Moodle version is not supported, reject.
                    return Promise.reject(_this.translate.instant('core.login.legacymoodleversion'));
                }
                // Try to get the site config.
                return _this.getSiteConfig(site).catch(function () {
                    // Error getting config, keep the current one.
                }).then(function (config) {
                    var newValues = {
                        info: JSON.stringify(info),
                        loggedOut: site.isLoggedOut() ? 1 : 0
                    };
                    if (typeof config != 'undefined') {
                        site.setConfig(config);
                        newValues.config = JSON.stringify(config);
                    }
                    return _this.appDB.updateRecords(_this.SITES_TABLE, newValues, { id: siteId }).finally(function () {
                        _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SITE_UPDATED, info, siteId);
                    });
                });
            });
        });
    };
    /**
     * Updates a site's info.
     *
     * @param {string} siteUrl  Site's URL.
     * @param {string} username Username.
     * @return {Promise<any>} A promise to be resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteInfoByUrl = function (siteUrl, username) {
        var siteId = this.createSiteID(siteUrl, username);
        return this.updateSiteInfo(siteId);
    };
    /**
     * Get the site IDs a URL belongs to.
     * Someone can have more than one account in the same site, that's why this function returns an array of IDs.
     *
     * @param {string} url URL to check.
     * @param {boolean} [prioritize] True if it should prioritize current site. If the URL belongs to current site then it won't
     *                               check any other site, it will only return current site.
     * @param {string} [username] If set, it will return only the sites where the current user has this username.
     * @return {Promise<string[]>} Promise resolved with the site IDs (array).
     */
    CoreSitesProvider.prototype.getSiteIdsFromUrl = function (url, prioritize, username) {
        var _this = this;
        // If prioritize is true, check current site first.
        if (prioritize && this.currentSite && this.currentSite.containsUrl(url)) {
            if (!username || this.currentSite.getInfo().username == username) {
                return Promise.resolve([this.currentSite.getId()]);
            }
        }
        // Check if URL has http(s) protocol.
        if (!url.match(/^https?:\/\//i)) {
            // URL doesn't have http(s) protocol. Check if it has any protocol.
            if (this.urlUtils.isAbsoluteURL(url)) {
                // It has some protocol. Return empty array.
                return Promise.resolve([]);
            }
            else {
                // No protocol, probably a relative URL. Return current site.
                if (this.currentSite) {
                    return Promise.resolve([this.currentSite.getId()]);
                }
                else {
                    return Promise.resolve([]);
                }
            }
        }
        return this.appDB.getAllRecords(this.SITES_TABLE).then(function (siteEntries) {
            var ids = [];
            var promises = [];
            siteEntries.forEach(function (site) {
                if (!_this.sites[site.id]) {
                    promises.push(_this.makeSiteFromSiteListEntry(site));
                }
                if (_this.sites[site.id].containsUrl(url)) {
                    if (!username || _this.sites[site.id].getInfo().username == username) {
                        ids.push(site.id);
                    }
                }
            });
            return Promise.all(promises).then(function () {
                return ids;
            });
        }).catch(function () {
            // Shouldn't happen.
            return [];
        });
    };
    /**
     * Get the site ID stored in DB as current site.
     *
     * @return {Promise<string>} Promise resolved with the site ID.
     */
    CoreSitesProvider.prototype.getStoredCurrentSiteId = function () {
        return this.appDB.getRecord(this.CURRENT_SITE_TABLE, { id: 1 }).then(function (currentSite) {
            return currentSite.siteId;
        });
    };
    /**
     * Get the public config of a certain site.
     *
     * @param {string} siteUrl URL of the site.
     * @return {Promise<any>} Promise resolved with the public config.
     */
    CoreSitesProvider.prototype.getSitePublicConfig = function (siteUrl) {
        var temporarySite = this.sitesFactory.makeSite(undefined, siteUrl);
        return temporarySite.getPublicConfig();
    };
    /**
     * Get site config.
     *
     * @param {any} site The site to get the config.
     * @return {Promise<any>} Promise resolved with config if available.
     */
    CoreSitesProvider.prototype.getSiteConfig = function (site) {
        if (!site.wsAvailable('tool_mobile_get_config')) {
            // WS not available, cannot get config.
            return Promise.resolve();
        }
        return site.getConfig(undefined, true);
    };
    /**
     * Check if a certain feature is disabled in a site.
     *
     * @param {string} name Name of the feature to check.
     * @param {string} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise<boolean>} Promise resolved with true if disabled.
     */
    CoreSitesProvider.prototype.isFeatureDisabled = function (name, siteId) {
        return this.getSite(siteId).then(function (site) {
            return site.isFeatureDisabled(name);
        });
    };
    /**
     * Create a table in all the sites databases.
     *
     * @param {SQLiteDBTamableSchema} table Table schema.
     */
    CoreSitesProvider.prototype.createTableFromSchema = function (table) {
        this.createTablesFromSchema([table]);
    };
    /**
     * Create several tables in all the sites databases.
     *
     * @param {SQLiteDBTamableSchema[]} tables List of tables schema.
     */
    CoreSitesProvider.prototype.createTablesFromSchema = function (tables) {
        // Add the tables to the list of schemas. This list is to create all the tables in new sites.
        this.siteTablesSchemas = this.siteTablesSchemas.concat(tables);
        // Now create these tables in current sites.
        for (var id in this.sites) {
            this.sites[id].getDb().createTablesFromSchema(tables);
        }
    };
    /**
     * Check if a WS is available in the current site, if any.
     *
     * @param {string} method WS name.
     * @param {boolean} [checkPrefix=true] When true also checks with the compatibility prefix.
     * @return {boolean} Whether the WS is available.
     */
    CoreSitesProvider.prototype.wsAvailableInCurrentSite = function (method, checkPrefix) {
        if (checkPrefix === void 0) { checkPrefix = true; }
        var site = this.getCurrentSite();
        return site && site.wsAvailable(method, checkPrefix);
    };
    /**
     * Check if a site is a legacy site by its info.
     *
     * @param {any} info The site info.
     * @return {boolean} Whether it's a legacy Moodle.
     */
    CoreSitesProvider.prototype.isLegacyMoodleByInfo = function (info) {
        return this.isValidMoodleVersion(info) == this.LEGACY_APP_VERSION;
    };
    /**
     * Register a site schema.
     */
    CoreSitesProvider.prototype.registerSiteSchema = function (schema) {
        this.siteSchemas[schema.name] = schema;
    };
    /**
     * Install and upgrade all the registered schemas and tables.
     *
     * @param {CoreSite} site Site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitesProvider.prototype.migrateSiteSchemas = function (site) {
        var _this = this;
        var db = site.getDb();
        if (this.siteSchemasMigration[site.id]) {
            return this.siteSchemasMigration[site.id];
        }
        this.logger.debug("Migrating all schemas of " + site.id);
        // First create tables not registerd with name/version.
        var promise = db.createTablesFromSchema(this.siteTablesSchemas).then(function () {
            // Fetch installed versions of the schema.
            return db.getAllRecords(_this.SCHEMA_VERSIONS_TABLE).then(function (records) {
                var versions = {};
                records.forEach(function (record) {
                    versions[record.name] = record.version;
                });
                var promises = [];
                var _loop_1 = function (name_1) {
                    var schema = _this.siteSchemas[name_1];
                    var oldVersion = versions[name_1] || 0;
                    if (oldVersion >= schema.version) {
                        return "continue";
                    }
                    _this.logger.debug("Migrating schema '" + name_1 + "' of " + site.id + " from version " + oldVersion + " to " + schema.version);
                    var promise_1 = Promise.resolve();
                    if (schema.tables) {
                        promise_1 = promise_1.then(function () { return db.createTablesFromSchema(schema.tables); });
                    }
                    if (schema.migrate) {
                        promise_1 = promise_1.then(function () { return schema.migrate(db, oldVersion, site.id); });
                    }
                    // Set installed version.
                    promise_1 = promise_1.then(function () { return db.insertRecord(_this.SCHEMA_VERSIONS_TABLE, { name: name_1, version: schema.version }); });
                    promises.push(promise_1);
                };
                for (var name_1 in _this.siteSchemas) {
                    _loop_1(name_1);
                }
                return Promise.all(promises);
            });
        });
        this.siteSchemasMigration[site.id] = promise;
        return promise.finally(function () {
            delete _this.siteSchemasMigration[site.id];
        });
    };
    /**
     * Check if a URL is the root URL of any of the stored sites.
     *
     * @param {string} url URL to check.
     * @param {string} [username] Username to check.
     * @return {Promise<{site: CoreSite, siteIds: string[]}>} Promise resolved with site to use and the list of sites that have
     *                                   the URL. Site will be undefined if it isn't the root URL of any stored site.
     */
    CoreSitesProvider.prototype.isStoredRootURL = function (url, username) {
        var _this = this;
        // Check if the site is stored.
        return this.getSiteIdsFromUrl(url, true, username).then(function (siteIds) {
            var result = {
                siteIds: siteIds,
                site: undefined
            };
            if (siteIds.length > 0) {
                // If more than one site is returned it usually means there are different users stored. Use any of them.
                return _this.getSite(siteIds[0]).then(function (site) {
                    var siteUrl = _this.textUtils.removeEndingSlash(_this.urlUtils.removeProtocolAndWWW(site.getURL())), treatedUrl = _this.textUtils.removeEndingSlash(_this.urlUtils.removeProtocolAndWWW(url));
                    if (siteUrl == treatedUrl) {
                        result.site = site;
                    }
                    return result;
                });
            }
            return result;
        });
    };
    /**
     * Returns the Site Schema names that can be cleared on space storage.
     *
     * @return {string[]} Name of the site schemas.
     */
    CoreSitesProvider.prototype.getSiteTableSchemasToClear = function () {
        var reset = [];
        for (var name_2 in this.siteSchemas) {
            if (this.siteSchemas[name_2].canBeCleared) {
                reset = reset.concat(this.siteSchemas[name_2].canBeCleared);
            }
        }
        return reset;
    };
    CoreSitesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_6__sites_factory__["a" /* CoreSitesFactoryProvider */],
            __WEBPACK_IMPORTED_MODULE_3__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_8__utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_7__utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_14__angular_common__["f" /* Location */],
            __WEBPACK_IMPORTED_MODULE_9__utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreSitesProvider);
    return CoreSitesProvider;
}());

//# sourceMappingURL=sites.js.map

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_in_app_browser__ = __webpack_require__(415);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__ = __webpack_require__(416);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_file_opener__ = __webpack_require__(417);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_web_intent__ = __webpack_require__(539);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__mimetype__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__lang__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ws__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_constants__ = __webpack_require__(39);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};















/*
 * "Utils" service with helper functions.
 */
var CoreUtilsProvider = /** @class */ (function () {
    function CoreUtilsProvider(iab, appProvider, clipboard, domUtils, logger, translate, platform, langProvider, eventsProvider, fileOpener, mimetypeUtils, webIntent, wsProvider, zone) {
        this.iab = iab;
        this.appProvider = appProvider;
        this.clipboard = clipboard;
        this.domUtils = domUtils;
        this.translate = translate;
        this.platform = platform;
        this.langProvider = langProvider;
        this.eventsProvider = eventsProvider;
        this.fileOpener = fileOpener;
        this.mimetypeUtils = mimetypeUtils;
        this.webIntent = webIntent;
        this.wsProvider = wsProvider;
        this.zone = zone;
        this.uniqueIds = {};
        this.logger = logger.getInstance('CoreUtilsProvider');
    }
    /**
     * Similar to Promise.all, but if a promise fails this function's promise won't be rejected until ALL promises have finished.
     *
     * @param {Promise<any>[]} promises Promises.
     * @return {Promise<any>} Promise resolved if all promises are resolved and rejected if at least 1 promise fails.
     */
    CoreUtilsProvider.prototype.allPromises = function (promises) {
        if (!promises || !promises.length) {
            return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
            var total = promises.length;
            var count = 0, hasFailed = false, error;
            promises.forEach(function (promise) {
                promise.catch(function (err) {
                    hasFailed = true;
                    error = err;
                }).finally(function () {
                    count++;
                    if (count === total) {
                        // All promises have finished, reject/resolve.
                        if (hasFailed) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                    }
                });
            });
        });
    };
    /**
     * Converts an array of objects to an object, using a property of each entry as the key.
     * E.g. [{id: 10, name: 'A'}, {id: 11, name: 'B'}] => {10: {id: 10, name: 'A'}, 11: {id: 11, name: 'B'}}
     *
     * @param {any[]} array The array to convert.
     * @param {string} propertyName The name of the property to use as the key.
     * @param {any} [result] Object where to put the properties. If not defined, a new object will be created.
     * @return {any} The object.
     */
    CoreUtilsProvider.prototype.arrayToObject = function (array, propertyName, result) {
        result = result || {};
        array.forEach(function (entry) {
            result[entry[propertyName]] = entry;
        });
        return result;
    };
    /**
     * Compare two objects. This function won't compare functions and proto properties, it's a basic compare.
     * Also, this will only check if itemA's properties are in itemB with same value. This function will still
     * return true if itemB has more properties than itemA.
     *
     * @param {any} itemA First object.
     * @param {any} itemB Second object.
     * @param {number} [maxLevels=0] Number of levels to reach if 2 objects are compared.
     * @param {number} [level=0] Current deep level (when comparing objects).
     * @param {boolean} [undefinedIsNull=true] True if undefined is equal to null. Defaults to true.
     * @return {boolean} Whether both items are equal.
     */
    CoreUtilsProvider.prototype.basicLeftCompare = function (itemA, itemB, maxLevels, level, undefinedIsNull) {
        if (maxLevels === void 0) { maxLevels = 0; }
        if (level === void 0) { level = 0; }
        if (undefinedIsNull === void 0) { undefinedIsNull = true; }
        if (typeof itemA == 'function' || typeof itemB == 'function') {
            return true; // Don't compare functions.
        }
        else if (typeof itemA == 'object' && typeof itemB == 'object') {
            if (level >= maxLevels) {
                return true; // Max deep reached.
            }
            var equal = true;
            for (var name_1 in itemA) {
                var value = itemA[name_1];
                if (name_1 == '$$hashKey') {
                    // Ignore $$hashKey property since it's a "calculated" property.
                    return;
                }
                if (!this.basicLeftCompare(value, itemB[name_1], maxLevels, level + 1)) {
                    equal = false;
                }
            }
            return equal;
        }
        else {
            if (undefinedIsNull && ((typeof itemA == 'undefined' && itemB === null) || (itemA === null && typeof itemB == 'undefined'))) {
                return true;
            }
            // We'll treat "2" and 2 as the same value.
            var floatA = parseFloat(itemA), floatB = parseFloat(itemB);
            if (!isNaN(floatA) && !isNaN(floatB)) {
                return floatA == floatB;
            }
            return itemA === itemB;
        }
    };
    /**
     * Blocks leaving a view.
     * @deprecated, use ionViewCanLeave instead.
     */
    CoreUtilsProvider.prototype.blockLeaveView = function () {
        return;
    };
    /**
     * Check if a URL has a redirect.
     *
     * @param {string} url The URL to check.
     * @return {Promise<boolean>} Promise resolved with boolean_ whether there is a redirect.
     */
    CoreUtilsProvider.prototype.checkRedirect = function (url) {
        if (window.fetch) {
            var win = window, // Convert to <any> to be able to use AbortController (not supported by our TS version).
            initOptions = {
                redirect: 'follow'
            };
            var controller_1;
            // Some browsers implement fetch but no AbortController.
            if (win.AbortController) {
                controller_1 = new win.AbortController();
                initOptions.signal = controller_1.signal;
            }
            return this.timeoutPromise(window.fetch(url, initOptions), __WEBPACK_IMPORTED_MODULE_14__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).then(function (response) {
                return response.redirected;
            }).catch(function (error) {
                if (error.timeout && controller_1) {
                    // Timeout, abort the request.
                    controller_1.abort();
                }
                // There was a timeout, cannot determine if there's a redirect. Assume it's false.
                return false;
            });
        }
        else {
            // Cannot check if there is a redirect, assume it's false.
            return Promise.resolve(false);
        }
    };
    /**
     * Close the InAppBrowser window.
     *
     * @param {boolean} [closeAll] Desktop only. True to close all secondary windows, false to close only the "current" one.
     */
    CoreUtilsProvider.prototype.closeInAppBrowser = function (closeAll) {
        if (this.iabInstance) {
            this.iabInstance.close();
            if (closeAll && this.appProvider.isDesktop()) {
                __webpack_require__(125).ipcRenderer.send('closeSecondaryWindows');
            }
        }
    };
    /**
     * Clone a variable. It should be an object, array or primitive type.
     *
     * @param {any} source The variable to clone.
     * @return {any} Cloned variable.
     */
    CoreUtilsProvider.prototype.clone = function (source) {
        if (Array.isArray(source)) {
            // Clone the array and all the entries.
            var newArray = [];
            for (var i = 0; i < source.length; i++) {
                newArray[i] = this.clone(source[i]);
            }
            return newArray;
        }
        else if (typeof source == 'object' && source !== null) {
            // Clone the object and all the subproperties.
            var newObject = {};
            for (var name_2 in source) {
                newObject[name_2] = this.clone(source[name_2]);
            }
            return newObject;
        }
        else {
            // Primitive type or unknown, return it as it is.
            return source;
        }
    };
    /**
     * Copy properties from one object to another.
     *
     * @param {any} from Object to copy the properties from.
     * @param {any} to Object where to store the properties.
     * @param {boolean} [clone=true] Whether the properties should be cloned (so they are different instances).
     */
    CoreUtilsProvider.prototype.copyProperties = function (from, to, clone) {
        if (clone === void 0) { clone = true; }
        for (var name_3 in from) {
            if (clone) {
                to[name_3] = this.clone(from[name_3]);
            }
            else {
                to[name_3] = from[name_3];
            }
        }
    };
    /**
     * Copies a text to clipboard and shows a toast message.
     *
     * @param {string} text Text to be copied
     * @return {Promise<any>} Promise resolved when text is copied.
     */
    CoreUtilsProvider.prototype.copyToClipboard = function (text) {
        var _this = this;
        return this.clipboard.copy(text).then(function () {
            // Show toast using ionicLoading.
            return _this.domUtils.showToast('core.copiedtoclipboard', true);
        }).catch(function () {
            // Ignore errors.
        });
    };
    /**
     * Create a "fake" WS error for local errors.
     *
     * @param {string} message The message to include in the error.
     * @param {boolean} [needsTranslate] If the message needs to be translated.
     * @return {CoreWSError} Fake WS error.
     */
    CoreUtilsProvider.prototype.createFakeWSError = function (message, needsTranslate) {
        return this.wsProvider.createFakeWSError(message, needsTranslate);
    };
    /**
     * Empties an array without losing its reference.
     *
     * @param {any[]} array Array to empty.
     */
    CoreUtilsProvider.prototype.emptyArray = function (array) {
        array.length = 0; // Empty array without losing its reference.
    };
    /**
     * Removes all properties from an object without losing its reference.
     *
     * @param {object} object Object to remove the properties.
     */
    CoreUtilsProvider.prototype.emptyObject = function (object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                delete object[key];
            }
        }
    };
    /**
     * Execute promises one depending on the previous.
     *
     * @param {any[]} orderedPromisesData Data to be executed including the following values:
     *                                 - func: Function to be executed.
     *                                 - context: Context to pass to the function. This allows using "this" inside the function.
     *                                 - params: Array of data to be sent to the function.
     *                                 - blocking: Boolean. If promise should block the following.
     * @return {Promise<any>} Promise resolved when all promises are resolved.
     */
    CoreUtilsProvider.prototype.executeOrderedPromises = function (orderedPromisesData) {
        var _this = this;
        var promises = [];
        var dependency = Promise.resolve();
        var _loop_1 = function (i) {
            var data = orderedPromisesData[i];
            var promise = void 0;
            // Add the process to the dependency stack.
            promise = dependency.finally(function () {
                var prom;
                try {
                    prom = data.func.apply(data.context, data.params || []);
                }
                catch (e) {
                    _this.logger.error(e.message);
                    return;
                }
                return prom;
            });
            promises.push(promise);
            // If the new process is blocking, we set it as the dependency.
            if (data.blocking) {
                dependency = promise;
            }
        };
        // Execute all the processes in order.
        for (var i in orderedPromisesData) {
            _loop_1(i);
        }
        // Return when all promises are done.
        return this.allPromises(promises);
    };
    /**
     * Flatten an object, moving subobjects' properties to the first level using dot notation. E.g.:
     * {a: {b: 1, c: 2}, d: 3} -> {'a.b': 1, 'a.c': 2, d: 3}
     *
     * @param {object} obj Object to flatten.
     * @return {object} Flatten object.
     */
    CoreUtilsProvider.prototype.flattenObject = function (obj) {
        var toReturn = {};
        for (var name_4 in obj) {
            if (!obj.hasOwnProperty(name_4)) {
                continue;
            }
            var value = obj[name_4];
            if (typeof value == 'object' && !Array.isArray(value)) {
                var flatObject = this.flattenObject(value);
                for (var subName in flatObject) {
                    if (!flatObject.hasOwnProperty(subName)) {
                        continue;
                    }
                    toReturn[name_4 + '.' + subName] = flatObject[subName];
                }
            }
            else {
                toReturn[name_4] = value;
            }
        }
        return toReturn;
    };
    /**
     * Given an array of strings, return only the ones that match a regular expression.
     *
     * @param {string[]} array Array to filter.
     * @param {RegExp} regex RegExp to apply to each string.
     * @return {string[]} Filtered array.
     */
    CoreUtilsProvider.prototype.filterByRegexp = function (array, regex) {
        if (!array || !array.length) {
            return [];
        }
        return array.filter(function (entry) {
            var matches = entry.match(regex);
            return matches && matches.length;
        });
    };
    /**
     * Filter the list of site IDs based on a isEnabled function.
     *
     * @param {string[]} siteIds Site IDs to filter.
     * @param {Function} isEnabledFn Function to call for each site. Must return true or a promise resolved with true if enabled.
     *                    It receives a siteId param and all the params sent to this function after 'checkAll'.
     * @param {boolean} [checkAll] True if it should check all the sites, false if it should check only 1 and treat them all
     *                   depending on this result.
     * @param {any} ...args All the params sent after checkAll will be passed to isEnabledFn.
     * @return {Promise<string[]>} Promise resolved with the list of enabled sites.
     */
    CoreUtilsProvider.prototype.filterEnabledSites = function (siteIds, isEnabledFn, checkAll) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        var promises = [], enabledSites = [];
        var _loop_2 = function (i) {
            var siteId = siteIds[i];
            if (checkAll || !promises.length) {
                promises.push(Promise.resolve(isEnabledFn.apply(isEnabledFn, [siteId].concat(args))).then(function (enabled) {
                    if (enabled) {
                        enabledSites.push(siteId);
                    }
                }));
            }
        };
        for (var i in siteIds) {
            _loop_2(i);
        }
        return this.allPromises(promises).catch(function () {
            // Ignore errors.
        }).then(function () {
            if (!checkAll) {
                // Checking 1 was enough, so it will either return all the sites or none.
                return enabledSites.length ? siteIds : [];
            }
            else {
                return enabledSites;
            }
        });
    };
    /**
     * Given a float, prints it nicely. Localized floats must not be used in calculations!
     * Based on Moodle's format_float.
     *
     * @param {any} float The float to print.
     * @return {string} Locale float.
     */
    CoreUtilsProvider.prototype.formatFloat = function (float) {
        if (typeof float == 'undefined' || float === null || typeof float == 'boolean') {
            return '';
        }
        var localeSeparator = this.translate.instant('core.decsep');
        // Convert float to string.
        float += '';
        return float.replace('.', localeSeparator);
    };
    /**
     * Returns a tree formatted from a plain list.
     * List has to be sorted by depth to allow this function to work correctly. Errors can be thrown if a child node is
     * processed before a parent node.
     *
     * @param {any[]} list List to format.
     * @param {string} [parentFieldName=parent] Name of the parent field to match with children.
     * @param {string} [idFieldName=id] Name of the children field to match with parent.
     * @param {number} [rootParentId=0] The id of the root.
     * @param {number} [maxDepth=5] Max Depth to convert to tree. Children found will be in the last level of depth.
     * @return {any[]} Array with the formatted tree, children will be on each node under children field.
     */
    CoreUtilsProvider.prototype.formatTree = function (list, parentFieldName, idFieldName, rootParentId, maxDepth) {
        if (parentFieldName === void 0) { parentFieldName = 'parent'; }
        if (idFieldName === void 0) { idFieldName = 'id'; }
        if (rootParentId === void 0) { rootParentId = 0; }
        if (maxDepth === void 0) { maxDepth = 5; }
        var map = {}, mapDepth = {}, tree = [];
        var parent, id;
        list.forEach(function (node, index) {
            id = node[idFieldName];
            parent = node[parentFieldName];
            node.children = [];
            // Use map to look-up the parents.
            map[id] = index;
            if (parent != rootParentId) {
                var parentNode = list[map[parent]];
                if (parentNode) {
                    if (mapDepth[parent] == maxDepth) {
                        // Reached max level of depth. Proceed with flat order. Find parent object of the current node.
                        var parentOfParent = parentNode[parentFieldName];
                        if (parentOfParent) {
                            // This element will be the child of the node that is two levels up the hierarchy
                            // (i.e. the child of node.parent.parent).
                            list[map[parentOfParent]].children.push(node);
                            // Assign depth level to the same depth as the parent (i.e. max depth level).
                            mapDepth[id] = mapDepth[parent];
                            // Change the parent to be the one that is two levels up the hierarchy.
                            node.parent = parentOfParent;
                        }
                    }
                    else {
                        parentNode.children.push(node);
                        // Increase the depth level.
                        mapDepth[id] = mapDepth[parent] + 1;
                    }
                }
            }
            else {
                tree.push(node);
                // Root elements are the first elements in the tree structure, therefore have the depth level 1.
                mapDepth[id] = 1;
            }
        });
        return tree;
    };
    /**
     * Get country name based on country code.
     *
     * @param {string} code Country code (AF, ES, US, ...).
     * @return {string} Country name. If the country is not found, return the country code.
     */
    CoreUtilsProvider.prototype.getCountryName = function (code) {
        var countryKey = 'assets.countries.' + code, countryName = this.translate.instant(countryKey);
        return countryName !== countryKey ? countryName : code;
    };
    /**
     * Get list of countries with their code and translated name.
     *
     * @return {Promise<any>} Promise resolved with the list of countries.
     */
    CoreUtilsProvider.prototype.getCountryList = function () {
        var _this = this;
        // Get the keys of the countries.
        return this.getCountryKeysList().then(function (keys) {
            // Now get the code and the translated name.
            var countries = {};
            keys.forEach(function (key) {
                if (key.indexOf('assets.countries.') === 0) {
                    var code = key.replace('assets.countries.', '');
                    countries[code] = _this.translate.instant(key);
                }
            });
            return countries;
        });
    };
    /**
     * Get the list of language keys of the countries.
     *
     * @return {Promise<string[]>} Promise resolved with the countries list. Rejected if not translated.
     */
    CoreUtilsProvider.prototype.getCountryKeysList = function () {
        var _this = this;
        // It's possible that the current language isn't translated, so try with default language first.
        var defaultLang = this.langProvider.getDefaultLanguage();
        return this.getCountryKeysListForLanguage(defaultLang).catch(function () {
            // Not translated, try to use the fallback language.
            var fallbackLang = _this.langProvider.getFallbackLanguage();
            if (fallbackLang === defaultLang) {
                // Same language, just reject.
                return Promise.reject('Countries not found.');
            }
            return _this.getCountryKeysListForLanguage(fallbackLang);
        });
    };
    /**
     * Get the list of language keys of the countries, based on the translation table for a certain language.
     *
     * @param {string} lang Language to check.
     * @return {Promise<string[]>} Promise resolved with the countries list. Rejected if not translated.
     */
    CoreUtilsProvider.prototype.getCountryKeysListForLanguage = function (lang) {
        // Get the translation table for the language.
        return this.langProvider.getTranslationTable(lang).then(function (table) {
            // Gather all the keys for countries,
            var keys = [];
            for (var name_5 in table) {
                if (name_5.indexOf('assets.countries.') === 0) {
                    keys.push(name_5);
                }
            }
            if (keys.length === 0) {
                // Not translated, reject.
                return Promise.reject('Countries not found.');
            }
            return keys;
        });
    };
    /**
     * Get the mimetype of a file given its URL. It'll try to guess it using the URL, if that fails then it'll
     * perform a HEAD request to get it. It's done in this order because pluginfile.php can return wrong mimetypes.
     * This function is in here instead of MimetypeUtils to prevent circular dependencies.
     *
     * @param {string} url The URL of the file.
     * @return {Promise<string>} Promise resolved with the mimetype.
     */
    CoreUtilsProvider.prototype.getMimeTypeFromUrl = function (url) {
        // First check if it can be guessed from the URL.
        var extension = this.mimetypeUtils.guessExtensionFromUrl(url), mimetype = this.mimetypeUtils.getMimeType(extension);
        if (mimetype) {
            return Promise.resolve(mimetype);
        }
        // Can't be guessed, get the remote mimetype.
        return this.wsProvider.getRemoteFileMimeType(url).then(function (mimetype) {
            return mimetype || '';
        });
    };
    /**
     * Get a unique ID for a certain name.
     *
     * @param {string} name The name to get the ID for.
     * @return {number} Unique ID.
     */
    CoreUtilsProvider.prototype.getUniqueId = function (name) {
        if (!this.uniqueIds[name]) {
            this.uniqueIds[name] = 0;
        }
        return ++this.uniqueIds[name];
    };
    /**
     * Given a list of files, check if there are repeated names.
     *
     * @param {any[]} files List of files.
     * @return {string|boolean} String with error message if repeated, false if no repeated.
     */
    CoreUtilsProvider.prototype.hasRepeatedFilenames = function (files) {
        if (!files || !files.length) {
            return false;
        }
        var names = [];
        // Check if there are 2 files with the same name.
        for (var i = 0; i < files.length; i++) {
            var name_6 = files[i].filename || files[i].name;
            if (names.indexOf(name_6) > -1) {
                return this.translate.instant('core.filenameexist', { $a: name_6 });
            }
            else {
                names.push(name_6);
            }
        }
        return false;
    };
    /**
     * Gets the index of the first string that matches a regular expression.
     *
     * @param {string[]} array Array to search.
     * @param {RegExp} regex RegExp to apply to each string.
     * @return {number} Index of the first string that matches the RegExp. -1 if not found.
     */
    CoreUtilsProvider.prototype.indexOfRegexp = function (array, regex) {
        if (!array || !array.length) {
            return -1;
        }
        for (var i = 0; i < array.length; i++) {
            var entry = array[i], matches = entry.match(regex);
            if (matches && matches.length) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Return true if the param is false (bool), 0 (number) or "0" (string).
     *
     * @param {any} value Value to check.
     * @return {boolean} Whether the value is false, 0 or "0".
     */
    CoreUtilsProvider.prototype.isFalseOrZero = function (value) {
        return typeof value != 'undefined' && (value === false || value === 'false' || parseInt(value, 10) === 0);
    };
    /**
     * Return true if the param is true (bool), 1 (number) or "1" (string).
     *
     * @param {any} value Value to check.
     * @return {boolean} Whether the value is true, 1 or "1".
     */
    CoreUtilsProvider.prototype.isTrueOrOne = function (value) {
        return typeof value != 'undefined' && (value === true || value === 'true' || parseInt(value, 10) === 1);
    };
    /**
     * Given an error returned by a WS call, check if the error is generated by the app or it has been returned by the WebSwervice.
     *
     * @param {any} error Error to check.
     * @return {boolean} Whether the error was returned by the WebService.
     */
    CoreUtilsProvider.prototype.isWebServiceError = function (error) {
        return error && (typeof error.warningcode != 'undefined' || (typeof error.errorcode != 'undefined' &&
            error.errorcode != 'invalidtoken' && error.errorcode != 'userdeleted' && error.errorcode != 'upgraderunning' &&
            error.errorcode != 'forcepasswordchangenotice' && error.errorcode != 'usernotfullysetup' &&
            error.errorcode != 'sitepolicynotagreed' && error.errorcode != 'sitemaintenance' &&
            (error.errorcode != 'accessexception' || error.message.indexOf('Invalid token - token expired') == -1)));
    };
    /**
     * Given a list (e.g. a,b,c,d,e) this function returns an array of 1->a, 2->b, 3->c etc.
     * Taken from make_menu_from_list on moodlelib.php (not the same but similar).
     *
     * @param {string} list The string to explode into array bits
     * @param {string} [defaultLabel] Element that will become default option, if not defined, it won't be added.
     * @param {string} [separator] The separator used within the list string. Default ','.
     * @param {any}  [defaultValue] Element that will become default option value. Default 0.
     * @return {any[]} The now assembled array
     */
    CoreUtilsProvider.prototype.makeMenuFromList = function (list, defaultLabel, separator, defaultValue) {
        if (separator === void 0) { separator = ','; }
        // Split and format the list.
        var split = list.split(separator).map(function (label, index) {
            return {
                label: label.trim(),
                value: index + 1
            };
        });
        if (defaultLabel) {
            split.unshift({
                label: defaultLabel,
                value: defaultValue || 0
            });
        }
        return split;
    };
    /**
     * Merge two arrays, removing duplicate values.
     *
     * @param {any[]} array1 The first array.
     * @param {any[]} array2 The second array.
     * @param [key] Key of the property that must be unique. If not specified, the whole entry.
     * @return {any[]} Merged array.
     */
    CoreUtilsProvider.prototype.mergeArraysWithoutDuplicates = function (array1, array2, key) {
        return this.uniqueArray(array1.concat(array2), key);
    };
    /**
     * Open a file using platform specific method.
     *
     * @param {string} path The local path of the file to be open.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUtilsProvider.prototype.openFile = function (path) {
        var _this = this;
        var extension = this.mimetypeUtils.getFileExtension(path), mimetype = this.mimetypeUtils.getMimeType(extension);
        // Path needs to be decoded, the file won't be opened if the path has %20 instead of spaces and so.
        try {
            path = decodeURIComponent(path);
        }
        catch (ex) {
            // Error, use the original path.
        }
        return this.fileOpener.open(path, mimetype).catch(function (error) {
            _this.logger.error('Error opening file ' + path + ' with mimetype ' + mimetype);
            _this.logger.error('Error: ', JSON.stringify(error));
            if (!extension || extension.indexOf('/') > -1 || extension.indexOf('\\') > -1) {
                // Extension not found.
                error = _this.translate.instant('core.erroropenfilenoextension');
            }
            else {
                error = _this.translate.instant('core.erroropenfilenoapp');
            }
            return Promise.reject(error);
        });
    };
    /**
     * Open a URL using InAppBrowser.
     * Do not use for files, refer to {@link openFile}.
     *
     * @param {string} url The URL to open.
     * @param {any} [options] Override default options passed to InAppBrowser.
     * @return {InAppBrowserObject} The opened window.
     */
    CoreUtilsProvider.prototype.openInApp = function (url, options) {
        var _this = this;
        if (!url) {
            return;
        }
        options = options || {};
        if (!options.enableViewPortScale) {
            options.enableViewPortScale = 'yes'; // Enable zoom on iOS.
        }
        if (!options.location && this.platform.is('ios') && url.indexOf('file://') === 0) {
            // The URL uses file protocol, don't show it on iOS.
            // In Android we keep it because otherwise we lose the whole toolbar.
            options.location = 'no';
        }
        this.iabInstance = this.iab.create(url, '_blank', options);
        if (this.appProvider.isDesktop() || this.appProvider.isMobile()) {
            var loadStopSubscription_1;
            var loadStartUrls_1 = [];
            // Trigger global events when a url is loaded or the window is closed. This is to make it work like in Ionic 1.
            var loadStartSubscription_1 = this.iabInstance.on('loadstart').subscribe(function (event) {
                // Execute the callback in the Angular zone, so change detection doesn't stop working.
                _this.zone.run(function () {
                    // Store the last loaded URLs (max 10).
                    loadStartUrls_1.push(event.url);
                    if (loadStartUrls_1.length > 10) {
                        loadStartUrls_1.shift();
                    }
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_9__events__["a" /* CoreEventsProvider */].IAB_LOAD_START, event);
                });
            });
            if (this.platform.is('android')) {
                // Load stop is needed with InAppBrowser v3. Custom URL schemes no longer trigger load start, simulate it.
                loadStopSubscription_1 = this.iabInstance.on('loadstop').subscribe(function (event) {
                    // Execute the callback in the Angular zone, so change detection doesn't stop working.
                    _this.zone.run(function () {
                        if (loadStartUrls_1.indexOf(event.url) == -1) {
                            // The URL was stopped but not started, probably a custom URL scheme.
                            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_9__events__["a" /* CoreEventsProvider */].IAB_LOAD_START, event);
                        }
                    });
                });
            }
            var exitSubscription_1 = this.iabInstance.on('exit').subscribe(function (event) {
                // Execute the callback in the Angular zone, so change detection doesn't stop working.
                _this.zone.run(function () {
                    loadStartSubscription_1.unsubscribe();
                    loadStopSubscription_1 && loadStopSubscription_1.unsubscribe();
                    exitSubscription_1.unsubscribe();
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_9__events__["a" /* CoreEventsProvider */].IAB_EXIT, event);
                });
            });
        }
        return this.iabInstance;
    };
    /**
     * Open a URL using a browser.
     * Do not use for files, refer to {@link openFile}.
     *
     * @param {string} url The URL to open.
     */
    CoreUtilsProvider.prototype.openInBrowser = function (url) {
        if (this.appProvider.isDesktop()) {
            // It's a desktop app, use Electron shell library to open the browser.
            var shell = __webpack_require__(125).shell;
            if (!shell.openExternal(url)) {
                // Open browser failed, open a new window in the app.
                window.open(url, '_system');
            }
        }
        else {
            window.open(url, '_system');
        }
    };
    /**
     * Open an online file using platform specific method.
     * Specially useful for audio and video since they can be streamed.
     *
     * @param {string} url The URL of the file.
     * @return {Promise<void>} Promise resolved when opened.
     */
    CoreUtilsProvider.prototype.openOnlineFile = function (url) {
        var _this = this;
        if (this.platform.is('android')) {
            // In Android we need the mimetype to open it.
            return this.getMimeTypeFromUrl(url).catch(function () {
                // Error getting mimetype, return undefined.
            }).then(function (mimetype) {
                if (!mimetype) {
                    // Couldn't retrieve mimetype. Return error.
                    return Promise.reject(_this.translate.instant('core.erroropenfilenoextension'));
                }
                var options = {
                    action: _this.webIntent.ACTION_VIEW,
                    url: url,
                    type: mimetype
                };
                return _this.webIntent.startActivity(options).catch(function (error) {
                    _this.logger.error('Error opening online file ' + url + ' with mimetype ' + mimetype);
                    _this.logger.error('Error: ', JSON.stringify(error));
                    return Promise.reject(_this.translate.instant('core.erroropenfilenoapp'));
                });
            });
        }
        // In the rest of platforms we need to open them in InAppBrowser.
        this.openInApp(url);
        return Promise.resolve();
    };
    /**
     * Converts an object into an array, losing the keys.
     *
     * @param {object} obj Object to convert.
     * @return {any[]} Array with the values of the object but losing the keys.
     */
    CoreUtilsProvider.prototype.objectToArray = function (obj) {
        return Object.keys(obj).map(function (key) {
            return obj[key];
        });
    };
    /**
     * Converts an object into an array of objects, where each entry is an object containing
     * the key and value of the original object.
     * For example, it can convert {size: 2} into [{name: 'size', value: 2}].
     *
     * @param {object} obj Object to convert.
     * @param {string} keyName Name of the properties where to store the keys.
     * @param {string} valueName Name of the properties where to store the values.
     * @param {boolean} [sortByKey] True to sort keys alphabetically, false otherwise. Has priority over sortByValue.
     * @param {boolean} [sortByValue] True to sort values alphabetically, false otherwise.
     * @return {any[]} Array of objects with the name & value of each property.
     */
    CoreUtilsProvider.prototype.objectToArrayOfObjects = function (obj, keyName, valueName, sortByKey, sortByValue) {
        // Get the entries from an object or primitive value.
        var getEntries = function (elKey, value) {
            if (typeof value == 'undefined' || value == null) {
                // Filter undefined and null values.
                return;
            }
            else if (typeof value == 'object') {
                // It's an object, return at least an entry for each property.
                var keys = Object.keys(value);
                var entries_1 = [];
                keys.forEach(function (key) {
                    var newElKey = elKey ? elKey + '[' + key + ']' : key, subEntries = getEntries(newElKey, value[key]);
                    if (subEntries) {
                        entries_1 = entries_1.concat(subEntries);
                    }
                });
                return entries_1;
            }
            else {
                // Not an object, return a single entry.
                var entry = {};
                entry[keyName] = elKey;
                entry[valueName] = value;
                return entry;
            }
        };
        if (!obj) {
            return [];
        }
        // "obj" will always be an object, so "entries" will always be an array.
        var entries = getEntries('', obj);
        if (sortByKey || sortByValue) {
            return entries.sort(function (a, b) {
                if (sortByKey) {
                    return a[keyName] >= b[keyName] ? 1 : -1;
                }
                else {
                    return a[valueName] >= b[valueName] ? 1 : -1;
                }
            });
        }
        return entries;
    };
    /**
     * Converts an array of objects into an object with key and value. The opposite of objectToArrayOfObjects.
     * For example, it can convert [{name: 'size', value: 2}] into {size: 2}.
     *
     * @param {object[]} objects List of objects to convert.
     * @param {string} keyName Name of the properties where the keys are stored.
     * @param {string} valueName Name of the properties where the values are stored.
     * @param {string} [keyPrefix] Key prefix if neededs to delete it.
     * @return {object} Object.
     */
    CoreUtilsProvider.prototype.objectToKeyValueMap = function (objects, keyName, valueName, keyPrefix) {
        if (!objects) {
            return;
        }
        var prefixSubstr = keyPrefix ? keyPrefix.length : 0, mapped = {};
        objects.forEach(function (item) {
            var key = prefixSubstr > 0 ? item[keyName].substr(prefixSubstr) : item[keyName];
            mapped[key] = item[valueName];
        });
        return mapped;
    };
    /**
     * Add a prefix to all the keys in an object.
     *
     * @param {any} data Object.
     * @param {string} prefix Prefix to add.
     * @return {any} Prefixed object.
     */
    CoreUtilsProvider.prototype.prefixKeys = function (data, prefix) {
        var newObj = {}, keys = Object.keys(data);
        keys.forEach(function (key) {
            newObj[prefix + key] = data[key];
        });
        return newObj;
    };
    /**
     * Similar to AngularJS $q.defer().
     *
     * @return {PromiseDefer} The deferred promise.
     */
    CoreUtilsProvider.prototype.promiseDefer = function () {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    };
    /**
     * Given a promise, returns true if it's rejected or false if it's resolved.
     *
     * @param {Promise<any>} promise Promise to check
     * @return {Promise<boolean>} Promise resolved with boolean: true if the promise is rejected or false if it's resolved.
     */
    CoreUtilsProvider.prototype.promiseFails = function (promise) {
        return promise.then(function () {
            return false;
        }).catch(function () {
            return true;
        });
    };
    /**
     * Given a promise, returns true if it's resolved or false if it's rejected.
     *
     * @param {Promise<any>} promise Promise to check
     * @return {Promise<boolean>} Promise resolved with boolean: true if the promise it's resolved or false if it's rejected.
     */
    CoreUtilsProvider.prototype.promiseWorks = function (promise) {
        return promise.then(function () {
            return true;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Tests to see whether two arrays or objects have the same value at a particular key.
     * Missing values are replaced by '', and the values are compared with ===.
     * Booleans and numbers are cast to string before comparing.
     *
     * @param {any} obj1 The first object or array.
     * @param {any} obj2 The second object or array.
     * @param {string} key Key to check.
     * @return {boolean} Whether the two objects/arrays have the same value (or lack of one) for a given key.
     */
    CoreUtilsProvider.prototype.sameAtKeyMissingIsBlank = function (obj1, obj2, key) {
        var value1 = typeof obj1[key] != 'undefined' ? obj1[key] : '', value2 = typeof obj2[key] != 'undefined' ? obj2[key] : '';
        if (typeof value1 == 'number' || typeof value1 == 'boolean') {
            value1 = '' + value1;
        }
        if (typeof value2 == 'number' || typeof value2 == 'boolean') {
            value2 = '' + value2;
        }
        return value1 === value2;
    };
    /**
     * Stringify an object, sorting the properties. It doesn't sort arrays, only object properties. E.g.:
     * {b: 2, a: 1} -> '{"a":1,"b":2}'
     *
     * @param {object} obj Object to stringify.
     * @return {string} Stringified object.
     */
    CoreUtilsProvider.prototype.sortAndStringify = function (obj) {
        return JSON.stringify(this.sortProperties(obj));
    };
    /**
     * Given an object, sort its properties and the properties of all the nested objects.
     *
     * @param {object} obj The object to sort. If it isn't an object, the original value will be returned.
     * @return {object} Sorted object.
     */
    CoreUtilsProvider.prototype.sortProperties = function (obj) {
        var _this = this;
        if (typeof obj == 'object' && !Array.isArray(obj)) {
            // It's an object, sort it.
            return Object.keys(obj).sort().reduce(function (accumulator, key) {
                // Always call sort with the value. If it isn't an object, the original value will be returned.
                accumulator[key] = _this.sortProperties(obj[key]);
                return accumulator;
            }, {});
        }
        else {
            return obj;
        }
    };
    /**
     * Given an object, sort its values. Values need to be primitive values, it cannot have subobjects.
     *
     * @param {object} obj The object to sort. If it isn't an object, the original value will be returned.
     * @return {object} Sorted object.
     */
    CoreUtilsProvider.prototype.sortValues = function (obj) {
        if (typeof obj == 'object' && !Array.isArray(obj)) {
            // It's an object, sort it. Convert it to an array to be able to sort it and then convert it back to object.
            var array = this.objectToArrayOfObjects(obj, 'name', 'value', false, true);
            return this.objectToKeyValueMap(array, 'name', 'value');
        }
        else {
            return obj;
        }
    };
    /**
     * Sum the filesizes from a list of files checking if the size will be partial or totally calculated.
     *
     * @param {any[]} files List of files to sum its filesize.
     * @return {{size: number, total: boolean}} File size and a boolean to indicate if it is the total size or only partial.
     */
    CoreUtilsProvider.prototype.sumFileSizes = function (files) {
        var result = {
            size: 0,
            total: true
        };
        files.forEach(function (file) {
            if (typeof file.filesize == 'undefined') {
                // We don't have the file size, cannot calculate its total size.
                result.total = false;
            }
            else {
                result.size += file.filesize;
            }
        });
        return result;
    };
    /**
     * Set a timeout to a Promise. If the time passes before the Promise is resolved or rejected, it will be automatically
     * rejected.
     *
     * @param {Promise<T>} promise The promise to timeout.
     * @param {number} time Number of milliseconds of the timeout.
     * @return {Promise<T>} Promise with the timeout.
     */
    CoreUtilsProvider.prototype.timeoutPromise = function (promise, time) {
        return new Promise(function (resolve, reject) {
            var timeout = setTimeout(function () {
                reject({ timeout: true });
            }, time);
            promise.then(resolve).catch(reject).finally(function () {
                clearTimeout(timeout);
            });
        });
    };
    /**
     * Converts locale specific floating point/comma number back to standard PHP float value.
     * Do NOT try to do any math operations before this conversion on any user submitted floats!
     * Based on Moodle's unformat_float function.
     *
     * @param {any} localeFloat Locale aware float representation.
     * @param {boolean} [strict] If true, then check the input and return false if it is not a valid number.
     * @return {any} False if bad format, empty string if empty value or the parsed float if not.
     */
    CoreUtilsProvider.prototype.unformatFloat = function (localeFloat, strict) {
        // Bad format on input type number.
        if (typeof localeFloat == 'undefined') {
            return false;
        }
        // Empty (but not zero).
        if (localeFloat == null) {
            return '';
        }
        // Convert float to string.
        localeFloat += '';
        localeFloat = localeFloat.trim();
        if (localeFloat == '') {
            return '';
        }
        localeFloat = localeFloat.replace(' ', ''); // No spaces - those might be used as thousand separators.
        localeFloat = localeFloat.replace(this.translate.instant('core.decsep'), '.');
        var parsedFloat = parseFloat(localeFloat);
        // Bad format.
        if (strict && (!isFinite(localeFloat) || isNaN(parsedFloat))) {
            return false;
        }
        return parsedFloat;
    };
    /**
     * Return an array without duplicate values.
     *
     * @param {any[]} array The array to treat.
     * @param [key] Key of the property that must be unique. If not specified, the whole entry.
     * @return {any[]} Array without duplicate values.
     */
    CoreUtilsProvider.prototype.uniqueArray = function (array, key) {
        var filtered = [], unique = {}; // Use an object to make it faster to check if it's duplicate.
        array.forEach(function (entry) {
            var value = key ? entry[key] : entry;
            if (!unique[value]) {
                unique[value] = true;
                filtered.push(entry);
            }
        });
        return filtered;
    };
    CoreUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ionic_native_in_app_browser__["a" /* InAppBrowser */], __WEBPACK_IMPORTED_MODULE_6__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__["a" /* Clipboard */],
            __WEBPACK_IMPORTED_MODULE_7__dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_10__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_11__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_12__lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_9__events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__ionic_native_file_opener__["a" /* FileOpener */], __WEBPACK_IMPORTED_MODULE_8__mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__ionic_native_web_intent__["a" /* WebIntent */],
            __WEBPACK_IMPORTED_MODULE_13__ws__["a" /* CoreWSProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["M" /* NgZone */]])
    ], CoreUtilsProvider);
    return CoreUtilsProvider;
}());

//# sourceMappingURL=utils.js.map

/***/ }),
/* 3 */,
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDomUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__config__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_bs_tooltip_bs_tooltip__ = __webpack_require__(538);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/*
 * "Utils" service with helper functions for UI, DOM elements and HTML code.
 */
var CoreDomUtilsProvider = /** @class */ (function () {
    function CoreDomUtilsProvider(translate, loadingCtrl, toastCtrl, alertCtrl, textUtils, appProvider, platform, configProvider, urlUtils, modalCtrl, sanitizer, popoverCtrl, fileProvider) {
        var _this = this;
        this.translate = translate;
        this.loadingCtrl = loadingCtrl;
        this.toastCtrl = toastCtrl;
        this.alertCtrl = alertCtrl;
        this.textUtils = textUtils;
        this.appProvider = appProvider;
        this.platform = platform;
        this.configProvider = configProvider;
        this.urlUtils = urlUtils;
        this.modalCtrl = modalCtrl;
        this.sanitizer = sanitizer;
        this.popoverCtrl = popoverCtrl;
        this.fileProvider = fileProvider;
        // List of input types that support keyboard.
        this.INPUT_SUPPORT_KEYBOARD = ['date', 'datetime', 'datetime-local', 'email', 'month', 'number', 'password',
            'search', 'tel', 'text', 'time', 'url', 'week'];
        this.INSTANCE_ID_ATTR_NAME = 'core-instance-id';
        this.template = document.createElement('template'); // A template element to convert HTML to element.
        this.instances = {}; // Store component/directive instances by id.
        this.lastInstanceId = 0;
        this.debugDisplay = false; // Whether to display debug messages. Store it in a variable to make it synchronous.
        this.displayedAlerts = {}; // To prevent duplicated alerts.
        // Check if debug messages should be displayed.
        configProvider.get(__WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].SETTINGS_DEBUG_DISPLAY, false).then(function (debugDisplay) {
            _this.debugDisplay = !!debugDisplay;
        });
    }
    /**
     * Equivalent to element.closest(). If the browser doesn't support element.closest, it will
     * traverse the parents to achieve the same functionality.
     * Returns the closest ancestor of the current element (or the current element itself) which matches the selector.
     *
     * @param {HTMLElement} element DOM Element.
     * @param {string} selector Selector to search.
     * @return {Element} Closest ancestor.
     */
    CoreDomUtilsProvider.prototype.closest = function (element, selector) {
        var _this = this;
        // Try to use closest if the browser supports it.
        if (typeof element.closest == 'function') {
            return element.closest(selector);
        }
        if (!this.matchesFn) {
            // Find the matches function supported by the browser.
            ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'].some(function (fn) {
                if (typeof document.body[fn] == 'function') {
                    _this.matchesFn = fn;
                    return true;
                }
                return false;
            });
            if (!this.matchesFn) {
                return;
            }
        }
        // Traverse parents.
        while (element) {
            if (element[this.matchesFn](selector)) {
                return element;
            }
            element = element.parentElement;
        }
    };
    /**
     * If the download size is higher than a certain threshold shows a confirm dialog.
     *
     * @param {any} size Object containing size to download and a boolean to indicate if its totally or partialy calculated.
     * @param {string} [message] Code of the message to show. Default: 'core.course.confirmdownload'.
     * @param {string} [unknownMessage] ID of the message to show if size is unknown.
     * @param {number} [wifiThreshold] Threshold to show confirm in WiFi connection. Default: CoreWifiDownloadThreshold.
     * @param {number} [limitedThreshold] Threshold to show confirm in limited connection. Default: CoreDownloadThreshold.
     * @param {boolean} [alwaysConfirm] True to show a confirm even if the size isn't high, false otherwise.
     * @return {Promise<void>} Promise resolved when the user confirms or if no confirm needed.
     */
    CoreDomUtilsProvider.prototype.confirmDownloadSize = function (size, message, unknownMessage, wifiThreshold, limitedThreshold, alwaysConfirm) {
        var _this = this;
        var readableSize = this.textUtils.bytesToSize(size.size, 2);
        var getAvailableBytes = new Promise(function (resolve) {
            if (_this.appProvider.isDesktop()) {
                // Free space calculation is not supported on desktop.
                resolve(null);
            }
            else {
                _this.fileProvider.calculateFreeSpace().then(function (availableBytes) {
                    if (_this.platform.is('android')) {
                        return availableBytes;
                    }
                    else {
                        // Space calculation is not accurate on iOS, but it gets more accurate when space is lower.
                        // We'll only use it when space is <500MB, or we're downloading more than twice the reported space.
                        if (availableBytes < __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].IOS_FREE_SPACE_THRESHOLD || size.size > availableBytes / 2) {
                            return availableBytes;
                        }
                        else {
                            return null;
                        }
                    }
                }).then(function (availableBytes) {
                    resolve(availableBytes);
                });
            }
        });
        var getAvailableSpace = getAvailableBytes.then(function (availableBytes) {
            if (availableBytes === null) {
                return '';
            }
            else {
                var availableSize = _this.textUtils.bytesToSize(availableBytes, 2);
                if (_this.platform.is('android') && size.size > availableBytes - __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].MINIMUM_FREE_SPACE) {
                    return Promise.reject(_this.translate.instant('core.course.insufficientavailablespace', { size: readableSize }));
                }
                return _this.translate.instant('core.course.availablespace', { available: availableSize });
            }
        });
        return getAvailableSpace.then(function (availableSpace) {
            wifiThreshold = typeof wifiThreshold == 'undefined' ? __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].WIFI_DOWNLOAD_THRESHOLD : wifiThreshold;
            limitedThreshold = typeof limitedThreshold == 'undefined' ? __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].DOWNLOAD_THRESHOLD : limitedThreshold;
            var wifiPrefix = '';
            if (_this.appProvider.isNetworkAccessLimited()) {
                wifiPrefix = _this.translate.instant('core.course.confirmlimiteddownload');
            }
            if (size.size < 0 || (size.size == 0 && !size.total)) {
                // Seems size was unable to be calculated. Show a warning.
                unknownMessage = unknownMessage || 'core.course.confirmdownloadunknownsize';
                return _this.showConfirm(wifiPrefix + _this.translate.instant(unknownMessage, { availableSpace: availableSpace }));
            }
            else if (!size.total) {
                // Filesize is only partial.
                return _this.showConfirm(wifiPrefix + _this.translate.instant('core.course.confirmpartialdownloadsize', { size: readableSize, availableSpace: availableSpace }));
            }
            else if (alwaysConfirm || size.size >= wifiThreshold ||
                (_this.appProvider.isNetworkAccessLimited() && size.size >= limitedThreshold)) {
                message = message || 'core.course.confirmdownload';
                return _this.showConfirm(wifiPrefix + _this.translate.instant(message, { size: readableSize, availableSpace: availableSpace }));
            }
            return Promise.resolve();
        });
    };
    /**
     * Convert some HTML as text into an HTMLElement. This HTML is put inside a div or a body.
     *
     * @param {string} html Text to convert.
     * @return {HTMLElement} Element.
     */
    CoreDomUtilsProvider.prototype.convertToElement = function (html) {
        // Add a div to hold the content, that's the element that will be returned.
        this.template.innerHTML = '<div>' + html + '</div>';
        return this.template.content.children[0];
    };
    /**
     * Create a "cancelled" error. These errors won't display an error message in showErrorModal functions.
     *
     * @return {any} The error object.
     */
    CoreDomUtilsProvider.prototype.createCanceledError = function () {
        return { coreCanceled: true };
    };
    /**
     * Given a list of changes for a component input detected by a KeyValueDiffers, create an object similar to the one
     * passed to the ngOnChanges functions.
     *
     * @param {any} changes Changes detected by KeyValueDiffer.
     * @return {{[name: string]: SimpleChange}} Changes in a format like ngOnChanges.
     */
    CoreDomUtilsProvider.prototype.createChangesFromKeyValueDiff = function (changes) {
        var newChanges = {};
        // Added items are considered first change.
        changes.forEachAddedItem(function (item) {
            newChanges[item.key] = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["_2" /* SimpleChange */](item.previousValue, item.currentValue, true);
        });
        // Changed or removed items aren't first change.
        changes.forEachChangedItem(function (item) {
            newChanges[item.key] = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["_2" /* SimpleChange */](item.previousValue, item.currentValue, false);
        });
        changes.forEachRemovedItem(function (item) {
            newChanges[item.key] = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["_2" /* SimpleChange */](item.previousValue, item.currentValue, true);
        });
        return newChanges;
    };
    /**
     * Extract the downloadable URLs from an HTML code.
     *
     * @param {string} html HTML code.
     * @return {string[]} List of file urls.
     */
    CoreDomUtilsProvider.prototype.extractDownloadableFilesFromHtml = function (html) {
        var urls = [];
        var elements;
        var element = this.convertToElement(html);
        elements = element.querySelectorAll('a, img, audio, video, source, track');
        for (var i = 0; i < elements.length; i++) {
            var element_1 = elements[i];
            var url = element_1.tagName === 'A' ? element_1.href : element_1.src;
            if (url && this.urlUtils.isDownloadableUrl(url) && urls.indexOf(url) == -1) {
                urls.push(url);
            }
            // Treat video poster.
            if (element_1.tagName == 'VIDEO' && element_1.getAttribute('poster')) {
                url = element_1.getAttribute('poster');
                if (url && this.urlUtils.isDownloadableUrl(url) && urls.indexOf(url) == -1) {
                    urls.push(url);
                }
            }
        }
        return urls;
    };
    /**
     * Extract the downloadable URLs from an HTML code and returns them in fake file objects.
     *
     * @param {string} html HTML code.
     * @return {any[]} List of fake file objects with file URLs.
     */
    CoreDomUtilsProvider.prototype.extractDownloadableFilesFromHtmlAsFakeFileObjects = function (html) {
        var urls = this.extractDownloadableFilesFromHtml(html);
        // Convert them to fake file objects.
        return urls.map(function (url) {
            return {
                fileurl: url
            };
        });
    };
    /**
     * Search all the URLs in a CSS file content.
     *
     * @param {string} code CSS code.
     * @return {string[]} List of URLs.
     */
    CoreDomUtilsProvider.prototype.extractUrlsFromCSS = function (code) {
        // First of all, search all the url(...) occurrences that don't include "data:".
        var urls = [], matches = code.match(/url\(\s*["']?(?!data:)([^)]+)\)/igm);
        if (!matches) {
            return urls;
        }
        // Extract the URL form each match.
        matches.forEach(function (match) {
            var submatches = match.match(/url\(\s*['"]?([^'"]*)['"]?\s*\)/im);
            if (submatches && submatches[1]) {
                urls.push(submatches[1]);
            }
        });
        return urls;
    };
    /**
     * Focus an element and open keyboard.
     *
     * @param {HTMLElement} el HTML element to focus.
     */
    CoreDomUtilsProvider.prototype.focusElement = function (el) {
        if (el && el.focus) {
            el.focus();
            if (this.platform.is('android') && this.supportsInputKeyboard(el)) {
                // On some Android versions the keyboard doesn't open automatically.
                this.appProvider.openKeyboard();
            }
        }
    };
    /**
     * Formats a size to be used as width/height of an element.
     * If the size is already valid (like '500px' or '50%') it won't be modified.
     * Returned size will have a format like '500px'.
     *
     * @param {any} size Size to format.
     * @return {string} Formatted size. If size is not valid, returns an empty string.
     */
    CoreDomUtilsProvider.prototype.formatPixelsSize = function (size) {
        if (typeof size == 'string' && (size.indexOf('px') > -1 || size.indexOf('%') > -1)) {
            // It seems to be a valid size.
            return size;
        }
        size = parseInt(size, 10);
        if (!isNaN(size)) {
            return size + 'px';
        }
        return '';
    };
    /**
     * Returns the contents of a certain selection in a DOM element.
     *
     * @param {HTMLElement} element DOM element to search in.
     * @param {string} selector Selector to search.
     * @return {string} Selection contents. Undefined if not found.
     */
    CoreDomUtilsProvider.prototype.getContentsOfElement = function (element, selector) {
        if (element) {
            var selected = element.querySelector(selector);
            if (selected) {
                return selected.innerHTML;
            }
        }
    };
    /**
     * Get the data from a form. It will only collect elements that have a name.
     *
     * @param {HTMLFormElement} form The form to get the data from.
     * @return {any} Object with the data. The keys are the names of the inputs.
     */
    CoreDomUtilsProvider.prototype.getDataFromForm = function (form) {
        if (!form || !form.elements) {
            return {};
        }
        var data = {};
        for (var i = 0; i < form.elements.length; i++) {
            var element = form.elements[i], name_1 = element.name || '';
            // Ignore submit inputs.
            if (!name_1 || element.type == 'submit' || element.tagName == 'BUTTON') {
                continue;
            }
            // Get the value.
            if (element.type == 'checkbox') {
                data[name_1] = !!element.checked;
            }
            else if (element.type == 'radio') {
                if (element.checked) {
                    data[name_1] = element.value;
                }
            }
            else {
                data[name_1] = element.value;
            }
        }
        return data;
    };
    /**
     * Returns the attribute value of a string element. Only the first element will be selected.
     *
     * @param  {string} html      HTML element in string.
     * @param  {string} attribute Attribute to get.
     * @return {string}           Attribute value.
     */
    CoreDomUtilsProvider.prototype.getHTMLElementAttribute = function (html, attribute) {
        return this.convertToElement(html).children[0].getAttribute('src');
    };
    /**
     * Returns height of an element.
     *
     * @param {any} element DOM element to measure.
     * @param {boolean} [usePadding] Whether to use padding to calculate the measure.
     * @param {boolean} [useMargin] Whether to use margin to calculate the measure.
     * @param {boolean} [useBorder] Whether to use borders to calculate the measure.
     * @param {boolean} [innerMeasure] If inner measure is needed: padding, margin or borders will be substracted.
     * @return {number} Height in pixels.
     */
    CoreDomUtilsProvider.prototype.getElementHeight = function (element, usePadding, useMargin, useBorder, innerMeasure) {
        return this.getElementMeasure(element, false, usePadding, useMargin, useBorder, innerMeasure);
    };
    /**
     * Returns height or width of an element.
     *
     * @param {any} element DOM element to measure.
     * @param {boolean} [getWidth] Whether to get width or height.
     * @param {boolean} [usePadding] Whether to use padding to calculate the measure.
     * @param {boolean} [useMargin] Whether to use margin to calculate the measure.
     * @param {boolean} [useBorder] Whether to use borders to calculate the measure.
     * @param {boolean} [innerMeasure] If inner measure is needed: padding, margin or borders will be substracted.
     * @return {number} Measure in pixels.
     */
    CoreDomUtilsProvider.prototype.getElementMeasure = function (element, getWidth, usePadding, useMargin, useBorder, innerMeasure) {
        var offsetMeasure = getWidth ? 'offsetWidth' : 'offsetHeight', measureName = getWidth ? 'width' : 'height', clientMeasure = getWidth ? 'clientWidth' : 'clientHeight', priorSide = getWidth ? 'Left' : 'Top', afterSide = getWidth ? 'Right' : 'Bottom';
        var measure = element[offsetMeasure] || element[measureName] || element[clientMeasure] || 0;
        // Measure not correctly taken.
        if (measure <= 0) {
            var style = getComputedStyle(element);
            if (style && style.display == '') {
                element.style.display = 'inline-block';
                measure = element[offsetMeasure] || element[measureName] || element[clientMeasure] || 0;
                element.style.display = '';
            }
        }
        if (usePadding || useMargin || useBorder) {
            var computedStyle = getComputedStyle(element);
            var surround = 0;
            if (usePadding) {
                surround += this.getComputedStyleMeasure(computedStyle, 'padding' + priorSide) +
                    this.getComputedStyleMeasure(computedStyle, 'padding' + afterSide);
            }
            if (useMargin) {
                surround += this.getComputedStyleMeasure(computedStyle, 'margin' + priorSide) +
                    this.getComputedStyleMeasure(computedStyle, 'margin' + afterSide);
            }
            if (useBorder) {
                surround += this.getComputedStyleMeasure(computedStyle, 'border' + priorSide + 'Width') +
                    this.getComputedStyleMeasure(computedStyle, 'border' + afterSide + 'Width');
            }
            if (innerMeasure) {
                measure = measure > surround ? measure - surround : 0;
            }
            else {
                measure += surround;
            }
        }
        return measure;
    };
    /**
     * Returns the computed style measure or 0 if not found or NaN.
     *
     * @param  {any}    style   Style from getComputedStyle.
     * @param  {string} measure Measure to get.
     * @return {number}         Result of the measure.
     */
    CoreDomUtilsProvider.prototype.getComputedStyleMeasure = function (style, measure) {
        return parseInt(style[measure], 10) || 0;
    };
    /**
     * Get the HTML code to render a connection warning icon.
     *
     * @return {string} HTML Code.
     */
    CoreDomUtilsProvider.prototype.getConnectionWarningIconHtml = function () {
        return '<div text-center><span class="core-icon-with-badge">' +
            '<ion-icon role="img" class="icon fa fa-wifi" aria-label="wifi"></ion-icon>' +
            '<ion-icon class="icon fa fa-exclamation-triangle core-icon-badge"></ion-icon>' +
            '</span></div>';
    };
    /**
     * Returns width of an element.
     *
     * @param {any} element DOM element to measure.
     * @param {boolean} [usePadding] Whether to use padding to calculate the measure.
     * @param {boolean} [useMargin] Whether to use margin to calculate the measure.
     * @param {boolean} [useBorder] Whether to use borders to calculate the measure.
     * @param {boolean} [innerMeasure] If inner measure is needed: padding, margin or borders will be substracted.
     * @return {number} Width in pixels.
     */
    CoreDomUtilsProvider.prototype.getElementWidth = function (element, usePadding, useMargin, useBorder, innerMeasure) {
        return this.getElementMeasure(element, true, usePadding, useMargin, useBorder, innerMeasure);
    };
    /**
     * Retrieve the position of a element relative to another element.
     *
     * @param {HTMLElement} container Element to search in.
     * @param {string} [selector] Selector to find the element to gets the position.
     * @param {string} [positionParentClass] Parent Class where to stop calculating the position. Default scroll-content.
     * @return {number[]} positionLeft, positionTop of the element relative to.
     */
    CoreDomUtilsProvider.prototype.getElementXY = function (container, selector, positionParentClass) {
        var element = (selector ? container.querySelector(selector) : container), offsetElement, positionTop = 0, positionLeft = 0;
        if (!positionParentClass) {
            positionParentClass = 'scroll-content';
        }
        if (!element) {
            return null;
        }
        while (element) {
            positionLeft += (element.offsetLeft - element.scrollLeft + element.clientLeft);
            positionTop += (element.offsetTop - element.scrollTop + element.clientTop);
            offsetElement = element.offsetParent;
            element = element.parentElement;
            // Every parent class has to be checked but the position has to be got form offsetParent.
            while (offsetElement != element && element) {
                // If positionParentClass element is reached, stop adding tops.
                if (element.className.indexOf(positionParentClass) != -1) {
                    element = null;
                }
                else {
                    element = element.parentElement;
                }
            }
            // Finally, check again.
            if (element && element.className.indexOf(positionParentClass) != -1) {
                element = null;
            }
        }
        return [positionLeft, positionTop];
    };
    /**
     * Given an error message, return a suitable error title.
     *
     * @param {string} message The error message.
     * @return {any} Title.
     */
    CoreDomUtilsProvider.prototype.getErrorTitle = function (message) {
        if (message == this.translate.instant('core.networkerrormsg') ||
            message == this.translate.instant('core.fileuploader.errormustbeonlinetoupload')) {
            return this.sanitizer.bypassSecurityTrustHtml(this.getConnectionWarningIconHtml());
        }
        return this.textUtils.decodeHTML(this.translate.instant('core.error'));
    };
    /**
     * Retrieve component/directive instance.
     * Please use this function only if you cannot retrieve the instance using parent/child methods: ViewChild (or similar)
     * or Angular's injection.
     *
     * @param {Element} element The root element of the component/directive.
     * @return {any} The instance, undefined if not found.
     */
    CoreDomUtilsProvider.prototype.getInstanceByElement = function (element) {
        var id = element.getAttribute(this.INSTANCE_ID_ATTR_NAME);
        return this.instances[id];
    };
    /**
     * Handle bootstrap tooltips in a certain element.
     *
     * @param {HTMLElement} element Element to check.
     */
    CoreDomUtilsProvider.prototype.handleBootstrapTooltips = function (element) {
        var _this = this;
        var els = Array.from(element.querySelectorAll('[data-toggle="tooltip"]'));
        els.forEach(function (el) {
            var content = el.getAttribute('title') || el.getAttribute('data-original-title'), trigger = el.getAttribute('data-trigger') || 'hover focus', treated = el.getAttribute('data-bstooltip-treated');
            if (!content || treated === 'true' ||
                (trigger.indexOf('hover') == -1 && trigger.indexOf('focus') == -1 && trigger.indexOf('click') == -1)) {
                return;
            }
            el.setAttribute('data-bstooltip-treated', 'true'); // Mark it as treated.
            // Store the title in data-original-title instead of title, like BS does.
            el.setAttribute('data-original-title', content);
            el.setAttribute('title', '');
            el.addEventListener('click', function (e) {
                var html = el.getAttribute('data-html');
                var popover = _this.popoverCtrl.create(__WEBPACK_IMPORTED_MODULE_10__components_bs_tooltip_bs_tooltip__["a" /* CoreBSTooltipComponent */], {
                    content: content,
                    html: html === 'true'
                });
                popover.present({
                    ev: e
                });
            });
        });
    };
    /**
     * Check if an element is outside of screen (viewport).
     *
     * @param {HTMLElement} scrollEl The element that must be scrolled.
     * @param {HTMLElement} element DOM element to check.
     * @return {boolean} Whether the element is outside of the viewport.
     */
    CoreDomUtilsProvider.prototype.isElementOutsideOfScreen = function (scrollEl, element) {
        var elementRect = element.getBoundingClientRect();
        var elementMidPoint, scrollElRect, scrollTopPos = 0;
        if (!elementRect) {
            return false;
        }
        elementMidPoint = Math.round((elementRect.bottom + elementRect.top) / 2);
        scrollElRect = scrollEl.getBoundingClientRect();
        scrollTopPos = (scrollElRect && scrollElRect.top) || 0;
        return elementMidPoint > window.innerHeight || elementMidPoint < scrollTopPos;
    };
    /**
     * Check if rich text editor is enabled.
     *
     * @return {Promise<boolean>} Promise resolved with boolean: true if enabled, false otherwise.
     */
    CoreDomUtilsProvider.prototype.isRichTextEditorEnabled = function () {
        if (this.isRichTextEditorSupported()) {
            return this.configProvider.get(__WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].SETTINGS_RICH_TEXT_EDITOR, true).then(function (enabled) {
                return !!enabled;
            });
        }
        return Promise.resolve(false);
    };
    /**
     * Check if rich text editor is supported in the platform.
     *
     * @return {boolean} Whether it's supported.
     */
    CoreDomUtilsProvider.prototype.isRichTextEditorSupported = function () {
        return true;
    };
    /**
     * Move children from one HTMLElement to another.
     *
     * @param {HTMLElement} oldParent The old parent.
     * @param {HTMLElement} newParent The new parent.
     * @return {Node[]} List of moved children.
     */
    CoreDomUtilsProvider.prototype.moveChildren = function (oldParent, newParent) {
        var movedChildren = [];
        while (oldParent.childNodes.length > 0) {
            var child = oldParent.childNodes[0];
            movedChildren.push(child);
            newParent.appendChild(child);
        }
        return movedChildren;
    };
    /**
     * Search and remove a certain element from inside another element.
     *
     * @param {HTMLElement} element DOM element to search in.
     * @param {string} selector Selector to search.
     */
    CoreDomUtilsProvider.prototype.removeElement = function (element, selector) {
        if (element) {
            var selected = element.querySelector(selector);
            if (selected) {
                selected.remove();
            }
        }
    };
    /**
     * Search and remove a certain element from an HTML code.
     *
     * @param {string} html HTML code to change.
     * @param {string} selector Selector to search.
     * @param {boolean} [removeAll] True if it should remove all matches found, false if it should only remove the first one.
     * @return {string} HTML without the element.
     */
    CoreDomUtilsProvider.prototype.removeElementFromHtml = function (html, selector, removeAll) {
        var selected;
        var element = this.convertToElement(html);
        if (removeAll) {
            selected = element.querySelectorAll(selector);
            for (var i = 0; i < selected.length; i++) {
                selected[i].remove();
            }
        }
        else {
            selected = element.querySelector(selector);
            if (selected) {
                selected.remove();
            }
        }
        return element.innerHTML;
    };
    /**
     * Remove a component/directive instance using the DOM Element.
     *
     * @param {Element} element The root element of the component/directive.
     */
    CoreDomUtilsProvider.prototype.removeInstanceByElement = function (element) {
        var id = element.getAttribute(this.INSTANCE_ID_ATTR_NAME);
        delete this.instances[id];
    };
    /**
     * Remove a component/directive instance using the ID.
     *
     * @param {string} id The ID to remove.
     */
    CoreDomUtilsProvider.prototype.removeInstanceById = function (id) {
        delete this.instances[id];
    };
    /**
     * Search for certain classes in an element contents and replace them with the specified new values.
     *
     * @param {HTMLElement} element DOM element.
     * @param {any} map Mapping of the classes to replace. Keys must be the value to replace, values must be
     *            the new class name. Example: {'correct': 'core-question-answer-correct'}.
     */
    CoreDomUtilsProvider.prototype.replaceClassesInElement = function (element, map) {
        for (var key in map) {
            var foundElements = element.querySelectorAll('.' + key);
            for (var i = 0; i < foundElements.length; i++) {
                var foundElement = foundElements[i];
                foundElement.className = foundElement.className.replace(key, map[key]);
            }
        }
    };
    /**
     * Given an HTML, search all links and media and tries to restore original sources using the paths object.
     *
     * @param {string} html HTML code.
     * @param {object} paths Object linking URLs in the html code with the real URLs to use.
     * @param {Function} [anchorFn] Function to call with each anchor. Optional.
     * @return {string} Treated HTML code.
     */
    CoreDomUtilsProvider.prototype.restoreSourcesInHtml = function (html, paths, anchorFn) {
        var _this = this;
        var media, anchors;
        var element = this.convertToElement(html);
        // Treat elements with src (img, audio, video, ...).
        media = Array.from(element.querySelectorAll('img, video, audio, source, track'));
        media.forEach(function (media) {
            var newSrc = paths[_this.textUtils.decodeURIComponent(media.getAttribute('src'))];
            if (typeof newSrc != 'undefined') {
                media.setAttribute('src', newSrc);
            }
            // Treat video posters.
            if (media.tagName == 'VIDEO' && media.getAttribute('poster')) {
                newSrc = paths[_this.textUtils.decodeURIComponent(media.getAttribute('poster'))];
                if (typeof newSrc !== 'undefined') {
                    media.setAttribute('poster', newSrc);
                }
            }
        });
        // Now treat links.
        anchors = Array.from(element.querySelectorAll('a'));
        anchors.forEach(function (anchor) {
            var href = _this.textUtils.decodeURIComponent(anchor.getAttribute('href')), newUrl = paths[href];
            if (typeof newUrl != 'undefined') {
                anchor.setAttribute('href', newUrl);
                if (typeof anchorFn == 'function') {
                    anchorFn(anchor, href);
                }
            }
        });
        return element.innerHTML;
    };
    /**
     * Scroll to somehere in the content.
     * Checks hidden property _scroll to avoid errors if view is not active.
     *
     * @param {Content} content Content where to execute the function.
     * @param {number} x  The x-value to scroll to.
     * @param {number} y  The y-value to scroll to.
     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.
     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.
     */
    CoreDomUtilsProvider.prototype.scrollTo = function (content, x, y, duration, done) {
        return content && content._scroll && content.scrollTo(x, y, duration, done);
    };
    /**
     * Scroll to Bottom of the content.
     * Checks hidden property _scroll to avoid errors if view is not active.
     *
     * @param {Content} content Content where to execute the function.
     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.
     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.
     */
    CoreDomUtilsProvider.prototype.scrollToBottom = function (content, duration) {
        return content && content._scroll && content.scrollToBottom(duration);
    };
    /**
     * Scroll to Top of the content.
     * Checks hidden property _scroll to avoid errors if view is not active.
     *
     * @param {Content} content Content where to execute the function.
     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.
     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.
     */
    CoreDomUtilsProvider.prototype.scrollToTop = function (content, duration) {
        return content && content._scroll && content.scrollToTop(duration);
    };
    /**
     * Returns contentHeight of the content.
     * Checks hidden property _scroll to avoid errors if view is not active.
     *
     * @param {Content} content Content where to execute the function.
     * @return {number}         Content contentHeight or 0.
     */
    CoreDomUtilsProvider.prototype.getContentHeight = function (content) {
        return (content && content._scroll && content.contentHeight) || 0;
    };
    /**
     * Returns scrollHeight of the content.
     * Checks hidden property _scroll to avoid errors if view is not active.
     *
     * @param {Content} content Content where to execute the function.
     * @return {number}         Content scrollHeight or 0.
     */
    CoreDomUtilsProvider.prototype.getScrollHeight = function (content) {
        return (content && content._scroll && content.scrollHeight) || 0;
    };
    /**
     * Returns scrollTop of the content.
     * Checks hidden property _scroll to avoid errors if view is not active.
     *
     * @param {Content} content Content where to execute the function.
     * @return {number}         Content scrollTop or 0.
     */
    CoreDomUtilsProvider.prototype.getScrollTop = function (content) {
        return (content && content._scroll && content.scrollTop) || 0;
    };
    /**
     * Scroll to a certain element.
     *
     * @param {Content} content The content that must be scrolled.
     * @param {HTMLElement} element The element to scroll to.
     * @param {string} [scrollParentClass] Parent class where to stop calculating the position. Default scroll-content.
     * @return {boolean} True if the element is found, false otherwise.
     */
    CoreDomUtilsProvider.prototype.scrollToElement = function (content, element, scrollParentClass) {
        var position = this.getElementXY(element, undefined, scrollParentClass);
        if (!position) {
            return false;
        }
        this.scrollTo(content, position[0], position[1]);
        return true;
    };
    /**
     * Scroll to a certain element using a selector to find it.
     *
     * @param {Content} content The content that must be scrolled.
     * @param {string} selector Selector to find the element to scroll to.
     * @param {string} [scrollParentClass] Parent class where to stop calculating the position. Default scroll-content.
     * @return {boolean} True if the element is found, false otherwise.
     */
    CoreDomUtilsProvider.prototype.scrollToElementBySelector = function (content, selector, scrollParentClass) {
        var position = this.getElementXY(content.getScrollElement(), selector, scrollParentClass);
        if (!position) {
            return false;
        }
        this.scrollTo(content, position[0], position[1]);
        return true;
    };
    /**
     * Search for an input with error (core-input-error directive) and scrolls to it if found.
     *
     * @param {Content} content The content that must be scrolled.
     * @param [scrollParentClass] Parent class where to stop calculating the position. Default scroll-content.
     * @return {boolean} True if the element is found, false otherwise.
     */
    CoreDomUtilsProvider.prototype.scrollToInputError = function (content, scrollParentClass) {
        if (!content) {
            return false;
        }
        return this.scrollToElementBySelector(content, '.core-input-error', scrollParentClass);
    };
    /**
     * Set whether debug messages should be displayed.
     *
     * @param {boolean} value Whether to display or not.
     */
    CoreDomUtilsProvider.prototype.setDebugDisplay = function (value) {
        this.debugDisplay = value;
    };
    /**
     * Show an alert modal with a button to close it.
     *
     * @param {string} title Title to show.
     * @param {string} message Message to show.
     * @param {string} [buttonText] Text of the button.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Promise<CoreAlert>} Promise resolved with the alert modal.
     */
    CoreDomUtilsProvider.prototype.showAlert = function (title, message, buttonText, autocloseTime) {
        var _this = this;
        var hasHTMLTags = this.textUtils.hasHTMLTags(message);
        var promise;
        if (hasHTMLTags) {
            // Format the text.
            promise = this.textUtils.formatText(message);
        }
        else {
            promise = Promise.resolve(message);
        }
        return promise.then(function (message) {
            var alertId = __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__["Md5"].hashAsciiStr((title || '') + '#' + (message || ''));
            if (_this.displayedAlerts[alertId]) {
                // There's already an alert with the same message and title. Return it.
                return _this.displayedAlerts[alertId];
            }
            var alert = _this.alertCtrl.create({
                title: title,
                message: message,
                buttons: [buttonText || _this.translate.instant('core.ok')]
            });
            alert.present().then(function () {
                if (hasHTMLTags) {
                    // Treat all anchors so they don't override the app.
                    var alertMessageEl = alert.pageRef().nativeElement.querySelector('.alert-message');
                    _this.treatAnchors(alertMessageEl);
                }
            });
            // Store the alert and remove it when dismissed.
            _this.displayedAlerts[alertId] = alert;
            // Define the observables to extend the Alert class. This will allow several callbacks instead of just one.
            alert.didDismiss = new __WEBPACK_IMPORTED_MODULE_12_rxjs__["Subject"]();
            alert.willDismiss = new __WEBPACK_IMPORTED_MODULE_12_rxjs__["Subject"]();
            // Set the callbacks to trigger an observable event.
            alert.onDidDismiss(function (data, role) {
                delete _this.displayedAlerts[alertId];
                alert.didDismiss.next({ data: data, role: role });
            });
            alert.onWillDismiss(function (data, role) {
                alert.willDismiss.next({ data: data, role: role });
            });
            if (autocloseTime > 0) {
                setTimeout(function () {
                    alert.dismiss();
                }, autocloseTime);
            }
            return alert;
        });
    };
    /**
     * Show an alert modal with a button to close it, translating the values supplied.
     *
     * @param {string} title Title to show.
     * @param {string} message Message to show.
     * @param {string} [buttonText] Text of the button.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Promise<Alert>} Promise resolved with the alert modal.
     */
    CoreDomUtilsProvider.prototype.showAlertTranslated = function (title, message, buttonText, autocloseTime) {
        title = title ? this.translate.instant(title) : title;
        message = message ? this.translate.instant(message) : message;
        buttonText = buttonText ? this.translate.instant(buttonText) : buttonText;
        return this.showAlert(title, message, buttonText, autocloseTime);
    };
    /**
     * Show a confirm modal.
     *
     * @param {string} message Message to show in the modal body.
     * @param {string} [title] Title of the modal.
     * @param {string} [okText] Text of the OK button.
     * @param {string} [cancelText] Text of the Cancel button.
     * @param {any} [options] More options. See https://ionicframework.com/docs/v3/api/components/alert/AlertController/
     * @return {Promise<any>} Promise resolved if the user confirms and rejected with a canceled error if he cancels.
     */
    CoreDomUtilsProvider.prototype.showConfirm = function (message, title, okText, cancelText, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var hasHTMLTags = _this.textUtils.hasHTMLTags(message);
            var promise;
            if (hasHTMLTags) {
                // Format the text.
                promise = _this.textUtils.formatText(message);
            }
            else {
                promise = Promise.resolve(message);
            }
            promise.then(function (message) {
                options = options || {};
                options.message = message;
                options.title = title;
                if (!title) {
                    options.cssClass = 'core-nohead';
                }
                options.buttons = [
                    {
                        text: cancelText || _this.translate.instant('core.cancel'),
                        role: 'cancel',
                        handler: function () {
                            reject(_this.createCanceledError());
                        }
                    },
                    {
                        text: okText || _this.translate.instant('core.ok'),
                        handler: function (data) {
                            resolve(data);
                        }
                    }
                ];
                var alert = _this.alertCtrl.create(options);
                alert.present().then(function () {
                    if (hasHTMLTags) {
                        // Treat all anchors so they don't override the app.
                        var alertMessageEl = alert.pageRef().nativeElement.querySelector('.alert-message');
                        _this.treatAnchors(alertMessageEl);
                    }
                });
            });
        });
    };
    /**
     * Show an alert modal with an error message.
     *
     * @param {any} error Message to show.
     * @param {boolean} [needsTranslate] Whether the error needs to be translated.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Promise<Alert>} Promise resolved with the alert modal.
     */
    CoreDomUtilsProvider.prototype.showErrorModal = function (error, needsTranslate, autocloseTime) {
        var extraInfo = '';
        if (typeof error == 'object') {
            if (this.debugDisplay) {
                // Get the debug info. Escape the HTML so it is displayed as it is in the view.
                if (error.debuginfo) {
                    extraInfo = '<br><br>' + this.textUtils.escapeHTML(error.debuginfo);
                }
                if (error.backtrace) {
                    extraInfo += '<br><br>' + this.textUtils.replaceNewLines(this.textUtils.escapeHTML(error.backtrace), '<br>');
                }
                // tslint:disable-next-line
                console.error(error);
            }
            // We received an object instead of a string. Search for common properties.
            if (error.coreCanceled) {
                // It's a canceled error, don't display an error.
                return;
            }
            error = this.textUtils.getErrorMessageFromError(error);
            if (!error) {
                // No common properties found, just stringify it.
                error = JSON.stringify(error);
                extraInfo = ''; // No need to add extra info because it's already in the error.
            }
            // Try to remove tokens from the contents.
            var matches = error.match(/token"?[=|:]"?(\w*)/, '');
            if (matches && matches[1]) {
                error = error.replace(new RegExp(matches[1], 'g'), 'secret');
            }
        }
        if (error == __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].DONT_SHOW_ERROR) {
            // The error shouldn't be shown, stop.
            return;
        }
        var message = this.textUtils.decodeHTML(needsTranslate ? this.translate.instant(error) : error);
        if (extraInfo) {
            message += extraInfo;
        }
        return this.showAlert(this.getErrorTitle(message), message, undefined, autocloseTime);
    };
    /**
     * Show an alert modal with an error message. It uses a default message if error is not a string.
     *
     * @param {any} error Message to show.
     * @param {any} [defaultError] Message to show if the error is not a string.
     * @param {boolean} [needsTranslate] Whether the error needs to be translated.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Promise<Alert>} Promise resolved with the alert modal.
     */
    CoreDomUtilsProvider.prototype.showErrorModalDefault = function (error, defaultError, needsTranslate, autocloseTime) {
        if (error && error.coreCanceled) {
            // It's a canceled error, don't display an error.
            return;
        }
        var errorMessage = error;
        if (error && typeof error != 'string') {
            errorMessage = this.textUtils.getErrorMessageFromError(error);
        }
        return this.showErrorModal(typeof errorMessage == 'string' ? error : defaultError, needsTranslate, autocloseTime);
    };
    /**
     * Show an alert modal with the first warning error message. It uses a default message if error is not a string.
     *
     * @param {any} warnings Warnings returned.
     * @param {any} [defaultError] Message to show if the error is not a string.
     * @param {boolean} [needsTranslate] Whether the error needs to be translated.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Promise<Alert>} Promise resolved with the alert modal.
     */
    CoreDomUtilsProvider.prototype.showErrorModalFirstWarning = function (warnings, defaultError, needsTranslate, autocloseTime) {
        var error = warnings && warnings.length && warnings[0].message;
        return this.showErrorModalDefault(error, defaultError, needsTranslate, autocloseTime);
    };
    /**
     * Displays a loading modal window.
     *
     * @param {string} [text] The text of the modal window. Default: core.loading.
     * @param {boolean} [needsTranslate] Whether the 'text' needs to be translated.
     * @return {Loading} Loading modal instance.
     * @description
     * Usage:
     *     let modal = domUtils.showModalLoading(myText);
     *     ...
     *     modal.dismiss();
     */
    CoreDomUtilsProvider.prototype.showModalLoading = function (text, needsTranslate) {
        if (!text) {
            text = this.translate.instant('core.loading');
        }
        else if (needsTranslate) {
            text = this.translate.instant(text);
        }
        var loader = this.loadingCtrl.create({
            content: text
        }), dismiss = loader.dismiss.bind(loader);
        var isPresented = false, isDismissed = false;
        // Override dismiss to prevent dismissing a modal twice (it can throw an error and cause problems).
        loader.dismiss = function (data, role, navOptions) {
            if (!isPresented || isDismissed) {
                isDismissed = true;
                return Promise.resolve();
            }
            isDismissed = true;
            return dismiss(data, role, navOptions);
        };
        // Wait a bit before presenting the modal, to prevent it being displayed if dissmiss is called fast.
        setTimeout(function () {
            if (!isDismissed) {
                isPresented = true;
                loader.present();
            }
        }, 40);
        return loader;
    };
    /**
     * Show a prompt modal to input some data.
     *
     * @param {string} message Modal message.
     * @param {string} [title] Modal title.
     * @param {string} [placeholder] Placeholder of the input element. By default, "Password".
     * @param {string} [type] Type of the input element. By default, password.
     * @return {Promise<any>} Promise resolved with the input data if the user clicks OK, rejected if cancels.
     */
    CoreDomUtilsProvider.prototype.showPrompt = function (message, title, placeholder, type) {
        var _this = this;
        if (type === void 0) { type = 'password'; }
        return new Promise(function (resolve, reject) {
            var hasHTMLTags = _this.textUtils.hasHTMLTags(message);
            var promise;
            if (hasHTMLTags) {
                // Format the text.
                promise = _this.textUtils.formatText(message);
            }
            else {
                promise = Promise.resolve(message);
            }
            promise.then(function (message) {
                var alert = _this.alertCtrl.create({
                    message: message,
                    title: title,
                    inputs: [
                        {
                            name: 'promptinput',
                            placeholder: placeholder || _this.translate.instant('core.login.password'),
                            type: type
                        }
                    ],
                    buttons: [
                        {
                            text: _this.translate.instant('core.cancel'),
                            role: 'cancel',
                            handler: function () {
                                reject();
                            }
                        },
                        {
                            text: _this.translate.instant('core.ok'),
                            handler: function (data) {
                                resolve(data.promptinput);
                            }
                        }
                    ]
                });
                alert.present().then(function () {
                    if (hasHTMLTags) {
                        // Treat all anchors so they don't override the app.
                        var alertMessageEl = alert.pageRef().nativeElement.querySelector('.alert-message');
                        _this.treatAnchors(alertMessageEl);
                    }
                });
            });
        });
    };
    /**
     * Displays an autodimissable toast modal window.
     *
     * @param {string} text The text of the toast.
     * @param {boolean} [needsTranslate] Whether the 'text' needs to be translated.
     * @param {number} [duration=2000] Duration in ms of the dimissable toast.
     * @param {string} [cssClass=""] Class to add to the toast.
     * @return {Toast} Toast instance.
     */
    CoreDomUtilsProvider.prototype.showToast = function (text, needsTranslate, duration, cssClass) {
        if (duration === void 0) { duration = 2000; }
        if (cssClass === void 0) { cssClass = ''; }
        if (needsTranslate) {
            text = this.translate.instant(text);
        }
        var loader = this.toastCtrl.create({
            message: text,
            duration: duration,
            position: 'bottom',
            cssClass: cssClass,
            dismissOnPageChange: true
        });
        loader.present();
        return loader;
    };
    /**
     * Stores a component/directive instance.
     *
     * @param {Element} element The root element of the component/directive.
     * @param {any} instance The instance to store.
     * @return {string} ID to identify the instance.
     */
    CoreDomUtilsProvider.prototype.storeInstanceByElement = function (element, instance) {
        var id = String(this.lastInstanceId++);
        element.setAttribute(this.INSTANCE_ID_ATTR_NAME, id);
        this.instances[id] = instance;
        return id;
    };
    /**
     * Check if an element supports input via keyboard.
     *
     * @param {any} el HTML element to check.
     * @return {boolean} Whether it supports input using keyboard.
     */
    CoreDomUtilsProvider.prototype.supportsInputKeyboard = function (el) {
        return el && !el.disabled && (el.tagName.toLowerCase() == 'textarea' ||
            (el.tagName.toLowerCase() == 'input' && this.INPUT_SUPPORT_KEYBOARD.indexOf(el.type) != -1));
    };
    /**
     * Converts HTML formatted text to DOM element(s).
     *
     * @param {string} text HTML text.
     * @return {HTMLCollection} Same text converted to HTMLCollection.
     */
    CoreDomUtilsProvider.prototype.toDom = function (text) {
        var element = this.convertToElement(text);
        return element.children;
    };
    /**
     * Treat anchors inside alert/modals.
     *
     * @param {HTMLElement} container The HTMLElement that can contain anchors.
     */
    CoreDomUtilsProvider.prototype.treatAnchors = function (container) {
        var _this = this;
        var anchors = Array.from(container.querySelectorAll('a'));
        anchors.forEach(function (anchor) {
            anchor.addEventListener('click', function (event) {
                if (event.defaultPrevented) {
                    // Stop.
                    return;
                }
                var href = anchor.getAttribute('href');
                if (href) {
                    event.preventDefault();
                    event.stopPropagation();
                    // We cannot use CoreDomUtilsProvider.openInBrowser due to circular dependencies.
                    if (_this.appProvider.isDesktop()) {
                        // It's a desktop app, use Electron shell library to open the browser.
                        var shell = __webpack_require__(125).shell;
                        if (!shell.openExternal(href)) {
                            // Open browser failed, open a new window in the app.
                            window.open(href, '_system');
                        }
                    }
                    else {
                        window.open(href, '_system');
                    }
                }
            });
        });
    };
    /**
     * View an image in a new page or modal.
     *
     * @param {string} image URL of the image.
     * @param {string} title Title of the page or modal.
     * @param {string} [component] Component to link the image to if needed.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     */
    CoreDomUtilsProvider.prototype.viewImage = function (image, title, component, componentId) {
        if (image) {
            var params = {
                title: title,
                image: image,
                component: component,
                componentId: componentId
            }, modal = this.modalCtrl.create('CoreViewerImagePage', params);
            modal.present();
        }
    };
    /**
     * Wait for images to load.
     *
     * @param {HTMLElement} element The element to search in.
     * @return {Promise<boolean>} Promise resolved with a boolean: whether there was any image to load.
     */
    CoreDomUtilsProvider.prototype.waitForImages = function (element) {
        var imgs = Array.from(element.querySelectorAll('img')), promises = [];
        var hasImgToLoad = false;
        imgs.forEach(function (img) {
            if (img && !img.complete) {
                hasImgToLoad = true;
                // Wait for image to load or fail.
                promises.push(new Promise(function (resolve, reject) {
                    var imgLoaded = function () {
                        resolve();
                        img.removeEventListener('load', imgLoaded);
                        img.removeEventListener('error', imgLoaded);
                    };
                    img.addEventListener('load', imgLoaded);
                    img.addEventListener('error', imgLoaded);
                }));
            }
        });
        return Promise.all(promises).then(function () {
            return hasImgToLoad;
        });
    };
    /**
     * Wrap an HTMLElement with another element.
     *
     * @param {HTMLElement} el The element to wrap.
     * @param {HTMLElement} wrapper Wrapper.
     */
    CoreDomUtilsProvider.prototype.wrapElement = function (el, wrapper) {
        // Insert the wrapper before the element.
        el.parentNode.insertBefore(wrapper, el);
        // Now move the element into the wrapper.
        wrapper.appendChild(el);
    };
    CoreDomUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* LoadingController */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["D" /* ToastController */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["b" /* AlertController */], __WEBPACK_IMPORTED_MODULE_4__text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_6__config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_7__url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ModalController */], __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["c" /* DomSanitizer */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["w" /* PopoverController */],
            __WEBPACK_IMPORTED_MODULE_8__providers_file__["a" /* CoreFileProvider */]])
    ], CoreDomUtilsProvider);
    return CoreDomUtilsProvider;
}());

//# sourceMappingURL=dom.js.map

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoggerProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Helper service to display messages in the console.
 *
 * @description
 * This service is meant to improve log messages, adding a timestamp and a name to all log messages.
 *
 * In your class constructor, call getInstance to configure your class name:
 * this.logger = logger.getInstance('InitPage');
 *
 * Then you can call the log function you want to use in this logger instance.
 */
var CoreLoggerProvider = /** @class */ (function () {
    function CoreLoggerProvider() {
        /** Whether the logging is enabled. */
        this.enabled = true;
        // Nothing to do.
    }
    /**
     * Get a logger instance for a certain class, service or component.
     *
     * @param {string} className Name to use in the messages.
     * @return {ant} Instance.
     */
    CoreLoggerProvider.prototype.getInstance = function (className) {
        className = className || '';
        /* tslint:disable no-console */
        return {
            log: this.prepareLogFn(console.log.bind(console), className),
            info: this.prepareLogFn(console.info.bind(console), className),
            warn: this.prepareLogFn(console.warn.bind(console), className),
            debug: this.prepareLogFn(console.debug.bind(console), className),
            error: this.prepareLogFn(console.error.bind(console), className)
        };
    };
    /**
     * Prepare a logging function, concatenating the timestamp and class name to all messages.
     *
     * @param {Function} logFn Log function to use.
     * @param {string} className Name to use in the messages.
     * @return {Function} Prepared function.
     */
    CoreLoggerProvider.prototype.prepareLogFn = function (logFn, className) {
        var _this = this;
        // Return our own function that will call the logging function with the treated message.
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (_this.enabled) {
                var now = __WEBPACK_IMPORTED_MODULE_1_moment__().format('l LTS');
                args[0] = now + ' ' + className + ': ' + args[0]; // Prepend timestamp and className to the original message.
                logFn.apply(null, args);
            }
        };
    };
    CoreLoggerProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], CoreLoggerProvider);
    return CoreLoggerProvider;
}());

//# sourceMappingURL=logger.js.map

/***/ }),
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreAppProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_keyboard__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_network__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_status_bar__ = __webpack_require__(527);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__db__ = __webpack_require__(406);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__configconstants__ = __webpack_require__(121);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Factory to provide some global functionalities, like access to the global app database.
 * @description
 * Each service or component should be responsible of creating their own database tables. Example:
 *
 * constructor(appProvider: CoreAppProvider) {
 *     this.appDB = appProvider.getDB();
 *     this.appDB.createTableFromSchema(this.tableSchema);
 * }
 */
var CoreAppProvider = /** @class */ (function () {
    function CoreAppProvider(dbProvider, platform, keyboard, appCtrl, network, logger, events, zone, menuCtrl, statusBar) {
        var _this = this;
        this.platform = platform;
        this.keyboard = keyboard;
        this.appCtrl = appCtrl;
        this.network = network;
        this.events = events;
        this.menuCtrl = menuCtrl;
        this.statusBar = statusBar;
        this.DBNAME = 'MoodleMobile';
        this.isKeyboardShown = false;
        this.backActions = [];
        this.mainMenuId = 0;
        this.forceOffline = false;
        this.logger = logger.getInstance('CoreAppProvider');
        this.db = dbProvider.getDB(this.DBNAME);
        this.keyboard.onKeyboardShow().subscribe(function (data) {
            // Execute the callback in the Angular zone, so change detection doesn't stop working.
            zone.run(function () {
                document.body.classList.add('keyboard-is-open');
                _this.isKeyboardShown = true;
                // Error on iOS calculating size.
                // More info: https://github.com/ionic-team/ionic-plugin-keyboard/issues/276 .
                events.trigger(__WEBPACK_IMPORTED_MODULE_7__events__["a" /* CoreEventsProvider */].KEYBOARD_CHANGE, data.keyboardHeight);
            });
        });
        this.keyboard.onKeyboardHide().subscribe(function (data) {
            // Execute the callback in the Angular zone, so change detection doesn't stop working.
            zone.run(function () {
                document.body.classList.remove('keyboard-is-open');
                _this.isKeyboardShown = false;
                events.trigger(__WEBPACK_IMPORTED_MODULE_7__events__["a" /* CoreEventsProvider */].KEYBOARD_CHANGE, 0);
            });
        });
        this.platform.registerBackButtonAction(function () {
            _this.backButtonAction();
        }, 100);
        // Export the app provider so Behat tests can change the forceOffline flag.
        window.appProvider = this;
    }
    /**
     * Check if the browser supports mediaDevices.getUserMedia.
     *
     * @return {boolean} Whether the function is supported.
     */
    CoreAppProvider.prototype.canGetUserMedia = function () {
        return !!(navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    };
    /**
     * Check if the browser supports MediaRecorder.
     *
     * @return {boolean} Whether the function is supported.
     */
    CoreAppProvider.prototype.canRecordMedia = function () {
        return !!window.MediaRecorder;
    };
    /**
     * Closes the keyboard.
     */
    CoreAppProvider.prototype.closeKeyboard = function () {
        if (this.isMobile()) {
            this.keyboard.hide();
        }
    };
    /**
     * Get the application global database.
     *
     * @return {SQLiteDB} App's DB.
     */
    CoreAppProvider.prototype.getDB = function () {
        return this.db;
    };
    /**
     * Get an ID for a main menu.
     *
     * @return {number} Main menu ID.
     */
    CoreAppProvider.prototype.getMainMenuId = function () {
        return this.mainMenuId++;
    };
    /**
     * Get the app's root NavController.
     *
     * @return {NavController} Root NavController.
     */
    CoreAppProvider.prototype.getRootNavController = function () {
        // Function getRootNav is deprecated. Get the first root nav, there should always be one.
        return this.appCtrl.getRootNavs()[0];
    };
    /**
     * Checks if the app is running in a 64 bits desktop environment (not browser).
     *
     * @return {boolean} Whether the app is running in a 64 bits desktop environment (not browser).
     */
    CoreAppProvider.prototype.is64Bits = function () {
        var process = window.process;
        return this.isDesktop() && process.arch == 'x64';
    };
    /**
     * Checks if the app is running in a desktop environment (not browser).
     *
     * @return {boolean} Whether the app is running in a desktop environment (not browser).
     */
    CoreAppProvider.prototype.isDesktop = function () {
        var process = window.process;
        return !!(process && process.versions && typeof process.versions.electron != 'undefined');
    };
    /**
     * Check if the keyboard is visible.
     *
     * @return {boolean} Whether keyboard is visible.
     */
    CoreAppProvider.prototype.isKeyboardVisible = function () {
        return this.isKeyboardShown;
    };
    /**
     * Check if the app is running in a Linux environment.
     *
     * @return {boolean} Whether it's running in a Linux environment.
     */
    CoreAppProvider.prototype.isLinux = function () {
        if (!this.isDesktop()) {
            return false;
        }
        try {
            return __webpack_require__(537).platform().indexOf('linux') === 0;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Check if the app is running in a Mac OS environment.
     *
     * @return {boolean} Whether it's running in a Mac OS environment.
     */
    CoreAppProvider.prototype.isMac = function () {
        if (!this.isDesktop()) {
            return false;
        }
        try {
            return __webpack_require__(537).platform().indexOf('darwin') === 0;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Check if the main menu is open.
     *
     * @return {boolean} Whether the main menu is open.
     */
    CoreAppProvider.prototype.isMainMenuOpen = function () {
        return typeof this.mainMenuOpen != 'undefined';
    };
    /**
     * Checks if the app is running in a mobile or tablet device (Cordova).
     *
     * @return {boolean} Whether the app is running in a mobile or tablet device.
     */
    CoreAppProvider.prototype.isMobile = function () {
        return this.platform.is('cordova');
    };
    /**
     * Checks if the current window is wider than a mobile.
     *
     * @return {boolean} Whether the app the current window is wider than a mobile.
     */
    CoreAppProvider.prototype.isWide = function () {
        return this.platform.width() > 768;
    };
    /**
     * Returns whether we are online.
     *
     * @return {boolean} Whether the app is online.
     */
    CoreAppProvider.prototype.isOnline = function () {
        if (this.forceOffline) {
            return false;
        }
        var online = this.network.type !== null && this.network.type != Connection.NONE && this.network.type != Connection.UNKNOWN;
        // Double check we are not online because we cannot rely 100% in Cordova APIs. Also, check it in browser.
        if (!online && navigator.onLine) {
            online = true;
        }
        return online;
    };
    /**
     * Check if device uses a limited connection.
     *
     * @return {boolean} Whether the device uses a limited connection.
     */
    CoreAppProvider.prototype.isNetworkAccessLimited = function () {
        var type = this.network.type;
        if (type === null) {
            // Plugin not defined, probably in browser.
            return false;
        }
        var limited = [Connection.CELL_2G, Connection.CELL_3G, Connection.CELL_4G, Connection.CELL];
        return limited.indexOf(type) > -1;
    };
    /**
     * Check if device uses a wifi connection.
     *
     * @return {boolean} Whether the device uses a wifi connection.
     */
    CoreAppProvider.prototype.isWifi = function () {
        return this.isOnline() && !this.isNetworkAccessLimited();
    };
    /**
     * Check if the app is running in a Windows environment.
     *
     * @return {boolean} Whether it's running in a Windows environment.
     */
    CoreAppProvider.prototype.isWindows = function () {
        if (!this.isDesktop()) {
            return false;
        }
        try {
            return __webpack_require__(537).platform().indexOf('win') === 0;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Open the keyboard.
     */
    CoreAppProvider.prototype.openKeyboard = function () {
        // Open keyboard is not supported in desktop and in iOS.
        if (this.isMobile() && !this.platform.is('ios')) {
            this.keyboard.show();
        }
    };
    /**
     * Set a main menu as open or not.
     *
     * @param {number} id Main menu ID.
     * @param {boolean} open Whether it's open or not.
     */
    CoreAppProvider.prototype.setMainMenuOpen = function (id, open) {
        if (open) {
            this.mainMenuOpen = id;
            this.events.trigger(__WEBPACK_IMPORTED_MODULE_7__events__["a" /* CoreEventsProvider */].MAIN_MENU_OPEN);
        }
        else if (this.mainMenuOpen == id) {
            delete this.mainMenuOpen;
        }
    };
    /**
     * Start an SSO authentication process.
     * Please notice that this function should be called when the app receives the new token from the browser,
     * NOT when the browser is opened.
     */
    CoreAppProvider.prototype.startSSOAuthentication = function () {
        var _this = this;
        var cancelTimeout, resolvePromise;
        this.ssoAuthenticationPromise = new Promise(function (resolve, reject) {
            resolvePromise = resolve;
            // Resolve it automatically after 10 seconds (it should never take that long).
            cancelTimeout = setTimeout(function () {
                _this.finishSSOAuthentication();
            }, 10000);
        });
        // Store the resolve function in the promise itself.
        this.ssoAuthenticationPromise.resolve = resolvePromise;
        // If the promise is resolved because finishSSOAuthentication is called, stop the cancel promise.
        this.ssoAuthenticationPromise.then(function () {
            clearTimeout(cancelTimeout);
        });
    };
    /**
     * Finish an SSO authentication process.
     */
    CoreAppProvider.prototype.finishSSOAuthentication = function () {
        if (this.ssoAuthenticationPromise) {
            this.ssoAuthenticationPromise.resolve && this.ssoAuthenticationPromise.resolve();
            this.ssoAuthenticationPromise = undefined;
        }
    };
    /**
     * Check if there's an ongoing SSO authentication process.
     *
     * @return {boolean} Whether there's a SSO authentication ongoing.
     */
    CoreAppProvider.prototype.isSSOAuthenticationOngoing = function () {
        return !!this.ssoAuthenticationPromise;
    };
    /**
     * Returns a promise that will be resolved once SSO authentication finishes.
     *
     * @return {Promise<any>} Promise resolved once SSO authentication finishes.
     */
    CoreAppProvider.prototype.waitForSSOAuthentication = function () {
        return this.ssoAuthenticationPromise || Promise.resolve();
    };
    /**
     * Retrieve redirect data.
     *
     * @return {CoreRedirectData} Object with siteid, state, params and timemodified.
     */
    CoreAppProvider.prototype.getRedirect = function () {
        if (localStorage && localStorage.getItem) {
            try {
                var data = {
                    siteId: localStorage.getItem('CoreRedirectSiteId'),
                    page: localStorage.getItem('CoreRedirectState'),
                    params: localStorage.getItem('CoreRedirectParams'),
                    timemodified: parseInt(localStorage.getItem('CoreRedirectTime'), 10)
                };
                if (data.params) {
                    data.params = JSON.parse(data.params);
                }
                return data;
            }
            catch (ex) {
                this.logger.error('Error loading redirect data:', ex);
            }
        }
        return {};
    };
    /**
     * Store redirect params.
     *
     * @param {string} siteId Site ID.
     * @param {string} page Page to go.
     * @param {any} params Page params.
     */
    CoreAppProvider.prototype.storeRedirect = function (siteId, page, params) {
        if (localStorage && localStorage.setItem) {
            try {
                localStorage.setItem('CoreRedirectSiteId', siteId);
                localStorage.setItem('CoreRedirectState', page);
                localStorage.setItem('CoreRedirectParams', JSON.stringify(params));
                localStorage.setItem('CoreRedirectTime', String(Date.now()));
            }
            catch (ex) {
                // Ignore errors.
            }
        }
    };
    /**
     * Implement the backbutton actions pile.
     */
    CoreAppProvider.prototype.backButtonAction = function () {
        var x = 0;
        for (; x < this.backActions.length; x++) {
            if (this.backActions[x].priority < 1000) {
                break;
            }
            // Stop in the first action taken.
            if (this.backActions[x].fn()) {
                return;
            }
        }
        // Close open modals if any.
        if (this.menuCtrl && this.menuCtrl.isOpen()) {
            this.menuCtrl.close();
            return;
        }
        // Remaining actions will have priority less than 1000.
        for (; x < this.backActions.length; x++) {
            if (this.backActions[x].priority < 500) {
                break;
            }
            // Stop in the first action taken.
            if (this.backActions[x].fn()) {
                return;
            }
        }
        // Nothing found, go back.
        var navPromise = this.appCtrl.navPop();
        if (navPromise) {
            return;
        }
        // No views to go back to.
        // Remaining actions will have priority less than 500.
        for (; x < this.backActions.length; x++) {
            // Stop in the first action taken.
            if (this.backActions[x].fn()) {
                return;
            }
        }
        // Ionic will decide (exit the app).
        this.appCtrl.goBack();
    };
    /**
     * The back button event is triggered when the user presses the native
     * platform's back button, also referred to as the "hardware" back button.
     * This event is only used within Cordova apps running on Android and
     * Windows platforms. This event is not fired on iOS since iOS doesn't come
     * with a hardware back button in the same sense an Android or Windows device
     * does.
     *
     * Registering a hardware back button action and setting a priority allows
     * apps to control which action should be called when the hardware back
     * button is pressed. This method decides which of the registered back button
     * actions has the highest priority and should be called.
     *
     * @param {Function} fn Called when the back button is pressed,
     * if this registered action has the highest priority.
     * @param {number} priority Set the priority for this action. All actions sorted by priority will be executed since one of
     * them returns true.
     *   * Priorities higher or equal than 1000 will go before closing modals
     *   * Priorities lower than 500 will only be executed if you are in the first state of the app (before exit).
     * @returns {Function} A function that, when called, will unregister
     * the back button action.
     */
    CoreAppProvider.prototype.registerBackButtonAction = function (fn, priority) {
        var _this = this;
        if (priority === void 0) { priority = 0; }
        var action = { fn: fn, priority: priority };
        this.backActions.push(action);
        this.backActions.sort(function (a, b) {
            return b.priority - a.priority;
        });
        return function () {
            var index = _this.backActions.indexOf(action);
            return index >= 0 && !!_this.backActions.splice(index, 1);
        };
    };
    /**
     * Set StatusBar color depending on platform.
     */
    CoreAppProvider.prototype.setStatusBarColor = function () {
        if (typeof __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbgios == 'string' && this.platform.is('ios')) {
            // IOS Status bar properties.
            this.statusBar.overlaysWebView(false);
            this.statusBar.backgroundColorByHexString(__WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbgios);
            __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarlighttextios ? this.statusBar.styleLightContent() : this.statusBar.styleDefault();
        }
        else if (typeof __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbgandroid == 'string' && this.platform.is('android')) {
            // Android Status bar properties.
            this.statusBar.backgroundColorByHexString(__WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbgandroid);
            __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarlighttextandroid ? this.statusBar.styleLightContent() : this.statusBar.styleDefault();
        }
        else if (typeof __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbg == 'string') {
            // Generic Status bar properties.
            this.platform.is('ios') && this.statusBar.overlaysWebView(false);
            this.statusBar.backgroundColorByHexString(__WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbg);
            __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarlighttext ? this.statusBar.styleLightContent() : this.statusBar.styleDefault();
        }
        else {
            // Default Status bar properties.
            this.platform.is('android') ? this.statusBar.styleLightContent() : this.statusBar.styleDefault();
        }
    };
    /**
     * Reset StatusBar color if any was set.
     */
    CoreAppProvider.prototype.resetStatusBarColor = function () {
        if (typeof __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbgremotetheme == 'string' &&
            ((typeof __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbgios == 'string' && this.platform.is('ios')) ||
                (typeof __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbgandroid == 'string' && this.platform.is('android')) ||
                typeof __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbg == 'string')) {
            // If the status bar has been overriden and there's a fallback color for remote themes, use it now.
            this.platform.is('ios') && this.statusBar.overlaysWebView(false);
            this.statusBar.backgroundColorByHexString(__WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarbgremotetheme);
            __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].statusbarlighttextremotetheme ?
                this.statusBar.styleLightContent() : this.statusBar.styleDefault();
        }
    };
    /**
     * Set value of forceOffline flag. If true, the app will think the device is offline.
     *
     * @param {boolean} value Value to set.
     */
    CoreAppProvider.prototype.setForceOffline = function (value) {
        this.forceOffline = !!value;
    };
    CoreAppProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__db__["a" /* CoreDbProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_keyboard__["a" /* Keyboard */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["c" /* App */],
            __WEBPACK_IMPORTED_MODULE_3__ionic_native_network__["a" /* Network */], __WEBPACK_IMPORTED_MODULE_6__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_7__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["M" /* NgZone */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["p" /* MenuController */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_status_bar__["a" /* StatusBar */]])
    ], CoreAppProvider);
    return CoreAppProvider;
}());

//# sourceMappingURL=app.js.map

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTextUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lang__ = __webpack_require__(164);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/*
 * "Utils" service with helper functions for text.
*/
var CoreTextUtilsProvider = /** @class */ (function () {
    function CoreTextUtilsProvider(translate, langProvider, modalCtrl, sanitizer, platform) {
        this.translate = translate;
        this.langProvider = langProvider;
        this.modalCtrl = modalCtrl;
        this.sanitizer = sanitizer;
        this.platform = platform;
        // List of regular expressions to convert the old nomenclature to new nomenclature for disabled features.
        this.DISABLED_FEATURES_COMPAT_REGEXPS = [
            { old: /\$mmLoginEmailSignup/g, new: 'CoreLoginEmailSignup' },
            { old: /\$mmSideMenuDelegate/g, new: 'CoreMainMenuDelegate' },
            { old: /\$mmCoursesDelegate/g, new: 'CoreCourseOptionsDelegate' },
            { old: /\$mmUserDelegate/g, new: 'CoreUserDelegate' },
            { old: /\$mmCourseDelegate/g, new: 'CoreCourseModuleDelegate' },
            { old: /_mmCourses/g, new: '_CoreCourses' },
            { old: /_mmaFrontpage/g, new: '_CoreSiteHome' },
            { old: /_mmaGrades/g, new: '_CoreGrades' },
            { old: /_mmaCompetency/g, new: '_AddonCompetency' },
            { old: /_mmaNotifications/g, new: '_AddonNotifications' },
            { old: /_mmaMessages/g, new: '_AddonMessages' },
            { old: /_mmaCalendar/g, new: '_AddonCalendar' },
            { old: /_mmaFiles/g, new: '_AddonFiles' },
            { old: /_mmaParticipants/g, new: '_CoreUserParticipants' },
            { old: /_mmaCourseCompletion/g, new: '_AddonCourseCompletion' },
            { old: /_mmaNotes/g, new: '_AddonNotes' },
            { old: /_mmaBadges/g, new: '_AddonBadges' },
            { old: /files_privatefiles/g, new: 'AddonFilesPrivateFiles' },
            { old: /files_sitefiles/g, new: 'AddonFilesSiteFiles' },
            { old: /files_upload/g, new: 'AddonFilesUpload' },
            { old: /_mmaModAssign/g, new: '_AddonModAssign' },
            { old: /_mmaModBook/g, new: '_AddonModBook' },
            { old: /_mmaModChat/g, new: '_AddonModChat' },
            { old: /_mmaModChoice/g, new: '_AddonModChoice' },
            { old: /_mmaModData/g, new: '_AddonModData' },
            { old: /_mmaModFeedback/g, new: '_AddonModFeedback' },
            { old: /_mmaModFolder/g, new: '_AddonModFolder' },
            { old: /_mmaModForum/g, new: '_AddonModForum' },
            { old: /_mmaModGlossary/g, new: '_AddonModGlossary' },
            { old: /_mmaModImscp/g, new: '_AddonModImscp' },
            { old: /_mmaModLabel/g, new: '_AddonModLabel' },
            { old: /_mmaModLesson/g, new: '_AddonModLesson' },
            { old: /_mmaModLti/g, new: '_AddonModLti' },
            { old: /_mmaModPage/g, new: '_AddonModPage' },
            { old: /_mmaModQuiz/g, new: '_AddonModQuiz' },
            { old: /_mmaModResource/g, new: '_AddonModResource' },
            { old: /_mmaModScorm/g, new: '_AddonModScorm' },
            { old: /_mmaModSurvey/g, new: '_AddonModSurvey' },
            { old: /_mmaModUrl/g, new: '_AddonModUrl' },
            { old: /_mmaModWiki/g, new: '_AddonModWiki' },
            { old: /_mmaModWorkshop/g, new: '_AddonModWorkshop' },
            { old: /remoteAddOn_/g, new: 'sitePlugin_' },
        ];
        this.template = document.createElement('template'); // A template element to convert HTML to element.
    }
    /**
     * Given an address as a string, return a URL to open the address in maps.
     *
     * @param {string} address The address.
     * @return {SafeUrl} URL to view the address.
     */
    CoreTextUtilsProvider.prototype.buildAddressURL = function (address) {
        return this.sanitizer.bypassSecurityTrustUrl((this.platform.is('android') ? 'geo:0,0?q=' : 'http://maps.google.com?q=') +
            encodeURIComponent(address));
    };
    /**
     * Given a list of sentences, build a message with all of them wrapped in <p>.
     *
     * @param {string[]} messages Messages to show.
     * @return {string} Message with all the messages.
     */
    CoreTextUtilsProvider.prototype.buildMessage = function (messages) {
        var result = '';
        messages.forEach(function (message) {
            if (message) {
                result += "<p>" + message + "</p>";
            }
        });
        return result;
    };
    /**
     * Convert size in bytes into human readable format
     *
     * @param {number} bytes Number of bytes to convert.
     * @param {number} [precision=2] Number of digits after the decimal separator.
     * @return {string} Size in human readable format.
     */
    CoreTextUtilsProvider.prototype.bytesToSize = function (bytes, precision) {
        if (precision === void 0) { precision = 2; }
        if (typeof bytes == 'undefined' || bytes === null || bytes < 0) {
            return this.translate.instant('core.notapplicable');
        }
        if (precision < 0) {
            precision = 2;
        }
        var keys = ['core.sizeb', 'core.sizekb', 'core.sizemb', 'core.sizegb', 'core.sizetb'], units = this.translate.instant(keys);
        var pos = 0;
        if (bytes >= 1024) {
            while (bytes >= 1024) {
                pos++;
                bytes = bytes / 1024;
            }
            // Round to "precision" decimals if needed.
            bytes = Number(Math.round(parseFloat(bytes + 'e+' + precision)) + 'e-' + precision);
        }
        return this.translate.instant('core.humanreadablesize', { size: bytes, unit: units[keys[pos]] });
    };
    /**
     * Clean HTML tags.
     *
     * @param {string} text The text to be cleaned.
     * @param {boolean} [singleLine] True if new lines should be removed (all the text in a single line).
     * @return {string} Clean text.
     */
    CoreTextUtilsProvider.prototype.cleanTags = function (text, singleLine) {
        if (typeof text != 'string') {
            return text;
        }
        if (!text) {
            return '';
        }
        // First, we use a regexpr.
        text = text.replace(/(<([^>]+)>)/ig, '');
        // Then, we rely on the browser. We need to wrap the text to be sure is HTML.
        var element = this.convertToElement(text);
        text = element.textContent;
        // Recover or remove new lines.
        text = this.replaceNewLines(text, singleLine ? ' ' : '<br>');
        return text;
    };
    /**
     * Concatenate two paths, adding a slash between them if needed.
     *
     * @param {string} leftPath Left path.
     * @param {string} rightPath Right path.
     * @return {string} Concatenated path.
     */
    CoreTextUtilsProvider.prototype.concatenatePaths = function (leftPath, rightPath) {
        if (!leftPath) {
            return rightPath;
        }
        else if (!rightPath) {
            return leftPath;
        }
        var lastCharLeft = leftPath.slice(-1), firstCharRight = rightPath.charAt(0);
        if (lastCharLeft === '/' && firstCharRight === '/') {
            return leftPath + rightPath.substr(1);
        }
        else if (lastCharLeft !== '/' && firstCharRight !== '/') {
            return leftPath + '/' + rightPath;
        }
        else {
            return leftPath + rightPath;
        }
    };
    /**
     * Convert some HTML as text into an HTMLElement. This HTML is put inside a div or a body.
     * This function is the same as in DomUtils, but we cannot use that one because of circular dependencies.
     *
     * @param {string} html Text to convert.
     * @return {HTMLElement} Element.
     */
    CoreTextUtilsProvider.prototype.convertToElement = function (html) {
        // Add a div to hold the content, that's the element that will be returned.
        this.template.innerHTML = '<div>' + html + '</div>';
        return this.template.content.children[0];
    };
    /**
     * Count words in a text.
     *
     * @param {string} text Text to count.
     * @return {number} Number of words.
     */
    CoreTextUtilsProvider.prototype.countWords = function (text) {
        if (!text || typeof text != 'string') {
            return 0;
        }
        var blockTags = ['address', 'article', 'aside', 'blockquote', 'br', ' details', 'dialog', 'dd', 'div', 'dl', 'dt',
            'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',
            'li', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];
        // Clean HTML scripts and tags.
        text = text.replace(/<script[^>]*>([\S\s]*?)<\/script>/gmi, '');
        // Replace block tags by space to get word count aware of line break and remove inline tags.
        text = text.replace(/<(\/[ ]*)?([a-zA-Z0-9]+)[^>]*>/gi, function (str, p1, match) {
            if (blockTags.indexOf(match) >= 0) {
                return ' ';
            }
            return '';
        });
        // Decode HTML entities.
        text = this.decodeHTMLEntities(text);
        // Replace underscores (which are classed as word characters) with spaces.
        text = text.replace(/_/gi, ' ');
        // This RegEx will detect any word change including Unicode chars. Some languages without spaces won't be counted fine.
        return text.match(/\S+/gi).length;
    };
    /**
     * Decode an escaped HTML text. This implementation is based on PHP's htmlspecialchars_decode.
     *
     * @param {string|number} text Text to decode.
     * @return {string} Decoded text.
     */
    CoreTextUtilsProvider.prototype.decodeHTML = function (text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        }
        else if (typeof text != 'string') {
            return '' + text;
        }
        return text
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#039;/g, '\'')
            .replace(/&nbsp;/g, ' ');
    };
    /**
     * Decode HTML entities in a text. Equivalent to PHP html_entity_decode.
     *
     * @param {string} text Text to decode.
     * @return {string} Decoded text.
     */
    CoreTextUtilsProvider.prototype.decodeHTMLEntities = function (text) {
        if (text) {
            var element = this.convertToElement(text);
            text = element.textContent;
        }
        return text;
    };
    /**
     * Same as Javascript's decodeURI, but if an exception is thrown it will return the original URI.
     *
     * @param {string} uri URI to decode.
     * @return {string} Decoded URI, or original URI if an exception is thrown.
     */
    CoreTextUtilsProvider.prototype.decodeURI = function (uri) {
        try {
            return decodeURI(uri);
        }
        catch (ex) {
            // Error, use the original URI.
        }
        return uri;
    };
    /**
     * Same as Javascript's decodeURIComponent, but if an exception is thrown it will return the original URI.
     *
     * @param {string} uri URI to decode.
     * @return {string} Decoded URI, or original URI if an exception is thrown.
     */
    CoreTextUtilsProvider.prototype.decodeURIComponent = function (uri) {
        try {
            return decodeURIComponent(uri);
        }
        catch (ex) {
            // Error, use the original URI.
        }
        return uri;
    };
    /**
     * Escapes some characters in a string to be used as a regular expression.
     *
     * @param {string} text Text to escape.
     * @return {string} Escaped text.
     */
    CoreTextUtilsProvider.prototype.escapeForRegex = function (text) {
        if (!text || typeof text != 'string') {
            return '';
        }
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    };
    /**
     * Escape an HTML text. This implementation is based on PHP's htmlspecialchars.
     *
     * @param {string|number} text Text to escape.
     * @return {string} Escaped text.
     */
    CoreTextUtilsProvider.prototype.escapeHTML = function (text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        }
        else if (typeof text != 'string') {
            return '' + text;
        }
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    };
    /**
     * Shows a text on a new page.
     *
     * @param {string} title Title of the new state.
     * @param {string} text Content of the text to be expanded.
     * @param {string} [component] Component to link the embedded files to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {any[]} [files] List of files to display along with the text.
     */
    CoreTextUtilsProvider.prototype.expandText = function (title, text, component, componentId, files) {
        if (text.length > 0) {
            var params = {
                title: title,
                content: text,
                component: component,
                componentId: componentId,
                files: files
            };
            // Open a modal with the contents.
            params.isModal = true;
            var modal = this.modalCtrl.create('CoreViewerTextPage', params);
            modal.present();
        }
    };
    /**
     * Formats a text, in HTML replacing new lines by correct html new lines.
     *
     * @param {string} text Text to format.
     * @return {string} Formatted text.
     */
    CoreTextUtilsProvider.prototype.formatHtmlLines = function (text) {
        var hasHTMLTags = this.hasHTMLTags(text);
        if (text.indexOf('<p>') == -1) {
            // Wrap the text in <p> tags.
            text = '<p>' + text + '</p>';
        }
        if (!hasHTMLTags) {
            // The text doesn't have HTML, replace new lines for <br>.
            return this.replaceNewLines(text, '<br>');
        }
        return text;
    };
    /**
     * Formats a text, treating multilang tags and cleaning HTML if needed.
     *
     * @param {string} text Text to format.
     * @param {boolean} [clean] Whether HTML tags should be removed.
     * @param {boolean} [singleLine] Whether new lines should be removed. Only valid if clean is true.
     * @param {number} [shortenLength] Number of characters to shorten the text.
     * @param {number} [highlight] Text to highlight.
     * @return {Promise<string>} Promise resolved with the formatted text.
     */
    CoreTextUtilsProvider.prototype.formatText = function (text, clean, singleLine, shortenLength, highlight) {
        var _this = this;
        return this.treatMultilangTags(text).then(function (formatted) {
            if (clean) {
                formatted = _this.cleanTags(formatted, singleLine);
            }
            if (shortenLength > 0) {
                formatted = _this.shortenText(formatted, shortenLength);
            }
            if (highlight) {
                formatted = _this.highlightText(formatted, highlight);
            }
            return formatted;
        });
    };
    /**
     * Get the error message from an error object.
     *
     * @param {any} error Error object.
     * @return {string} Error message, undefined if not found.
     */
    CoreTextUtilsProvider.prototype.getErrorMessageFromError = function (error) {
        if (typeof error == 'string') {
            return error;
        }
        return error && (error.message || error.error || error.content || error.body);
    };
    /**
     * Get the pluginfile URL to replace @@PLUGINFILE@@ wildcards.
     *
     * @param {any[]} files Files to extract the URL from. They need to have the URL in a 'url' or 'fileurl' attribute.
     * @return {string} Pluginfile URL, undefined if no files found.
     */
    CoreTextUtilsProvider.prototype.getTextPluginfileUrl = function (files) {
        if (files && files.length) {
            var fileURL = files[0].url || files[0].fileurl;
            // Remove text after last slash (encoded or not).
            return fileURL.substr(0, Math.max(fileURL.lastIndexOf('/'), fileURL.lastIndexOf('%2F')));
        }
        return undefined;
    };
    /**
     * Check if a text contains HTML tags.
     *
     * @param {string} text Text to check.
     * @return {boolean} Whether it has HTML tags.
     */
    CoreTextUtilsProvider.prototype.hasHTMLTags = function (text) {
        return /<[a-z][\s\S]*>/i.test(text);
    };
    /**
     * Highlight all occurrences of a certain text inside another text. It will add some HTML code to highlight it.
     *
     * @param {string} text Full text.
     * @param {string} searchText Text to search and highlight.
     * @return {string} Highlighted text.
     */
    CoreTextUtilsProvider.prototype.highlightText = function (text, searchText) {
        if (!text || typeof text != 'string') {
            return '';
        }
        else if (!searchText) {
            return text;
        }
        var regex = new RegExp('(' + searchText + ')', 'gi');
        return text.replace(regex, '<span class="matchtext">$1</span>');
    };
    /**
     * Check if HTML content is blank.
     *
     * @param {string} content HTML content.
     * @return {boolean} True if the string does not contain actual content: text, images, etc.
     */
    CoreTextUtilsProvider.prototype.htmlIsBlank = function (content) {
        if (!content) {
            return true;
        }
        var div = document.createElement('div');
        div.innerHTML = content;
        return div.textContent === '' && div.querySelector('img, object, hr') === null;
    };
    /**
     * Check if a text contains Unicode long chars.
     * Using as threshold Hex value D800
     *
     * @param {string} text Text to check.
     * @return {boolean} True if has Unicode chars, false otherwise.
     */
    CoreTextUtilsProvider.prototype.hasUnicode = function (text) {
        for (var x = 0; x < text.length; x++) {
            if (text.charCodeAt(x) > 55295) {
                return true;
            }
        }
        return false;
    };
    /**
     * Check if an object has any long Unicode char.
     *
     * @param {object} data Object to be checked.
     * @return {boolean} If the data has any long Unicode char on it.
     */
    CoreTextUtilsProvider.prototype.hasUnicodeData = function (data) {
        for (var el in data) {
            if (typeof data[el] == 'object') {
                if (this.hasUnicodeData(data[el])) {
                    return true;
                }
            }
            else if (typeof data[el] == 'string' && this.hasUnicode(data[el])) {
                return true;
            }
        }
        return false;
    };
    /**
     * Same as Javascript's JSON.parse, but it will handle errors.
     *
     * @param {string} json JSON text.
     * @param {any} [defaultValue] Default value t oreturn if the parse fails. Defaults to the original value.
     * @param {Function} [logErrorFn] An error to call with the exception to log the error. If not supplied, no error.
     * @return {any} JSON parsed as object or what it gets.
     */
    CoreTextUtilsProvider.prototype.parseJSON = function (json, defaultValue, logErrorFn) {
        try {
            return JSON.parse(json);
        }
        catch (ex) {
            // Error, log the error if needed.
            if (logErrorFn) {
                logErrorFn(ex);
            }
        }
        // Error parsing, return the default value or the original value.
        return typeof defaultValue != 'undefined' ? defaultValue : json;
    };
    /**
     * Remove ending slash from a path or URL.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.removeEndingSlash = function (text) {
        if (!text) {
            return '';
        }
        if (text.slice(-1) == '/') {
            return text.substr(0, text.length - 1);
        }
        return text;
    };
    /**
     * Replace all characters that cause problems with files in Android and iOS.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.removeSpecialCharactersForFiles = function (text) {
        if (!text || typeof text != 'string') {
            return '';
        }
        return text.replace(/[#:\/\?\\]+/g, '_');
    };
    /**
     * Replace all the new lines on a certain text.
     *
     * @param {string} text The text to be treated.
     * @param {string} newValue Text to use instead of new lines.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.replaceNewLines = function (text, newValue) {
        if (!text || typeof text != 'string') {
            return '';
        }
        return text.replace(/(?:\r\n|\r|\n)/g, newValue);
    };
    /**
     * Replace @@PLUGINFILE@@ wildcards with the real URL in a text.
     *
     * @param {string} Text to treat.
     * @param {any[]} files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.replacePluginfileUrls = function (text, files) {
        if (text && typeof text == 'string') {
            var fileURL = this.getTextPluginfileUrl(files);
            if (fileURL) {
                return text.replace(/@@PLUGINFILE@@/g, fileURL);
            }
        }
        return text;
    };
    /**
     * Replace pluginfile URLs with @@PLUGINFILE@@ wildcards.
     *
     * @param {string} text Text to treat.
     * @param {any[]} files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.restorePluginfileUrls = function (text, files) {
        if (text && typeof text == 'string') {
            var fileURL = this.getTextPluginfileUrl(files);
            if (fileURL) {
                return text.replace(new RegExp(this.escapeForRegex(fileURL), 'g'), '@@PLUGINFILE@@');
            }
        }
        return text;
    };
    /**
     * Rounds a number to use a certain amout of decimals or less.
     * Difference between this function and float's toFixed:
     * 7.toFixed(2) -> 7.00
     * roundToDecimals(7, 2) -> 7
     *
     * @param {number} num Number to round.
     * @param {number} [decimals=2] Number of decimals. By default, 2.
     * @return {number} Rounded number.
     */
    CoreTextUtilsProvider.prototype.roundToDecimals = function (num, decimals) {
        if (decimals === void 0) { decimals = 2; }
        var multiplier = Math.pow(10, decimals);
        return Math.round(num * multiplier) / multiplier;
    };
    /**
     * Add quotes to HTML characters.
     *
     * Returns text with HTML characters (like "<", ">", etc.) properly quoted.
     * Based on Moodle's s() function.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.s = function (text) {
        if (!text) {
            return '';
        }
        return this.escapeHTML(text).replace(/&amp;#(\d+|x[0-9a-f]+);/i, '&#$1;');
    };
    /**
     * Shortens a text to length and adds an ellipsis.
     *
     * @param {string} text The text to be shortened.
     * @param {number} length The desired length.
     * @return {string} Shortened text.
     */
    CoreTextUtilsProvider.prototype.shortenText = function (text, length) {
        if (text.length > length) {
            text = text.substr(0, length);
            // Now, truncate at the last word boundary (if exists).
            var lastWordPos = text.lastIndexOf(' ');
            if (lastWordPos > 0) {
                text = text.substr(0, lastWordPos);
            }
            text += '&hellip;';
        }
        return text;
    };
    /**
     * Strip Unicode long char of a given text.
     * Using as threshold Hex value D800
     *
     * @param {string} text Text to check.
     * @return {string} Without the Unicode chars.
     */
    CoreTextUtilsProvider.prototype.stripUnicode = function (text) {
        var stripped = '';
        for (var x = 0; x < text.length; x++) {
            if (text.charCodeAt(x) <= 55295) {
                stripped += text.charAt(x);
            }
        }
        return stripped;
    };
    /**
     * Treat the list of disabled features, replacing old nomenclature with the new one.
     *
     * @param {string} features List of disabled features.
     * @return {string} Treated list.
     */
    CoreTextUtilsProvider.prototype.treatDisabledFeatures = function (features) {
        if (!features) {
            return '';
        }
        for (var i = 0; i < this.DISABLED_FEATURES_COMPAT_REGEXPS.length; i++) {
            var entry = this.DISABLED_FEATURES_COMPAT_REGEXPS[i];
            features = features.replace(entry.old, entry.new);
        }
        return features;
    };
    /**
     * Treat the multilang tags from a HTML code, leaving only the current language.
     *
     * @param {string} text The text to be treated.
     * @return {Promise<string>} Promise resolved with the formatted text.
     */
    CoreTextUtilsProvider.prototype.treatMultilangTags = function (text) {
        if (!text || typeof text != 'string') {
            return Promise.resolve('');
        }
        return this.langProvider.getCurrentLanguage().then(function (language) {
            // Match the current language.
            var anyLangRegEx = /<(?:lang|span)[^>]+lang="[a-zA-Z0-9_-]+"[^>]*>(.*?)<\/(?:lang|span)>/g;
            var currentLangRegEx = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
            if (!text.match(currentLangRegEx)) {
                // Current lang not found. Try to find the first language.
                var matches = text.match(anyLangRegEx);
                if (matches && matches[0]) {
                    language = matches[0].match(/lang="([a-zA-Z0-9_-]+)"/)[1];
                    currentLangRegEx = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
                }
                else {
                    // No multi-lang tag found, stop.
                    return text;
                }
            }
            // Extract contents of current language.
            text = text.replace(currentLangRegEx, '$1');
            // Delete the rest of languages
            text = text.replace(anyLangRegEx, '');
            return text;
        });
    };
    /**
     * If a number has only 1 digit, add a leading zero to it.
     *
     * @param {string|number} num Number to convert.
     * @return {string} Number with leading zeros.
     */
    CoreTextUtilsProvider.prototype.twoDigits = function (num) {
        if (num < 10) {
            return '0' + num;
        }
        else {
            return '' + num; // Convert to string for coherence.
        }
    };
    /**
     * Make a string's first character uppercase.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.ucFirst = function (text) {
        return text.charAt(0).toUpperCase() + text.slice(1);
    };
    /**
     * Unserialize Array from PHP.
     * Taken from: https://github.com/kvz/locutus/blob/master/src/php/var/unserialize.js
     *
     * @param  {string} data String to unserialize.
     * @param {Function} [logErrorFn] An error to call with the exception to log the error. If not supplied, no error.
     * @return {any}         Unserialized data.
     */
    CoreTextUtilsProvider.prototype.unserialize = function (data, logErrorFn) {
        //  Discuss at: http://locutus.io/php/unserialize/
        // Original by: Arpad Ray (mailto:arpad@php.net)
        // Improved by: Pedro Tainha (http://www.pedrotainha.com)
        // Improved by: Kevin van Zonneveld (http://kvz.io)
        // Improved by: Kevin van Zonneveld (http://kvz.io)
        // Improved by: Chris
        // Improved by: James
        // Improved by: Le Torbi
        // Improved by: Eli Skeggs
        // Bugfixed by: dptr1988
        // Bugfixed by: Kevin van Zonneveld (http://kvz.io)
        // Bugfixed by: Brett Zamir (http://brett-zamir.me)
        // Bugfixed by: philippsimon (https://github.com/philippsimon/)
        //  Revised by: d3x
        //    Input by: Brett Zamir (http://brett-zamir.me)
        //    Input by: Martin (http://www.erlenwiese.de/)
        //    Input by: kilops
        //    Input by: Jaroslaw Czarniak
        //    Input by: lovasoa (https://github.com/lovasoa/)
        //      Note 1: We feel the main purpose of this function should be
        //      Note 1: to ease the transport of data between php & js
        //      Note 1: Aiming for PHP-compatibility, we have to translate objects to arrays
        //   Example 1: unserialize('a:3:{i:0;s:5:"Kevin";i:1;s:3:"van";i:2;s:9:"Zonneveld";}')
        //   Returns 1: ['Kevin', 'van', 'Zonneveld']
        //   Example 2: unserialize('a:2:{s:9:"firstName";s:5:"Kevin";s:7:"midName";s:3:"van";}')
        //   Returns 2: {firstName: 'Kevin', midName: 'van'}
        //   Example 3: unserialize('a:3:{s:2:"ü";s:2:"ü";s:3:"四";s:3:"四";s:4:"𠜎";s:4:"𠜎";}')
        //   Returns 3: {'ü': 'ü', '四': '四', '𠜎': '𠜎'}
        var utf8Overhead = function (str) {
            var s = str.length;
            for (var i = str.length - 1; i >= 0; i--) {
                var code = str.charCodeAt(i);
                if (code > 0x7f && code <= 0x7ff) {
                    s++;
                }
                else if (code > 0x7ff && code <= 0xffff) {
                    s += 2;
                }
                // Trail surrogate.
                if (code >= 0xDC00 && code <= 0xDFFF) {
                    i--;
                }
            }
            return s - 1;
        };
        var error = function (type, msg) {
            if (logErrorFn) {
                logErrorFn(type + msg);
            }
        };
        var readUntil = function (data, offset, stopchr) {
            var i = 2;
            var buf = [];
            var chr = data.slice(offset, offset + 1);
            while (chr !== stopchr) {
                if ((i + offset) > data.length) {
                    error('Error', 'Invalid');
                }
                buf.push(chr);
                chr = data.slice(offset + (i - 1), offset + i);
                i += 1;
            }
            return [buf.length, buf.join('')];
        };
        var readChrs = function (data, offset, length) {
            var chr;
            var buf = [];
            for (var i = 0; i < length; i++) {
                chr = data.slice(offset + (i - 1), offset + i);
                buf.push(chr);
                length -= utf8Overhead(chr);
            }
            return [buf.length, buf.join('')];
        };
        var _unserialize = function (data, offset) {
            var dtype, dataoffset, keyandchrs, keys, contig, length, array, readdata, readData, ccount, stringlength, i, key, kprops, kchrs, vprops, vchrs, value, chrs = 0, typeconvert = function (x) {
                return x;
            };
            if (!offset) {
                offset = 0;
            }
            dtype = (data.slice(offset, offset + 1)).toLowerCase();
            dataoffset = offset + 2;
            switch (dtype) {
                case 'i':
                    typeconvert = function (x) {
                        return parseInt(x, 10);
                    };
                    readData = readUntil(data, dataoffset, ';');
                    chrs = readData[0];
                    readdata = readData[1];
                    dataoffset += chrs + 1;
                    break;
                case 'b':
                    typeconvert = function (x) {
                        return parseInt(x, 10) !== 0;
                    };
                    readData = readUntil(data, dataoffset, ';');
                    chrs = readData[0];
                    readdata = readData[1];
                    dataoffset += chrs + 1;
                    break;
                case 'd':
                    typeconvert = function (x) {
                        return parseFloat(x);
                    };
                    readData = readUntil(data, dataoffset, ';');
                    chrs = readData[0];
                    readdata = readData[1];
                    dataoffset += chrs + 1;
                    break;
                case 'n':
                    readdata = null;
                    break;
                case 's':
                    ccount = readUntil(data, dataoffset, ':');
                    chrs = ccount[0];
                    stringlength = ccount[1];
                    dataoffset += chrs + 2;
                    readData = readChrs(data, dataoffset + 1, parseInt(stringlength, 10));
                    chrs = readData[0];
                    readdata = readData[1];
                    dataoffset += chrs + 2;
                    if (chrs !== parseInt(stringlength, 10) && chrs !== readdata.length) {
                        error('SyntaxError', 'String length mismatch');
                    }
                    break;
                case 'a':
                    readdata = {};
                    keyandchrs = readUntil(data, dataoffset, ':');
                    chrs = keyandchrs[0];
                    keys = keyandchrs[1];
                    dataoffset += chrs + 2;
                    length = parseInt(keys, 10);
                    contig = true;
                    for (var i_1 = 0; i_1 < length; i_1++) {
                        kprops = _unserialize(data, dataoffset);
                        kchrs = kprops[1];
                        key = kprops[2];
                        dataoffset += kchrs;
                        vprops = _unserialize(data, dataoffset);
                        vchrs = vprops[1];
                        value = vprops[2];
                        dataoffset += vchrs;
                        if (key !== i_1) {
                            contig = false;
                        }
                        readdata[key] = value;
                    }
                    if (contig) {
                        array = new Array(length);
                        for (i = 0; i < length; i++) {
                            array[i] = readdata[i];
                        }
                        readdata = array;
                    }
                    dataoffset += 1;
                    break;
                default:
                    error('SyntaxError', 'Unknown / Unhandled data type(s): ' + dtype);
                    break;
            }
            return [dtype, dataoffset - offset, typeconvert(readdata)];
        };
        return _unserialize((data + ''), 0)[2];
    };
    CoreTextUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_4__lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* ModalController */],
            __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__["c" /* DomSanitizer */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["v" /* Platform */]])
    ], CoreTextUtilsProvider);
    return CoreTextUtilsProvider;
}());

//# sourceMappingURL=text.js.map

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEventsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/*
 * Service to send and listen to events.
 */
var CoreEventsProvider = /** @class */ (function () {
    function CoreEventsProvider(logger) {
        this.observables = {};
        this.uniqueEvents = {};
        this.logger = logger.getInstance('CoreEventsProvider');
    }
    /**
     * Listen for a certain event. To stop listening to the event:
     * let observer = eventsProvider.on('something', myCallBack);
     * ...
     * observer.off();
     *
     * @param {string} eventName Name of the event to listen to.
     * @param {Function} callBack Function to call when the event is triggered.
     * @param {string} [siteId] Site where to trigger the event. Undefined won't check the site.
     * @return {CoreEventObserver} Observer to stop listening.
     */
    CoreEventsProvider.prototype.on = function (eventName, callBack, siteId) {
        var _this = this;
        // If it's a unique event and has been triggered already, call the callBack.
        // We don't need to create an observer because the event won't be triggered again.
        if (this.uniqueEvents[eventName]) {
            callBack(this.uniqueEvents[eventName].data);
            // Return a fake observer to prevent errors.
            return {
                off: function () {
                    // Nothing to do.
                }
            };
        }
        this.logger.debug("New observer listening to event '" + eventName + "'");
        if (typeof this.observables[eventName] == 'undefined') {
            // No observable for this event, create a new one.
            this.observables[eventName] = new __WEBPACK_IMPORTED_MODULE_1_rxjs__["Subject"]();
        }
        var subscription = this.observables[eventName].subscribe(function (value) {
            if (!siteId || value.siteId == siteId) {
                callBack(value);
            }
        });
        // Create and return a CoreEventObserver.
        return {
            off: function () {
                _this.logger.debug("Stop listening to event '" + eventName + "'");
                subscription.unsubscribe();
            }
        };
    };
    /**
     * Triggers an event, notifying all the observers.
     *
     * @param {string} event Name of the event to trigger.
     * @param {any} [data] Data to pass to the observers.
     * @param {string} [siteId] Site where to trigger the event. Undefined means no Site.
     */
    CoreEventsProvider.prototype.trigger = function (eventName, data, siteId) {
        this.logger.debug("Event '" + eventName + "' triggered.");
        if (this.observables[eventName]) {
            if (siteId) {
                if (!data) {
                    data = {};
                }
                data.siteId = siteId;
            }
            this.observables[eventName].next(data);
        }
    };
    /**
     * Triggers a unique event, notifying all the observers. If the event has already been triggered, don't do anything.
     *
     * @param {string} event Name of the event to trigger.
     * @param {any} data Data to pass to the observers.
     * @param {string} [siteId] Site where to trigger the event. Undefined means no Site.
     */
    CoreEventsProvider.prototype.triggerUnique = function (eventName, data, siteId) {
        if (this.uniqueEvents[eventName]) {
            this.logger.debug("Unique event '" + eventName + "' ignored because it was already triggered.");
        }
        else {
            this.logger.debug("Unique event '" + eventName + "' triggered.");
            if (siteId) {
                if (!data) {
                    data = {};
                }
                data.siteId = siteId;
            }
            // Store the data so it can be passed to observers that register from now on.
            this.uniqueEvents[eventName] = {
                data: data
            };
            // Now pass the data to observers.
            if (this.observables[eventName]) {
                this.observables[eventName].next(data);
            }
        }
    };
    CoreEventsProvider.SESSION_EXPIRED = 'session_expired';
    CoreEventsProvider.PASSWORD_CHANGE_FORCED = 'password_change_forced';
    CoreEventsProvider.USER_NOT_FULLY_SETUP = 'user_not_fully_setup';
    CoreEventsProvider.SITE_POLICY_NOT_AGREED = 'site_policy_not_agreed';
    CoreEventsProvider.LOGIN = 'login';
    CoreEventsProvider.LOGOUT = 'logout';
    CoreEventsProvider.LANGUAGE_CHANGED = 'language_changed';
    CoreEventsProvider.NOTIFICATION_SOUND_CHANGED = 'notification_sound_changed';
    CoreEventsProvider.SITE_ADDED = 'site_added';
    CoreEventsProvider.SITE_UPDATED = 'site_updated';
    CoreEventsProvider.SITE_DELETED = 'site_deleted';
    CoreEventsProvider.COMPLETION_MODULE_VIEWED = 'completion_module_viewed';
    CoreEventsProvider.USER_DELETED = 'user_deleted';
    CoreEventsProvider.PACKAGE_STATUS_CHANGED = 'package_status_changed';
    CoreEventsProvider.COURSE_STATUS_CHANGED = 'course_status_changed';
    CoreEventsProvider.SECTION_STATUS_CHANGED = 'section_status_changed';
    CoreEventsProvider.SITE_PLUGINS_LOADED = 'site_plugins_loaded';
    CoreEventsProvider.LOGIN_SITE_CHECKED = 'login_site_checked';
    CoreEventsProvider.LOGIN_SITE_UNCHECKED = 'login_site_unchecked';
    CoreEventsProvider.IAB_LOAD_START = 'inappbrowser_load_start';
    CoreEventsProvider.IAB_EXIT = 'inappbrowser_exit';
    CoreEventsProvider.APP_LAUNCHED_URL = 'app_launched_url'; // App opened with a certain URL (custom URL scheme).
    CoreEventsProvider.FILE_SHARED = 'file_shared';
    CoreEventsProvider.KEYBOARD_CHANGE = 'keyboard_change';
    CoreEventsProvider.CORE_LOADING_CHANGED = 'core_loading_changed';
    CoreEventsProvider.ORIENTATION_CHANGE = 'orientation_change';
    CoreEventsProvider.LOAD_PAGE_MAIN_MENU = 'load_page_main_menu';
    CoreEventsProvider.SEND_ON_ENTER_CHANGED = 'send_on_enter_changed';
    CoreEventsProvider.MAIN_MENU_OPEN = 'main_menu_open';
    CoreEventsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreEventsProvider);
    return CoreEventsProvider;
}());

//# sourceMappingURL=events.js.map

/***/ }),
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__course_offline__ = __webpack_require__(335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_siteplugins_providers_siteplugins__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__format_delegate__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_pushnotifications_providers_pushnotifications__ = __webpack_require__(140);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};















/**
 * Service that provides some features regarding a course.
 */
var CoreCourseProvider = /** @class */ (function () {
    function CoreCourseProvider(logger, sitesProvider, eventsProvider, utils, timeUtils, translate, courseOffline, appProvider, courseFormatDelegate, sitePluginsProvider, domUtils, pushNotificationsProvider) {
        this.sitesProvider = sitesProvider;
        this.eventsProvider = eventsProvider;
        this.utils = utils;
        this.timeUtils = timeUtils;
        this.translate = translate;
        this.courseOffline = courseOffline;
        this.appProvider = appProvider;
        this.courseFormatDelegate = courseFormatDelegate;
        this.sitePluginsProvider = sitePluginsProvider;
        this.domUtils = domUtils;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.ROOT_CACHE_KEY = 'mmCourse:';
        // Variables for database.
        this.COURSE_STATUS_TABLE = 'course_status';
        this.siteSchema = {
            name: 'CoreCourseProvider',
            version: 1,
            tables: [
                {
                    name: this.COURSE_STATUS_TABLE,
                    columns: [
                        {
                            name: 'id',
                            type: 'INTEGER',
                            primaryKey: true
                        },
                        {
                            name: 'status',
                            type: 'TEXT',
                            notNull: true
                        },
                        {
                            name: 'previous',
                            type: 'TEXT'
                        },
                        {
                            name: 'updated',
                            type: 'INTEGER'
                        },
                        {
                            name: 'downloadTime',
                            type: 'INTEGER'
                        },
                        {
                            name: 'previousDownloadTime',
                            type: 'INTEGER'
                        }
                    ]
                }
            ]
        };
        this.CORE_MODULES = [
            'assign', 'assignment', 'book', 'chat', 'choice', 'data', 'database', 'date', 'external-tool',
            'feedback', 'file', 'folder', 'forum', 'glossary', 'ims', 'imscp', 'label', 'lesson', 'lti', 'page', 'quiz',
            'resource', 'scorm', 'survey', 'url', 'wiki', 'workshop'
        ];
        this.logger = logger.getInstance('CoreCourseProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    CoreCourseProvider_1 = CoreCourseProvider;
    /**
     * Check if the get course blocks WS is available in current site.
     *
     * @return {boolean} Whether it's available.
     * @since 3.3
     */
    CoreCourseProvider.prototype.canGetCourseBlocks = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_block_get_course_blocks');
    };
    /**
     * Check whether the site supports requesting stealth modules.
     *
     * @param {CoreSite} [site] Site. If not defined, current site.
     * @return {boolean} Whether the site supports requesting stealth modules.
     * @since 3.4.6, 3.5.3, 3.6
     */
    CoreCourseProvider.prototype.canRequestStealthModules = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isVersionGreaterEqualThan(['3.4.6', '3.5.3']);
    };
    /**
     * Check if module completion could have changed. If it could have, trigger event. This function must be used,
     * for example, after calling a "module_view" WS since it can change the module completion.
     *
     * @param {number} courseId Course ID.
     * @param {any} completion Completion status of the module.
     */
    CoreCourseProvider.prototype.checkModuleCompletion = function (courseId, completion) {
        var _this = this;
        if (completion && completion.tracking === 2 && completion.state === 0) {
            this.invalidateSections(courseId).finally(function () {
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].COMPLETION_MODULE_VIEWED, { courseId: courseId });
            });
        }
    };
    /**
     * Clear all courses status in a site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when all status are cleared.
     */
    CoreCourseProvider.prototype.clearAllCoursesStatus = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Clear all course status for site ' + site.id);
            return site.getDb().deleteRecords(_this.COURSE_STATUS_TABLE).then(function () {
                _this.triggerCourseStatusChanged(CoreCourseProvider_1.ALL_COURSES_CLEARED, __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED, site.id);
            });
        });
    };
    /**
     * Get completion status of all the activities in a course for a certain user.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user.
     * @param {boolean} [forceCache] True if it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {boolean} [includeOffline=true] True if it should load offline data in the completion status.
     * @return {Promise<any>} Promise resolved with the completion statuses: object where the key is module ID.
     */
    CoreCourseProvider.prototype.getActivitiesCompletionStatus = function (courseId, siteId, userId, forceCache, ignoreCache, includeOffline) {
        var _this = this;
        if (forceCache === void 0) { forceCache = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        if (includeOffline === void 0) { includeOffline = true; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug("Getting completion status for user " + userId + " in course " + courseId);
            var params = {
                courseid: courseId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getActivitiesCompletionCacheKey(courseId, userId)
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('core_completion_get_activities_completion_status', params, preSets).then(function (data) {
                if (data && data.statuses) {
                    return _this.utils.arrayToObject(data.statuses, 'cmid');
                }
                return Promise.reject(null);
            }).then(function (completionStatus) {
                if (!includeOffline) {
                    return completionStatus;
                }
                // Now get the offline completion (if any).
                return _this.courseOffline.getCourseManualCompletions(courseId, site.id).then(function (offlineCompletions) {
                    offlineCompletions.forEach(function (offlineCompletion) {
                        if (offlineCompletion && typeof completionStatus[offlineCompletion.cmid] != 'undefined') {
                            var onlineCompletion = completionStatus[offlineCompletion.cmid];
                            // If the activity uses manual completion, override the value with the offline one.
                            if (onlineCompletion.tracking === 1) {
                                onlineCompletion.state = offlineCompletion.completed;
                                onlineCompletion.offline = true;
                            }
                        }
                    });
                    return completionStatus;
                }).catch(function () {
                    // Ignore errors.
                    return completionStatus;
                });
            });
        });
    };
    /**
     * Get cache key for activities completion WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getActivitiesCompletionCacheKey = function (courseId, userId) {
        return this.ROOT_CACHE_KEY + 'activitiescompletion:' + courseId + ':' + userId;
    };
    /**
     * Get course blocks.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of blocks.
     * @since 3.3
     */
    CoreCourseProvider.prototype.getCourseBlocks = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseid: courseId
            }, preSets = {
                cacheKey: _this.getCourseBlocksCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_block_get_course_blocks', params, preSets).then(function (result) {
                return result.blocks || [];
            });
        });
    };
    /**
     * Get cache key for course blocks WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getCourseBlocksCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'courseblocks:' + courseId;
    };
    /**
     * Get the data stored for a course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the data.
     */
    CoreCourseProvider.prototype.getCourseStatusData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.COURSE_STATUS_TABLE, { id: courseId }).then(function (entry) {
                if (!entry) {
                    return Promise.reject(null);
                }
                return entry;
            });
        });
    };
    /**
     * Get a course status.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreCourseProvider.prototype.getCourseStatus = function (courseId, siteId) {
        return this.getCourseStatusData(courseId, siteId).then(function (entry) {
            return entry.status || __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        });
    };
    /**
     * Get a module from Moodle.
     *
     * @param {number} moduleId The module ID.
     * @param {number} [courseId] The course ID. Recommended to speed up the process and minimize data usage.
     * @param {number} [sectionId] The section ID.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {string} [modName] If set, the app will retrieve all modules of this type with a single WS call. This reduces the
     *                           number of WS calls, but it isn't recommended for modules that can return a lot of contents.
     * @return {Promise<any>} Promise resolved with the module.
     */
    CoreCourseProvider.prototype.getModule = function (moduleId, courseId, sectionId, preferCache, ignoreCache, siteId, modName) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Helper function to do the WS request without processing the result.
        var doRequest = function (site, moduleId, modName, includeStealth, preferCache) {
            var params = {
                courseid: courseId,
                options: []
            };
            var preSets = {
                omitExpires: preferCache,
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (includeStealth) {
                params.options.push({
                    name: 'includestealthmodules',
                    value: 1
                });
            }
            // If modName is set, retrieve all modules of that type. Otherwise get only the module.
            if (modName) {
                params.options.push({
                    name: 'modname',
                    value: modName
                });
                preSets.cacheKey = _this.getModuleByModNameCacheKey(modName);
            }
            else {
                params.options.push({
                    name: 'cmid',
                    value: moduleId
                });
                preSets.cacheKey = _this.getModuleCacheKey(moduleId);
            }
            if (!preferCache && ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('core_course_get_contents', params, preSets).catch(function () {
                // The module might still be cached by a request with different parameters.
                if (!ignoreCache && !_this.appProvider.isOnline()) {
                    if (includeStealth) {
                        // Older versions didn't include the includestealthmodules option.
                        return doRequest(site, moduleId, modName, false, true);
                    }
                    else if (modName) {
                        // Falback to the request for the given moduleId only.
                        return doRequest(site, moduleId, undefined, _this.canRequestStealthModules(site), true);
                    }
                }
                return Promise.reject(null);
            });
        };
        var promise;
        if (!courseId) {
            // No courseId passed, try to retrieve it.
            promise = this.getModuleBasicInfo(moduleId, siteId).then(function (module) {
                courseId = module.course;
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            return _this.sitesProvider.getSite(siteId);
        }).then(function (site) {
            // We have courseId, we can use core_course_get_contents for compatibility.
            _this.logger.debug("Getting module " + moduleId + " in course " + courseId);
            return doRequest(site, moduleId, modName, _this.canRequestStealthModules(site), preferCache);
        }).catch(function () {
            // Error getting the module. Try to get all contents (without filtering by module).
            var preSets = {
                omitExpires: preferCache
            };
            if (!preferCache && ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return _this.getSections(courseId, false, false, preSets, siteId);
        }).then(function (sections) {
            for (var i = 0; i < sections.length; i++) {
                var section = sections[i];
                if (sectionId != null && !isNaN(sectionId) && section.id != CoreCourseProvider_1.STEALTH_MODULES_SECTION_ID &&
                    sectionId != section.id) {
                    continue;
                }
                for (var j = 0; j < section.modules.length; j++) {
                    var module_1 = section.modules[j];
                    if (module_1.id == moduleId) {
                        module_1.course = courseId;
                        return module_1;
                    }
                }
            }
            return Promise.reject(null);
        });
    };
    /**
     * Gets a module basic info by module ID.
     *
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module's info.
     */
    CoreCourseProvider.prototype.getModuleBasicInfo = function (moduleId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                cmid: moduleId
            }, preSets = {
                cacheKey: _this.getModuleCacheKey(moduleId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_course_get_course_module', params, preSets).then(function (response) {
                if (response.warnings && response.warnings.length) {
                    return Promise.reject(response.warnings[0]);
                }
                else if (response.cm) {
                    return response.cm;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Gets a module basic grade info by module ID.
     *
     * If the user does not have permision to manage the activity false is returned.
     *
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module's grade info.
     */
    CoreCourseProvider.prototype.getModuleBasicGradeInfo = function (moduleId, siteId) {
        return this.getModuleBasicInfo(moduleId, siteId).then(function (info) {
            var grade = {
                advancedgrading: info.advancedgrading || false,
                grade: info.grade || false,
                gradecat: info.gradecat || false,
                gradepass: info.gradepass || false,
                outcomes: info.outcomes || false,
                scale: info.scale || false
            };
            if (grade.grade !== false || grade.advancedgrading !== false || grade.outcomes !== false) {
                return grade;
            }
            return false;
        });
    };
    /**
     * Gets a module basic info by instance.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module's info.
     */
    CoreCourseProvider.prototype.getModuleBasicInfoByInstance = function (id, module, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                instance: id,
                module: module
            }, preSets = {
                cacheKey: _this.getModuleBasicInfoByInstanceCacheKey(id, module),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_course_get_course_module_by_instance', params, preSets).then(function (response) {
                if (response.warnings && response.warnings.length) {
                    return Promise.reject(response.warnings[0]);
                }
                else if (response.cm) {
                    return response.cm;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get module by instance WS calls.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getModuleBasicInfoByInstanceCacheKey = function (id, module) {
        return this.ROOT_CACHE_KEY + 'moduleByInstance:' + module + ':' + id;
    };
    /**
     * Get cache key for module WS calls.
     *
     * @param {number} moduleId Module ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getModuleCacheKey = function (moduleId) {
        return this.ROOT_CACHE_KEY + 'module:' + moduleId;
    };
    /**
     * Get cache key for module by modname WS calls.
     *
     * @param {string} modName Name of the module.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getModuleByModNameCacheKey = function (modName) {
        return this.ROOT_CACHE_KEY + 'module:modName:' + modName;
    };
    /**
     * Returns the source to a module icon.
     *
     * @param {string} moduleName The module name.
     * @param {string} [modicon] The mod icon string to use in case we are not using a core activity.
     * @return {string} The IMG src.
     */
    CoreCourseProvider.prototype.getModuleIconSrc = function (moduleName, modicon) {
        // @TODO: Check modicon url theme to apply other theme icons.
        // Use default icon on core themes.
        if (this.CORE_MODULES.indexOf(moduleName) < 0) {
            if (modicon) {
                return modicon;
            }
            moduleName = 'external-tool';
        }
        return 'assets/img/mod/' + moduleName + '.svg';
    };
    /**
     * Get the section ID a module belongs to.
     *
     * @param {number} moduleId The module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the section ID.
     */
    CoreCourseProvider.prototype.getModuleSectionId = function (moduleId, siteId) {
        // Try to get the section using getModuleBasicInfo.
        return this.getModuleBasicInfo(moduleId, siteId).then(function (module) {
            return module.section;
        });
    };
    /**
     * Return a specific section.
     *
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @param {boolean} [excludeModules] Do not return modules, return only the sections structure.
     * @param {boolean} [excludeContents] Do not return module contents (i.e: files inside a resource).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the section.
     */
    CoreCourseProvider.prototype.getSection = function (courseId, sectionId, excludeModules, excludeContents, siteId) {
        if (sectionId < 0) {
            return Promise.reject('Invalid section ID');
        }
        return this.getSections(courseId, excludeModules, excludeContents, undefined, siteId).then(function (sections) {
            for (var i = 0; i < sections.length; i++) {
                if (sections[i].id == sectionId) {
                    return sections[i];
                }
            }
            return Promise.reject('Unkown section');
        });
    };
    /**
     * Get the course sections.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} [excludeModules] Do not return modules, return only the sections structure.
     * @param {boolean} [excludeContents] Do not return module contents (i.e: files inside a resource).
     * @param {CoreSiteWSPreSets} [preSets] Presets to use.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [includeStealthModules] Whether to include stealth modules. Defaults to true.
     * @return {Promise}                The reject contains the error message, else contains the sections.
     */
    CoreCourseProvider.prototype.getSections = function (courseId, excludeModules, excludeContents, preSets, siteId, includeStealthModules) {
        var _this = this;
        if (includeStealthModules === void 0) { includeStealthModules = true; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            preSets = preSets || {};
            preSets.cacheKey = _this.getSectionsCacheKey(courseId);
            preSets.updateFrequency = preSets.updateFrequency || __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY;
            var params = {
                courseid: courseId,
                options: [
                    {
                        name: 'excludemodules',
                        value: excludeModules ? 1 : 0
                    },
                    {
                        name: 'excludecontents',
                        value: excludeContents ? 1 : 0
                    }
                ]
            };
            if (_this.canRequestStealthModules(site)) {
                params.options.push({
                    name: 'includestealthmodules',
                    value: includeStealthModules ? 1 : 0
                });
            }
            return site.read('core_course_get_contents', params, preSets).catch(function () {
                // Error getting the data, it could fail because we added a new parameter and the call isn't cached.
                // Retry without the new parameter and forcing cache.
                preSets.omitExpires = true;
                params.options.splice(-1, 1);
                return site.read('core_course_get_contents', params, preSets);
            }).then(function (sections) {
                var siteHomeId = site.getSiteHomeId();
                var showSections = true;
                if (courseId == siteHomeId) {
                    showSections = site.getStoredConfig('numsections');
                }
                if (typeof showSections != 'undefined' && !showSections && sections.length > 0) {
                    // Get only the last section (Main menu block section).
                    sections.pop();
                }
                return sections;
            });
        });
    };
    /**
     * Get cache key for section WS call.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getSectionsCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'sections:' + courseId;
    };
    /**
     * Given a list of sections, returns the list of modules in the sections.
     *
     * @param {any[]} sections Sections.
     * @return {any[]} Modules.
     */
    CoreCourseProvider.prototype.getSectionsModules = function (sections) {
        if (!sections || !sections.length) {
            return [];
        }
        var modules = [];
        sections.forEach(function (section) {
            if (section.modules) {
                modules = modules.concat(section.modules);
            }
        });
        return modules;
    };
    /**
     * Invalidates course blocks WS call.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateCourseBlocks = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseBlocksCacheKey(courseId));
        });
    };
    /**
     * Invalidates module WS call.
     *
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {string} [modName] Module name. E.g. 'label', 'url', ...
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateModule = function (moduleId, siteId, modName) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [];
            if (modName) {
                promises.push(site.invalidateWsCacheForKey(_this.getModuleByModNameCacheKey(modName)));
            }
            promises.push(site.invalidateWsCacheForKey(_this.getModuleCacheKey(moduleId)));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates module WS call.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateModuleByInstance = function (id, module, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getModuleBasicInfoByInstanceCacheKey(id, module));
        });
    };
    /**
     * Invalidates sections WS call.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateSections = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [], siteHomeId = site.getSiteHomeId();
            userId = userId || site.getUserId();
            promises.push(site.invalidateWsCacheForKey(_this.getSectionsCacheKey(courseId)));
            promises.push(site.invalidateWsCacheForKey(_this.getActivitiesCompletionCacheKey(courseId, userId)));
            if (courseId == siteHomeId) {
                promises.push(site.invalidateConfig());
            }
            return Promise.all(promises);
        });
    };
    /**
     * Load module contents into module.contents if they aren't loaded already.
     *
     * @param {any} module Module to load the contents.
     * @param {number} [courseId] The course ID. Recommended to speed up the process and minimize data usage.
     * @param {number} [sectionId] The section ID.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {string} [modName] If set, the app will retrieve all modules of this type with a single WS call. This reduces the
     *                           number of WS calls, but it isn't recommended for modules that can return a lot of contents.
     * @return {Promise<void>} Promise resolved when loaded.
     */
    CoreCourseProvider.prototype.loadModuleContents = function (module, courseId, sectionId, preferCache, ignoreCache, siteId, modName) {
        if (!ignoreCache && module.contents && module.contents.length) {
            // Already loaded.
            return Promise.resolve();
        }
        return this.getModule(module.id, courseId, sectionId, preferCache, ignoreCache, siteId, modName).then(function (mod) {
            module.contents = mod.contents;
        });
    };
    /**
     * Report a course and section as being viewed.
     *
     * @param {number} courseId  Course ID.
     * @param {number} [sectionNumber] Section number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {string} [name] Name of the course.
     * @return {Promise<void>} Promise resolved when the WS call is successful.
     */
    CoreCourseProvider.prototype.logView = function (courseId, sectionNumber, siteId, name) {
        var _this = this;
        var params = {
            courseid: courseId
        }, wsName = 'core_course_view_course';
        if (typeof sectionNumber != 'undefined') {
            params.sectionnumber = sectionNumber;
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.pushNotificationsProvider.logViewEvent(courseId, name, 'course', wsName, { sectionnumber: sectionNumber }, siteId);
            return site.write('core_course_view_course', params).then(function (response) {
                if (!response.status) {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Offline version for manually marking a module as completed.
     *
     * @param {number} cmId The module ID.
     * @param {number} completed Whether the module is completed or not.
     * @param {number} courseId Course ID the module belongs to.
     * @param {string} [courseName] Course name. Recommended, it is used to display a better warning message.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when completion is successfully sent or stored.
     */
    CoreCourseProvider.prototype.markCompletedManually = function (cmId, completed, courseId, courseName, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a completion to be synchronized later.
        var storeOffline = function () {
            return _this.courseOffline.markCompletedManually(cmId, completed, courseId, courseName, siteId);
        };
        // The offline function requires a courseId and it could be missing because it's a calculated field.
        if (!this.appProvider.isOnline() && courseId) {
            // App is offline, store the action.
            return storeOffline();
        }
        // Try to send it to server.
        return this.markCompletedManuallyOnline(cmId, completed, siteId).then(function (result) {
            // Data sent to server, if there is some offline data delete it now.
            return _this.courseOffline.deleteManualCompletion(cmId, siteId).catch(function () {
                // Ignore errors, shouldn't happen.
            }).then(function () {
                return result;
            });
        }).catch(function (error) {
            if (_this.utils.isWebServiceError(error) || !courseId) {
                // The WebService has thrown an error, this means that responses cannot be submitted.
                return Promise.reject(error);
            }
            else {
                // Couldn't connect to server, store it offline.
                return storeOffline();
            }
        });
    };
    /**
     * Offline version for manually marking a module as completed.
     *
     * @param {number} cmId The module ID.
     * @param {number} completed Whether the module is completed or not.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when completion is successfully sent.
     */
    CoreCourseProvider.prototype.markCompletedManuallyOnline = function (cmId, completed, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                cmid: cmId,
                completed: completed
            };
            return site.write('core_completion_update_activity_completion_status_manually', params);
        });
    };
    /**
     * Check if a module has a view page. E.g. labels don't have a view page.
     *
     * @param {any} module The module object.
     * @return {boolean} Whether the module has a view page.
     */
    CoreCourseProvider.prototype.moduleHasView = function (module) {
        return !!module.url;
    };
    /**
     * Wait for any course format plugin to load, and open the course page.
     *
     * If the plugin's promise is resolved, the course page will be opened.  If it is rejected, they will see an error.
     * If the promise for the plugin is still in progress when the user tries to open the course, a loader
     * will be displayed until it is complete, before the course page is opened.  If the promise is already complete,
     * they will see the result immediately.
     *
     * This function must be in here instead of course helper to prevent circular dependencies.
     *
     * @param {NavController} navCtrl The nav controller to use. If not defined, the course will be opened in main menu.
     * @param {any} course Course to open
     * @param {any} [params] Other params to pass to the course page.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseProvider.prototype.openCourse = function (navCtrl, course, params) {
        var _this = this;
        var loading = this.domUtils.showModalLoading();
        // Wait for site plugins to be fetched.
        return this.sitePluginsProvider.waitFetchPlugins().then(function () {
            if (_this.sitePluginsProvider.sitePluginPromiseExists('format_' + course.format)) {
                // This course uses a custom format plugin, wait for the format plugin to finish loading.
                return _this.sitePluginsProvider.sitePluginLoaded('format_' + course.format).then(function () {
                    // The format loaded successfully, but the handlers wont be registered until all site plugins have loaded.
                    if (_this.sitePluginsProvider.sitePluginsFinishedLoading) {
                        return _this.courseFormatDelegate.openCourse(navCtrl, course, params);
                    }
                    else {
                        // Wait for plugins to be loaded.
                        var deferred_1 = _this.utils.promiseDefer(), observer_1 = _this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].SITE_PLUGINS_LOADED, function () {
                            observer_1 && observer_1.off();
                            _this.courseFormatDelegate.openCourse(navCtrl, course, params).then(function (response) {
                                deferred_1.resolve(response);
                            }).catch(function (error) {
                                deferred_1.reject(error);
                            });
                        });
                        return deferred_1.promise;
                    }
                }).catch(function () {
                    // The site plugin failed to load. The user needs to restart the app to try loading it again.
                    _this.domUtils.showErrorModal('core.courses.errorloadplugins', true);
                });
            }
            else {
                // No custom format plugin. We don't need to wait for anything.
                return _this.courseFormatDelegate.openCourse(navCtrl, course, params);
            }
        }).finally(function () {
            loading.dismiss();
        });
    };
    /**
     * Change the course status, setting it to the previous status.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved when the status is changed. Resolve param: new status.
     */
    CoreCourseProvider.prototype.setCoursePreviousStatus = function (courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.logger.debug("Set previous status for course " + courseId + " in site " + siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var db = site.getDb(), newData = {};
            // Get current stored data.
            return _this.getCourseStatusData(courseId, siteId).then(function (entry) {
                _this.logger.debug("Set previous status '" + entry.status + "' for course " + courseId);
                newData.status = entry.previous || __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                newData.updated = Date.now();
                if (entry.status == __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADING) {
                    // Going back from downloading to previous status, restore previous download time.
                    newData.downloadTime = entry.previousDownloadTime;
                }
                return db.updateRecords(_this.COURSE_STATUS_TABLE, newData, { id: courseId }).then(function () {
                    // Success updating, trigger event.
                    _this.triggerCourseStatusChanged(courseId, newData.status, siteId);
                    return newData.status;
                });
            });
        });
    };
    /**
     * Store course status.
     *
     * @param {number} courseId Course ID.
     * @param {string} status New course status.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when the status is stored.
     */
    CoreCourseProvider.prototype.setCourseStatus = function (courseId, status, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.logger.debug("Set status '" + status + "' for course " + courseId + " in site " + siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var downloadTime, previousDownloadTime;
            if (status == __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADING) {
                // Set download time if course is now downloading.
                downloadTime = _this.timeUtils.timestamp();
            }
            // Search current status to set it as previous status.
            return _this.getCourseStatusData(courseId, siteId).then(function (entry) {
                if (typeof downloadTime == 'undefined') {
                    // Keep previous download time.
                    downloadTime = entry.downloadTime;
                    previousDownloadTime = entry.previousDownloadTime;
                }
                else {
                    // The downloadTime will be updated, store current time as previous.
                    previousDownloadTime = entry.downloadTime;
                }
                return entry.status;
            }).catch(function () {
                // No previous status.
            }).then(function (previousStatus) {
                if (previousStatus != status) {
                    // Status has changed, update it.
                    var data = {
                        id: courseId,
                        status: status,
                        previous: previousStatus,
                        updated: new Date().getTime(),
                        downloadTime: downloadTime,
                        previousDownloadTime: previousDownloadTime
                    };
                    return site.getDb().insertRecord(_this.COURSE_STATUS_TABLE, data);
                }
            }).then(function () {
                // Success inserting, trigger event.
                _this.triggerCourseStatusChanged(courseId, status, siteId);
            });
        });
    };
    /**
     * Translate a module name to current language.
     *
     * @param {string} moduleName The module name.
     * @return {string} Translated name.
     */
    CoreCourseProvider.prototype.translateModuleName = function (moduleName) {
        if (this.CORE_MODULES.indexOf(moduleName) < 0) {
            moduleName = 'external-tool';
        }
        var langKey = 'core.mod_' + moduleName, translated = this.translate.instant(langKey);
        return translated !== langKey ? translated : moduleName;
    };
    /**
     * Trigger COURSE_STATUS_CHANGED with the right data.
     *
     * @param {number} courseId Course ID.
     * @param {string} status New course status.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreCourseProvider.prototype.triggerCourseStatusChanged = function (courseId, status, siteId) {
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].COURSE_STATUS_CHANGED, {
            courseId: courseId,
            status: status
        }, siteId);
    };
    CoreCourseProvider.ALL_SECTIONS_ID = -2;
    CoreCourseProvider.STEALTH_MODULES_SECTION_ID = -1;
    CoreCourseProvider.ACCESS_GUEST = 'courses_access_guest';
    CoreCourseProvider.ACCESS_DEFAULT = 'courses_access_default';
    CoreCourseProvider.ALL_COURSES_CLEARED = -1;
    CoreCourseProvider.COMPLETION_TRACKING_NONE = 0;
    CoreCourseProvider.COMPLETION_TRACKING_MANUAL = 1;
    CoreCourseProvider.COMPLETION_TRACKING_AUTOMATIC = 2;
    CoreCourseProvider.COMPLETION_INCOMPLETE = 0;
    CoreCourseProvider.COMPLETION_COMPLETE = 1;
    CoreCourseProvider.COMPLETION_COMPLETE_PASS = 2;
    CoreCourseProvider.COMPLETION_COMPLETE_FAIL = 3;
    CoreCourseProvider.COMPONENT = 'CoreCourse';
    CoreCourseProvider = CoreCourseProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_11__course_offline__["a" /* CoreCourseOfflineProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_13__format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_12__core_siteplugins_providers_siteplugins__["a" /* CoreSitePluginsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_14__core_pushnotifications_providers_pushnotifications__["a" /* CorePushNotificationsProvider */]])
    ], CoreCourseProvider);
    return CoreCourseProvider;
    var CoreCourseProvider_1;
}());

//# sourceMappingURL=course.js.map

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_init__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_login_providers_helper__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__delegate__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__configconstants__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_siteplugins_providers_siteplugins__ = __webpack_require__(55);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
















/**
 * Service that provides some features regarding content links.
 */
var CoreContentLinksHelperProvider = /** @class */ (function () {
    function CoreContentLinksHelperProvider(logger, sitesProvider, loginHelper, contentLinksDelegate, appProvider, domUtils, urlUtils, translate, initDelegate, eventsProvider, textUtils, sitePluginsProvider, zone, utils) {
        this.sitesProvider = sitesProvider;
        this.loginHelper = loginHelper;
        this.contentLinksDelegate = contentLinksDelegate;
        this.appProvider = appProvider;
        this.domUtils = domUtils;
        this.urlUtils = urlUtils;
        this.translate = translate;
        this.initDelegate = initDelegate;
        this.textUtils = textUtils;
        this.sitePluginsProvider = sitePluginsProvider;
        this.zone = zone;
        this.utils = utils;
        this.logger = logger.getInstance('CoreContentLinksHelperProvider');
    }
    /**
     * Check whether a link can be handled by the app.
     *
     * @param {string} url URL to handle.
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @param {string} [username] Username to use to filter sites.
     * @param {boolean} [checkRoot] Whether to check if the URL is the root URL of a site.
     * @return {Promise<boolean>} Promise resolved with a boolean: whether the URL can be handled.
     */
    CoreContentLinksHelperProvider.prototype.canHandleLink = function (url, courseId, username, checkRoot) {
        var _this = this;
        var promise;
        if (checkRoot) {
            promise = this.sitesProvider.isStoredRootURL(url, username);
        }
        else {
            promise = Promise.resolve({});
        }
        return promise.then(function (data) {
            if (data.site) {
                // URL is the root of the site, can handle it.
                return true;
            }
            return _this.contentLinksDelegate.getActionsFor(url, undefined, username).then(function (actions) {
                return !!_this.getFirstValidAction(actions);
            });
        }).catch(function () {
            return false;
        });
    };
    /**
     * Get the first valid action in a list of actions.
     *
     * @param {CoreContentLinksAction[]} actions List of actions.
     * @return {CoreContentLinksAction} First valid action. Returns undefined if no valid action found.
     */
    CoreContentLinksHelperProvider.prototype.getFirstValidAction = function (actions) {
        if (actions) {
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                if (action && action.sites && action.sites.length) {
                    return action;
                }
            }
        }
    };
    /**
     * Goes to a certain page in a certain site. If the site is current site it will perform a regular navigation,
     * otherwise it will 'redirect' to the other site.
     *
     * @param {NavController} navCtrl The NavController instance to use.
     * @param {string} pageName Name of the page to go.
     * @param {any} [pageParams] Params to send to the page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreContentLinksHelperProvider.prototype.goInSite = function (navCtrl, pageName, pageParams, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var deferred = this.utils.promiseDefer();
        // Execute the code in the Angular zone, so change detection doesn't stop working.
        this.zone.run(function () {
            if (navCtrl && siteId == _this.sitesProvider.getCurrentSiteId()) {
                navCtrl.push(pageName, pageParams).then(deferred.resolve, deferred.reject);
            }
            else {
                _this.loginHelper.redirect(pageName, pageParams, siteId).then(deferred.resolve, deferred.reject);
            }
        });
        return deferred.promise;
    };
    /**
     * Go to the page to choose a site.
     *
     * @param {string} url URL to treat.
     */
    CoreContentLinksHelperProvider.prototype.goToChooseSite = function (url) {
        this.appProvider.getRootNavController().setRoot('CoreContentLinksChooseSitePage', { url: url });
    };
    /**
     * Handle a URL received by Custom URL Scheme.
     *
     * @param {string} url URL to handle.
     * @return {boolean} True if the URL should be handled by this component, false otherwise.
     * @deprecated Please use CoreCustomURLSchemesProvider.handleCustomURL instead.
     */
    CoreContentLinksHelperProvider.prototype.handleCustomUrl = function (url) {
        var _this = this;
        var contentLinksScheme = __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].customurlscheme + '://link';
        if (url.indexOf(contentLinksScheme) == -1) {
            return false;
        }
        var modal = this.domUtils.showModalLoading();
        var username;
        url = this.textUtils.decodeURIComponent(url);
        // App opened using custom URL scheme.
        this.logger.debug('Treating custom URL scheme: ' + url);
        // Delete the scheme from the URL.
        url = url.replace(contentLinksScheme + '=', '');
        // Detect if there's a user specified.
        username = this.urlUtils.getUsernameFromUrl(url);
        if (username) {
            url = url.replace(username + '@', ''); // Remove the username from the URL.
        }
        // Wait for the app to be ready.
        this.initDelegate.ready().then(function () {
            // Check if it's the root URL.
            return _this.sitesProvider.isStoredRootURL(url, username);
        }).then(function (data) {
            if (data.site) {
                // Root URL.
                modal.dismiss();
                return _this.handleRootURL(data.site, false);
            }
            else if (data.siteIds.length > 0) {
                modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.
                return _this.handleLink(url, username).then(function (treated) {
                    if (!treated) {
                        _this.domUtils.showErrorModal('core.contentlinks.errornoactions', true);
                    }
                });
            }
            else {
                // Get the site URL.
                var siteUrl = _this.contentLinksDelegate.getSiteUrl(url), urlToOpen_1 = url;
                if (!siteUrl) {
                    // Site URL not found, use the original URL since it could be the root URL of the site.
                    siteUrl = url;
                    urlToOpen_1 = undefined;
                }
                // Check that site exists.
                return _this.sitesProvider.checkSite(siteUrl).then(function (result) {
                    // Site exists. We'll allow to add it.
                    var ssoNeeded = _this.loginHelper.isSSOLoginNeeded(result.code), pageName = 'CoreLoginCredentialsPage', pageParams = {
                        siteUrl: result.siteUrl,
                        username: username,
                        urlToOpen: urlToOpen_1,
                        siteConfig: result.config
                    };
                    var promise, hasSitePluginsLoaded = false;
                    modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.
                    if (!_this.sitesProvider.isLoggedIn()) {
                        // Not logged in, no need to confirm. If SSO the confirm will be shown later.
                        promise = Promise.resolve();
                    }
                    else {
                        // Ask the user before changing site.
                        var confirmMsg = _this.translate.instant('core.contentlinks.confirmurlothersite');
                        promise = _this.domUtils.showConfirm(confirmMsg).then(function () {
                            if (!ssoNeeded) {
                                hasSitePluginsLoaded = _this.sitePluginsProvider.hasSitePluginsLoaded;
                                if (hasSitePluginsLoaded) {
                                    // Store the redirect since logout will restart the app.
                                    _this.appProvider.storeRedirect(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].NO_SITE_ID, pageName, pageParams);
                                }
                                return _this.sitesProvider.logout().catch(function () {
                                    // Ignore errors (shouldn't happen).
                                });
                            }
                        });
                    }
                    return promise.then(function () {
                        if (ssoNeeded) {
                            _this.loginHelper.confirmAndOpenBrowserForSSOLogin(result.siteUrl, result.code, result.service, result.config && result.config.launchurl);
                        }
                        else if (!hasSitePluginsLoaded) {
                            return _this.loginHelper.goToNoSitePage(undefined, pageName, pageParams);
                        }
                    });
                }).catch(function (error) {
                    _this.domUtils.showErrorModalDefault(error, _this.translate.instant('core.login.invalidsite'));
                });
            }
        }).finally(function () {
            modal.dismiss();
        });
        return true;
    };
    /**
     * Handle a link.
     *
     * @param {string} url URL to handle.
     * @param {string} [username] Username related with the URL. E.g. in 'http://myuser@m.com', url would be 'http://m.com' and
     *                            the username 'myuser'. Don't use it if you don't want to filter by username.
     * @param {NavController} [navCtrl] Nav Controller to use to navigate.
     * @param {boolean} [checkRoot] Whether to check if the URL is the root URL of a site.
     * @param {boolean} [openBrowserRoot] Whether to open in browser if it's root URL and it belongs to current site.
     * @return {Promise<boolean>} Promise resolved with a boolean: true if URL was treated, false otherwise.
     */
    CoreContentLinksHelperProvider.prototype.handleLink = function (url, username, navCtrl, checkRoot, openBrowserRoot) {
        var _this = this;
        var promise;
        if (checkRoot) {
            promise = this.sitesProvider.isStoredRootURL(url, username);
        }
        else {
            promise = Promise.resolve({});
        }
        return promise.then(function (data) {
            if (data.site) {
                // URL is the root of the site.
                _this.handleRootURL(data.site, openBrowserRoot);
                return true;
            }
            // Check if the link should be treated by some component/addon.
            return _this.contentLinksDelegate.getActionsFor(url, undefined, username).then(function (actions) {
                var action = _this.getFirstValidAction(actions);
                if (action) {
                    if (!_this.sitesProvider.isLoggedIn()) {
                        // No current site. Perform the action if only 1 site found, choose the site otherwise.
                        if (action.sites.length == 1) {
                            action.action(action.sites[0], navCtrl);
                        }
                        else {
                            _this.goToChooseSite(url);
                        }
                    }
                    else if (action.sites.length == 1 && action.sites[0] == _this.sitesProvider.getCurrentSiteId()) {
                        // Current site.
                        action.action(action.sites[0], navCtrl);
                    }
                    else {
                        // Not current site or more than one site. Ask for confirmation.
                        _this.domUtils.showConfirm(_this.translate.instant('core.contentlinks.confirmurlothersite')).then(function () {
                            if (action.sites.length == 1) {
                                action.action(action.sites[0], navCtrl);
                            }
                            else {
                                _this.goToChooseSite(url);
                            }
                        }).catch(function () {
                            // User canceled.
                        });
                    }
                    return true;
                }
                return false;
            }).catch(function () {
                return false;
            });
        });
    };
    /**
     * Handle a root URL of a site.
     *
     * @param {CoreSite} site Site to handle.
     * @param {boolean} [openBrowserRoot] Whether to open in browser if it's root URL and it belongs to current site.
     * @param {boolean} [checkToken] Whether to check that token is the same to verify it's current site. If false or not defined,
     *                               only the URL will be checked.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreContentLinksHelperProvider.prototype.handleRootURL = function (site, openBrowserRoot, checkToken) {
        var currentSite = this.sitesProvider.getCurrentSite();
        if (currentSite && currentSite.getURL() == site.getURL() && (!checkToken || currentSite.getToken() == site.getToken())) {
            // Already logged in.
            if (openBrowserRoot) {
                return site.openInBrowserWithAutoLogin(site.getURL());
            }
            return Promise.resolve();
        }
        else {
            // Login in the site.
            return this.loginHelper.redirect('', {}, site.getId());
        }
    };
    CoreContentLinksHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_11__core_login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_12__delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_4__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_15__core_siteplugins_providers_siteplugins__["a" /* CoreSitePluginsProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["M" /* NgZone */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreContentLinksHelperProvider);
    return CoreContentLinksHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFilepoolProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__init__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__plugin_file_delegate__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ws__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__utils_mimetype__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


















/*
 * Factory for handling downloading files and retrieve downloaded files.
 *
 * @description
 * This factory is responsible for handling downloading files.
 *
 * The two main goals of this is to keep the content available offline, and improve the user experience by caching
 * the content locally.
 */
var CoreFilepoolProvider = /** @class */ (function () {
    function CoreFilepoolProvider(logger, appProvider, fileProvider, sitesProvider, wsProvider, textUtils, utils, mimeUtils, urlUtils, timeUtils, eventsProvider, initDelegate, network, pluginFileDelegate, domUtils, zone) {
        var _this = this;
        this.appProvider = appProvider;
        this.fileProvider = fileProvider;
        this.sitesProvider = sitesProvider;
        this.wsProvider = wsProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.mimeUtils = mimeUtils;
        this.urlUtils = urlUtils;
        this.timeUtils = timeUtils;
        this.eventsProvider = eventsProvider;
        this.pluginFileDelegate = pluginFileDelegate;
        this.domUtils = domUtils;
        // Constants.
        this.QUEUE_PROCESS_INTERVAL = 0;
        this.FOLDER = 'filepool';
        this.WIFI_DOWNLOAD_THRESHOLD = 20971520; // 20MB.
        this.DOWNLOAD_THRESHOLD = 2097152; // 2MB.
        this.QUEUE_RUNNING = 'CoreFilepool:QUEUE_RUNNING';
        this.QUEUE_PAUSED = 'CoreFilepool:QUEUE_PAUSED';
        this.ERR_QUEUE_IS_EMPTY = 'CoreFilepoolError:ERR_QUEUE_IS_EMPTY';
        this.ERR_FS_OR_NETWORK_UNAVAILABLE = 'CoreFilepoolError:ERR_FS_OR_NETWORK_UNAVAILABLE';
        this.ERR_QUEUE_ON_PAUSE = 'CoreFilepoolError:ERR_QUEUE_ON_PAUSE';
        // Variables for database.
        this.QUEUE_TABLE = 'filepool_files_queue'; // Queue of files to download.
        this.FILES_TABLE = 'filepool_files'; // Downloaded files.
        this.LINKS_TABLE = 'filepool_files_links'; // Links between downloaded files and components.
        this.PACKAGES_TABLE = 'filepool_packages'; // Downloaded packages (sets of files).
        this.appTablesSchema = [
            {
                name: this.QUEUE_TABLE,
                columns: [
                    {
                        name: 'siteId',
                        type: 'TEXT'
                    },
                    {
                        name: 'fileId',
                        type: 'TEXT'
                    },
                    {
                        name: 'added',
                        type: 'INTEGER'
                    },
                    {
                        name: 'priority',
                        type: 'INTEGER'
                    },
                    {
                        name: 'url',
                        type: 'TEXT'
                    },
                    {
                        name: 'revision',
                        type: 'INTEGER'
                    },
                    {
                        name: 'timemodified',
                        type: 'INTEGER'
                    },
                    {
                        name: 'isexternalfile',
                        type: 'INTEGER'
                    },
                    {
                        name: 'repositorytype',
                        type: 'TEXT'
                    },
                    {
                        name: 'path',
                        type: 'TEXT'
                    },
                    {
                        name: 'links',
                        type: 'TEXT'
                    }
                ],
                primaryKeys: ['siteId', 'fileId']
            }
        ];
        this.siteSchema = {
            name: 'CoreFilepoolProvider',
            version: 1,
            tables: [
                {
                    name: this.FILES_TABLE,
                    columns: [
                        {
                            name: 'fileId',
                            type: 'TEXT',
                            primaryKey: true
                        },
                        {
                            name: 'url',
                            type: 'TEXT',
                            notNull: true
                        },
                        {
                            name: 'revision',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        },
                        {
                            name: 'stale',
                            type: 'INTEGER'
                        },
                        {
                            name: 'downloadTime',
                            type: 'INTEGER'
                        },
                        {
                            name: 'isexternalfile',
                            type: 'INTEGER'
                        },
                        {
                            name: 'repositorytype',
                            type: 'TEXT'
                        },
                        {
                            name: 'path',
                            type: 'TEXT'
                        },
                        {
                            name: 'extension',
                            type: 'TEXT'
                        }
                    ]
                },
                {
                    name: this.LINKS_TABLE,
                    columns: [
                        {
                            name: 'fileId',
                            type: 'TEXT'
                        },
                        {
                            name: 'component',
                            type: 'TEXT'
                        },
                        {
                            name: 'componentId',
                            type: 'TEXT'
                        }
                    ],
                    primaryKeys: ['fileId', 'component', 'componentId']
                },
                {
                    name: this.PACKAGES_TABLE,
                    columns: [
                        {
                            name: 'id',
                            type: 'TEXT',
                            primaryKey: true
                        },
                        {
                            name: 'component',
                            type: 'TEXT'
                        },
                        {
                            name: 'componentId',
                            type: 'TEXT'
                        },
                        {
                            name: 'status',
                            type: 'TEXT'
                        },
                        {
                            name: 'previous',
                            type: 'TEXT'
                        },
                        {
                            name: 'updated',
                            type: 'INTEGER'
                        },
                        {
                            name: 'downloadTime',
                            type: 'INTEGER'
                        },
                        {
                            name: 'previousDownloadTime',
                            type: 'INTEGER'
                        },
                        {
                            name: 'extra',
                            type: 'TEXT'
                        }
                    ]
                }
            ]
        };
        this.tokenRegex = new RegExp('(\\?|&)token=([A-Za-z0-9]*)');
        this.urlAttributes = [
            this.tokenRegex,
            new RegExp('(\\?|&)forcedownload=[0-1]'),
            new RegExp('(\\?|&)preview=[A-Za-z0-9]+'),
            new RegExp('(\\?|&)offline=[0-1]', 'g')
        ];
        this.queueDeferreds = {}; // To handle file downloads using the queue.
        this.sizeCache = {}; // A "cache" to store file sizes to prevent performing too many HEAD requests.
        // Variables to prevent downloading packages/files twice at the same time.
        this.packagesPromises = {};
        this.filePromises = {};
        this.logger = logger.getInstance('CoreFilepoolProvider');
        this.appDB = this.appProvider.getDB();
        this.appDB.createTablesFromSchema(this.appTablesSchema);
        this.sitesProvider.registerSiteSchema(this.siteSchema);
        initDelegate.ready().then(function () {
            // Waiting for the app to be ready to start processing the queue.
            _this.checkQueueProcessing();
            // Start queue when device goes online.
            network.onConnect().subscribe(function () {
                // Execute the callback in the Angular zone, so change detection doesn't stop working.
                zone.run(function () {
                    _this.checkQueueProcessing();
                });
            });
        });
    }
    /**
     * Link a file with a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreFilepoolProvider.prototype.addFileLink = function (siteId, fileId, component, componentId) {
        var _this = this;
        if (!component) {
            return Promise.reject(null);
        }
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var newEntry = {
                fileId: fileId,
                component: component,
                componentId: componentId || ''
            };
            return db.insertRecord(_this.LINKS_TABLE, newEntry);
        });
    };
    /**
     * Link a file with a component by URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file Url.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Promise resolved on success.
     * @description
     * Use this method to create a link between a URL and a component. You usually do not need to call this manually since
     * downloading a file automatically does this. Note that this method does not check if the file exists in the pool.
     */
    CoreFilepoolProvider.prototype.addFileLinkByUrl = function (siteId, fileUrl, component, componentId) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.addFileLink(siteId, fileId, component, componentId);
        });
    };
    /**
     * Link a file with several components.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {any[]} links Array of objects containing the component and optionally componentId.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreFilepoolProvider.prototype.addFileLinks = function (siteId, fileId, links) {
        var _this = this;
        var promises = [];
        links.forEach(function (link) {
            promises.push(_this.addFileLink(siteId, fileId, link.component, link.componentId));
        });
        return Promise.all(promises);
    };
    /**
     * Add files to queue using a URL.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} files Array of files to add.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component (optional).
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.addFilesToQueue = function (siteId, files, component, componentId) {
        return this.downloadOrPrefetchFiles(siteId, files, true, false, component, componentId);
    };
    /**
     * Add a file to the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {any} data Additional information to store about the file (timemodified, url, ...). See FILES_TABLE schema.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreFilepoolProvider.prototype.addFileToPool = function (siteId, fileId, data) {
        var _this = this;
        var values = Object.assign({}, data);
        values.fileId = fileId;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.insertRecord(_this.FILES_TABLE, values);
        });
    };
    /**
     * Adds a hash to a filename if needed.
     *
     * @param {string} url The URL of the file, already treated (decoded, without revision, etc.).
     * @param {string} filename The filename.
     * @return {string} The filename with the hash.
     */
    CoreFilepoolProvider.prototype.addHashToFilename = function (url, filename) {
        // Check if the file already has a hash. If a file is downloaded and re-uploaded with the app it will have a hash already.
        var matches = filename.match(/_[a-f0-9]{32}/g);
        if (matches && matches.length) {
            // There is at least 1 match. Get the last one.
            var hash = matches[matches.length - 1], treatedUrl = url.replace(hash, ''); // Remove the hash from the URL.
            // Check that the hash is valid.
            if ('_' + __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__["Md5"].hashAsciiStr('url:' + treatedUrl) == hash) {
                // The data found is a hash of the URL, don't need to add it again.
                return filename;
            }
        }
        return filename + '_' + __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__["Md5"].hashAsciiStr('url:' + url);
    };
    /**
     * Add a file to the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {string} url The absolute URL to the file.
     * @param {number} priority The priority this file should get in the queue (range 0-999).
     * @param {number} revision The revision of the file.
     * @param {number} timemodified The time this file was modified. Can be used to check file state.
     * @param {string} [filePath] Filepath to download the file to. If not defined, download to the filepool folder.
     * @param {any} options Extra options (isexternalfile, repositorytype).
     * @param {any} [link] The link to add for the file.
     * @return {Promise<any>} Promise resolved when the file is downloaded.
     */
    CoreFilepoolProvider.prototype.addToQueue = function (siteId, fileId, url, priority, revision, timemodified, filePath, onProgress, options, link) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.logger.debug("Adding " + fileId + " to the queue");
        return this.appDB.insertRecord(this.QUEUE_TABLE, {
            siteId: siteId,
            fileId: fileId,
            url: url,
            priority: priority,
            revision: revision,
            timemodified: timemodified,
            path: filePath,
            isexternalfile: options.isexternalfile ? 1 : 0,
            repositorytype: options.repositorytype,
            links: JSON.stringify(link ? [link] : []),
            added: Date.now()
        }).then(function () {
            // Check if the queue is running.
            _this.checkQueueProcessing();
            _this.notifyFileDownloading(siteId, fileId);
            return _this.getQueuePromise(siteId, fileId, true, onProgress);
        });
    };
    /**
     * Add an entry to queue using a URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component (optional).
     * @param {number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {string} [filePath] Filepath to download the file to. If not defined, download to the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {number} [priority=0] The priority this file should get in the queue (range 0-999).
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @param {number} [revision] File revision. If not defined, it will be calculated using the URL.
     * @return {Promise} Resolved on success.
     */
    CoreFilepoolProvider.prototype.addToQueueByUrl = function (siteId, fileUrl, component, componentId, timemodified, filePath, onProgress, priority, options, revision) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        if (priority === void 0) { priority = 0; }
        if (options === void 0) { options = {}; }
        var fileId, link, queueDeferred;
        if (!this.fileProvider.isAvailable()) {
            return Promise.reject(null);
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canDownloadFiles()) {
                return Promise.reject(null);
            }
            return _this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
                var primaryKey = { siteId: siteId, fileId: fileId };
                revision = revision || _this.getRevisionFromUrl(fileUrl);
                fileId = _this.getFileIdByUrl(fileUrl);
                // Set up the component.
                if (typeof component != 'undefined') {
                    link = {
                        component: component,
                        componentId: _this.fixComponentId(componentId)
                    };
                }
                // Retrieve the queue deferred now if it exists.
                // This is to prevent errors if file is removed from queue while we're checking if the file is in queue.
                queueDeferred = _this.getQueueDeferred(siteId, fileId, false, onProgress);
                return _this.hasFileInQueue(siteId, fileId).then(function (entry) {
                    var newData = {};
                    var foundLink = false;
                    if (entry) {
                        // We already have the file in queue, we update the priority and links.
                        if (entry.priority < priority) {
                            newData.priority = priority;
                        }
                        if (revision && entry.revision !== revision) {
                            newData.revision = revision;
                        }
                        if (timemodified && entry.timemodified !== timemodified) {
                            newData.timemodified = timemodified;
                        }
                        if (filePath && entry.path !== filePath) {
                            newData.path = filePath;
                        }
                        if (entry.isexternalfile !== options.isexternalfile && (entry.isexternalfile || options.isexternalfile)) {
                            newData.isexternalfile = options.isexternalfile;
                        }
                        if (entry.repositorytype !== options.repositorytype && (entry.repositorytype || options.repositorytype)) {
                            newData.repositorytype = options.repositorytype;
                        }
                        if (link) {
                            // We need to add the new link if it does not exist yet.
                            if (entry.links && entry.links.length) {
                                for (var i in entry.links) {
                                    var fileLink = entry.links[i];
                                    if (fileLink.component == link.component && fileLink.componentId == link.componentId) {
                                        foundLink = true;
                                        break;
                                    }
                                }
                            }
                            if (!foundLink) {
                                newData.links = entry.links || [];
                                newData.links.push(link);
                                newData.links = JSON.stringify(entry.links);
                            }
                        }
                        if (Object.keys(newData).length) {
                            // Update only when required.
                            _this.logger.debug("Updating file " + fileId + " which is already in queue");
                            return _this.appDB.updateRecords(_this.QUEUE_TABLE, newData, primaryKey).then(function () {
                                return _this.getQueuePromise(siteId, fileId, true, onProgress);
                            });
                        }
                        _this.logger.debug("File " + fileId + " already in queue and does not require update");
                        if (queueDeferred) {
                            // If we were able to retrieve the queue deferred before, we use that one.
                            return queueDeferred.promise;
                        }
                        else {
                            // Create a new deferred and return its promise.
                            return _this.getQueuePromise(siteId, fileId, true, onProgress);
                        }
                    }
                    else {
                        return _this.addToQueue(siteId, fileId, fileUrl, priority, revision, timemodified, filePath, onProgress, options, link);
                    }
                }, function () {
                    // Unsure why we could not get the record, let's add to the queue anyway.
                    return _this.addToQueue(siteId, fileId, fileUrl, priority, revision, timemodified, filePath, onProgress, options, link);
                });
            });
        });
    };
    /**
     * Adds a file to the queue if the size is allowed to be downloaded.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @param {number} [revision] File revision. If not defined, it will be calculated using the URL.
     * @return {Promise<any>} Promise resolved when the file is downloaded.
     */
    CoreFilepoolProvider.prototype.addToQueueIfNeeded = function (siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options, revision) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        var promise;
        if (checkSize) {
            if (typeof this.sizeCache[fileUrl] != 'undefined') {
                promise = Promise.resolve(this.sizeCache[fileUrl]);
            }
            else {
                if (!this.appProvider.isOnline()) {
                    // Cannot check size in offline, stop.
                    return Promise.reject(null);
                }
                promise = this.wsProvider.getRemoteFileSize(fileUrl);
            }
            // Calculate the size of the file.
            return promise.then(function (size) {
                var isWifi = _this.appProvider.isWifi(), sizeUnknown = size <= 0;
                if (!sizeUnknown) {
                    // Store the size in the cache.
                    _this.sizeCache[fileUrl] = size;
                }
                // Check if the file should be downloaded.
                if (sizeUnknown) {
                    if (downloadUnknown && isWifi) {
                        return _this.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options, revision);
                    }
                }
                else if (size <= _this.DOWNLOAD_THRESHOLD || (isWifi && size <= _this.WIFI_DOWNLOAD_THRESHOLD)) {
                    return _this.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options, revision);
                }
            });
        }
        else {
            // No need to check size, just add it to the queue.
            return this.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options, revision);
        }
    };
    /**
     * Check the queue processing.
     *
     * @description
     * In mose cases, this will enable the queue processing if it was paused.
     * Though, this will disable the queue if we are missing network or if the file system
     * is not accessible. Also, this will have no effect if the queue is already running.
     */
    CoreFilepoolProvider.prototype.checkQueueProcessing = function () {
        if (!this.fileProvider.isAvailable() || !this.appProvider.isOnline()) {
            this.queueState = this.QUEUE_PAUSED;
            return;
        }
        else if (this.queueState === this.QUEUE_RUNNING) {
            return;
        }
        this.queueState = this.QUEUE_RUNNING;
        this.processQueue();
    };
    /**
     * Clear all packages status in a site.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when all status are cleared.
     */
    CoreFilepoolProvider.prototype.clearAllPackagesStatus = function (siteId) {
        var _this = this;
        this.logger.debug('Clear all packages status for site ' + siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Get all the packages to be able to "notify" the change in the status.
            return site.getDb().getAllRecords(_this.PACKAGES_TABLE).then(function (entries) {
                // Delete all the entries.
                return site.getDb().deleteRecords(_this.PACKAGES_TABLE).then(function () {
                    entries.forEach(function (entry) {
                        // Trigger module status changed, setting it as not downloaded.
                        _this.triggerPackageStatusChanged(siteId, __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED, entry.component, entry.componentId);
                    });
                });
            });
        });
    };
    /**
     * Clears the filepool. Use it only when all the files from a site are deleted.
     *
     * @param  {string} siteId ID of the site to clear.
     * @return {Promise<any>} Promise resolved when the filepool is cleared.
     */
    CoreFilepoolProvider.prototype.clearFilepool = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return Promise.all([
                db.deleteRecords(_this.FILES_TABLE),
                db.deleteRecords(_this.LINKS_TABLE)
            ]);
        });
    };
    /**
     * Returns whether a component has files in the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<void>} Resolved means yes, rejected means no.
     */
    CoreFilepoolProvider.prototype.componentHasFiles = function (siteId, component, componentId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var conditions = {
                component: component,
                componentId: componentId || ''
            };
            return db.countRecords(_this.LINKS_TABLE, conditions).then(function (count) {
                if (count <= 0) {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Given the current status of a list of packages and the status of one of the packages,
     * determine the new status for the list of packages. The status of a list of packages is:
     *     - CoreConstants.NOT_DOWNLOADABLE if there are no downloadable packages.
     *     - CoreConstants.NOT_DOWNLOADED if at least 1 package has status CoreConstants.NOT_DOWNLOADED.
     *     - CoreConstants.DOWNLOADED if ALL the downloadable packages have status CoreConstants.DOWNLOADED.
     *     - CoreConstants.DOWNLOADING if ALL the downloadable packages have status CoreConstants.DOWNLOADING or
     *                                     CoreConstants.DOWNLOADED, with at least 1 package with CoreConstants.DOWNLOADING.
     *     - CoreConstants.OUTDATED if ALL the downloadable packages have status CoreConstants.OUTDATED or CoreConstants.DOWNLOADED
     *                                     or CoreConstants.DOWNLOADING, with at least 1 package with CoreConstants.OUTDATED.
     *
     * @param {string} current Current status of the list of packages.
     * @param {string} packagestatus Status of one of the packages.
     * @return {string} New status for the list of packages;
     */
    CoreFilepoolProvider.prototype.determinePackagesStatus = function (current, packageStatus) {
        if (!current) {
            current = __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE;
        }
        if (packageStatus === __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
            // If 1 package is not downloaded the status of the whole list will always be not downloaded.
            return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }
        else if (packageStatus === __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADED && current === __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
            // If all packages are downloaded or not downloadable with at least 1 downloaded, status will be downloaded.
            return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADED;
        }
        else if (packageStatus === __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADING &&
            (current === __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE || current === __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADED)) {
            // If all packages are downloading/downloaded/notdownloadable with at least 1 downloading, status will be downloading.
            return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADING;
        }
        else if (packageStatus === __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].OUTDATED && current !== __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
            // If there are no packages notdownloaded and there is at least 1 outdated, status will be outdated.
            return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].OUTDATED;
        }
        // Status remains the same.
        return current;
    };
    /**
     * Downloads a URL and update or add it to the pool.
     *
     * This uses the file system, you should always make sure that it is accessible before calling this method.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @param {any} [options] Extra options (revision, timemodified, isexternalfile, repositorytype).
     * @param {string} [filePath] Filepath to download the file to. If defined, no extension will be added.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {CoreFilepoolFileEntry} [poolFileObject] When set, the object will be updated, a new entry will not be created.
     * @return {Promise<any>} Resolved with internal URL on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.downloadForPoolByUrl = function (siteId, fileUrl, options, filePath, onProgress, poolFileObject) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var fileId = this.getFileIdByUrl(fileUrl), extension = this.mimeUtils.guessExtensionFromUrl(fileUrl), addExtension = typeof filePath == 'undefined', pathPromise = filePath ? filePath : this.getFilePath(siteId, fileId, extension);
        return Promise.resolve(pathPromise).then(function (filePath) {
            if (poolFileObject && poolFileObject.fileId !== fileId) {
                _this.logger.error('Invalid object to update passed');
                return Promise.reject(null);
            }
            var downloadId = _this.getFileDownloadId(fileUrl, filePath);
            if (_this.filePromises[siteId] && _this.filePromises[siteId][downloadId]) {
                // There's already a download ongoing for this file in this location, return the promise.
                return _this.filePromises[siteId][downloadId];
            }
            else if (!_this.filePromises[siteId]) {
                _this.filePromises[siteId] = {};
            }
            _this.filePromises[siteId][downloadId] = _this.sitesProvider.getSite(siteId).then(function (site) {
                if (!site.canDownloadFiles()) {
                    return Promise.reject(null);
                }
                return _this.wsProvider.downloadFile(fileUrl, filePath, addExtension, onProgress).then(function (fileEntry) {
                    var data = poolFileObject || {};
                    data.downloadTime = Date.now();
                    data.stale = 0;
                    data.url = fileUrl;
                    data.revision = options.revision;
                    data.timemodified = options.timemodified;
                    data.isexternalfile = options.isexternalfile ? 1 : 0;
                    data.repositorytype = options.repositorytype;
                    data.path = fileEntry.path;
                    data.extension = fileEntry.extension;
                    return _this.addFileToPool(siteId, fileId, data).then(function () {
                        return fileEntry.toURL();
                    });
                });
            }).finally(function () {
                // Download finished, delete the promise.
                delete _this.filePromises[siteId][downloadId];
            });
            return _this.filePromises[siteId][downloadId];
        });
    };
    /**
     * Download or prefetch several files into the filepool folder.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} files Array of files to download.
     * @param {boolean} prefetch True if should prefetch the contents (queue), false if they should be downloaded right now.
     * @param {boolean} [ignoreStale] True if 'stale' should be ignored. Only if prefetch=false.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.downloadOrPrefetchFiles = function (siteId, files, prefetch, ignoreStale, component, componentId, dirPath) {
        var _this = this;
        var promises = [];
        // Download files.
        files.forEach(function (file) {
            var url = file.url || file.fileurl, timemodified = file.timemodified, options = {
                isexternalfile: file.isexternalfile,
                repositorytype: file.repositorytype
            };
            var path;
            if (dirPath) {
                // Calculate the path to the file.
                path = file.filename;
                if (file.filepath !== '/') {
                    path = file.filepath.substr(1) + path;
                }
                path = _this.textUtils.concatenatePaths(dirPath, path);
            }
            if (prefetch) {
                promises.push(_this.addToQueueByUrl(siteId, url, component, componentId, timemodified, path, undefined, 0, options));
            }
            else {
                promises.push(_this.downloadUrl(siteId, url, ignoreStale, component, componentId, timemodified, path, undefined, options));
            }
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Downloads or prefetches a list of files as a "package".
     *
     * @param {string} siteId The site ID.
     * @param {any[]} fileList List of files to download.
     * @param {boolean} [prefetch] True if should prefetch the contents (queue), false if they should be downloaded right now.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId]  An ID to use in conjunction with the component.
     * @param {string} [extra] Extra data to store for the package.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when the package is downloaded.
     */
    CoreFilepoolProvider.prototype.downloadOrPrefetchPackage = function (siteId, fileList, prefetch, component, componentId, extra, dirPath, onProgress) {
        var _this = this;
        var packageId = this.getPackageId(component, componentId);
        var promise;
        if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId]) {
            // There's already a download ongoing for this package, return the promise.
            return this.packagesPromises[siteId][packageId];
        }
        else if (!this.packagesPromises[siteId]) {
            this.packagesPromises[siteId] = {};
        }
        // Set package as downloading.
        promise = this.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADING, component, componentId).then(function () {
            var promises = [];
            var packageLoaded = 0;
            fileList.forEach(function (file) {
                var fileUrl = file.url || file.fileurl, options = {
                    isexternalfile: file.isexternalfile,
                    repositorytype: file.repositorytype
                };
                var path, promise, fileLoaded = 0, onFileProgress;
                if (onProgress) {
                    // There's a onProgress event, create a function to receive file download progress events.
                    onFileProgress = function (progress) {
                        if (progress && progress.loaded) {
                            // Add the new size loaded to the package loaded.
                            packageLoaded = packageLoaded + (progress.loaded - fileLoaded);
                            fileLoaded = progress.loaded;
                            onProgress({
                                packageDownload: true,
                                loaded: packageLoaded,
                                fileProgress: progress
                            });
                        }
                    };
                }
                if (dirPath) {
                    // Calculate the path to the file.
                    path = file.filename;
                    if (file.filepath !== '/') {
                        path = file.filepath.substr(1) + path;
                    }
                    path = _this.textUtils.concatenatePaths(dirPath, path);
                }
                if (prefetch) {
                    promise = _this.addToQueueByUrl(siteId, fileUrl, component, componentId, file.timemodified, path, undefined, 0, options);
                }
                else {
                    promise = _this.downloadUrl(siteId, fileUrl, false, component, componentId, file.timemodified, onFileProgress, path, options);
                }
                // Using undefined for success & fail will pass the success/failure to the parent promise.
                promises.push(promise);
            });
            return Promise.all(promises).then(function () {
                // Success prefetching, store package as downloaded.
                return _this.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADED, component, componentId, extra);
            }).catch(function (error) {
                // Error downloading, go back to previous status and reject the promise.
                return _this.setPackagePreviousStatus(siteId, component, componentId).then(function () {
                    return Promise.reject(error);
                });
            });
        }).finally(function () {
            // Download finished, delete the promise.
            delete _this.packagesPromises[siteId][packageId];
        });
        this.packagesPromises[siteId][packageId] = promise;
        return promise;
    };
    /**
     * Downloads a list of files.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} fileList List of files to download.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to identify the download.
     * @param {string} [extra] Extra data to store for the package.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>}  Promise resolved when all files are downloaded.
     */
    CoreFilepoolProvider.prototype.downloadPackage = function (siteId, fileList, component, componentId, extra, dirPath, onProgress) {
        return this.downloadOrPrefetchPackage(siteId, fileList, false, component, componentId, extra, dirPath, onProgress);
    };
    /**
     * Downloads a file on the spot.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @param {boolean} [ignoreStale] Whether 'stale' should be ignored.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {string} [filePath] Filepath to download the file to. If not defined, download to the filepool folder.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @param {number} [revision] File revision. If not defined, it will be calculated using the URL.
     * @return {Promise<any>} Resolved with internal URL on success, rejected otherwise.
     * @description
     * Downloads a file on the spot.
     *
     * This will also take care of adding the file to the pool if it's missing. However, please note that this will
     * not force a file to be re-downloaded if it is already part of the pool. You should mark a file as stale using
     * invalidateFileByUrl to trigger a download.
     */
    CoreFilepoolProvider.prototype.downloadUrl = function (siteId, fileUrl, ignoreStale, component, componentId, timemodified, onProgress, filePath, options, revision) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        if (options === void 0) { options = {}; }
        var fileId, promise;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, fileUrl).then(function (fixedUrl) {
                fileUrl = fixedUrl;
                options = Object.assign({}, options); // Create a copy to prevent modifying the original object.
                options.timemodified = timemodified || 0;
                options.revision = revision || _this.getRevisionFromUrl(fileUrl);
                fileId = _this.getFileIdByUrl(fileUrl);
                return _this.hasFileInPool(siteId, fileId).then(function (fileObject) {
                    if (typeof fileObject === 'undefined') {
                        // We do not have the file, download and add to pool.
                        _this.notifyFileDownloading(siteId, fileId);
                        return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress);
                    }
                    else if (_this.isFileOutdated(fileObject, options.revision, options.timemodified) &&
                        _this.appProvider.isOnline() && !ignoreStale) {
                        // The file is outdated, force the download and update it.
                        _this.notifyFileDownloading(siteId, fileId);
                        return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, fileObject);
                    }
                    // Everything is fine, return the file on disk.
                    if (filePath) {
                        promise = _this.getInternalUrlByPath(filePath);
                    }
                    else {
                        promise = _this.getInternalUrlById(siteId, fileId);
                    }
                    return promise.then(function (response) {
                        return response;
                    }, function () {
                        // The file was not found in the pool, weird.
                        _this.notifyFileDownloading(siteId, fileId);
                        return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, fileObject);
                    });
                }, function () {
                    // The file is not in the pool just yet.
                    _this.notifyFileDownloading(siteId, fileId);
                    return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress);
                }).then(function (response) {
                    if (typeof component != 'undefined') {
                        _this.addFileLink(siteId, fileId, component, componentId).catch(function () {
                            // Ignore errors.
                        });
                    }
                    _this.notifyFileDownloaded(siteId, fileId);
                    return response;
                }, function (err) {
                    _this.notifyFileDownloadError(siteId, fileId);
                    return Promise.reject(err);
                });
            });
        }
        else {
            return Promise.reject(null);
        }
    };
    /**
     * Fill Missing Extension In the File Object if needed.
     * This is to migrate from old versions.
     *
     * @param {CoreFilepoolFileEntry} fileObject File object to be migrated.
     * @param {string} siteId SiteID to get migrated.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFilepoolProvider.prototype.fillExtensionInFile = function (entry, siteId) {
        var _this = this;
        if (typeof entry.extension != 'undefined') {
            // Already filled.
            return Promise.resolve();
        }
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var extension = _this.mimeUtils.getFileExtension(entry.path);
            if (!extension) {
                // Files does not have extension. Invalidate file (stale = true).
                // Minor problem: file will remain in the filesystem once downloaded again.
                _this.logger.debug('Staled file with no extension ' + entry.fileId);
                return db.updateRecords(_this.FILES_TABLE, { stale: 1 }, { fileId: entry.fileId });
            }
            // File has extension. Save extension, and add extension to path.
            var fileId = entry.fileId;
            entry.fileId = _this.mimeUtils.removeExtension(fileId);
            entry.extension = extension;
            return db.updateRecords(_this.FILES_TABLE, entry, { fileId: fileId }).then(function () {
                if (entry.fileId == fileId) {
                    // File ID hasn't changed, we're done.
                    _this.logger.debug('Removed extesion ' + extension + ' from file ' + entry.fileId);
                    return;
                }
                // Now update the links.
                return db.updateRecords(_this.LINKS_TABLE, { fileId: entry.fileId }, { fileId: fileId });
            });
        });
    };
    /**
     * Fill Missing Extension In Files, used to migrate from previous file handling.
     * Reserved for core use, please do not call.
     *
     * @param {string} siteId SiteID to get migrated
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFilepoolProvider.prototype.fillMissingExtensionInFiles = function (siteId) {
        var _this = this;
        this.logger.debug('Fill missing extensions in files of ' + siteId);
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getAllRecords(_this.FILES_TABLE).then(function (entries) {
                var promises = [];
                entries.forEach(function (entry) {
                    promises.push(_this.fillExtensionInFile(entry, siteId));
                });
                return Promise.all(promises);
            });
        });
    };
    /**
     * Fix a component ID to always be a Number if possible.
     *
     * @param {string|number} componentId The component ID.
     * @return {string|number} The normalised component ID. -1 when undefined was passed.
     */
    CoreFilepoolProvider.prototype.fixComponentId = function (componentId) {
        if (typeof componentId == 'number') {
            return componentId;
        }
        // Try to convert it to a number.
        var id = parseInt(componentId, 10);
        if (isNaN(id)) {
            // Not a number.
            if (typeof componentId == 'undefined' || componentId === null) {
                return -1;
            }
            else {
                return componentId;
            }
        }
        return id;
    };
    /**
     * Add the wstoken url and points to the correct script.
     *
     * @param {string} siteId  The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise}       Resolved with fixed URL on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.fixPluginfileURL = function (siteId, fileUrl) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.fixPluginfileURL(fileUrl);
        });
    };
    /**
     * Convenience function to get component files.
     *
     * @param {SQLiteDB} db Site's DB.
     * @param {string} component The component to get.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    CoreFilepoolProvider.prototype.getComponentFiles = function (db, component, componentId) {
        var conditions = {
            component: component,
            componentId: componentId || ''
        };
        return db.getRecords(this.LINKS_TABLE, conditions);
    };
    /**
     * Returns the local URL of a directory.
     *
     * @param {string} siteId  The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise}       Resolved with the URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getDirectoryUrlByUrl = function (siteId, fileUrl) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
                var fileId = _this.getFileIdByUrl(fileUrl), filePath = _this.getFilePath(siteId, fileId, ''); // No extension, the function will return a string.
                return _this.fileProvider.getDir(filePath).then(function (dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Get the ID of a file download. Used to keep track of filePromises.
     *
     * @param {string} fileUrl  The file URL.
     * @param {string} filePath The file destination path.
     * @return {string}         File download ID.
     */
    CoreFilepoolProvider.prototype.getFileDownloadId = function (fileUrl, filePath) {
        return __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__["Md5"].hashAsciiStr(fileUrl + '###' + filePath);
    };
    /**
     * Get the name of the event used to notify download events (CoreEventsProvider).
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {string} Event name.
     */
    CoreFilepoolProvider.prototype.getFileEventName = function (siteId, fileId) {
        return 'CoreFilepoolFile:' + siteId + ':' + fileId;
    };
    /**
     * Get the name of the event used to notify download events (CoreEventsProvider).
     *
     * @param {string} siteId  The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @return {Promise}       Promise resolved with event name.
     */
    CoreFilepoolProvider.prototype.getFileEventNameByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.getFileEventName(siteId, fileId);
        });
    };
    /**
     * Creates a unique ID based on a URL.
     *
     * This has a minimal handling of pluginfiles in order to generate a clean file ID which will not change if
     * pointing to the same pluginfile URL even if the token or extra attributes have changed.
     *
     * @param {string} fileUrl The absolute URL to the file.
     * @return {string} The file ID.
     */
    CoreFilepoolProvider.prototype.getFileIdByUrl = function (fileUrl) {
        var url = this.removeRevisionFromUrl(fileUrl), filename;
        // Decode URL.
        url = this.textUtils.decodeHTML(this.textUtils.decodeURIComponent(url));
        if (url.indexOf('/webservice/pluginfile') !== -1) {
            // Remove attributes that do not matter.
            this.urlAttributes.forEach(function (regex) {
                url = url.replace(regex, '');
            });
        }
        // Try to guess the filename the target file should have.
        // We want to keep the original file name so people can easily identify the files after the download.
        filename = this.guessFilenameFromUrl(url);
        return this.addHashToFilename(url, filename);
    };
    /**
     * Get the links of a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<any[]>} Promise resolved with the links.
     */
    CoreFilepoolProvider.prototype.getFileLinks = function (siteId, fileId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecords(_this.LINKS_TABLE, { fileId: fileId });
        });
    };
    /**
     * Get the path to a file. This does not check if the file exists or not.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {string} [extension] Previously calculated extension. Empty to not add any. Undefined to calculate it.
     * @return {string|Promise<string>} The path to the file relative to storage root.
     */
    CoreFilepoolProvider.prototype.getFilePath = function (siteId, fileId, extension) {
        var path = this.getFilepoolFolderPath(siteId) + '/' + fileId;
        if (typeof extension == 'undefined') {
            // We need the extension to be able to open files properly.
            return this.hasFileInPool(siteId, fileId).then(function (entry) {
                if (entry.extension) {
                    path += '.' + entry.extension;
                }
                return path;
            }).catch(function () {
                // If file not found, use the path without extension.
                return path;
            });
        }
        else {
            if (extension) {
                path += '.' + extension;
            }
            return path;
        }
    };
    /**
     * Get the path to a file from its URL. This does not check if the file exists or not.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<string>} Promise resolved with the path to the file relative to storage root.
     */
    CoreFilepoolProvider.prototype.getFilePathByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.getFilePath(siteId, fileId);
        });
    };
    /**
     * Get site Filepool Folder Path
     *
     * @param {string} siteId The site ID.
     * @return {string} The root path to the filepool of the site.
     */
    CoreFilepoolProvider.prototype.getFilepoolFolderPath = function (siteId) {
        return this.fileProvider.getSiteFolder(siteId) + '/' + this.FOLDER;
    };
    /**
     * Get all the matching files from a component. Returns objects containing properties like path, extension and url.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to get.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any[]>} Promise resolved with the files on success.
     */
    CoreFilepoolProvider.prototype.getFilesByComponent = function (siteId, component, componentId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return _this.getComponentFiles(db, component, componentId).then(function (items) {
                var promises = [], files = [];
                items.forEach(function (item) {
                    promises.push(db.getRecord(_this.FILES_TABLE, { fileId: item.fileId }).then(function (fileEntry) {
                        if (!fileEntry) {
                            return;
                        }
                        files.push({
                            url: fileEntry.url,
                            path: fileEntry.path,
                            extension: fileEntry.extension,
                            revision: fileEntry.revision,
                            timemodified: fileEntry.timemodified
                        });
                    }).catch(function () {
                        // File not found, ignore error.
                    }));
                });
                return Promise.all(promises).then(function () {
                    return files;
                });
            });
        });
    };
    /**
     * Get the size of all the files from a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} component    The component to get.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<number>} Promise resolved with the size on success.
     */
    CoreFilepoolProvider.prototype.getFilesSizeByComponent = function (siteId, component, componentId) {
        var _this = this;
        return this.getFilesByComponent(siteId, component, componentId).then(function (files) {
            var promises = [];
            var size = 0;
            files.forEach(function (file) {
                promises.push(_this.fileProvider.getFileSize(file.path).then(function (fs) {
                    size += fs;
                }).catch(function () {
                    // Ignore failures, maybe some file was deleted.
                }));
            });
            return Promise.all(promises).then(function () {
                return size;
            });
        });
    };
    /**
     * Returns the file state: mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded or mmCoreOutdated.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl File URL.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {string} [filePath] Filepath to download the file to. If defined, no extension will be added.
     * @param {number} [revision] File revision. If not defined, it will be calculated using the URL.
     * @return {Promise<string>} Promise resolved with the file state.
     */
    CoreFilepoolProvider.prototype.getFileStateByUrl = function (siteId, fileUrl, timemodified, filePath, revision) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        var fileId;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fixedUrl) {
            fileUrl = fixedUrl;
            revision = revision || _this.getRevisionFromUrl(fileUrl);
            fileId = _this.getFileIdByUrl(fileUrl);
            // Check if the file is in queue (waiting to be downloaded).
            return _this.hasFileInQueue(siteId, fileId).then(function () {
                return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            }).catch(function () {
                // Check if the file is being downloaded right now.
                var extension = _this.mimeUtils.guessExtensionFromUrl(fileUrl), path = filePath ? filePath : _this.getFilePath(siteId, fileId, extension);
                return Promise.resolve(path).then(function (filePath) {
                    var downloadId = _this.getFileDownloadId(fileUrl, filePath);
                    if (_this.filePromises[siteId] && _this.filePromises[siteId][downloadId]) {
                        return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADING;
                    }
                    // File is not being downloaded. Check if it's downloaded and if it's outdated.
                    return _this.hasFileInPool(siteId, fileId).then(function (entry) {
                        if (_this.isFileOutdated(entry, revision, timemodified)) {
                            return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].OUTDATED;
                        }
                        else {
                            return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADED;
                        }
                    }).catch(function () {
                        return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                    });
                });
            });
        });
    };
    /**
     * Returns an absolute URL to access the file URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @param {number} [revision] File revision. If not defined, it will be calculated using the URL.
     * @return {Promise<string>} Resolved with the URL to use.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     *
     * This handles the queue and validity of the file. If there is a local file and it's valid, return the local URL.
     * If the file isn't downloaded or it's outdated, return the online URL and add it to the queue to be downloaded later.
     */
    CoreFilepoolProvider.prototype.getFileUrlByUrl = function (siteId, fileUrl, component, componentId, mode, timemodified, checkSize, downloadUnknown, options, revision) {
        var _this = this;
        if (mode === void 0) { mode = 'url'; }
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        var fileId;
        var addToQueue = function (fileUrl) {
            // Add the file to queue if needed and ignore errors.
            _this.addToQueueIfNeeded(siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options, revision).catch(function () {
                // Ignore errors.
            });
        };
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fixedUrl) {
            fileUrl = fixedUrl;
            revision = revision || _this.getRevisionFromUrl(fileUrl);
            fileId = _this.getFileIdByUrl(fileUrl);
            return _this.hasFileInPool(siteId, fileId).then(function (entry) {
                var response;
                if (typeof entry === 'undefined') {
                    // We do not have the file, add it to the queue, and return real URL.
                    addToQueue(fileUrl);
                    response = fileUrl;
                }
                else if (_this.isFileOutdated(entry, revision, timemodified) && _this.appProvider.isOnline()) {
                    // The file is outdated, we add to the queue and return real URL.
                    addToQueue(fileUrl);
                    response = fileUrl;
                }
                else {
                    // We found the file entry, now look for the file on disk.
                    if (mode === 'src') {
                        response = _this.getInternalSrcById(siteId, fileId);
                    }
                    else {
                        response = _this.getInternalUrlById(siteId, fileId);
                    }
                    response = response.then(function (internalUrl) {
                        // The file is on disk.
                        return internalUrl;
                    }).catch(function () {
                        // We could not retrieve the file, delete the entries associated with that ID.
                        _this.logger.debug('File ' + fileId + ' not found on disk');
                        _this.removeFileById(siteId, fileId);
                        addToQueue(fileUrl);
                        if (_this.appProvider.isOnline()) {
                            // We still have a chance to serve the right content.
                            return fileUrl;
                        }
                        return Promise.reject(null);
                    });
                }
                return response;
            }, function () {
                // We do not have the file in store yet. Add to queue and return the fixed URL.
                addToQueue(fileUrl);
                return fileUrl;
            });
        });
    };
    /**
     * Returns the internal SRC of a file.
     *
     * The returned URL from this method is typically used with IMG tags.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<string>} Resolved with the internal URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getInternalSrcById = function (siteId, fileId) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return Promise.resolve(this.getFilePath(siteId, fileId)).then(function (path) {
                return _this.fileProvider.getFile(path).then(function (fileEntry) {
                    // We use toInternalURL so images are loaded in iOS8 using img HTML tags.
                    return _this.fileProvider.getInternalURL(fileEntry);
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Returns the local URL of a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<string>} Resolved with the URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getInternalUrlById = function (siteId, fileId) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return Promise.resolve(this.getFilePath(siteId, fileId)).then(function (path) {
                return _this.fileProvider.getFile(path).then(function (fileEntry) {
                    // This URL is usually used to launch files or put them in HTML. In desktop we need the internal URL.
                    if (_this.appProvider.isDesktop()) {
                        return fileEntry.toInternalURL();
                    }
                    else {
                        return fileEntry.toURL();
                    }
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Returns the local URL of a file.
     *
     * @param {string} filePath The file path.
     * @return {Promise<string>} Resolved with the URL.
     */
    CoreFilepoolProvider.prototype.getInternalUrlByPath = function (filePath) {
        if (this.fileProvider.isAvailable()) {
            return this.fileProvider.getFile(filePath).then(function (fileEntry) {
                return fileEntry.toURL();
            });
        }
        return Promise.reject(null);
    };
    /**
     * Returns the local URL of a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<string>} Resolved with the URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getInternalUrlByUrl = function (siteId, fileUrl) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
                var fileId = _this.getFileIdByUrl(fileUrl);
                return _this.getInternalUrlById(siteId, fileId);
            });
        }
        return Promise.reject(null);
    };
    /**
     * Get the data stored for a package.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<CoreFilepoolPackageEntry>} Promise resolved with the data.
     */
    CoreFilepoolProvider.prototype.getPackageData = function (siteId, component, componentId) {
        var _this = this;
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            return site.getDb().getRecord(_this.PACKAGES_TABLE, { id: packageId });
        });
    };
    /**
     * Creates the name for a package directory (hash).
     *
     * @param {string} url An URL to identify the package.
     * @return {string} The directory name.
     */
    CoreFilepoolProvider.prototype.getPackageDirNameByUrl = function (url) {
        var candidate, extension = '';
        url = this.removeRevisionFromUrl(url);
        if (url.indexOf('/webservice/pluginfile') !== -1) {
            // Remove attributes that do not matter.
            this.urlAttributes.forEach(function (regex) {
                url = url.replace(regex, '');
            });
            // Guess the extension of the URL. This is for backwards compatibility.
            candidate = this.mimeUtils.guessExtensionFromUrl(url);
            if (candidate && candidate !== 'php') {
                extension = '.' + candidate;
            }
        }
        return __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__["Md5"].hashAsciiStr('url:' + url) + extension;
    };
    /**
     * Get the path to a directory to store a package files. This does not check if the file exists or not.
     *
     * @param {string} siteId The site ID.
     * @param {string} url An URL to identify the package.
     * @return {Promise<string>} Promise resolved with the path of the package.
     */
    CoreFilepoolProvider.prototype.getPackageDirPathByUrl = function (siteId, url) {
        var _this = this;
        return this.fixPluginfileURL(siteId, url).then(function (fixedUrl) {
            var dirName = _this.getPackageDirNameByUrl(fixedUrl);
            return _this.getFilePath(siteId, dirName, '');
        });
    };
    /**
     * Returns the local URL of a package directory.
     *
     * @param {string} siteId The site ID.
     * @param {string} url An URL to identify the package.
     * @return {Promise<string>} Resolved with the URL.
     */
    CoreFilepoolProvider.prototype.getPackageDirUrlByUrl = function (siteId, url) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, url).then(function (fixedUrl) {
                var dirName = _this.getPackageDirNameByUrl(fixedUrl), dirPath = _this.getFilePath(siteId, dirName, ''); // No extension, the function will return a string.
                return _this.fileProvider.getDir(dirPath).then(function (dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Get a download promise. If the promise is not set, return undefined.
     *
     * @param {string} siteId Site ID.
     * @param {string} component The component of the package.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Download promise or undefined.
     */
    CoreFilepoolProvider.prototype.getPackageDownloadPromise = function (siteId, component, componentId) {
        var packageId = this.getPackageId(component, componentId);
        if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId]) {
            return this.packagesPromises[siteId][packageId];
        }
    };
    /**
     * Get a package extra data.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved with the extra data.
     */
    CoreFilepoolProvider.prototype.getPackageExtra = function (siteId, component, componentId) {
        return this.getPackageData(siteId, component, componentId).then(function (entry) {
            return entry.extra;
        });
    };
    /**
     * Get the ID of a package.
     *
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {string} Package ID.
     */
    CoreFilepoolProvider.prototype.getPackageId = function (component, componentId) {
        return __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__["Md5"].hashAsciiStr(component + '#' + this.fixComponentId(componentId));
    };
    /**
     * Get a package previous status.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreFilepoolProvider.prototype.getPackagePreviousStatus = function (siteId, component, componentId) {
        return this.getPackageData(siteId, component, componentId).then(function (entry) {
            return entry.previous || __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        });
    };
    /**
     * Get a package status.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreFilepoolProvider.prototype.getPackageStatus = function (siteId, component, componentId) {
        return this.getPackageData(siteId, component, componentId).then(function (entry) {
            return entry.status || __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        });
    };
    /**
     * Return the array of arguments of the pluginfile url.
     *
     * @param {string} url URL to get the args.
     * @return {string[]} The args found, undefined if not a pluginfile.
     */
    CoreFilepoolProvider.prototype.getPluginFileArgs = function (url) {
        if (!this.urlUtils.isPluginFileUrl(url)) {
            // Not pluginfile, return.
            return;
        }
        var relativePath = url.substr(url.indexOf('/pluginfile.php') + 16), args = relativePath.split('/');
        if (args.length < 3) {
            // To be a plugin file it should have at least contextId, Component and Filearea.
            return;
        }
        return args;
    };
    /**
     * Get the deferred object for a file in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {boolean} [create=true] True if it should create a new deferred if it doesn't exist.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {any} Deferred.
     */
    CoreFilepoolProvider.prototype.getQueueDeferred = function (siteId, fileId, create, onProgress) {
        if (create === void 0) { create = true; }
        if (!this.queueDeferreds[siteId]) {
            if (!create) {
                return;
            }
            this.queueDeferreds[siteId] = {};
        }
        if (!this.queueDeferreds[siteId][fileId]) {
            if (!create) {
                return;
            }
            this.queueDeferreds[siteId][fileId] = this.utils.promiseDefer();
        }
        if (onProgress) {
            this.queueDeferreds[siteId][fileId].onProgress = onProgress;
        }
        return this.queueDeferreds[siteId][fileId];
    };
    /**
     * Get the on progress for a file in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Function} On progress function, undefined if not found.
     */
    CoreFilepoolProvider.prototype.getQueueOnProgress = function (siteId, fileId) {
        var deferred = this.getQueueDeferred(siteId, fileId, false);
        if (deferred) {
            return deferred.onProgress;
        }
    };
    /**
     * Get the promise for a file in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {boolean} [create=true] True if it should create a new promise if it doesn't exist.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise.
     */
    CoreFilepoolProvider.prototype.getQueuePromise = function (siteId, fileId, create, onProgress) {
        if (create === void 0) { create = true; }
        return this.getQueueDeferred(siteId, fileId, create, onProgress).promise;
    };
    /**
     * Get a revision number from a list of files (highest revision).
     *
     * @param {any[]} files Package files.
     * @return {number} Highest revision.
     */
    CoreFilepoolProvider.prototype.getRevisionFromFileList = function (files) {
        var _this = this;
        var revision = 0;
        files.forEach(function (file) {
            if (file.url || file.fileurl) {
                var r = _this.getRevisionFromUrl(file.url || file.fileurl);
                if (r > revision) {
                    revision = r;
                }
            }
        });
        return revision;
    };
    /**
     * Get the revision number from a file URL.
     *
     * @param {string} url URL to get the revision number.
     * @return {number} Revision number.
     */
    CoreFilepoolProvider.prototype.getRevisionFromUrl = function (url) {
        var args = this.getPluginFileArgs(url);
        if (!args) {
            // Not a pluginfile, no revision will be found.
            return 0;
        }
        var revisionRegex = this.pluginFileDelegate.getComponentRevisionRegExp(args);
        if (!revisionRegex) {
            return 0;
        }
        var matches = url.match(revisionRegex);
        if (matches && typeof matches[1] != 'undefined') {
            return parseInt(matches[1], 10);
        }
        return 0;
    };
    /**
     * Returns an absolute URL to use in IMG tags.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @param {number} [revision] File revision. If not defined, it will be calculated using the URL.
     * @return {Promise<string>} Resolved with the URL to use.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with IMG tags.
     */
    CoreFilepoolProvider.prototype.getSrcByUrl = function (siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options, revision) {
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        return this.getFileUrlByUrl(siteId, fileUrl, component, componentId, 'src', timemodified, checkSize, downloadUnknown, options, revision);
    };
    /**
     * Get time modified from a list of files.
     *
     * @param {any[]} files List of files.
     * @return {number} Time modified.
     */
    CoreFilepoolProvider.prototype.getTimemodifiedFromFileList = function (files) {
        var timemodified = 0;
        files.forEach(function (file) {
            if (file.timemodified > timemodified) {
                timemodified = file.timemodified;
            }
        });
        return timemodified;
    };
    /**
     * Returns an absolute URL to access the file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @param {number} [revision] File revision. If not defined, it will be calculated using the URL.
     * @return {Promise<string>} Resolved with the URL to use.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with a local browser.
     */
    CoreFilepoolProvider.prototype.getUrlByUrl = function (siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options, revision) {
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        return this.getFileUrlByUrl(siteId, fileUrl, component, componentId, 'url', timemodified, checkSize, downloadUnknown, options, revision);
    };
    /**
     * Guess the filename of a file from its URL. This is very weak and unreliable.
     *
     * @param {string} fileUrl The file URL.
     * @return {string}        The filename treated so it doesn't have any special character.
     */
    CoreFilepoolProvider.prototype.guessFilenameFromUrl = function (fileUrl) {
        var filename = '';
        if (fileUrl.indexOf('/webservice/pluginfile') !== -1) {
            // It's a pluginfile URL. Search for the 'file' param to extract the name.
            var params = this.urlUtils.extractUrlParams(fileUrl);
            if (params.file) {
                filename = params.file.substr(params.file.lastIndexOf('/') + 1);
            }
            else {
                // 'file' param not found. Extract what's after the last '/' without params.
                filename = this.urlUtils.getLastFileWithoutParams(fileUrl);
            }
        }
        else if (this.urlUtils.isGravatarUrl(fileUrl)) {
            // Extract gravatar ID.
            filename = 'gravatar_' + this.urlUtils.getLastFileWithoutParams(fileUrl);
        }
        else if (this.urlUtils.isThemeImageUrl(fileUrl)) {
            // Extract user ID.
            var matches = fileUrl.match(/\/core\/([^\/]*)\//);
            if (matches && matches[1]) {
                filename = matches[1];
            }
            // Attach a constant and the image type.
            filename = 'default_' + filename + '_' + this.urlUtils.getLastFileWithoutParams(fileUrl);
        }
        else {
            // Another URL. Just get what's after the last /.
            filename = this.urlUtils.getLastFileWithoutParams(fileUrl);
        }
        // Remove the extension from the filename.
        filename = this.mimeUtils.removeExtension(filename);
        return this.textUtils.removeSpecialCharactersForFiles(filename);
    };
    /**
     * Check if the file is already in the pool. This does not check if the file is on the disk.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<CoreFilepoolFileEntry>} Resolved with file object from DB on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.hasFileInPool = function (siteId, fileId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecord(_this.FILES_TABLE, { fileId: fileId }).then(function (entry) {
                if (typeof entry === 'undefined') {
                    return Promise.reject(null);
                }
                return entry;
            });
        });
    };
    /**
     * Check if the file is in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise} Resolved with file object from DB on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.hasFileInQueue = function (siteId, fileId) {
        var _this = this;
        return this.appDB.getRecord(this.QUEUE_TABLE, { siteId: siteId, fileId: fileId }).then(function (entry) {
            if (typeof entry === 'undefined') {
                return Promise.reject(null);
            }
            // Convert the links to an object.
            entry.links = _this.textUtils.parseJSON(entry.links, []);
            return entry;
        });
    };
    /**
     * Invalidate all the files in a site.
     *
     * @param {string} siteId The site ID.
     * @param {boolean} [onlyUnknown=true] True to only invalidate files from external repos or without revision/timemodified.
     *                                     It is advised to set it to true to reduce the performance and data usage of the app.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.invalidateAllFiles = function (siteId, onlyUnknown) {
        var _this = this;
        if (onlyUnknown === void 0) { onlyUnknown = true; }
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var where, whereParams;
            if (onlyUnknown) {
                where = 'isexternalfile = ? OR (revision < ? AND timemodified = ?)';
                whereParams = [0, 1, 0];
            }
            return db.updateRecordsWhere(_this.FILES_TABLE, { stale: 1 }, where, whereParams);
        });
    };
    /**
     * Invalidate a file by URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<any>} Resolved on success.
     * @description
     * Invalidates a file by marking it stale. It will not be added to the queue automatically, but the next time this file
     * is requested it will be added to the queue.
     * You can manully call addToQueueByUrl to add this file to the queue immediately.
     * Please note that, if a file is stale, the user will be presented the stale file if there is no network access.
     */
    CoreFilepoolProvider.prototype.invalidateFileByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.sitesProvider.getSiteDb(siteId).then(function (db) {
                return db.updateRecords(_this.FILES_TABLE, { stale: 1 }, { fileId: fileId });
            });
        });
    };
    /**
     * Invalidate all the matching files from a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to invalidate.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {boolean} [onlyUnknown=true] True to only invalidate files from external repos or without revision/timemodified.
     *                                     It is advised to set it to true to reduce the performance and data usage of the app.
     * @return {Promise<any>} Resolved when done.
     */
    CoreFilepoolProvider.prototype.invalidateFilesByComponent = function (siteId, component, componentId, onlyUnknown) {
        var _this = this;
        if (onlyUnknown === void 0) { onlyUnknown = true; }
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return _this.getComponentFiles(db, component, componentId).then(function (items) {
                var fileIds = items.map(function (item) {
                    return item.fileId;
                }), whereAndParams = db.getInOrEqual(fileIds);
                whereAndParams[0] = 'fileId ' + whereAndParams[0];
                if (onlyUnknown) {
                    whereAndParams[0] += ' AND (isexternalfile = ? OR (revision < ? AND timemodified = ?))';
                    whereAndParams[1] = whereAndParams[1].concat([0, 1, 0]);
                }
                return db.updateRecordsWhere(_this.FILES_TABLE, { stale: 1 }, whereAndParams[0], whereAndParams[1]);
            });
        });
    };
    /**
     * Check if a file is downloading.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl File URL.
     * @param {Promise<any>} Promise resolved if file is downloading, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.isFileDownloadingByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.hasFileInQueue(siteId, fileId);
        });
    };
    /**
     * Check if a file is outdated.
     *
     * @param {CoreFilepoolFileEntry} entry Filepool entry.
     * @param {number} [revision]  File revision number.
     * @param {number} [timemodified] The time this file was modified.
     * @param {boolean} Whether the file is outdated.
     */
    CoreFilepoolProvider.prototype.isFileOutdated = function (entry, revision, timemodified) {
        return !!entry.stale || revision > entry.revision || timemodified > entry.timemodified;
    };
    /**
     * Check if cannot determine if a file has been updated.
     *
     * @param {CoreFilepoolFileEntry} entry Filepool entry.
     * @return {boolean} Whether it cannot determine updates.
     */
    CoreFilepoolProvider.prototype.isFileUpdateUnknown = function (entry) {
        return !!entry.isexternalfile || (entry.revision < 1 && !entry.timemodified);
    };
    /**
     * Notify a file has been deleted.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDeleted = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'deleted' });
    };
    /**
     * Notify a file has been downloaded.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDownloaded = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'download', success: true });
    };
    /**
     * Notify error occurred while downloading a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDownloadError = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'download', success: false });
    };
    /**
     * Notify a file starts being downloaded or added to queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDownloading = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'downloading' });
    };
    /**
     * Notify a file has been outdated.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileOutdated = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'outdated' });
    };
    /**
     * Prefetches a list of files.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} fileList List of files to download.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to identify the download.
     * @param {string} [extra] Extra data to store for the package.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>}  Promise resolved when all files are downloaded.
     */
    CoreFilepoolProvider.prototype.prefetchPackage = function (siteId, fileList, component, componentId, extra, dirPath, onProgress) {
        return this.downloadOrPrefetchPackage(siteId, fileList, true, component, componentId, extra, dirPath, onProgress);
    };
    /**
     * Process the queue.
     *
     * @description
     * This loops over itself to keep on processing the queue in the background.
     * The queue process is site agnostic.
     */
    CoreFilepoolProvider.prototype.processQueue = function () {
        var _this = this;
        var promise;
        if (this.queueState !== this.QUEUE_RUNNING) {
            // Silently ignore, the queue is on pause.
            promise = Promise.reject(this.ERR_QUEUE_ON_PAUSE);
        }
        else if (!this.fileProvider.isAvailable() || !this.appProvider.isOnline()) {
            promise = Promise.reject(this.ERR_FS_OR_NETWORK_UNAVAILABLE);
        }
        else {
            promise = this.processImportantQueueItem();
        }
        promise.then(function () {
            // All good, we schedule next execution.
            setTimeout(function () {
                _this.processQueue();
            }, _this.QUEUE_PROCESS_INTERVAL);
        }, function (error) {
            // We had an error, in which case we pause the processing.
            if (error === _this.ERR_FS_OR_NETWORK_UNAVAILABLE) {
                _this.logger.debug('Filesysem or network unavailable, pausing queue processing.');
            }
            else if (error === _this.ERR_QUEUE_IS_EMPTY) {
                _this.logger.debug('Queue is empty, pausing queue processing.');
            }
            _this.queueState = _this.QUEUE_PAUSED;
        });
    };
    /**
     * Process the most important queue item.
     *
     * @return {Promise} Resolved on success. Rejected on failure.
     */
    CoreFilepoolProvider.prototype.processImportantQueueItem = function () {
        var _this = this;
        return this.appDB.getRecords(this.QUEUE_TABLE, undefined, 'priority DESC, added ASC', undefined, 0, 1).then(function (items) {
            var item = items.pop();
            if (!item) {
                return Promise.reject(_this.ERR_QUEUE_IS_EMPTY);
            }
            // Convert the links to an object.
            item.links = _this.textUtils.parseJSON(item.links, []);
            return _this.processQueueItem(item);
        }, function () {
            return Promise.reject(_this.ERR_QUEUE_IS_EMPTY);
        });
    };
    /**
     * Process a queue item.
     *
     * @param {CoreFilepoolQueueEntry} item The object from the queue store.
     * @return {Promise<any>} Resolved on success. Rejected on failure.
     */
    CoreFilepoolProvider.prototype.processQueueItem = function (item) {
        var _this = this;
        // Cast optional fields to undefined instead of null.
        var siteId = item.siteId, fileId = item.fileId, fileUrl = item.url, options = {
            revision: item.revision || undefined,
            timemodified: item.timemodified || undefined,
            isexternalfile: item.isexternalfile || undefined,
            repositorytype: item.repositorytype || undefined
        }, filePath = item.path || undefined, links = item.links || [];
        this.logger.debug('Processing queue item: ' + siteId + ', ' + fileId);
        // Check if the file is already in pool.
        return this.hasFileInPool(siteId, fileId).catch(function () {
            // File not in pool.
        }).then(function (entry) {
            if (entry && !options.isexternalfile && !_this.isFileOutdated(entry, options.revision, options.timemodified)) {
                // We have the file, it is not stale, we can update links and remove from queue.
                _this.logger.debug('Queued file already in store, ignoring...');
                _this.addFileLinks(siteId, fileId, links).catch(function () {
                    // Ignore errors.
                });
                _this.removeFromQueue(siteId, fileId).catch(function () {
                    // Ignore errors.
                }).finally(function () {
                    _this.treatQueueDeferred(siteId, fileId, true);
                });
                _this.notifyFileDownloaded(siteId, fileId);
                return;
            }
            // The file does not exist, or is stale, ... download it.
            var onProgress = _this.getQueueOnProgress(siteId, fileId);
            return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, entry).then(function () {
                // Success, we add links and remove from queue.
                _this.addFileLinks(siteId, fileId, links).catch(function () {
                    // Ignore errors.
                });
                _this.treatQueueDeferred(siteId, fileId, true);
                _this.notifyFileDownloaded(siteId, fileId);
                // Wait for the item to be removed from queue before resolving the promise.
                // If the item could not be removed from queue we still resolve the promise.
                return _this.removeFromQueue(siteId, fileId).catch(function () {
                    // Ignore errors.
                });
            }, function (errorObject) {
                // Whoops, we have an error...
                var dropFromQueue = false;
                if (errorObject && errorObject.source === fileUrl) {
                    // This is most likely a FileTransfer error.
                    if (errorObject.code === 1) {
                        // The file was not found, most likely a 404, we remove from queue.
                        dropFromQueue = true;
                    }
                    else if (errorObject.code === 2) {
                        // The URL is invalid, we drop the file from the queue.
                        dropFromQueue = true;
                    }
                    else if (errorObject.code === 3) {
                        // If there was an HTTP status, then let's remove from the queue.
                        dropFromQueue = true;
                    }
                    else if (errorObject.code === 4) {
                        // The transfer was aborted, we will keep the file in queue.
                    }
                    else if (errorObject.code === 5) {
                        // We have the latest version of the file, HTTP 304 status.
                        dropFromQueue = true;
                    }
                    else {
                        // Unknown error, let's remove the file from the queue to avoi locking down the queue.
                        dropFromQueue = true;
                    }
                }
                else {
                    dropFromQueue = true;
                }
                var errorMessage = null;
                // Some Android devices restrict the amount of usable storage using quotas.
                // If this quota would be exceeded by the download, it throws an exception.
                // We catch this exception here, and report a meaningful error message to the user.
                if (errorObject instanceof FileTransferError && errorObject.exception && errorObject.exception.includes('EDQUOT')) {
                    errorMessage = 'core.course.insufficientavailablequota';
                }
                if (dropFromQueue) {
                    _this.logger.debug('Item dropped from queue due to error: ' + fileUrl, errorObject);
                    return _this.removeFromQueue(siteId, fileId).catch(function () {
                        // Consider this as a silent error, never reject the promise here.
                    }).then(function () {
                        _this.treatQueueDeferred(siteId, fileId, false, errorMessage);
                        _this.notifyFileDownloadError(siteId, fileId);
                    });
                }
                else {
                    // We considered the file as legit but did not get it, failure.
                    _this.treatQueueDeferred(siteId, fileId, false, errorMessage);
                    _this.notifyFileDownloadError(siteId, fileId);
                    return Promise.reject(errorObject);
                }
            });
        });
    };
    /**
     * Remove a file from the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<any>} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     */
    CoreFilepoolProvider.prototype.removeFromQueue = function (siteId, fileId) {
        return this.appDB.deleteRecords(this.QUEUE_TABLE, { siteId: siteId, fileId: fileId });
    };
    /**
     * Remove a file from the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.removeFileById = function (siteId, fileId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            // Get the path to the file first since it relies on the file object stored in the pool.
            return Promise.resolve(_this.getFilePath(siteId, fileId)).then(function (path) {
                var promises = [];
                // Remove entry from filepool store.
                promises.push(db.deleteRecords(_this.FILES_TABLE, { fileId: fileId }));
                // Remove links.
                promises.push(db.deleteRecords(_this.LINKS_TABLE, { fileId: fileId }));
                // Remove the file.
                if (_this.fileProvider.isAvailable()) {
                    promises.push(_this.fileProvider.removeFile(path).catch(function (error) {
                        if (error && error.code == 1) {
                            // Not found, ignore error since maybe it was deleted already.
                        }
                        else {
                            return Promise.reject(error);
                        }
                    }));
                }
                return Promise.all(promises).then(function () {
                    _this.notifyFileDeleted(siteId, fileId);
                });
            });
        });
    };
    /**
     * Delete all the matching files from a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.removeFilesByComponent = function (siteId, component, componentId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return _this.getComponentFiles(db, component, componentId);
        }).then(function (items) {
            return Promise.all(items.map(function (item) {
                return _this.removeFileById(siteId, item.fileId);
            }));
        });
    };
    /**
     * Remove a file from the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<any>} Resolved on success, rejected on failure.
     */
    CoreFilepoolProvider.prototype.removeFileByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.removeFileById(siteId, fileId);
        });
    };
    /**
     * Removes the revision number from a file URL.
     *
     * @param {string} url URL to remove the revision number.
     * @return {string} URL without revision number.
     * @description
     * The revision is used to know if a file has changed. We remove it from the URL to prevent storing a file per revision.
     */
    CoreFilepoolProvider.prototype.removeRevisionFromUrl = function (url) {
        var args = this.getPluginFileArgs(url);
        if (!args) {
            // Not a pluginfile, no revision will be found.
            return url;
        }
        return this.pluginFileDelegate.removeRevisionFromUrl(url, args);
    };
    /**
     * Change the package status, setting it to the previous status.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved when the status is changed. Resolve param: new status.
     */
    CoreFilepoolProvider.prototype.setPackagePreviousStatus = function (siteId, component, componentId) {
        var _this = this;
        componentId = this.fixComponentId(componentId);
        this.logger.debug("Set previous status for package " + component + " " + componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            // Get current stored data, we'll only update 'status' and 'updated' fields.
            return site.getDb().getRecord(_this.PACKAGES_TABLE, { id: packageId }).then(function (entry) {
                var newData = {};
                if (entry.status == __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                    // Going back from downloading to previous status, restore previous download time.
                    newData.downloadTime = entry.previousDownloadTime;
                }
                newData.status = entry.previous || __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                newData.updated = Date.now();
                _this.logger.debug("Set previous status '" + entry.status + "' for package " + component + " " + componentId);
                return site.getDb().updateRecords(_this.PACKAGES_TABLE, newData, { id: packageId }).then(function () {
                    // Success updating, trigger event.
                    _this.triggerPackageStatusChanged(site.id, newData.status, component, componentId);
                    return newData.status;
                });
            });
        });
    };
    /**
     * Convenience function to check if a file should be downloaded before opening it.
     *
     * @param {string} url File online URL.
     * @param {number} size File size.
     * @return {Promise}     Promise resolved if should download before open, rejected otherwise.
     * @description
     * Convenience function to check if a file should be downloaded before opening it.
     *
     * The default behaviour in the app is to download first and then open the local file in the following cases:
     *     - The file is small (less than DOWNLOAD_THRESHOLD).
     *     - The file cannot be streamed.
     * If the file is big and can be streamed, the promise returned by this function will be rejected.
     */
    CoreFilepoolProvider.prototype.shouldDownloadBeforeOpen = function (url, size) {
        if (size >= 0 && size <= this.DOWNLOAD_THRESHOLD) {
            // The file is small, download it.
            return Promise.resolve();
        }
        if (this.appProvider.isDesktop()) {
            // In desktop always download first.
            return Promise.resolve();
        }
        return this.utils.getMimeTypeFromUrl(url).then(function (mimetype) {
            // If the file is streaming (audio or video) we reject.
            if (mimetype.indexOf('video') != -1 || mimetype.indexOf('audio') != -1) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Store package status.
     *
     * @param {string} siteId Site ID.
     * @param {string} status New package status.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [extra] Extra data to store for the package. If you want to store more than 1 value, use JSON.stringify.
     * @return {Promise<any>} Promise resolved when status is stored.
     */
    CoreFilepoolProvider.prototype.storePackageStatus = function (siteId, status, component, componentId, extra) {
        var _this = this;
        this.logger.debug("Set status '" + status + "' for package " + component + " " + componentId);
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            var downloadTime, previousDownloadTime;
            if (status == __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                // Set download time if package is now downloading.
                downloadTime = _this.timeUtils.timestamp();
            }
            // Search current status to set it as previous status.
            return site.getDb().getRecord(_this.PACKAGES_TABLE, { id: packageId }).then(function (entry) {
                if (typeof extra == 'undefined' || extra === null) {
                    extra = entry.extra;
                }
                if (typeof downloadTime == 'undefined') {
                    // Keep previous download time.
                    downloadTime = entry.downloadTime;
                    previousDownloadTime = entry.previousDownloadTime;
                }
                else {
                    // The downloadTime will be updated, store current time as previous.
                    previousDownloadTime = entry.downloadTime;
                }
                return entry.status;
            }).catch(function () {
                // No previous status.
            }).then(function (previousStatus) {
                var packageEntry = {
                    id: packageId,
                    component: component,
                    componentId: componentId,
                    status: status,
                    previous: previousStatus,
                    updated: Date.now(),
                    downloadTime: downloadTime,
                    previousDownloadTime: previousDownloadTime,
                    extra: extra
                };
                var promise;
                if (previousStatus === status) {
                    // The package already has this status, no need to change it.
                    promise = Promise.resolve();
                }
                else {
                    promise = site.getDb().insertRecord(_this.PACKAGES_TABLE, packageEntry);
                }
                return promise.then(function () {
                    // Success inserting, trigger event.
                    _this.triggerPackageStatusChanged(siteId, status, component, componentId);
                });
            });
        });
    };
    /**
     * Search for files in a CSS code and try to download them. Once downloaded, replace their URLs
     * and store the result in the CSS file.
     *
     * @param {string} siteId  Site ID.
     * @param {string} fileUrl CSS file URL.
     * @param {string} cssCode CSS code.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [revision] Revision to use in all files. If not defined, it will be calculated using the URL of each file.
     * @return {Promise<string>} Promise resolved with the CSS code.
     */
    CoreFilepoolProvider.prototype.treatCSSCode = function (siteId, fileUrl, cssCode, component, componentId, revision) {
        var _this = this;
        var urls = this.domUtils.extractUrlsFromCSS(cssCode), promises = [];
        var filePath, updated = false;
        // Get the path of the CSS file.
        promises.push(this.getFilePathByUrl(siteId, fileUrl).then(function (path) {
            filePath = path;
        }));
        urls.forEach(function (url) {
            // Download the file only if it's an online URL.
            if (url.indexOf('http') == 0) {
                promises.push(_this.downloadUrl(siteId, url, false, component, componentId, 0, undefined, undefined, undefined, revision).then(function (fileUrl) {
                    if (fileUrl != url) {
                        cssCode = cssCode.replace(new RegExp(_this.textUtils.escapeForRegex(url), 'g'), fileUrl);
                        updated = true;
                    }
                }).catch(function (error) {
                    // It shouldn't happen. Ignore errors.
                    _this.logger.warn('Error treating file ', url, error);
                }));
            }
        });
        return Promise.all(promises).then(function () {
            // All files downloaded. Store the result if it has changed.
            if (updated) {
                return _this.fileProvider.writeFile(filePath, cssCode);
            }
        }).then(function () {
            return cssCode;
        });
    };
    /**
     * Remove extension from fileId in queue, used to migrate from previous file handling.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFilepoolProvider.prototype.treatExtensionInQueue = function () {
        var _this = this;
        this.logger.debug('Treat extensions in queue');
        return this.appDB.getAllRecords(this.QUEUE_TABLE).then(function (entries) {
            var promises = [];
            entries.forEach(function (entry) {
                // For files in the queue, we only need to remove the extension from the fileId.
                // After downloading, additional info will be added.
                var fileId = entry.fileId;
                entry.fileId = _this.mimeUtils.removeExtension(fileId);
                if (fileId == entry.fileId) {
                    return;
                }
                promises.push(_this.appDB.updateRecords(_this.QUEUE_TABLE, { fileId: entry.fileId }, { fileId: fileId }));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Resolves or rejects a queue deferred and removes it from the list.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {boolean} resolve True if promise should be resolved, false if it should be rejected.
     * @param {string} error String identifier for error message, if rejected.
     */
    CoreFilepoolProvider.prototype.treatQueueDeferred = function (siteId, fileId, resolve, error) {
        if (this.queueDeferreds[siteId] && this.queueDeferreds[siteId][fileId]) {
            if (resolve) {
                this.queueDeferreds[siteId][fileId].resolve();
            }
            else {
                this.queueDeferreds[siteId][fileId].reject(error);
            }
            delete this.queueDeferreds[siteId][fileId];
        }
    };
    /**
     * Trigger mmCoreEventPackageStatusChanged with the right data.
     *
     * @param {string} siteId Site ID.
     * @param {string} status New package status.
     * @param {string} component  Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     */
    CoreFilepoolProvider.prototype.triggerPackageStatusChanged = function (siteId, status, component, componentId) {
        var data = {
            component: component,
            componentId: this.fixComponentId(componentId),
            status: status
        };
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_3__events__["a" /* CoreEventsProvider */].PACKAGE_STATUS_CHANGED, data, siteId);
    };
    /**
     * Update the download time of a package. This doesn't modify the previous download time.
     * This function should be used if a package generates some new data during a download. Calling this function
     * right after generating the data in the download will prevent detecting this data as an update.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Promise resolved when status is stored.
     */
    CoreFilepoolProvider.prototype.updatePackageDownloadTime = function (siteId, component, componentId) {
        var _this = this;
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            return site.getDb().updateRecords(_this.PACKAGES_TABLE, { downloadTime: _this.timeUtils.timestamp() }, { id: packageId });
        });
    };
    CoreFilepoolProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_4__file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_8__sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__ws__["a" /* CoreWSProvider */], __WEBPACK_IMPORTED_MODULE_12__utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_15__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_11__utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_14__utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_13__utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_5__init__["a" /* CoreInitDelegate */],
            __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__["a" /* Network */], __WEBPACK_IMPORTED_MODULE_7__plugin_file_delegate__["a" /* CorePluginFileDelegate */], __WEBPACK_IMPORTED_MODULE_10__utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_0__angular_core__["M" /* NgZone */]])
    ], CoreFilepoolProvider);
    return CoreFilepoolProvider;
}());

//# sourceMappingURL=filepool.js.map

/***/ }),
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUrlUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lang__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__text__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/*
 * "Utils" service with helper functions for URLs.
 */
var CoreUrlUtilsProvider = /** @class */ (function () {
    function CoreUrlUtilsProvider(langProvider, textUtils) {
        this.langProvider = langProvider;
        this.textUtils = textUtils;
    }
    /**
     * Add or remove 'www' from a URL. The url needs to have http or https protocol.
     *
     * @param {string} url URL to modify.
     * @return {string} Modified URL.
     */
    CoreUrlUtilsProvider.prototype.addOrRemoveWWW = function (url) {
        if (url) {
            if (url.match(/http(s)?:\/\/www\./)) {
                // Already has www. Remove it.
                url = url.replace('www.', '');
            }
            else {
                url = url.replace('https://', 'https://www.');
                url = url.replace('http://', 'http://www.');
            }
        }
        return url;
    };
    /**
     * Extracts the parameters from a URL and stores them in an object.
     *
     * @param {string} url URL to treat.
     * @return {any} Object with the params.
     */
    CoreUrlUtilsProvider.prototype.extractUrlParams = function (url) {
        var regex = /[?&]+([^=&]+)=?([^&]*)?/gi, subParamsPlaceholder = '@@@SUBPARAMS@@@', params = {}, urlAndHash = url.split('#'), questionMarkSplit = urlAndHash[0].split('?');
        var subParams;
        if (questionMarkSplit.length > 2) {
            // There is more than one question mark in the URL. This can happen if any of the params is a URL with params.
            // We only want to treat the first level of params, so we'll remove this second list of params and restore it later.
            questionMarkSplit.splice(0, 2);
            subParams = '?' + questionMarkSplit.join('?');
            urlAndHash[0] = urlAndHash[0].replace(subParams, subParamsPlaceholder);
        }
        urlAndHash[0].replace(regex, function (match, key, value) {
            params[key] = typeof value != 'undefined' ? value : '';
            if (subParams) {
                params[key] = params[key].replace(subParamsPlaceholder, subParams);
            }
            return match;
        });
        if (urlAndHash.length > 1) {
            // Remove the URL from the array.
            urlAndHash.shift();
            // Add the hash as a param with a special name. Use a join in case there is more than one #.
            params.urlHash = urlAndHash.join('#');
        }
        return params;
    };
    /**
     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
     * For download remote files from Moodle we need to use the special /webservice/pluginfile passing
     * the ws token as a get parameter.
     *
     * @param {string} url The url to be fixed.
     * @param {string} token Token to use.
     * @param {string} siteUrl The URL of the site the URL belongs to.
     * @return {string} Fixed URL.
     */
    CoreUrlUtilsProvider.prototype.fixPluginfileURL = function (url, token, siteUrl) {
        if (!url) {
            return '';
        }
        url = url.replace(/&amp;/g, '&');
        // First check if we need to fix this url or is already fixed.
        if (url.indexOf('token=') != -1) {
            return url;
        }
        // Check if is a valid URL (contains the pluginfile endpoint).
        if (!this.isPluginFileUrl(url)) {
            return url;
        }
        // Check if the URL already has params.
        if (url.match(/\?[^=]+=/)) {
            url += '&';
        }
        else {
            url += '?';
        }
        // Always send offline=1 (for external repositories). It shouldn't cause problems for local files or old Moodles.
        url += 'token=' + token + '&offline=1';
        // Some webservices returns directly the correct download url, others not.
        if (url.indexOf(this.textUtils.concatenatePaths(siteUrl, 'pluginfile.php')) === 0) {
            url = url.replace('/pluginfile', '/webservice/pluginfile');
        }
        return url;
    };
    /**
     * Formats a URL, trim, lowercase, etc...
     *
     * @param {string} url The url to be formatted.
     * @return {string} Fromatted url.
     */
    CoreUrlUtilsProvider.prototype.formatURL = function (url) {
        url = url.trim();
        // Check if the URL starts by http or https.
        if (!/^http(s)?\:\/\/.*/i.test(url)) {
            // Test first allways https.
            url = 'https://' + url;
        }
        // http allways in lowercase.
        url = url.replace(/^http/i, 'http');
        url = url.replace(/^https/i, 'https');
        // Replace last slash.
        url = url.replace(/\/$/, '');
        return url;
    };
    /**
     * Returns the URL to the documentation of the app, based on Moodle version and current language.
     *
     * @param {string} [release] Moodle release.
     * @param {string} [page=Mobile_app] Docs page to go to.
     * @return {Promise<string>} Promise resolved with the Moodle docs URL.
     */
    CoreUrlUtilsProvider.prototype.getDocsUrl = function (release, page) {
        if (page === void 0) { page = 'Mobile_app'; }
        var docsUrl = 'https://docs.moodle.org/en/' + page;
        if (typeof release != 'undefined') {
            var version = release.substr(0, 3).replace('.', '');
            // Check is a valid number.
            if (parseInt(version) >= 24) {
                // Append release number.
                docsUrl = docsUrl.replace('https://docs.moodle.org/', 'https://docs.moodle.org/' + version + '/');
            }
        }
        return this.langProvider.getCurrentLanguage().then(function (lang) {
            return docsUrl.replace('/en/', '/' + lang + '/');
        }).catch(function () {
            return docsUrl;
        });
    };
    /**
     * Given a URL, returns what's after the last '/' without params.
     * Example:
     * http://mysite.com/a/course.html?id=1 -> course.html
     *
     * @param {string} url URL to treat.
     * @return {string} Last file without params.
     */
    CoreUrlUtilsProvider.prototype.getLastFileWithoutParams = function (url) {
        var filename = url.substr(url.lastIndexOf('/') + 1);
        if (filename.indexOf('?') != -1) {
            filename = filename.substr(0, filename.indexOf('?'));
        }
        return filename;
    };
    /**
     * Get the protocol from a URL.
     * E.g. http://www.google.com returns 'http'.
     *
     * @param {string} url URL to treat.
     * @return {string} Protocol, undefined if no protocol found.
     */
    CoreUrlUtilsProvider.prototype.getUrlProtocol = function (url) {
        if (!url) {
            return;
        }
        var matches = url.match(/^([^\/:\.\?]*):\/\//);
        if (matches && matches[1]) {
            return matches[1];
        }
    };
    /**
     * Get the scheme from a URL. Please notice that, if a URL has protocol, it will return the protocol.
     * E.g. javascript:doSomething() returns 'javascript'.
     *
     * @param {string} url URL to treat.
     * @return {string} Scheme, undefined if no scheme found.
     */
    CoreUrlUtilsProvider.prototype.getUrlScheme = function (url) {
        if (!url) {
            return;
        }
        var matches = url.match(/^([a-z][a-z0-9+\-.]*):/);
        if (matches && matches[1]) {
            return matches[1];
        }
    };
    /*
     * Gets a username from a URL like: user@mysite.com.
     *
     * @param {string} url URL to treat.
     * @return {string} Username. Undefined if no username found.
     */
    CoreUrlUtilsProvider.prototype.getUsernameFromUrl = function (url) {
        if (url.indexOf('@') > -1) {
            // Get URL without protocol.
            var withoutProtocol = url.replace(/^[^?@\/]*:\/\//, ''), matches = withoutProtocol.match(/[^@]*/);
            // Make sure that @ is at the start of the URL, not in a param at the end.
            if (matches && matches.length && !matches[0].match(/[\/|?]/)) {
                return matches[0];
            }
        }
    };
    /**
     * Returns if a URL has any protocol (not a relative URL).
     *
     * @param {string} url The url to test against the pattern.
     * @return {boolean} Whether the url is absolute.
     */
    CoreUrlUtilsProvider.prototype.isAbsoluteURL = function (url) {
        return /^[^:]{2,}:\/\//i.test(url) || /^(tel:|mailto:|geo:)/.test(url);
    };
    /**
     * Returns if a URL is downloadable: plugin file OR theme/image.php OR gravatar.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is downloadable.
     */
    CoreUrlUtilsProvider.prototype.isDownloadableUrl = function (url) {
        return this.isPluginFileUrl(url) || this.isThemeImageUrl(url) || this.isGravatarUrl(url);
    };
    /**
     * Returns if a URL is a gravatar URL.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is a gravatar URL.
     */
    CoreUrlUtilsProvider.prototype.isGravatarUrl = function (url) {
        return url && url.indexOf('gravatar.com/avatar') !== -1;
    };
    /**
     * Check if a URL uses http or https protocol.
     *
     * @param {string} url The url to test.
     * @return {boolean} Whether the url uses http or https protocol.
     */
    CoreUrlUtilsProvider.prototype.isHttpURL = function (url) {
        return /^https?\:\/\/.+/i.test(url);
    };
    /**
     * Returns if a URL is a pluginfile URL.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is a pluginfile URL.
     */
    CoreUrlUtilsProvider.prototype.isPluginFileUrl = function (url) {
        return url && url.indexOf('/pluginfile.php') !== -1;
    };
    /**
     * Returns if a URL is a theme image URL.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is a theme image URL.
     */
    CoreUrlUtilsProvider.prototype.isThemeImageUrl = function (url) {
        return url && url.indexOf('/theme/image.php') !== -1;
    };
    /**
     * Remove protocol and www from a URL.
     *
     * @param {string} url URL to treat.
     * @return {string} Treated URL.
     */
    CoreUrlUtilsProvider.prototype.removeProtocolAndWWW = function (url) {
        // Remove protocol.
        url = url.replace(/.*?:\/\//g, '');
        // Remove www.
        url = url.replace(/^www./, '');
        return url;
    };
    /**
     * Remove the parameters from a URL, returning the URL without them.
     *
     * @param {string} url URL to treat.
     * @return {string} URL without params.
     */
    CoreUrlUtilsProvider.prototype.removeUrlParams = function (url) {
        var matches = url.match(/^[^\?]+/);
        return matches && matches[0];
    };
    CoreUrlUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_2__text__["a" /* CoreTextUtilsProvider */]])
    ], CoreUrlUtilsProvider);
    return CoreUrlUtilsProvider;
}());

//# sourceMappingURL=url.js.map

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTimeUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_constants__ = __webpack_require__(39);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/*
 * "Utils" service with helper functions for date and time.
*/
var CoreTimeUtilsProvider = /** @class */ (function () {
    function CoreTimeUtilsProvider(translate) {
        this.translate = translate;
        this.FORMAT_REPLACEMENTS = {
            '%a': 'ddd',
            '%A': 'dddd',
            '%d': 'DD',
            '%e': 'D',
            '%j': 'DDDD',
            '%u': 'E',
            '%w': 'e',
            '%U': 'ww',
            '%V': 'WW',
            '%W': 'ww',
            '%b': 'MMM',
            '%B': 'MMMM',
            '%h': 'MMM',
            '%m': 'MM',
            '%C': '',
            '%g': 'GG',
            '%G': 'GGGG',
            '%y': 'YY',
            '%Y': 'YYYY',
            '%H': 'HH',
            '%k': 'H',
            '%I': 'hh',
            '%l': 'h',
            '%M': 'mm',
            '%p': 'A',
            '%P': 'a',
            '%r': 'hh:mm:ss A',
            '%R': 'HH:mm',
            '%S': 'ss',
            '%T': 'HH:mm:ss',
            '%X': 'LTS',
            '%z': 'ZZ',
            '%Z': 'ZZ',
            '%c': 'LLLL',
            '%D': 'MM/DD/YY',
            '%F': 'YYYY-MM-DD',
            '%s': 'X',
            '%x': 'L',
            '%n': '\n',
            '%t': '\t',
            '%%': '%'
        };
    }
    /**
     * Convert a PHP format to a Moment format.
     *
     * @param {string} format PHP format.
     * @return {string} Converted format.
     */
    CoreTimeUtilsProvider.prototype.convertPHPToMoment = function (format) {
        if (typeof format != 'string') {
            // Not valid.
            return '';
        }
        var converted = '', escaping = false;
        for (var i = 0; i < format.length; i++) {
            var char = format[i];
            if (char == '%') {
                // It's a PHP format, try to convert it.
                i++;
                char += format[i] || '';
                if (escaping) {
                    // We were escaping some characters, stop doing it now.
                    escaping = false;
                    converted += ']';
                }
                converted += typeof this.FORMAT_REPLACEMENTS[char] != 'undefined' ? this.FORMAT_REPLACEMENTS[char] : char;
            }
            else {
                // Not a PHP format. We need to escape them, otherwise the letters could be confused with Moment formats.
                if (!escaping) {
                    escaping = true;
                    converted += '[';
                }
                converted += char;
            }
        }
        if (escaping) {
            // Finish escaping.
            converted += ']';
        }
        return converted;
    };
    /**
     * Returns hours, minutes and seconds in a human readable format
     *
     * @param {number} seconds A number of seconds
     * @return {string} Seconds in a human readable format.
     */
    CoreTimeUtilsProvider.prototype.formatTime = function (seconds) {
        var totalSecs, years, days, hours, mins, secs, remainder;
        totalSecs = Math.abs(seconds);
        years = Math.floor(totalSecs / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_YEAR);
        remainder = totalSecs - (years * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_YEAR);
        days = Math.floor(remainder / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_DAY);
        remainder = totalSecs - (days * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_DAY);
        hours = Math.floor(remainder / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR);
        remainder = remainder - (hours * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR);
        mins = Math.floor(remainder / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE);
        secs = remainder - (mins * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE);
        var ss = this.translate.instant('core.' + (secs == 1 ? 'sec' : 'secs')), sm = this.translate.instant('core.' + (mins == 1 ? 'min' : 'mins')), sh = this.translate.instant('core.' + (hours == 1 ? 'hour' : 'hours')), sd = this.translate.instant('core.' + (days == 1 ? 'day' : 'days')), sy = this.translate.instant('core.' + (years == 1 ? 'year' : 'years'));
        var oyears = '', odays = '', ohours = '', omins = '', osecs = '';
        if (years) {
            oyears = years + ' ' + sy;
        }
        if (days) {
            odays = days + ' ' + sd;
        }
        if (hours) {
            ohours = hours + ' ' + sh;
        }
        if (mins) {
            omins = mins + ' ' + sm;
        }
        if (secs) {
            osecs = secs + ' ' + ss;
        }
        if (years) {
            return oyears + ' ' + odays;
        }
        if (days) {
            return odays + ' ' + ohours;
        }
        if (hours) {
            return ohours + ' ' + omins;
        }
        if (mins) {
            return omins + ' ' + osecs;
        }
        if (secs) {
            return osecs;
        }
        return this.translate.instant('core.now');
    };
    /**
     * Returns hours, minutes and seconds in a human readable format.
     *
     * @param {number} duration Duration in seconds
     * @param {number} [precision] Number of elements to have in precission. 0 or undefined to full precission.
     * @return {string} Duration in a human readable format.
     */
    CoreTimeUtilsProvider.prototype.formatDuration = function (duration, precision) {
        precision = precision || 5;
        var eventDuration = __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](duration, 'seconds');
        var durationString = '';
        if (precision && eventDuration.years() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.years(), 'years').humanize();
            precision--;
        }
        if (precision && eventDuration.months() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.months(), 'months').humanize();
            precision--;
        }
        if (precision && eventDuration.days() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.days(), 'days').humanize();
            precision--;
        }
        if (precision && eventDuration.hours() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.hours(), 'hours').humanize();
            precision--;
        }
        if (precision && eventDuration.minutes() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.minutes(), 'minutes').humanize();
            precision--;
        }
        return durationString.trim();
    };
    /**
     * Return the current timestamp in a "readable" format: YYYYMMDDHHmmSS.
     *
     * @return {string} The readable timestamp.
     */
    CoreTimeUtilsProvider.prototype.readableTimestamp = function () {
        return __WEBPACK_IMPORTED_MODULE_2_moment__(Date.now()).format('YYYYMMDDHHmmSS');
    };
    /**
     * Return the current timestamp (UNIX format, seconds).
     *
     * @return {number} The current timestamp in seconds.
     */
    CoreTimeUtilsProvider.prototype.timestamp = function () {
        return Math.round(Date.now() / 1000);
    };
    /**
     * Convert a timestamp into a readable date.
     *
     * @param {number} timestamp Timestamp in milliseconds.
     * @param {string} [format] The format to use (lang key). Defaults to core.strftimedaydatetime.
     * @param {boolean} [convert=true] If true (default), convert the format from PHP to Moment. Set it to false for Moment formats.
     * @param {boolean} [fixDay=true] If true (default) then the leading zero from %d is removed.
     * @param {boolean} [fixHour=true] If true (default) then the leading zero from %I is removed.
     * @return {string} Readable date.
     */
    CoreTimeUtilsProvider.prototype.userDate = function (timestamp, format, convert, fixDay, fixHour) {
        if (convert === void 0) { convert = true; }
        if (fixDay === void 0) { fixDay = true; }
        if (fixHour === void 0) { fixHour = true; }
        format = this.translate.instant(format ? format : 'core.strftimedaydatetime');
        if (fixDay) {
            format = format.replace(/%d/g, '%e');
        }
        if (fixHour) {
            format = format.replace('%I', '%l');
        }
        // Format could be in PHP format, convert it to moment.
        if (convert) {
            format = this.convertPHPToMoment(format);
        }
        return __WEBPACK_IMPORTED_MODULE_2_moment__(timestamp).format(format);
    };
    /**
     * Convert a text into user timezone timestamp.
     *
     * @param {number} date To convert to timestamp.
     * @return {number} Converted timestamp.
     */
    CoreTimeUtilsProvider.prototype.convertToTimestamp = function (date) {
        return __WEBPACK_IMPORTED_MODULE_2_moment__(date).unix() - (__WEBPACK_IMPORTED_MODULE_2_moment__().utcOffset() * 60);
    };
    /**
     * Return the localized ISO format (i.e DDMMYY) from the localized moment format. Useful for translations.
     * DO NOT USE this function for ion-datetime format. Moment escapes characters with [], but ion-datetime doesn't support it.
     *
     * @param {any} localizedFormat Format to use.
     * @return {string} Localized ISO format
     */
    CoreTimeUtilsProvider.prototype.getLocalizedDateFormat = function (localizedFormat) {
        return __WEBPACK_IMPORTED_MODULE_2_moment__["localeData"]().longDateFormat(localizedFormat);
    };
    /**
     * For a given timestamp get the midnight value in the user's timezone.
     *
     * The calculation is performed relative to the user's midnight timestamp
     * for today to ensure that timezones are preserved.
     *
     * @param {number} [timestamp] The timestamp to calculate from. If not defined, return today's midnight.
     * @return {number} The midnight value of the user's timestamp.
     */
    CoreTimeUtilsProvider.prototype.getMidnightForTimestamp = function (timestamp) {
        if (timestamp) {
            return __WEBPACK_IMPORTED_MODULE_2_moment__(timestamp * 1000).startOf('day').unix();
        }
        else {
            return __WEBPACK_IMPORTED_MODULE_2_moment__().startOf('day').unix();
        }
    };
    CoreTimeUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreTimeUtilsProvider);
    return CoreTimeUtilsProvider;
}());

//# sourceMappingURL=time.js.map

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directives_directives_module__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pipes_pipes_module__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__loading_loading__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__mark_required_mark_required__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__input_errors_input_errors__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__show_password_show_password__ = __webpack_require__(359);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__split_view_split_view__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__iframe_iframe__ = __webpack_require__(268);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__progress_bar_progress_bar__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__empty_box_empty_box__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__search_box_search_box__ = __webpack_require__(468);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__file_file__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__icon_icon__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__context_menu_context_menu__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__context_menu_context_menu_item__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__context_menu_context_menu_popover__ = __webpack_require__(542);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__course_picker_menu_course_picker_menu_popover__ = __webpack_require__(731);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__chart_chart__ = __webpack_require__(423);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__chrono_chrono__ = __webpack_require__(1445);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__download_refresh_download_refresh__ = __webpack_require__(374);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__local_file_local_file__ = __webpack_require__(266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__site_picker_site_picker__ = __webpack_require__(1446);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__tabs_tabs__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__tabs_tab__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__rich_text_editor_rich_text_editor__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__navbar_buttons_navbar_buttons__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__dynamic_component_dynamic_component__ = __webpack_require__(202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__send_message_form_send_message_form__ = __webpack_require__(1422);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__timer_timer__ = __webpack_require__(1423);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__recaptcha_recaptcha__ = __webpack_require__(1424);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__recaptcha_recaptchamodal__ = __webpack_require__(543);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__navigation_bar_navigation_bar__ = __webpack_require__(375);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__attachments_attachments__ = __webpack_require__(301);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__ion_tabs_ion_tabs__ = __webpack_require__(691);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__ion_tabs_ion_tab__ = __webpack_require__(1447);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__infinite_loading_infinite_loading__ = __webpack_require__(261);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__user_avatar_user_avatar__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__style_style__ = __webpack_require__(470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__bs_tooltip_bs_tooltip__ = __webpack_require__(538);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










































var CoreComponentsModule = /** @class */ (function () {
    function CoreComponentsModule() {
    }
    CoreComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__loading_loading__["a" /* CoreLoadingComponent */],
                __WEBPACK_IMPORTED_MODULE_6__mark_required_mark_required__["a" /* CoreMarkRequiredComponent */],
                __WEBPACK_IMPORTED_MODULE_7__input_errors_input_errors__["a" /* CoreInputErrorsComponent */],
                __WEBPACK_IMPORTED_MODULE_8__show_password_show_password__["a" /* CoreShowPasswordComponent */],
                __WEBPACK_IMPORTED_MODULE_9__split_view_split_view__["a" /* CoreSplitViewComponent */],
                __WEBPACK_IMPORTED_MODULE_10__iframe_iframe__["a" /* CoreIframeComponent */],
                __WEBPACK_IMPORTED_MODULE_11__progress_bar_progress_bar__["a" /* CoreProgressBarComponent */],
                __WEBPACK_IMPORTED_MODULE_12__empty_box_empty_box__["a" /* CoreEmptyBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_13__search_box_search_box__["a" /* CoreSearchBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_14__file_file__["a" /* CoreFileComponent */],
                __WEBPACK_IMPORTED_MODULE_15__icon_icon__["a" /* CoreIconComponent */],
                __WEBPACK_IMPORTED_MODULE_16__context_menu_context_menu__["a" /* CoreContextMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_17__context_menu_context_menu_item__["a" /* CoreContextMenuItemComponent */],
                __WEBPACK_IMPORTED_MODULE_18__context_menu_context_menu_popover__["a" /* CoreContextMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_19__course_picker_menu_course_picker_menu_popover__["a" /* CoreCoursePickerMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_20__chart_chart__["a" /* CoreChartComponent */],
                __WEBPACK_IMPORTED_MODULE_21__chrono_chrono__["a" /* CoreChronoComponent */],
                __WEBPACK_IMPORTED_MODULE_22__download_refresh_download_refresh__["a" /* CoreDownloadRefreshComponent */],
                __WEBPACK_IMPORTED_MODULE_23__local_file_local_file__["a" /* CoreLocalFileComponent */],
                __WEBPACK_IMPORTED_MODULE_24__site_picker_site_picker__["a" /* CoreSitePickerComponent */],
                __WEBPACK_IMPORTED_MODULE_25__tabs_tabs__["a" /* CoreTabsComponent */],
                __WEBPACK_IMPORTED_MODULE_26__tabs_tab__["a" /* CoreTabComponent */],
                __WEBPACK_IMPORTED_MODULE_27__rich_text_editor_rich_text_editor__["a" /* CoreRichTextEditorComponent */],
                __WEBPACK_IMPORTED_MODULE_28__navbar_buttons_navbar_buttons__["a" /* CoreNavBarButtonsComponent */],
                __WEBPACK_IMPORTED_MODULE_29__dynamic_component_dynamic_component__["a" /* CoreDynamicComponent */],
                __WEBPACK_IMPORTED_MODULE_30__send_message_form_send_message_form__["a" /* CoreSendMessageFormComponent */],
                __WEBPACK_IMPORTED_MODULE_31__timer_timer__["a" /* CoreTimerComponent */],
                __WEBPACK_IMPORTED_MODULE_32__recaptcha_recaptcha__["a" /* CoreRecaptchaComponent */],
                __WEBPACK_IMPORTED_MODULE_33__recaptcha_recaptchamodal__["a" /* CoreRecaptchaModalComponent */],
                __WEBPACK_IMPORTED_MODULE_34__navigation_bar_navigation_bar__["a" /* CoreNavigationBarComponent */],
                __WEBPACK_IMPORTED_MODULE_35__attachments_attachments__["a" /* CoreAttachmentsComponent */],
                __WEBPACK_IMPORTED_MODULE_36__ion_tabs_ion_tabs__["a" /* CoreIonTabsComponent */],
                __WEBPACK_IMPORTED_MODULE_37__ion_tabs_ion_tab__["a" /* CoreIonTabComponent */],
                __WEBPACK_IMPORTED_MODULE_38__infinite_loading_infinite_loading__["a" /* CoreInfiniteLoadingComponent */],
                __WEBPACK_IMPORTED_MODULE_39__user_avatar_user_avatar__["a" /* CoreUserAvatarComponent */],
                __WEBPACK_IMPORTED_MODULE_40__style_style__["a" /* CoreStyleComponent */],
                __WEBPACK_IMPORTED_MODULE_41__bs_tooltip_bs_tooltip__["a" /* CoreBSTooltipComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_18__context_menu_context_menu_popover__["a" /* CoreContextMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_19__course_picker_menu_course_picker_menu_popover__["a" /* CoreCoursePickerMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_33__recaptcha_recaptchamodal__["a" /* CoreRecaptchaModalComponent */],
                __WEBPACK_IMPORTED_MODULE_41__bs_tooltip_bs_tooltip__["a" /* CoreBSTooltipComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_3__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_4__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__loading_loading__["a" /* CoreLoadingComponent */],
                __WEBPACK_IMPORTED_MODULE_6__mark_required_mark_required__["a" /* CoreMarkRequiredComponent */],
                __WEBPACK_IMPORTED_MODULE_7__input_errors_input_errors__["a" /* CoreInputErrorsComponent */],
                __WEBPACK_IMPORTED_MODULE_8__show_password_show_password__["a" /* CoreShowPasswordComponent */],
                __WEBPACK_IMPORTED_MODULE_9__split_view_split_view__["a" /* CoreSplitViewComponent */],
                __WEBPACK_IMPORTED_MODULE_10__iframe_iframe__["a" /* CoreIframeComponent */],
                __WEBPACK_IMPORTED_MODULE_11__progress_bar_progress_bar__["a" /* CoreProgressBarComponent */],
                __WEBPACK_IMPORTED_MODULE_12__empty_box_empty_box__["a" /* CoreEmptyBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_13__search_box_search_box__["a" /* CoreSearchBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_14__file_file__["a" /* CoreFileComponent */],
                __WEBPACK_IMPORTED_MODULE_15__icon_icon__["a" /* CoreIconComponent */],
                __WEBPACK_IMPORTED_MODULE_16__context_menu_context_menu__["a" /* CoreContextMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_17__context_menu_context_menu_item__["a" /* CoreContextMenuItemComponent */],
                __WEBPACK_IMPORTED_MODULE_20__chart_chart__["a" /* CoreChartComponent */],
                __WEBPACK_IMPORTED_MODULE_21__chrono_chrono__["a" /* CoreChronoComponent */],
                __WEBPACK_IMPORTED_MODULE_22__download_refresh_download_refresh__["a" /* CoreDownloadRefreshComponent */],
                __WEBPACK_IMPORTED_MODULE_23__local_file_local_file__["a" /* CoreLocalFileComponent */],
                __WEBPACK_IMPORTED_MODULE_24__site_picker_site_picker__["a" /* CoreSitePickerComponent */],
                __WEBPACK_IMPORTED_MODULE_25__tabs_tabs__["a" /* CoreTabsComponent */],
                __WEBPACK_IMPORTED_MODULE_26__tabs_tab__["a" /* CoreTabComponent */],
                __WEBPACK_IMPORTED_MODULE_27__rich_text_editor_rich_text_editor__["a" /* CoreRichTextEditorComponent */],
                __WEBPACK_IMPORTED_MODULE_28__navbar_buttons_navbar_buttons__["a" /* CoreNavBarButtonsComponent */],
                __WEBPACK_IMPORTED_MODULE_29__dynamic_component_dynamic_component__["a" /* CoreDynamicComponent */],
                __WEBPACK_IMPORTED_MODULE_30__send_message_form_send_message_form__["a" /* CoreSendMessageFormComponent */],
                __WEBPACK_IMPORTED_MODULE_31__timer_timer__["a" /* CoreTimerComponent */],
                __WEBPACK_IMPORTED_MODULE_32__recaptcha_recaptcha__["a" /* CoreRecaptchaComponent */],
                __WEBPACK_IMPORTED_MODULE_34__navigation_bar_navigation_bar__["a" /* CoreNavigationBarComponent */],
                __WEBPACK_IMPORTED_MODULE_35__attachments_attachments__["a" /* CoreAttachmentsComponent */],
                __WEBPACK_IMPORTED_MODULE_36__ion_tabs_ion_tabs__["a" /* CoreIonTabsComponent */],
                __WEBPACK_IMPORTED_MODULE_37__ion_tabs_ion_tab__["a" /* CoreIonTabComponent */],
                __WEBPACK_IMPORTED_MODULE_38__infinite_loading_infinite_loading__["a" /* CoreInfiniteLoadingComponent */],
                __WEBPACK_IMPORTED_MODULE_39__user_avatar_user_avatar__["a" /* CoreUserAvatarComponent */],
                __WEBPACK_IMPORTED_MODULE_40__style_style__["a" /* CoreStyleComponent */],
                __WEBPACK_IMPORTED_MODULE_41__bs_tooltip_bs_tooltip__["a" /* CoreBSTooltipComponent */]
            ]
        })
    ], CoreComponentsModule);
    return CoreComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./src/directives/auto-focus.ts
var auto_focus = __webpack_require__(357);

// EXTERNAL MODULE: ./src/providers/file-helper.ts
var file_helper = __webpack_require__(132);

// EXTERNAL MODULE: ./src/providers/utils/dom.ts
var dom = __webpack_require__(4);

// CONCATENATED MODULE: ./src/directives/download-file.ts
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to allow downloading and open a file. When the item with this directive is clicked, the file will be
 * downloaded (if needed) and opened.
 */
var download_file_CoreDownloadFileDirective = /** @class */ (function () {
    function CoreDownloadFileDirective(element, domUtils, fileHelper) {
        this.domUtils = domUtils;
        this.fileHelper = fileHelper;
        this.element = element.nativeElement || element;
    }
    /**
     * Component being initialized.
     */
    CoreDownloadFileDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.element.addEventListener('click', function (ev) {
            if (!_this.file) {
                return;
            }
            ev.preventDefault();
            ev.stopPropagation();
            var modal = _this.domUtils.showModalLoading();
            _this.fileHelper.downloadAndOpenFile(_this.file, _this.component, _this.componentId).catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
            }).finally(function () {
                modal.dismiss();
            });
        });
    };
    __decorate([
        Object(core["D" /* Input */])('core-download-file'),
        __metadata("design:type", Object)
    ], CoreDownloadFileDirective.prototype, "file", void 0);
    __decorate([
        Object(core["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreDownloadFileDirective.prototype, "component", void 0);
    __decorate([
        Object(core["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreDownloadFileDirective.prototype, "componentId", void 0);
    CoreDownloadFileDirective = __decorate([
        Object(core["s" /* Directive */])({
            selector: '[core-download-file]'
        }),
        __metadata("design:paramtypes", [core["t" /* ElementRef */], dom["a" /* CoreDomUtilsProvider */], file_helper["a" /* CoreFileHelperProvider */]])
    ], CoreDownloadFileDirective);
    return CoreDownloadFileDirective;
}());

//# sourceMappingURL=download-file.js.map
// EXTERNAL MODULE: ./src/directives/external-content.ts
var external_content = __webpack_require__(236);

// EXTERNAL MODULE: ./src/directives/fab.ts
var fab = __webpack_require__(276);

// EXTERNAL MODULE: ./src/directives/format-text.ts
var format_text = __webpack_require__(42);

// EXTERNAL MODULE: ./src/directives/link.ts
var directives_link = __webpack_require__(188);

// EXTERNAL MODULE: ./src/providers/utils/utils.ts
var utils = __webpack_require__(2);

// CONCATENATED MODULE: ./src/directives/keep-keyboard.ts
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var keep_keyboard___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var keep_keyboard___metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * IMPORTANT: This directive is deprecated because it causes a weird effect (the keyboard closes and opens again).
 * We recommend using core-suppress-events directive for a better user experience.
 *
 * Directive to keep the keyboard open when clicking a certain element (usually a button).
 *
 * @description
 *
 * This directive needs to be applied to an input or textarea. The value of the directive needs to be a selector
 * to identify the element to listen for clicks (usually a button).
 *
 * When that element is clicked, the input that has this directive will keep the focus if it has it already and the keyboard
 * won't be closed.
 *
 * Example usage:
 *
 * <textarea [core-keep-keyboard]="'#mma-messages-send-message-button'"></textarea>
 * <button id="mma-messages-send-message-button">Send</button>
 *
 * Alternatively, this directive can be applied to the button. The value of the directive needs to be a selector to identify
 * the input element. In this case, you need to set [inButton]="true".
 *
 * Example usage:
 *
 * <textarea id="send-message-input"></textarea>
 * <button [core-keep-keyboard]="'#send-message-input'" [inButton]="true">Send</button>
 *
 * @deprecated v3.5.2
 */
var keep_keyboard_CoreKeepKeyboardDirective = /** @class */ (function () {
    function CoreKeepKeyboardDirective(element, domUtils, utils) {
        this.domUtils = domUtils;
        this.utils = utils;
        this.lastFocusOut = 0; // Last time the input was focused out.
        this.element = element.nativeElement;
    }
    /**
     * View has been initialized.
     */
    CoreKeepKeyboardDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        // Use a setTimeout because to make sure that child components have been treated.
        setTimeout(function () {
            var inButton = _this.utils.isTrueOrOne(_this.inButton);
            var candidateEls, selectedEl;
            if (typeof _this.selector != 'string' || !_this.selector) {
                // Not a valid selector, stop.
                return;
            }
            // Get the selected element. Get the last one found.
            candidateEls = document.querySelectorAll(_this.selector);
            selectedEl = candidateEls[candidateEls.length - 1];
            if (!selectedEl) {
                // Element not found.
                return;
            }
            if (inButton) {
                // The directive is applied to the button.
                _this.button = _this.element;
                _this.input = selectedEl;
            }
            else {
                // The directive is applied to the input.
                _this.button = selectedEl;
                if (_this.element.tagName == 'ION-INPUT') {
                    // Search the inner input.
                    _this.input = _this.element.querySelector('input');
                }
                else if (_this.element.tagName == 'ION-TEXTAREA') {
                    // Search the inner textarea.
                    _this.input = _this.element.querySelector('textarea');
                }
                else {
                    _this.input = _this.element;
                }
                if (!_this.input) {
                    // Input not found, stop.
                    return;
                }
            }
            // Listen for focusout event. This is to be able to check if previous focus was on this element.
            _this.focusOutListener = _this.focusOut.bind(_this);
            _this.input.addEventListener('focusout', _this.focusOutListener);
            // Listen for clicks in the button.
            _this.clickListener = _this.buttonClicked.bind(_this);
            _this.button.addEventListener('click', _this.clickListener);
        });
    };
    /**
     * Component destroyed.
     */
    CoreKeepKeyboardDirective.prototype.ngOnDestroy = function () {
        if (this.button && this.clickListener) {
            this.button.removeEventListener('click', this.clickListener);
        }
        if (this.input && this.focusOutListener) {
            this.input.removeEventListener('focusout', this.focusOutListener);
        }
    };
    /**
     * The button we're interested in was clicked.
     */
    CoreKeepKeyboardDirective.prototype.buttonClicked = function () {
        if (document.activeElement == this.input) {
            // Directive's element is focused at the time the button is clicked. Listen for focusout to focus it again.
            this.focusAgainListener = this.focusElementAgain.bind(this);
            this.input.addEventListener('focusout', this.focusAgainListener);
        }
        else if (document.activeElement == this.button && Date.now() - this.lastFocusOut < 200) {
            // Last focused element was the directive's element, focus it again.
            setTimeout(this.focusElementAgain.bind(this), 0);
        }
    };
    /**
     * If keyboard is open, focus the input again and stop listening focusout to focus again if needed.
     */
    CoreKeepKeyboardDirective.prototype.focusElementAgain = function () {
        var _this = this;
        this.domUtils.focusElement(this.input);
        if (this.focusAgainListener) {
            // Sometimes we can receive more than 1 focus out event.
            // If we spend 1 second without receiving any, stop listening for them.
            var listener_1 = this.focusAgainListener; // Store it in a local variable, in case it changes.
            clearTimeout(this.stopFocusAgainTimeout);
            this.stopFocusAgainTimeout = setTimeout(function () {
                _this.input.removeEventListener('focusout', listener_1);
                if (listener_1 == _this.focusAgainListener) {
                    delete _this.focusAgainListener;
                }
            }, 1000);
        }
    };
    /**
     * Input was focused out, save the time it was done.
     */
    CoreKeepKeyboardDirective.prototype.focusOut = function () {
        this.lastFocusOut = Date.now();
    };
    keep_keyboard___decorate([
        Object(core["D" /* Input */])('core-keep-keyboard'),
        keep_keyboard___metadata("design:type", String)
    ], CoreKeepKeyboardDirective.prototype, "selector", void 0);
    keep_keyboard___decorate([
        Object(core["D" /* Input */])(),
        keep_keyboard___metadata("design:type", Object)
    ], CoreKeepKeyboardDirective.prototype, "inButton", void 0);
    CoreKeepKeyboardDirective = keep_keyboard___decorate([
        Object(core["s" /* Directive */])({
            selector: '[core-keep-keyboard]'
        }),
        keep_keyboard___metadata("design:paramtypes", [core["t" /* ElementRef */], dom["a" /* CoreDomUtilsProvider */], utils["a" /* CoreUtilsProvider */]])
    ], CoreKeepKeyboardDirective);
    return CoreKeepKeyboardDirective;
}());

//# sourceMappingURL=keep-keyboard.js.map
// EXTERNAL MODULE: ./src/directives/user-link.ts
var user_link = __webpack_require__(697);

// EXTERNAL MODULE: ./src/directives/auto-rows.ts
var auto_rows = __webpack_require__(364);

// EXTERNAL MODULE: ./src/directives/long-press.ts
var long_press = __webpack_require__(1479);

// EXTERNAL MODULE: ./src/directives/back-button.ts
var back_button = __webpack_require__(687);

// EXTERNAL MODULE: ./src/directives/supress-events.ts
var supress_events = __webpack_require__(368);

// CONCATENATED MODULE: ./src/directives/directives.module.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return directives_module_CoreDirectivesModule; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var directives_module___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};













var directives_module_CoreDirectivesModule = /** @class */ (function () {
    function CoreDirectivesModule() {
    }
    CoreDirectivesModule = directives_module___decorate([
        Object(core["I" /* NgModule */])({
            declarations: [
                auto_focus["a" /* CoreAutoFocusDirective */],
                download_file_CoreDownloadFileDirective,
                external_content["a" /* CoreExternalContentDirective */],
                fab["a" /* CoreFabDirective */],
                format_text["a" /* CoreFormatTextDirective */],
                keep_keyboard_CoreKeepKeyboardDirective,
                directives_link["a" /* CoreLinkDirective */],
                user_link["a" /* CoreUserLinkDirective */],
                auto_rows["a" /* CoreAutoRowsDirective */],
                long_press["a" /* CoreLongPressDirective */],
                back_button["a" /* CoreBackButtonDirective */],
                supress_events["a" /* CoreSupressEventsDirective */]
            ],
            imports: [],
            exports: [
                auto_focus["a" /* CoreAutoFocusDirective */],
                download_file_CoreDownloadFileDirective,
                external_content["a" /* CoreExternalContentDirective */],
                fab["a" /* CoreFabDirective */],
                format_text["a" /* CoreFormatTextDirective */],
                keep_keyboard_CoreKeepKeyboardDirective,
                directives_link["a" /* CoreLinkDirective */],
                user_link["a" /* CoreUserLinkDirective */],
                auto_rows["a" /* CoreAutoRowsDirective */],
                long_press["a" /* CoreLongPressDirective */],
                back_button["a" /* CoreBackButtonDirective */],
                supress_events["a" /* CoreSupressEventsDirective */]
            ]
        })
    ], CoreDirectivesModule);
    return CoreDirectivesModule;
}());

//# sourceMappingURL=directives.module.js.map

/***/ }),
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSplitViewComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_fileuploader_providers_fileuploader__ = __webpack_require__(67);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
// Code based on https://github.com/martinpritchardelevate/ionic-split-pane-demo




/**
 * Directive to create a split view layout.
 *
 * @description
 * To init/change the right pane contents (content pane), inject this component in the master page.
 * @ViewChild(CoreSplitViewComponent) splitviewCtrl: CoreSplitViewComponent;
 * Then use the push function to load.
 *
 * Accepts the following params:
 *
 * @param {string|boolean} [when] When the split-pane should be shown. Can be a CSS media query expression, or a shortcut
 * expression. Can also be a boolean expression. Check split-pane component documentation for more information.
 *
 * Example:
 *
 * <core-split-view [when]="lg">
 *     <ion-content><!-- CONTENT TO SHOW ON THE LEFT PANEL (MENU) --></ion-content>
 * </core-split-view>
 */
var CoreSplitViewComponent = /** @class */ (function () {
    function CoreSplitViewComponent(masterNav, element, fileUploaderProvider, platform, translate) {
        var _this = this;
        this.masterNav = masterNav;
        this.when = 'md';
        this.masterPageName = '';
        this.masterPageIndex = 0;
        this.loadDetailPage = false;
        this.masterCanLeaveOverridden = false;
        this.ignoreSplitChanged = false;
        // Empty placeholder for the 'detail' page.
        this.detailPage = null;
        this.element = element.nativeElement;
        this.audioCaptureSubscription = fileUploaderProvider.onAudioCapture.subscribe(function (starting) {
            _this.ignoreSplitChanged = starting;
        });
        // Change the side when the language changes.
        this.languageChangedSubscription = translate.onLangChange.subscribe(function (event) {
            setTimeout(function () {
                _this.side = platform.isRTL ? 'right' : 'left';
                _this.menu.setElementAttribute('side', _this.side);
            });
        });
    }
    /**
     * Component being initialized.
     */
    CoreSplitViewComponent.prototype.ngOnInit = function () {
        // Get the master page name and set an empty page as a placeholder.
        this.masterPageName = this.masterNav.getActive().component.name;
        this.masterPageIndex = this.masterNav.indexOf(this.masterNav.getActive());
        this.emptyDetails();
        this.handleCanLeave();
    };
    /**
     * Get the details NavController. If split view is not enabled, it will return the master nav.
     *
     * @return {NavController} Details NavController.
     */
    CoreSplitViewComponent.prototype.getDetailsNav = function () {
        if (this.isEnabled) {
            return this.detailNav;
        }
        else {
            return this.masterNav;
        }
    };
    /**
     * Get the master NavController.
     *
     * @return {NavController} Master NavController.
     */
    CoreSplitViewComponent.prototype.getMasterNav = function () {
        return this.masterNav;
    };
    /**
     * Handle ionViewCanLeave functions in details page. By default, this function isn't captured by Ionic when
     * clicking the back button, it only uses the one in the master page.
     */
    CoreSplitViewComponent.prototype.handleCanLeave = function () {
        var _this = this;
        // Listen for the didEnter event on the details nav to detect everytime a page is loaded.
        this.detailsDidEnterSubscription = this.detailNav.viewDidEnter.subscribe(function (detailsViewController) {
            if (!_this.isOn()) {
                return;
            }
            var masterViewController = _this.masterNav.getActive();
            if (_this.masterCanLeaveOverridden) {
                // We've overridden the can leave of the master page for a previous details page. Restore it.
                masterViewController.instance.ionViewCanLeave = _this.originalMasterCanLeave;
                _this.originalMasterCanLeave = undefined;
                _this.masterCanLeaveOverridden = false;
            }
            if (detailsViewController && detailsViewController.instance && detailsViewController.instance.ionViewCanLeave) {
                // The details page defines a canLeave function. Check if the master page also defines one.
                if (masterViewController.instance.ionViewCanLeave) {
                    // Master page also defines a canLeave function, store it because it will be overridden.
                    _this.originalMasterCanLeave = masterViewController.instance.ionViewCanLeave;
                }
                // Override the master canLeave function so it also calls the details canLeave.
                _this.masterCanLeaveOverridden = true;
                masterViewController.instance.ionViewCanLeave = function () {
                    // Always return a Promise.
                    return Promise.resolve().then(function () {
                        if (_this.originalMasterCanLeave) {
                            // First call the master canLeave.
                            var result = _this.originalMasterCanLeave.apply(masterViewController.instance);
                            if (typeof result == 'boolean' && !result) {
                                // User cannot leave, return a rejected promise so the details canLeave isn't executed.
                                return Promise.reject(null);
                            }
                            else {
                                return result;
                            }
                        }
                    }).then(function () {
                        // User can leave the master page. Check if he can also leave the details page.
                        return detailsViewController.instance.ionViewCanLeave();
                    });
                };
            }
        });
    };
    /**
     * Check if both panels are shown. It depends on screen width.
     *
     * @return {boolean} If split view is enabled.
     */
    CoreSplitViewComponent.prototype.isOn = function () {
        return !!this.isEnabled;
    };
    /**
     * Push a page to the navigation stack. It will decide where to load it depending on the size of the screen.
     *
     * @param {any} page   The component class or deeplink name you want to push onto the navigation stack.
     * @param {any} params Any NavParams you want to pass along to the next view.
     * @param {boolean} [retrying] Whether it's retrying.
     */
    CoreSplitViewComponent.prototype.push = function (page, params, retrying) {
        var _this = this;
        if (typeof this.isEnabled == 'undefined' && !retrying) {
            // Hasn't calculated if it's enabled yet. Wait a bit and try again.
            setTimeout(function () {
                _this.push(page, params, true);
            }, 200);
        }
        else {
            if (this.isEnabled) {
                this.detailNav.setRoot(page, params);
            }
            else {
                this.loadDetailPage = {
                    component: page,
                    data: params
                };
                this.masterNav.push(page, params);
            }
        }
    };
    /**
     * Set the details panel to default info.
     */
    CoreSplitViewComponent.prototype.emptyDetails = function () {
        this.loadDetailPage = false;
        this.detailNav.setRoot('CoreSplitViewPlaceholderPage');
    };
    /**
     * Splitpanel visibility has changed.
     *
     * @param {Boolean} isOn If it fits both panels at the same time.
     */
    CoreSplitViewComponent.prototype.onSplitPaneChanged = function (isOn) {
        if (this.ignoreSplitChanged) {
            return;
        }
        this.isEnabled = isOn;
        if (this.masterNav && this.detailNav) {
            (isOn) ? this.activateSplitView() : this.deactivateSplitView();
        }
    };
    /**
     * Enable the split view, show both panels and do some magical navigation.
     */
    CoreSplitViewComponent.prototype.activateSplitView = function () {
        var currentView = this.masterNav.getActive(), currentPageName = currentView.component.name;
        if (this.masterNav.getPrevious() && this.masterNav.getPrevious().component.name == this.masterPageName) {
            if (currentPageName != this.masterPageName) {
                // CurrentView is a 'Detail' page remove it from the 'master' nav stack.
                this.masterNav.pop();
                // And add it to the 'detail' nav stack.
                this.detailNav.setRoot(currentView.component, currentView.data);
            }
            else if (this.loadDetailPage) {
                // MasterPage is shown, load the last detail page if found.
                this.detailNav.setRoot(this.loadDetailPage.component, this.loadDetailPage.data);
            }
            this.loadDetailPage = false;
        }
    };
    /**
     * Disabled the split view, show only one panel and do some magical navigation.
     */
    CoreSplitViewComponent.prototype.deactivateSplitView = function () {
        var detailView = this.detailNav.getActive(), currentPageName = detailView.component.name;
        if (currentPageName != 'CoreSplitViewPlaceholderPage') {
            // Current detail view is a 'Detail' page so, not the placeholder page, push it on 'master' nav stack.
            this.masterNav.insert(this.masterPageIndex + 1, detailView.component, detailView.data);
        }
    };
    /**
     * Component being destroyed.
     */
    CoreSplitViewComponent.prototype.ngOnDestroy = function () {
        this.detailsDidEnterSubscription && this.detailsDidEnterSubscription.unsubscribe();
        this.audioCaptureSubscription.unsubscribe();
        this.languageChangedSubscription.unsubscribe();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('detailNav'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["r" /* Nav */])
    ], CoreSplitViewComponent.prototype, "detailNav", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('menu'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["o" /* Menu */])
    ], CoreSplitViewComponent.prototype, "menu", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSplitViewComponent.prototype, "when", void 0);
    CoreSplitViewComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-split-view',
            templateUrl: 'core-split-view.html'
        }),
        __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__core_fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreSplitViewComponent);
    return CoreSplitViewComponent;
}());

//# sourceMappingURL=split-view.js.map

/***/ }),
/* 35 */,
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_file_helper__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__options_delegate__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_sitehome_providers_sitehome__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_courses_providers_courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__course_offline__ = __webpack_require__(335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__module_delegate__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__module_prefetch_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__core_login_providers_helper__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_moment__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






















/**
 * Helper to gather some common course functions.
 */
var CoreCourseHelperProvider = /** @class */ (function () {
    function CoreCourseHelperProvider(courseProvider, domUtils, moduleDelegate, prefetchDelegate, filepoolProvider, sitesProvider, textUtils, timeUtils, utils, translate, loginHelper, courseOptionsDelegate, siteHomeProvider, eventsProvider, fileHelper, appProvider, fileProvider, injector, coursesProvider, courseOffline) {
        this.courseProvider = courseProvider;
        this.domUtils = domUtils;
        this.moduleDelegate = moduleDelegate;
        this.prefetchDelegate = prefetchDelegate;
        this.filepoolProvider = filepoolProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.timeUtils = timeUtils;
        this.utils = utils;
        this.translate = translate;
        this.loginHelper = loginHelper;
        this.courseOptionsDelegate = courseOptionsDelegate;
        this.siteHomeProvider = siteHomeProvider;
        this.eventsProvider = eventsProvider;
        this.fileHelper = fileHelper;
        this.appProvider = appProvider;
        this.fileProvider = fileProvider;
        this.injector = injector;
        this.coursesProvider = coursesProvider;
        this.courseOffline = courseOffline;
        this.courseDwnPromises = {};
    }
    /**
     * This function treats every module on the sections provided to load the handler data, treat completion
     * and navigate to a module page if required. It also returns if sections has content.
     *
     * @param {any[]} sections List of sections to treat modules.
     * @param {number} courseId Course ID of the modules.
     * @param {any[]} [completionStatus] List of completion status.
     * @param {string} [courseName] Course name. Recommended if completionStatus is supplied.
     * @return {boolean} Whether the sections have content.
     */
    CoreCourseHelperProvider.prototype.addHandlerDataForModules = function (sections, courseId, completionStatus, courseName) {
        var _this = this;
        var hasContent = false;
        sections.forEach(function (section) {
            if (!section || !_this.sectionHasContent(section) || !section.modules) {
                return;
            }
            hasContent = true;
            section.modules.forEach(function (module) {
                module.handlerData = _this.moduleDelegate.getModuleDataFor(module.modname, module, courseId, section.id);
                if (module.completiondata && module.completion > 0) {
                    module.completiondata.courseId = courseId;
                    module.completiondata.courseName = courseName;
                    module.completiondata.tracking = module.completion;
                    module.completiondata.cmid = module.id;
                    // Use of completionstatus is deprecated, use completiondata instead.
                    module.completionstatus = module.completiondata;
                }
                else if (completionStatus && typeof completionStatus[module.id] != 'undefined') {
                    // Should not happen on > 3.6. Check if activity has completions and if it's marked.
                    module.completiondata = completionStatus[module.id];
                    module.completiondata.courseId = courseId;
                    module.completiondata.courseName = courseName;
                    // Use of completionstatus is deprecated, use completiondata instead.
                    module.completionstatus = module.completiondata;
                }
                // Check if the module is stealth.
                module.isStealth = module.visibleoncoursepage === 0 || (module.visible && !section.visible);
            });
        });
        return hasContent;
    };
    /**
     * Calculate the status of a section.
     *
     * @param {any} section Section to calculate its status. It can't be "All sections".
     * @param {number} courseId Course ID the section belongs to.
     * @param {boolean} [refresh] True if it shouldn't use module status cache (slower).
     * @return {Promise<any>} Promise resolved when the status is calculated.
     */
    CoreCourseHelperProvider.prototype.calculateSectionStatus = function (section, courseId, refresh) {
        var _this = this;
        if (section.id == __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            return Promise.reject(null);
        }
        // Get the status of this section.
        return this.prefetchDelegate.getModulesStatus(section.modules, courseId, section.id, refresh, true).then(function (result) {
            // Check if it's being downloaded.
            var downloadId = _this.getSectionDownloadId(section);
            if (_this.prefetchDelegate.isBeingDownloaded(downloadId)) {
                result.status = __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            }
            section.downloadStatus = result.status;
            section.canCheckUpdates = _this.prefetchDelegate.canCheckUpdates();
            // Set this section data.
            if (result.status !== __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING || !_this.prefetchDelegate.isBeingDownloaded(section.id)) {
                section.isDownloading = false;
                section.total = 0;
            }
            else {
                // Section is being downloaded.
                section.isDownloading = true;
                _this.prefetchDelegate.setOnProgress(downloadId, function (data) {
                    section.count = data.count;
                    section.total = data.total;
                });
            }
            return result;
        });
    };
    /**
     * Calculate the status of a list of sections, setting attributes to determine the icons/data to be shown.
     *
     * @param {any[]} sections Sections to calculate their status.
     * @param {number} courseId Course ID the sections belong to.
     * @param {boolean} [refresh] True if it shouldn't use module status cache (slower).
     * @return {Promise<void>} Promise resolved when the states are calculated.
     */
    CoreCourseHelperProvider.prototype.calculateSectionsStatus = function (sections, courseId, refresh) {
        var _this = this;
        var promises = [];
        var allSectionsSection, allSectionsStatus;
        sections.forEach(function (section) {
            if (section.id === __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                // "All sections" section status is calculated using the status of the rest of sections.
                allSectionsSection = section;
                section.isCalculating = true;
            }
            else {
                section.isCalculating = true;
                promises.push(_this.calculateSectionStatus(section, courseId, refresh).then(function (result) {
                    // Calculate "All sections" status.
                    allSectionsStatus = _this.filepoolProvider.determinePackagesStatus(allSectionsStatus, result.status);
                }).finally(function () {
                    section.isCalculating = false;
                }));
            }
        });
        return Promise.all(promises).then(function () {
            if (allSectionsSection) {
                // Set "All sections" data.
                allSectionsSection.downloadStatus = allSectionsStatus;
                allSectionsSection.canCheckUpdates = _this.prefetchDelegate.canCheckUpdates();
                allSectionsSection.isDownloading = allSectionsStatus === __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            }
        }).finally(function () {
            if (allSectionsSection) {
                allSectionsSection.isCalculating = false;
            }
        });
    };
    /**
     * Show a confirm and prefetch a course. It will retrieve the sections and the course options if not provided.
     * This function will set the icon to "spinner" when starting and it will also set it back to the initial icon if the
     * user cancels. All the other updates of the icon should be made when CoreEventsProvider.COURSE_STATUS_CHANGED is received.
     *
     * @param {any} data An object where to store the course icon and title: "prefetchCourseIcon", "title" and "downloadSucceeded".
     * @param {any} course Course to prefetch.
     * @param {any[]} [sections] List of course sections.
     * @param {CoreCourseOptionsHandlerToDisplay[]} courseHandlers List of course handlers.
     * @param {CoreCourseOptionsMenuHandlerToDisplay[]} menuHandlers List of course menu handlers.
     * @return {Promise<boolean>} Promise resolved when the download finishes, rejected if an error occurs or the user cancels.
     */
    CoreCourseHelperProvider.prototype.confirmAndPrefetchCourse = function (data, course, sections, courseHandlers, menuHandlers) {
        var _this = this;
        var initialIcon = data.prefetchCourseIcon, initialTitle = data.title, siteId = this.sitesProvider.getCurrentSiteId();
        var promise;
        data.downloadSucceeded = false;
        data.prefetchCourseIcon = 'spinner';
        data.title = 'core.downloading';
        // Get the sections first if needed.
        if (sections) {
            promise = Promise.resolve(sections);
        }
        else {
            promise = this.courseProvider.getSections(course.id, false, true);
        }
        return promise.then(function (sections) {
            // Confirm the download.
            return _this.confirmDownloadSizeSection(course.id, undefined, sections, true).then(function () {
                // User confirmed, get the course handlers if needed.
                var subPromises = [];
                if (!courseHandlers) {
                    subPromises.push(_this.courseOptionsDelegate.getHandlersToDisplay(_this.injector, course)
                        .then(function (cHandlers) {
                        courseHandlers = cHandlers;
                    }));
                }
                if (!menuHandlers) {
                    subPromises.push(_this.courseOptionsDelegate.getMenuHandlersToDisplay(_this.injector, course)
                        .then(function (mHandlers) {
                        menuHandlers = mHandlers;
                    }));
                }
                return Promise.all(subPromises).then(function () {
                    // Now we have all the data, download the course.
                    return _this.prefetchCourse(course, sections, courseHandlers, menuHandlers, siteId);
                }).then(function () {
                    // Download successful.
                    data.downloadSucceeded = true;
                    return true;
                });
            }, function (error) {
                // User cancelled or there was an error calculating the size.
                data.prefetchCourseIcon = initialIcon;
                data.title = initialTitle;
                return Promise.reject(error);
            });
        });
    };
    /**
     * Confirm and prefetches a list of courses.
     *
     * @param {any[]} courses List of courses to download.
     * @param {Function} [onProgress] Function to call everytime a course is downloaded.
     * @return {Promise<boolean>} Resolved when downloaded, rejected if error or canceled.
     */
    CoreCourseHelperProvider.prototype.confirmAndPrefetchCourses = function (courses, onProgress) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId();
        // Confirm the download without checking size because it could take a while.
        return this.domUtils.showConfirm(this.translate.instant('core.areyousure')).then(function () {
            var promises = [], total = courses.length;
            var count = 0;
            courses.forEach(function (course) {
                var subPromises = [];
                var sections, handlers, menuHandlers, success = true;
                // Get the sections and the handlers.
                subPromises.push(_this.courseProvider.getSections(course.id, false, true).then(function (courseSections) {
                    sections = courseSections;
                }));
                subPromises.push(_this.courseOptionsDelegate.getHandlersToDisplay(_this.injector, course).then(function (cHandlers) {
                    handlers = cHandlers;
                }));
                subPromises.push(_this.courseOptionsDelegate.getMenuHandlersToDisplay(_this.injector, course).then(function (mHandlers) {
                    menuHandlers = mHandlers;
                }));
                promises.push(Promise.all(subPromises).then(function () {
                    return _this.prefetchCourse(course, sections, handlers, menuHandlers, siteId);
                }).catch(function (error) {
                    success = false;
                    return Promise.reject(error);
                }).finally(function () {
                    // Course downloaded or failed, notify the progress.
                    count++;
                    if (onProgress) {
                        onProgress({ count: count, total: total, courseId: course.id, success: success });
                    }
                }));
            });
            if (onProgress) {
                // Notify the start of the download.
                onProgress({ count: 0, total: total, success: true });
            }
            return _this.utils.allPromises(promises);
        });
    };
    /**
     * Show confirmation dialog and then remove a module files.
     *
     * @param {any} module Module to remove the files.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.confirmAndRemoveFiles = function (module, courseId) {
        var _this = this;
        return this.domUtils.showConfirm(this.translate.instant('core.course.confirmdeletemodulefiles')).then(function () {
            return _this.prefetchDelegate.removeModuleFiles(module, courseId);
        }).catch(function (error) {
            if (error) {
                _this.domUtils.showErrorModal(error);
            }
        });
    };
    /**
     * Calculate the size to download a section and show a confirm modal if needed.
     *
     * @param {number} courseId Course ID the section belongs to.
     * @param {any} [section] Section. If not provided, all sections.
     * @param {any[]} [sections] List of sections. Used when downloading all the sections.
     * @param {boolean} [alwaysConfirm] True to show a confirm even if the size isn't high, false otherwise.
     * @return {Promise<any>} Promise resolved if the user confirms or there's no need to confirm.
     */
    CoreCourseHelperProvider.prototype.confirmDownloadSizeSection = function (courseId, section, sections, alwaysConfirm) {
        var _this = this;
        var sizePromise, haveEmbeddedFiles = false;
        // Calculate the size of the download.
        if (section && section.id != __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            sizePromise = this.prefetchDelegate.getDownloadSize(section.modules, courseId);
            // Check if the section has embedded files in the description.
            haveEmbeddedFiles = this.domUtils.extractDownloadableFilesFromHtml(section.summary).length > 0;
        }
        else {
            var promises_1 = [], results_1 = {
                size: 0,
                total: true
            };
            sections.forEach(function (s) {
                if (s.id != __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                    promises_1.push(_this.prefetchDelegate.getDownloadSize(s.modules, courseId).then(function (sectionSize) {
                        results_1.total = results_1.total && sectionSize.total;
                        results_1.size += sectionSize.size;
                    }));
                    // Check if the section has embedded files in the description.
                    if (!haveEmbeddedFiles && _this.domUtils.extractDownloadableFilesFromHtml(s.summary).length > 0) {
                        haveEmbeddedFiles = true;
                    }
                }
            });
            sizePromise = Promise.all(promises_1).then(function () {
                return results_1;
            });
        }
        return sizePromise.then(function (size) {
            if (haveEmbeddedFiles) {
                size.total = false;
            }
            // Show confirm modal if needed.
            return _this.domUtils.confirmDownloadSize(size, undefined, undefined, undefined, undefined, alwaysConfirm);
        });
    };
    /**
     * Helper function to prefetch a module, showing a confirmation modal if the size is big.
     * This function is meant to be called from a context menu option. It will also modify some data like the prefetch icon.
     *
     * @param {any} instance The component instance that has the context menu. It should have prefetchStatusIcon and isDestroyed.
     * @param {any} module Module to be prefetched
     * @param {number} courseId Course ID the module belongs to.
     * @param {Function} [done] Function to call when done. It will close the context menu.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.contextMenuPrefetch = function (instance, module, courseId, done) {
        var _this = this;
        var initialIcon = instance.prefetchStatusIcon;
        instance.prefetchStatusIcon = 'spinner'; // Show spinner since this operation might take a while.
        // We need to call getDownloadSize, the package might have been updated.
        return this.prefetchDelegate.getModuleDownloadSize(module, courseId, true).then(function (size) {
            return _this.domUtils.confirmDownloadSize(size).then(function () {
                return _this.prefetchDelegate.prefetchModule(module, courseId, true);
            });
        }).then(function () {
            // Success, close menu.
            done && done();
        }).catch(function (error) {
            instance.prefetchStatusIcon = initialIcon;
            if (!instance.isDestroyed) {
                _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
            }
        });
    };
    /**
     * Determine the status of a list of courses.
     *
     * @param {any[]} courses Courses
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreCourseHelperProvider.prototype.determineCoursesStatus = function (courses) {
        var _this = this;
        // Get the status of each course.
        var promises = [], siteId = this.sitesProvider.getCurrentSiteId();
        courses.forEach(function (course) {
            promises.push(_this.courseProvider.getCourseStatus(course.id, siteId));
        });
        return Promise.all(promises).then(function (statuses) {
            // Now determine the status of the whole list.
            var status = statuses[0];
            for (var i = 1; i < statuses.length; i++) {
                status = _this.filepoolProvider.determinePackagesStatus(status, statuses[i]);
            }
            return status;
        });
    };
    /**
     * Convenience function to open a module main file, downloading the package if needed.
     * This is meant for modules like mod_resource.
     *
     * @param {any} module The module to download.
     * @param {number} courseId The course ID of the module.
     * @param {string} [component] The component to link the files to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {any[]} [files] List of files of the module. If not provided, use module.contents.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<any>} Resolved on success.
     */
    CoreCourseHelperProvider.prototype.downloadModuleAndOpenFile = function (module, courseId, component, componentId, files, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promise;
        if (files) {
            promise = Promise.resolve(files);
        }
        else {
            promise = this.courseProvider.loadModuleContents(module, courseId).then(function () {
                files = module.contents;
            });
        }
        // Make sure that module contents are loaded.
        return promise.then(function () {
            if (!files || !files.length) {
                return Promise.reject(_this.utils.createFakeWSError('core.filenotfound', true));
            }
            return _this.sitesProvider.getSite(siteId);
        }).then(function (site) {
            var mainFile = files[0], fileUrl = _this.fileHelper.getFileUrl(mainFile);
            // Check if the file should be opened in browser.
            if (_this.fileHelper.shouldOpenInBrowser(mainFile)) {
                if (_this.appProvider.isOnline()) {
                    // Open in browser.
                    var fixedUrl = site.fixPluginfileURL(fileUrl).replace('&offline=1', '');
                    // Remove forcedownload when followed by another param.
                    fixedUrl = fixedUrl.replace(/forcedownload=\d+&/, '');
                    // Remove forcedownload when not followed by any param.
                    fixedUrl = fixedUrl.replace(/[\?|\&]forcedownload=\d+/, '');
                    _this.utils.openInBrowser(fixedUrl);
                    if (_this.fileProvider.isAvailable()) {
                        // Download the file if needed (file outdated or not downloaded).
                        // Download will be in background, don't return the promise.
                        _this.downloadModule(module, courseId, component, componentId, files, siteId);
                    }
                    return;
                }
                else {
                    // Not online, get the offline file. It will fail if not found.
                    return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl).then(function (path) {
                        return _this.utils.openFile(path);
                    }).catch(function (error) {
                        return Promise.reject(_this.translate.instant('core.networkerrormsg'));
                    });
                }
            }
            // File shouldn't be opened in browser. Download the module if it needs to be downloaded.
            return _this.downloadModuleWithMainFileIfNeeded(module, courseId, component, componentId, files, siteId)
                .then(function (result) {
                if (result.path.indexOf('http') === 0) {
                    /* In iOS, if we use the same URL in embedded browser and background download then the download only
                       downloads a few bytes (cached ones). Add a hash to the URL so both URLs are different. */
                    result.path = result.path + '#moodlemobile-embedded';
                    return _this.utils.openOnlineFile(result.path).catch(function (error) {
                        // Error opening the file, some apps don't allow opening online files.
                        if (!_this.fileProvider.isAvailable()) {
                            return Promise.reject(error);
                        }
                        else if (result.status === __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                            return Promise.reject(_this.translate.instant('core.erroropenfiledownloading'));
                        }
                        var promise;
                        if (result.status === __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
                            // Not downloaded, download it now and return the local file.
                            promise = _this.downloadModule(module, courseId, component, componentId, files, siteId).then(function () {
                                return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                            });
                        }
                        else {
                            // File is outdated or stale and can't be opened in online, return the local URL.
                            promise = _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                        }
                        return promise.then(function (path) {
                            return _this.utils.openFile(path);
                        });
                    });
                }
                else {
                    return _this.utils.openFile(result.path);
                }
            });
        });
    };
    /**
     * Convenience function to download a module that has a main file and return the local file's path and other info.
     * This is meant for modules like mod_resource.
     *
     * @param {any} module The module to download.
     * @param {number} courseId The course ID of the module.
     * @param {string} [component] The component to link the files to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {any[]} [files] List of files of the module. If not provided, use module.contents.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<{fixedUrl: string, path: string, status: string}>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.downloadModuleWithMainFileIfNeeded = function (module, courseId, component, componentId, files, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!files || !files.length) {
            // Module not valid, stop.
            return Promise.reject(null);
        }
        var mainFile = files[0], fileUrl = this.fileHelper.getFileUrl(mainFile), timemodified = this.fileHelper.getFileTimemodified(mainFile), result = {
            fixedUrl: undefined,
            path: undefined,
            status: undefined
        };
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var fixedUrl = site.fixPluginfileURL(fileUrl);
            result.fixedUrl = fixedUrl;
            if (_this.fileProvider.isAvailable()) {
                // The file system is available.
                return _this.filepoolProvider.getPackageStatus(siteId, component, componentId).then(function (status) {
                    result.status = status;
                    var isWifi = _this.appProvider.isWifi(), isOnline = _this.appProvider.isOnline();
                    if (status === __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADED) {
                        // Get the local file URL.
                        return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl).catch(function (error) {
                            // File not found, mark the module as not downloaded and reject.
                            return _this.filepoolProvider.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED, component, componentId).then(function () {
                                return Promise.reject(error);
                            });
                        });
                    }
                    else if (status === __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING && !_this.appProvider.isDesktop()) {
                        // Return the online URL.
                        return fixedUrl;
                    }
                    else {
                        if (!isOnline && status === __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
                            // Not downloaded and we're offline, reject.
                            return Promise.reject(_this.translate.instant('core.networkerrormsg'));
                        }
                        return _this.filepoolProvider.shouldDownloadBeforeOpen(fixedUrl, mainFile.filesize).then(function () {
                            // Download and then return the local URL.
                            return _this.downloadModule(module, courseId, component, componentId, files, siteId).then(function () {
                                return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                            });
                        }, function () {
                            // Start the download if in wifi, but return the URL right away so the file is opened.
                            if (isWifi) {
                                _this.downloadModule(module, courseId, component, componentId, files, siteId);
                            }
                            if (!_this.fileHelper.isStateDownloaded(status) || isOnline) {
                                // Not downloaded or online, return the online URL.
                                return fixedUrl;
                            }
                            else {
                                // Outdated but offline, so we return the local URL. Use getUrlByUrl so it's added to the queue.
                                return _this.filepoolProvider.getUrlByUrl(siteId, fileUrl, component, componentId, timemodified, false, false, mainFile);
                            }
                        });
                    }
                }).then(function (path) {
                    result.path = path;
                    return result;
                });
            }
            else {
                // We use the live URL.
                result.path = fixedUrl;
                return result;
            }
        });
    };
    /**
     * Convenience function to download a module.
     *
     * @param {any} module The module to download.
     * @param {number} courseId The course ID of the module.
     * @param {string} [component] The component to link the files to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {any[]} [files] List of files of the module. If not provided, use module.contents.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.downloadModule = function (module, courseId, component, componentId, files, siteId) {
        var prefetchHandler = this.prefetchDelegate.getPrefetchHandlerFor(module);
        if (prefetchHandler) {
            // Use the prefetch handler to download the module.
            if (prefetchHandler.download) {
                return prefetchHandler.download(module, courseId);
            }
            else {
                return prefetchHandler.prefetch(module, courseId, true);
            }
        }
        // There's no prefetch handler for the module, just download the files.
        files = files || module.contents;
        return this.filepoolProvider.downloadOrPrefetchFiles(siteId, files, false, false, component, componentId);
    };
    /**
     * Fill the Context Menu for a certain module.
     *
     * @param {any} instance The component instance that has the context menu.
     * @param {any} module Module to be prefetched
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [invalidateCache] Invalidates the cache first.
     * @param {string} [component] Component of the module.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.fillContextMenu = function (instance, module, courseId, invalidateCache, component) {
        var _this = this;
        return this.getModulePrefetchInfo(module, courseId, invalidateCache, component).then(function (moduleInfo) {
            instance.size = moduleInfo.size > 0 ? moduleInfo.sizeReadable : 0;
            instance.prefetchStatusIcon = moduleInfo.statusIcon;
            instance.prefetchStatus = moduleInfo.status;
            if (moduleInfo.status != __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
                // Module is downloadable, get the text to display to prefetch.
                if (moduleInfo.downloadTime > 0) {
                    instance.prefetchText = _this.translate.instant('core.lastdownloaded') + ': ' + moduleInfo.downloadTimeReadable;
                }
                else {
                    // Module not downloaded, show a default text.
                    instance.prefetchText = _this.translate.instant('core.download');
                }
            }
            if (typeof instance.contextMenuStatusObserver == 'undefined' && component) {
                instance.contextMenuStatusObserver = _this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].PACKAGE_STATUS_CHANGED, function (data) {
                    if (data.componentId == module.id && data.component == component) {
                        _this.fillContextMenu(instance, module, courseId, false, component);
                    }
                }, _this.sitesProvider.getCurrentSiteId());
            }
        });
    };
    /**
     * Get a course. It will first check the user courses, and fallback to another WS if not enrolled.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{enrolled: boolean, course: any}>} Promise resolved with the course.
     */
    CoreCourseHelperProvider.prototype.getCourse = function (courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Try with enrolled courses first.
        return this.coursesProvider.getUserCourse(courseId, false, siteId).then(function (course) {
            return { enrolled: true, course: course };
        }).catch(function () {
            // Not enrolled or an error happened. Try to use another WebService.
            return _this.coursesProvider.isGetCoursesByFieldAvailableInSite(siteId).then(function (available) {
                if (available) {
                    return _this.coursesProvider.getCourseByField('id', courseId, siteId);
                }
                else {
                    return _this.coursesProvider.getCourse(courseId, siteId);
                }
            }).then(function (course) {
                return { enrolled: false, course: course };
            });
        });
    };
    /**
     * Get a course, wait for any course format plugin to load, and open the course page. It basically chains the functions
     * getCourse and openCourse.
     *
     * @param {NavController} navCtrl The nav controller to use. If not defined, the course will be opened in main menu.
     * @param {number} courseId Course ID.
     * @param {any} [params] Other params to pass to the course page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreCourseHelperProvider.prototype.getAndOpenCourse = function (navCtrl, courseId, params, siteId) {
        var _this = this;
        var modal = this.domUtils.showModalLoading();
        return this.getCourse(courseId, siteId).then(function (data) {
            return data.course;
        }).catch(function () {
            // Cannot get course, return a "fake".
            return { id: courseId };
        }).then(function (course) {
            modal.dismiss();
            return _this.openCourse(navCtrl, course, params, siteId);
        });
    };
    /**
     * Check if the course has a block with that name.
     *
     * @param {number} courseId Course ID.
     * @param {string} name     Block name to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if the block exists or false otherwise.
     * @since 3.3
     */
    CoreCourseHelperProvider.prototype.hasABlockNamed = function (courseId, name, siteId) {
        return this.courseProvider.getCourseBlocks(courseId, siteId).then(function (blocks) {
            return blocks.some(function (block) {
                return block.name == name;
            });
        }).catch(function () {
            return false;
        });
    };
    /**
     * Initialize the prefetch icon for selected courses.
     *
     * @param  {any[]}        courses  Courses array to get info from.
     * @param  {any}          prefetch Prefetch information.
     * @param  {number}       [minCourses=2] Min course to show icon.
     * @return {Promise<any>}          Resolved with the prefetch information updated when done.
     */
    CoreCourseHelperProvider.prototype.initPrefetchCoursesIcons = function (courses, prefetch, minCourses) {
        var _this = this;
        if (minCourses === void 0) { minCourses = 2; }
        if (!courses || courses.length < minCourses) {
            // Not enough courses.
            prefetch.icon = '';
            return Promise.resolve(prefetch);
        }
        return this.determineCoursesStatus(courses).then(function (status) {
            var icon = _this.getCourseStatusIconAndTitleFromStatus(status).icon;
            if (icon == 'spinner') {
                // It seems all courses are being downloaded, show a download button instead.
                icon = 'cloud-download';
            }
            prefetch.icon = icon;
            return prefetch;
        });
    };
    /**
     * Load offline completion into a list of sections.
     * This should be used in 3.6 sites or higher, where the course contents already include the completion.
     *
     * @param {number} courseId The course to get the completion.
     * @param {any[]} sections List of sections of the course.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.loadOfflineCompletion = function (courseId, sections, siteId) {
        var _this = this;
        return this.courseOffline.getCourseManualCompletions(courseId, siteId).then(function (offlineCompletions) {
            if (!offlineCompletions || !offlineCompletions.length) {
                // No offline completion.
                return;
            }
            var totalOffline = offlineCompletions.length;
            var loaded = 0;
            offlineCompletions = _this.utils.arrayToObject(offlineCompletions, 'cmid');
            // Load the offline data in the modules.
            for (var i = 0; i < sections.length; i++) {
                var section = sections[i];
                if (!section.modules || !section.modules.length) {
                    // Section has no modules, ignore it.
                    continue;
                }
                for (var j = 0; j < section.modules.length; j++) {
                    var module_1 = section.modules[j], offlineCompletion = offlineCompletions[module_1.id];
                    if (offlineCompletion && typeof module_1.completiondata != 'undefined' &&
                        offlineCompletion.timecompleted >= module_1.completiondata.timecompleted * 1000) {
                        // The module has offline completion. Load it.
                        module_1.completiondata.state = offlineCompletion.completed;
                        module_1.completiondata.offline = true;
                        // If all completions have been loaded, stop.
                        loaded++;
                        if (loaded == totalOffline) {
                            break;
                        }
                    }
                }
            }
        });
    };
    /**
     * Prefetch all the courses in the array.
     *
     * @param  {any[]}        courses  Courses array to prefetch.
     * @param  {any}          prefetch Prefetch information to be updated.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.prefetchCourses = function (courses, prefetch) {
        prefetch.icon = 'spinner';
        prefetch.badge = '';
        return this.confirmAndPrefetchCourses(courses, function (progress) {
            prefetch.badge = progress.count + ' / ' + progress.total;
        }).then(function () {
            prefetch.icon = 'refresh';
        }).finally(function () {
            prefetch.badge = '';
        });
    };
    /**
     * Get a course download promise (if any).
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Download promise, undefined if not found.
     */
    CoreCourseHelperProvider.prototype.getCourseDownloadPromise = function (courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.courseDwnPromises[siteId] && this.courseDwnPromises[siteId][courseId];
    };
    /**
     * Get a course status icon and the langkey to use as a title.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{icon: string, title: string}>} Promise resolved with the icon name and the title key.
     */
    CoreCourseHelperProvider.prototype.getCourseStatusIconAndTitle = function (courseId, siteId) {
        var _this = this;
        return this.courseProvider.getCourseStatus(courseId, siteId).then(function (status) {
            return _this.getCourseStatusIconAndTitleFromStatus(status);
        });
    };
    /**
     * Get a course status icon and the langkey to use as a title from status.
     *
     * @param {string} status Course status.
     * @return {{icon: string, title: string}} Title and icon name.
     */
    CoreCourseHelperProvider.prototype.getCourseStatusIconAndTitleFromStatus = function (status) {
        if (status == __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADED) {
            // Always show refresh icon, we cannot know if there's anything new in course options.
            return {
                icon: 'refresh',
                title: 'core.course.refreshcourse'
            };
        }
        else if (status == __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
            return {
                icon: 'spinner',
                title: 'core.downloading'
            };
        }
        else {
            return {
                icon: 'cloud-download',
                title: 'core.course.downloadcourse'
            };
        }
    };
    /**
     * Get the course ID from a module instance ID, showing an error message if it can't be retrieved.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the module's course ID.
     */
    CoreCourseHelperProvider.prototype.getModuleCourseIdByInstance = function (id, module, siteId) {
        var _this = this;
        return this.courseProvider.getModuleBasicInfoByInstance(id, module, siteId).then(function (cm) {
            return cm.course;
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);
            return Promise.reject(null);
        });
    };
    /**
     * Get prefetch info for a module.
     *
     * @param {any} module Module to get the info from.
     * @param {number} courseId Course ID the section belongs to.
     * @param {boolean} [invalidateCache] Invalidates the cache first.
     * @param {string} [component] Component of the module.
     * @return {Promise<CoreCourseModulePrefetchInfo>} Promise resolved with the info.
     */
    CoreCourseHelperProvider.prototype.getModulePrefetchInfo = function (module, courseId, invalidateCache, component) {
        var _this = this;
        var moduleInfo = {}, siteId = this.sitesProvider.getCurrentSiteId(), promises = [];
        if (invalidateCache) {
            this.prefetchDelegate.invalidateModuleStatusCache(module);
        }
        promises.push(this.prefetchDelegate.getModuleDownloadedSize(module, courseId).then(function (moduleSize) {
            moduleInfo.size = moduleSize;
            moduleInfo.sizeReadable = _this.textUtils.bytesToSize(moduleSize, 2);
        }));
        promises.push(this.prefetchDelegate.getModuleStatus(module, courseId).then(function (moduleStatus) {
            moduleInfo.status = moduleStatus;
            switch (moduleStatus) {
                case __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED:
                    moduleInfo.statusIcon = 'cloud-download';
                    break;
                case __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING:
                    moduleInfo.statusIcon = 'spinner';
                    break;
                case __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].OUTDATED:
                    moduleInfo.statusIcon = 'refresh';
                    break;
                case __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADED:
                    if (!_this.prefetchDelegate.canCheckUpdates()) {
                        moduleInfo.statusIcon = 'refresh';
                        break;
                    }
                default:
                    moduleInfo.statusIcon = '';
                    break;
            }
        }));
        // Get the time it was downloaded (if it was downloaded).
        promises.push(this.filepoolProvider.getPackageData(siteId, component, module.id).then(function (data) {
            if (data && data.downloadTime && (data.status == __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].OUTDATED || data.status == __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADED)) {
                var now = _this.timeUtils.timestamp();
                moduleInfo.downloadTime = data.downloadTime;
                if (now - data.downloadTime < 7 * 86400) {
                    moduleInfo.downloadTimeReadable = __WEBPACK_IMPORTED_MODULE_21_moment__(data.downloadTime * 1000).fromNow();
                }
                else {
                    moduleInfo.downloadTimeReadable = __WEBPACK_IMPORTED_MODULE_21_moment__(data.downloadTime * 1000).calendar();
                }
            }
        }).catch(function () {
            // Not downloaded.
            moduleInfo.downloadTime = 0;
        }));
        return Promise.all(promises).then(function () {
            return moduleInfo;
        });
    };
    /**
     * Get the download ID of a section. It's used to interact with CoreCourseModulePrefetchDelegate.
     *
     * @param {any} section Section.
     * @return {string} Section download ID.
     */
    CoreCourseHelperProvider.prototype.getSectionDownloadId = function (section) {
        return 'Section-' + section.id;
    };
    /**
     * Navigate to a module.
     *
     * @param {number} moduleId Module's ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [courseId] Course ID. If not defined we'll try to retrieve it from the site.
     * @param {number} [sectionId] Section the module belongs to. If not defined we'll try to retrieve it from the site.
     * @param {string} [modName] If set, the app will retrieve all modules of this type with a single WS call. This reduces the
     *                           number of WS calls, but it isn't recommended for modules that can return a lot of contents.
     * @param {any} [modParams] Params to pass to the module
     * @return {Promise<void>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.navigateToModule = function (moduleId, siteId, courseId, sectionId, modName, modParams) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var modal = this.domUtils.showModalLoading();
        var promise, site;
        if (courseId && sectionId) {
            // No need to retrieve more data.
            promise = Promise.resolve();
        }
        else if (!courseId) {
            // We don't have courseId.
            promise = this.courseProvider.getModuleBasicInfo(moduleId, siteId).then(function (module) {
                courseId = module.course;
                sectionId = module.section;
            });
        }
        else {
            // We don't have sectionId but we have courseId.
            promise = this.courseProvider.getModuleSectionId(moduleId, siteId).then(function (id) {
                sectionId = id;
            });
        }
        return promise.then(function () {
            // Make sure they're numbers.
            courseId = Number(courseId);
            sectionId = Number(sectionId);
            // Get the site.
            return _this.sitesProvider.getSite(siteId);
        }).then(function (s) {
            site = s;
            // Get the module.
            return _this.courseProvider.getModule(moduleId, courseId, sectionId, false, false, siteId, modName);
        }).then(function (module) {
            var params = {
                course: { id: courseId },
                module: module,
                sectionId: sectionId,
                modParams: modParams
            };
            module.handlerData = _this.moduleDelegate.getModuleDataFor(module.modname, module, courseId, sectionId);
            if (courseId == site.getSiteHomeId()) {
                // Check if site home is available.
                return _this.siteHomeProvider.isAvailable().then(function () {
                    _this.loginHelper.redirect('CoreSiteHomeIndexPage', params, siteId);
                }).finally(function () {
                    modal.dismiss();
                });
            }
            else {
                modal.dismiss();
                return _this.getAndOpenCourse(undefined, courseId, params, siteId);
            }
        }).catch(function (error) {
            modal.dismiss();
            _this.domUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);
        });
    };
    /**
     * Open a module.
     *
     * @param {NavController} navCtrl The NavController to use.
     * @param {any} module The module to open.
     * @param {number} courseId The course ID of the module.
     * @param {number} [sectionId] The section ID of the module.
     * @param {any} [modParams] Params to pass to the module
     * @param {boolean} True if module can be opened, false otherwise.
     */
    CoreCourseHelperProvider.prototype.openModule = function (navCtrl, module, courseId, sectionId, modParams) {
        if (!module.handlerData) {
            module.handlerData = this.moduleDelegate.getModuleDataFor(module.modname, module, courseId, sectionId);
        }
        if (module.handlerData && module.handlerData.action) {
            module.handlerData.action(new Event('click'), navCtrl, module, courseId, { animate: false }, modParams);
            return true;
        }
        return false;
    };
    /**
     * Prefetch all the activities in a course and also the course addons.
     *
     * @param {any} course The course to prefetch.
     * @param {any[]} sections List of course sections.
     * @param {CoreCourseOptionsHandlerToDisplay[]} courseHandlers List of course options handlers.
     * @param {CoreCourseOptionsMenuHandlerToDisplay[]} courseMenuHandlers List of course menu handlers.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise}                Promise resolved when the download finishes.
     */
    CoreCourseHelperProvider.prototype.prefetchCourse = function (course, sections, courseHandlers, courseMenuHandlers, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.courseDwnPromises[siteId] && this.courseDwnPromises[siteId][course.id]) {
            // There's already a download ongoing for this course, return the promise.
            return this.courseDwnPromises[siteId][course.id];
        }
        else if (!this.courseDwnPromises[siteId]) {
            this.courseDwnPromises[siteId] = {};
        }
        // First of all, mark the course as being downloaded.
        this.courseDwnPromises[siteId][course.id] = this.courseProvider.setCourseStatus(course.id, __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING, siteId).then(function () {
            var promises = [];
            var allSectionsSection = sections[0];
            // Prefetch all the sections. If the first section is "All sections", use it. Otherwise, use a fake "All sections".
            if (sections[0].id != __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                allSectionsSection = { id: __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID };
            }
            promises.push(_this.prefetchSection(allSectionsSection, course.id, sections));
            // Prefetch course options.
            courseHandlers.forEach(function (handler) {
                if (handler.prefetch) {
                    promises.push(handler.prefetch(course));
                }
            });
            courseMenuHandlers.forEach(function (handler) {
                if (handler.prefetch) {
                    promises.push(handler.prefetch(course));
                }
            });
            // Prefetch other data needed to render the course.
            if (_this.coursesProvider.isGetCoursesByFieldAvailable()) {
                promises.push(_this.coursesProvider.getCoursesByField('id', course.id));
            }
            var sectionWithModules = sections.find(function (section) {
                return section.modules && section.modules.length > 0;
            });
            if (!sectionWithModules || typeof sectionWithModules.modules[0].completion == 'undefined') {
                promises.push(_this.courseProvider.getActivitiesCompletionStatus(course.id));
            }
            return _this.utils.allPromises(promises);
        }).then(function () {
            // Download success, mark the course as downloaded.
            return _this.courseProvider.setCourseStatus(course.id, __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADED, siteId);
        }).catch(function (error) {
            // Error, restore previous status.
            return _this.courseProvider.setCoursePreviousStatus(course.id, siteId).then(function () {
                return Promise.reject(error);
            });
        }).finally(function () {
            delete _this.courseDwnPromises[siteId][course.id];
        });
        return this.courseDwnPromises[siteId][course.id];
    };
    /**
     * Helper function to prefetch a module, showing a confirmation modal if the size is big
     * and invalidating contents if refreshing.
     *
     * @param {handler} handler Prefetch handler to use. Must implement 'prefetch' and 'invalidateContent'.
     * @param {any} module Module to download.
     * @param {any} size Object containing size to download (in bytes) and a boolean to indicate if its totally calculated.
     * @param {number} courseId Course ID of the module.
     * @param {boolean} [refresh] True if refreshing, false otherwise.
     * @return {Promise<any>} Promise resolved when downloaded.
     */
    CoreCourseHelperProvider.prototype.prefetchModule = function (handler, module, size, courseId, refresh) {
        var _this = this;
        // Show confirmation if needed.
        return this.domUtils.confirmDownloadSize(size).then(function () {
            // Invalidate content if refreshing and download the data.
            var promise = refresh ? handler.invalidateContent(module.id, courseId) : Promise.resolve();
            return promise.catch(function () {
                // Ignore errors.
            }).then(function () {
                return _this.prefetchDelegate.prefetchModule(module, courseId, true);
            });
        });
    };
    /**
     * Prefetch one section or all the sections.
     * If the section is "All sections" it will prefetch all the sections.
     *
     * @param {any} section Section.
     * @param {number} courseId Course ID the section belongs to.
     * @param {any[]} [sections] List of sections. Used when downloading all the sections.
     * @return {Promise<any>} Promise resolved when the prefetch is finished.
     */
    CoreCourseHelperProvider.prototype.prefetchSection = function (section, courseId, sections) {
        var _this = this;
        if (section.id != __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            // Download only this section.
            return this.prefetchSingleSectionIfNeeded(section, courseId).finally(function () {
                // Calculate the status of the section that finished.
                return _this.calculateSectionStatus(section, courseId);
            });
        }
        else {
            // Download all the sections except "All sections".
            var promises_2 = [];
            var allSectionsStatus_1;
            section.isDownloading = true;
            sections.forEach(function (section) {
                if (section.id != __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                    promises_2.push(_this.prefetchSingleSectionIfNeeded(section, courseId).finally(function () {
                        // Calculate the status of the section that finished.
                        return _this.calculateSectionStatus(section, courseId).then(function (result) {
                            // Calculate "All sections" status.
                            allSectionsStatus_1 = _this.filepoolProvider.determinePackagesStatus(allSectionsStatus_1, result.status);
                        });
                    }));
                }
            });
            return this.utils.allPromises(promises_2).then(function () {
                // Set "All sections" data.
                section.downloadStatus = allSectionsStatus_1;
                section.canCheckUpdates = _this.prefetchDelegate.canCheckUpdates();
                section.isDownloading = allSectionsStatus_1 === __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            }).finally(function () {
                section.isDownloading = false;
            });
        }
    };
    /**
     * Prefetch a certain section if it needs to be prefetched.
     * If the section is "All sections" it will be ignored.
     *
     * @param {any} section Section to prefetch.
     * @param {number} courseId Course ID the section belongs to.
     * @return {Promise<any>} Promise resolved when the section is prefetched.
     */
    CoreCourseHelperProvider.prototype.prefetchSingleSectionIfNeeded = function (section, courseId) {
        var _this = this;
        if (section.id == __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            return Promise.resolve();
        }
        if (section.hiddenbynumsections) {
            // Hidden section.
            return Promise.resolve();
        }
        var promises = [];
        section.isDownloading = true;
        // Sync the modules first.
        promises.push(this.prefetchDelegate.syncModules(section.modules, courseId).then(function () {
            // Validate the section needs to be downloaded and calculate amount of modules that need to be downloaded.
            return _this.prefetchDelegate.getModulesStatus(section.modules, courseId, section.id).then(function (result) {
                if (result.status == __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADED || result.status == __WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
                    // Section is downloaded or not downloadable, nothing to do.
                    return;
                }
                return _this.prefetchSingleSection(section, result, courseId);
            }, function (error) {
                section.isDownloading = false;
                return Promise.reject(error);
            });
        }));
        // Download the files in the section description.
        var introFiles = this.domUtils.extractDownloadableFilesFromHtmlAsFakeFileObjects(section.summary), siteId = this.sitesProvider.getCurrentSiteId();
        promises.push(this.filepoolProvider.addFilesToQueue(siteId, introFiles, __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].COMPONENT, courseId)
            .catch(function () {
            // Ignore errors.
        }));
        return Promise.all(promises);
    };
    /**
     * Start or restore the prefetch of a section.
     * If the section is "All sections" it will be ignored.
     *
     * @param {any} section Section to download.
     * @param {any} result Result of CoreCourseModulePrefetchDelegate.getModulesStatus for this section.
     * @param {number} courseId Course ID the section belongs to.
     * @return {Promise<any>} Promise resolved when the section has been prefetched.
     */
    CoreCourseHelperProvider.prototype.prefetchSingleSection = function (section, result, courseId) {
        if (section.id == __WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            return Promise.resolve();
        }
        if (section.total > 0) {
            // Already being downloaded.
            return Promise.resolve();
        }
        // We only download modules with status notdownloaded, downloading or outdated.
        var modules = result[__WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].OUTDATED].concat(result[__WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED])
            .concat(result[__WEBPACK_IMPORTED_MODULE_20__core_constants__["a" /* CoreConstants */].DOWNLOADING]), downloadId = this.getSectionDownloadId(section);
        section.isDownloading = true;
        // Prefetch all modules to prevent incoeherences in download count and to download stale data not marked as outdated.
        return this.prefetchDelegate.prefetchModules(downloadId, modules, courseId, function (data) {
            section.count = data.count;
            section.total = data.total;
        });
    };
    /**
     * Check if a section has content.
     *
     * @param {any} section Section to check.
     * @return {boolean} Whether the section has content.
     */
    CoreCourseHelperProvider.prototype.sectionHasContent = function (section) {
        if (section.hiddenbynumsections) {
            return false;
        }
        return (typeof section.availabilityinfo != 'undefined' && section.availabilityinfo != '') ||
            section.summary != '' || (section.modules && section.modules.length > 0);
    };
    /**
     * Wait for any course format plugin to load, and open the course page.
     *
     * If the plugin's promise is resolved, the course page will be opened.  If it is rejected, they will see an error.
     * If the promise for the plugin is still in progress when the user tries to open the course, a loader
     * will be displayed until it is complete, before the course page is opened.  If the promise is already complete,
     * they will see the result immediately.
     *
     * @param {NavController} navCtrl The nav controller to use. If not defined, the course will be opened in main menu.
     * @param {any} course Course to open
     * @param {any} [params] Params to pass to the course page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.openCourse = function (navCtrl, course, params, siteId) {
        if (!siteId || siteId == this.sitesProvider.getCurrentSiteId()) {
            // Current site, we can open the course.
            return this.courseProvider.openCourse(navCtrl, course, params);
        }
        else {
            // We need to load the site first.
            params = params || {};
            Object.assign(params, { course: course });
            return this.loginHelper.redirect(__WEBPACK_IMPORTED_MODULE_19__core_login_providers_helper__["a" /* CoreLoginHelperProvider */].OPEN_COURSE, params, siteId);
        }
    };
    CoreCourseHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_15__course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_17__module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_18__module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */],
            __WEBPACK_IMPORTED_MODULE_5__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_19__core_login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_12__options_delegate__["a" /* CoreCourseOptionsDelegate */], __WEBPACK_IMPORTED_MODULE_13__core_sitehome_providers_sitehome__["a" /* CoreSiteHomeProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_file_helper__["a" /* CoreFileHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */],
            __WEBPACK_IMPORTED_MODULE_14__core_courses_providers_courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_16__course_offline__["a" /* CoreCourseOfflineProvider */]])
    ], CoreCourseHelperProvider);
    return CoreCourseHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreIframeUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_network__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_contentlinks_providers_helper__ = __webpack_require__(16);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/*
 * "Utils" service with helper functions for iframes, embed and similar.
 */
var CoreIframeUtilsProvider = /** @class */ (function () {
    function CoreIframeUtilsProvider(logger, fileProvider, sitesProvider, urlUtils, textUtils, utils, domUtils, platform, appProvider, translate, network, zone, config, contentLinksHelper) {
        this.fileProvider = fileProvider;
        this.sitesProvider = sitesProvider;
        this.urlUtils = urlUtils;
        this.textUtils = textUtils;
        this.utils = utils;
        this.domUtils = domUtils;
        this.platform = platform;
        this.appProvider = appProvider;
        this.translate = translate;
        this.network = network;
        this.zone = zone;
        this.config = config;
        this.contentLinksHelper = contentLinksHelper;
        this.logger = logger.getInstance('CoreUtilsProvider');
    }
    CoreIframeUtilsProvider_1 = CoreIframeUtilsProvider;
    /**
     * Check if a frame uses an online URL but the app is offline. If it does, the iframe is hidden and a warning is shown.
     *
     * @param {any} element The frame to check (iframe, embed, ...).
     * @param {boolean} [isSubframe] Whether it's a frame inside another frame.
     * @return {boolean} True if frame is online and the app is offline, false otherwise.
     */
    CoreIframeUtilsProvider.prototype.checkOnlineFrameInOffline = function (element, isSubframe) {
        var _this = this;
        var src = element.src || element.data;
        if (src && src.match(/^https?:\/\//i) && !this.appProvider.isOnline()) {
            if (element.classList.contains('core-iframe-offline-disabled')) {
                // Iframe already hidden, stop.
                return true;
            }
            // The frame has an online URL but the app is offline. Show a warning, or a link if the URL can be opened in the app.
            var div_1 = document.createElement('div');
            div_1.setAttribute('text-center', '');
            div_1.setAttribute('padding', '');
            div_1.classList.add('core-iframe-offline-warning');
            var site = this.sitesProvider.getCurrentSite();
            var username_1 = site ? site.getInfo().username : undefined;
            this.contentLinksHelper.canHandleLink(src, undefined, username_1).then(function (canHandleLink) {
                if (canHandleLink) {
                    var link = document.createElement('a');
                    if (isSubframe) {
                        // Ionic styles are not available in subframes, adding some minimal inline styles.
                        link.style.display = 'block';
                        link.style.padding = '1em';
                        link.style.fontWeight = '500';
                        link.style.textAlign = 'center';
                        link.style.textTransform = 'uppercase';
                        link.style.cursor = 'pointer';
                    }
                    else {
                        var mode = _this.config.get('mode');
                        link.setAttribute('ion-button', '');
                        link.classList.add('button', 'button-' + mode, 'button-default', 'button-default-' + mode, 'button-block', 'button-block-' + mode);
                    }
                    var message = _this.translate.instant('core.viewembeddedcontent');
                    link.innerHTML = isSubframe ? message : '<span class="button-inner">' + message + '</span>';
                    link.onclick = function (event) {
                        _this.contentLinksHelper.handleLink(src, username_1);
                        event.preventDefault();
                    };
                    div_1.appendChild(link);
                }
                else {
                    div_1.innerHTML = (isSubframe ? '' : _this.domUtils.getConnectionWarningIconHtml()) +
                        '<p>' + _this.translate.instant('core.networkerroriframemsg') + '</p>';
                }
                element.parentElement.insertBefore(div_1, element);
            });
            // Add a class to specify that the iframe is hidden.
            element.classList.add('core-iframe-offline-disabled');
            if (isSubframe) {
                // We cannot apply CSS styles in subframes, just hide the iframe.
                element.style.display = 'none';
            }
            // If the network changes, check it again.
            var subscription_1 = this.network.onConnect().subscribe(function () {
                // Execute the callback in the Angular zone, so change detection doesn't stop working.
                _this.zone.run(function () {
                    if (!_this.checkOnlineFrameInOffline(element, isSubframe)) {
                        // Now the app is online, no need to check connection again.
                        subscription_1.unsubscribe();
                    }
                });
            });
            return true;
        }
        else if (element.classList.contains('core-iframe-offline-disabled')) {
            // Reload the frame.
            element.src = element.src;
            element.data = element.data;
            // Remove the warning and show the iframe
            this.domUtils.removeElement(element.parentElement, 'div.core-iframe-offline-warning');
            element.classList.remove('core-iframe-offline-disabled');
            if (isSubframe) {
                element.style.display = '';
            }
        }
        return false;
    };
    /**
     * Given an element, return the content window and document.
     * Please notice that the element should be an iframe, embed or similar.
     *
     * @param {any} element Element to treat (iframe, embed, ...).
     * @return {{ window: Window, document: Document }} Window and Document.
     */
    CoreIframeUtilsProvider.prototype.getContentWindowAndDocument = function (element) {
        var contentWindow = element.contentWindow, contentDocument;
        try {
            contentDocument = element.contentDocument || (contentWindow && contentWindow.document);
        }
        catch (ex) {
            // Ignore errors.
        }
        if (!contentWindow && contentDocument) {
            // It's probably an <object>. Try to get the window.
            contentWindow = contentDocument.defaultView;
        }
        if (!contentWindow && element.getSVGDocument) {
            // It's probably an <embed>. Try to get the window and the document.
            try {
                contentDocument = element.getSVGDocument();
            }
            catch (ex) {
                // Ignore errors.
            }
            if (contentDocument && contentDocument.defaultView) {
                contentWindow = contentDocument.defaultView;
            }
            else if (element.window) {
                contentWindow = element.window;
            }
            else if (element.getWindow) {
                contentWindow = element.getWindow();
            }
        }
        return { window: contentWindow, document: contentDocument };
    };
    /**
     * Redefine the open method in the contentWindow of an element and the sub frames.
     * Please notice that the element should be an iframe, embed or similar.
     *
     * @param {any} element Element to treat (iframe, embed, ...).
     * @param {Window} contentWindow The window of the element contents.
     * @param {Document} contentDocument The document of the element contents.
     */
    CoreIframeUtilsProvider.prototype.redefineWindowOpen = function (element, contentWindow, contentDocument) {
        var _this = this;
        if (contentWindow) {
            // Intercept window.open.
            contentWindow.open = function (url, target) {
                var scheme = _this.urlUtils.getUrlScheme(url);
                if (!scheme) {
                    // It's a relative URL, use the frame src to create the full URL.
                    var src = element.src || element.data;
                    if (src) {
                        var dirAndFile = _this.fileProvider.getFileAndDirectoryFromPath(src);
                        if (dirAndFile.directory) {
                            url = _this.textUtils.concatenatePaths(dirAndFile.directory, url);
                        }
                        else {
                            _this.logger.warn('Cannot get iframe dir path to open relative url', url, element);
                            return null;
                        }
                    }
                    else {
                        _this.logger.warn('Cannot get iframe src to open relative url', url, element);
                        return null;
                    }
                }
                if (target == '_self') {
                    // Link should be loaded in the same frame.
                    if (element.tagName.toLowerCase() == 'object') {
                        element.setAttribute('data', url);
                    }
                    else {
                        element.setAttribute('src', url);
                    }
                }
                else if (url.indexOf('cdvfile://') === 0 || url.indexOf('file://') === 0) {
                    // It's a local file.
                    _this.utils.openFile(url).catch(function (error) {
                        _this.domUtils.showErrorModal(error);
                    });
                }
                else {
                    // It's an external link, we will open with browser. Check if we need to auto-login.
                    if (!_this.sitesProvider.isLoggedIn()) {
                        // Not logged in, cannot auto-login.
                        _this.utils.openInBrowser(url);
                    }
                    else {
                        _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(url);
                    }
                }
                // We cannot create new Window objects directly, return null which is a valid return value for Window.open().
                return null;
            };
        }
        if (contentDocument) {
            // Search sub frames.
            CoreIframeUtilsProvider_1.FRAME_TAGS.forEach(function (tag) {
                var elements = Array.from(contentDocument.querySelectorAll(tag));
                elements.forEach(function (subElement) {
                    _this.treatFrame(subElement, true);
                });
            });
        }
    };
    /**
     * Intercept window.open in a frame and its subframes, shows an error modal instead.
     * Search links (<a>) and open them in browser or InAppBrowser if needed.
     *
     * @param {any} element Element to treat (iframe, embed, ...).
     * @param {boolean} [isSubframe] Whether it's a frame inside another frame.
     */
    CoreIframeUtilsProvider.prototype.treatFrame = function (element, isSubframe) {
        var _this = this;
        if (element) {
            this.checkOnlineFrameInOffline(element, isSubframe);
            var winAndDoc_1 = this.getContentWindowAndDocument(element);
            // Redefine window.open in this element and sub frames, it might have been loaded already.
            this.redefineWindowOpen(element, winAndDoc_1.window, winAndDoc_1.document);
            // Treat links.
            this.treatFrameLinks(element, winAndDoc_1.document);
            element.addEventListener('load', function () {
                _this.checkOnlineFrameInOffline(element, isSubframe);
                // Element loaded, redefine window.open and treat links again.
                winAndDoc_1 = _this.getContentWindowAndDocument(element);
                _this.redefineWindowOpen(element, winAndDoc_1.window, winAndDoc_1.document);
                _this.treatFrameLinks(element, winAndDoc_1.document);
                if (winAndDoc_1.window) {
                    // Send a resize events to the iframe so it calculates the right size if needed.
                    setTimeout(function () {
                        winAndDoc_1.window.dispatchEvent(new Event('resize'));
                    }, 1000);
                }
            });
        }
    };
    /**
     * Search links (<a>) in a frame and open them in browser or InAppBrowser if needed.
     * Only links that haven't been treated by the frame's Javascript will be treated.
     *
     * @param {any} element Element to treat (iframe, embed, ...).
     * @param {Document} contentDocument The document of the element contents.
     */
    CoreIframeUtilsProvider.prototype.treatFrameLinks = function (element, contentDocument) {
        var _this = this;
        if (!contentDocument) {
            return;
        }
        contentDocument.addEventListener('click', function (event) {
            if (event.defaultPrevented) {
                // Event already prevented by some other code.
                return;
            }
            // Find the link being clicked.
            var el = event.target;
            while (el && el.tagName !== 'A') {
                el = el.parentElement;
            }
            if (!el || el.tagName !== 'A') {
                return;
            }
            var link = el;
            var scheme = _this.urlUtils.getUrlScheme(link.href);
            if (!link.href || (scheme && scheme == 'javascript')) {
                // Links with no URL and Javascript links are ignored.
                return;
            }
            if (scheme && scheme != 'file' && scheme != 'filesystem') {
                // Scheme suggests it's an external resource.
                event.preventDefault();
                var frameSrc = element.src || element.data, frameScheme = _this.urlUtils.getUrlScheme(frameSrc);
                // If the frame is not local, check the target to identify how to treat the link.
                if (frameScheme && frameScheme != 'file' && frameScheme != 'filesystem' &&
                    (!link.target || link.target == '_self')) {
                    // Load the link inside the frame itself.
                    if (element.tagName.toLowerCase() == 'object') {
                        element.setAttribute('data', link.href);
                    }
                    else {
                        element.setAttribute('src', link.href);
                    }
                    return;
                }
                // The frame is local or the link needs to be opened in a new window. Open in browser.
                if (!_this.sitesProvider.isLoggedIn()) {
                    _this.utils.openInBrowser(link.href);
                }
                else {
                    _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(link.href);
                }
            }
            else if (link.target == '_parent' || link.target == '_top' || link.target == '_blank') {
                // Opening links with _parent, _top or _blank can break the app. We'll open it in InAppBrowser.
                event.preventDefault();
                _this.utils.openFile(link.href).catch(function (error) {
                    _this.domUtils.showErrorModal(error);
                });
            }
            else if (_this.platform.is('ios') && (!link.target || link.target == '_self')) {
                // In cordova ios 4.1.0 links inside iframes stopped working. We'll manually treat them.
                event.preventDefault();
                if (element.tagName.toLowerCase() == 'object') {
                    element.setAttribute('data', link.href);
                }
                else {
                    element.setAttribute('src', link.href);
                }
            }
        });
    };
    CoreIframeUtilsProvider.FRAME_TAGS = ['iframe', 'frame', 'object', 'embed'];
    CoreIframeUtilsProvider = CoreIframeUtilsProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_7__sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_10__url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_11__utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_4__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_network__["a" /* Network */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["M" /* NgZone */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Config */],
            __WEBPACK_IMPORTED_MODULE_12__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */]])
    ], CoreIframeUtilsProvider);
    return CoreIframeUtilsProvider;
    var CoreIframeUtilsProvider_1;
}());

//# sourceMappingURL=iframe.js.map

/***/ }),
/* 38 */,
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreConstants; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Static class to contain all the core constants.
 */
var CoreConstants = /** @class */ (function () {
    function CoreConstants() {
    }
    CoreConstants.SECONDS_YEAR = 31536000;
    CoreConstants.SECONDS_WEEK = 604800;
    CoreConstants.SECONDS_DAY = 86400;
    CoreConstants.SECONDS_HOUR = 3600;
    CoreConstants.SECONDS_MINUTE = 60;
    CoreConstants.WIFI_DOWNLOAD_THRESHOLD = 104857600; // 100MB.
    CoreConstants.DOWNLOAD_THRESHOLD = 10485760; // 10MB.
    CoreConstants.MINIMUM_FREE_SPACE = 10485760; // 10MB.
    CoreConstants.IOS_FREE_SPACE_THRESHOLD = 524288000; // 500MB.
    CoreConstants.DONT_SHOW_ERROR = 'CoreDontShowError';
    CoreConstants.NO_SITE_ID = 'NoSite';
    // Settings constants.
    CoreConstants.SETTINGS_RICH_TEXT_EDITOR = 'CoreSettingsRichTextEditor';
    CoreConstants.SETTINGS_NOTIFICATION_SOUND = 'CoreSettingsNotificationSound';
    CoreConstants.SETTINGS_SYNC_ONLY_ON_WIFI = 'CoreSettingsSyncOnlyOnWifi';
    CoreConstants.SETTINGS_DEBUG_DISPLAY = 'CoreSettingsDebugDisplay';
    CoreConstants.SETTINGS_REPORT_IN_BACKGROUND = 'CoreSettingsReportInBackground'; // @deprecated since 3.5.0
    CoreConstants.SETTINGS_SEND_ON_ENTER = 'CoreSettingsSendOnEnter';
    // WS constants.
    CoreConstants.WS_TIMEOUT = 30000;
    CoreConstants.WS_PREFIX = 'local_mobile_';
    // Login constants.
    CoreConstants.LOGIN_SSO_CODE = 2; // SSO in browser window is required.
    CoreConstants.LOGIN_SSO_INAPP_CODE = 3; // SSO in embedded browser is required.
    CoreConstants.LOGIN_LAUNCH_DATA = 'CoreLoginLaunchData';
    // Download status constants.
    CoreConstants.DOWNLOADED = 'downloaded';
    CoreConstants.DOWNLOADING = 'downloading';
    CoreConstants.NOT_DOWNLOADED = 'notdownloaded';
    CoreConstants.OUTDATED = 'outdated';
    CoreConstants.NOT_DOWNLOADABLE = 'notdownloadable';
    // Constants from Moodle's resourcelib.
    CoreConstants.RESOURCELIB_DISPLAY_AUTO = 0; // Try the best way.
    CoreConstants.RESOURCELIB_DISPLAY_EMBED = 1; // Display using object tag.
    CoreConstants.RESOURCELIB_DISPLAY_FRAME = 2; // Display inside frame.
    CoreConstants.RESOURCELIB_DISPLAY_NEW = 3; // Display normal link in new window.
    CoreConstants.RESOURCELIB_DISPLAY_DOWNLOAD = 4; // Force download of file instead of display.
    CoreConstants.RESOURCELIB_DISPLAY_OPEN = 5; // Open directly.
    CoreConstants.RESOURCELIB_DISPLAY_POPUP = 6; // Open in "emulated" pop-up without navigation.
    // Feature constants. Used to report features that are, or are not, supported by a module.
    CoreConstants.FEATURE_GRADE_HAS_GRADE = 'grade_has_grade'; // True if module can provide a grade.
    CoreConstants.FEATURE_GRADE_OUTCOMES = 'outcomes'; // True if module supports outcomes.
    CoreConstants.FEATURE_ADVANCED_GRADING = 'grade_advanced_grading'; // True if module supports advanced grading methods.
    CoreConstants.FEATURE_CONTROLS_GRADE_VISIBILITY = 'controlsgradevisbility'; // True if module controls grade visibility over gradebook.
    CoreConstants.FEATURE_PLAGIARISM = 'plagiarism'; // True if module supports plagiarism plugins.
    CoreConstants.FEATURE_COMPLETION_TRACKS_VIEWS = 'completion_tracks_views'; // True if module tracks whether somebody viewed it.
    CoreConstants.FEATURE_COMPLETION_HAS_RULES = 'completion_has_rules'; // True if module has custom completion rules.
    CoreConstants.FEATURE_NO_VIEW_LINK = 'viewlink'; // True if module has no 'view' page (like label).
    CoreConstants.FEATURE_IDNUMBER = 'idnumber'; // True if module wants support for setting the ID number for grade calculation purposes.
    CoreConstants.FEATURE_GROUPS = 'groups'; // True if module supports groups.
    CoreConstants.FEATURE_GROUPINGS = 'groupings'; // True if module supports groupings.
    CoreConstants.FEATURE_MOD_ARCHETYPE = 'mod_archetype'; // Type of module.
    CoreConstants.FEATURE_MOD_INTRO = 'mod_intro'; // True if module supports intro editor.
    CoreConstants.FEATURE_MODEDIT_DEFAULT_COMPLETION = 'modedit_default_completion'; // True if module has default completion.
    CoreConstants.FEATURE_COMMENT = 'comment';
    CoreConstants.FEATURE_RATE = 'rate';
    CoreConstants.FEATURE_BACKUP_MOODLE2 = 'backup_moodle2'; // True if module supports backup/restore of moodle2 format.
    CoreConstants.FEATURE_SHOW_DESCRIPTION = 'showdescription'; // True if module can show description on course main page.
    CoreConstants.FEATURE_USES_QUESTIONS = 'usesquestions'; // True if module uses the question bank.
    // Pssobile archetypes for modules.
    CoreConstants.MOD_ARCHETYPE_OTHER = 0; // Unspecified module archetype.
    CoreConstants.MOD_ARCHETYPE_RESOURCE = 1; // Resource-like type module.
    CoreConstants.MOD_ARCHETYPE_ASSIGNMENT = 2; // Assignment module archetype.
    CoreConstants.MOD_ARCHETYPE_SYSTEM = 3; // System (not user-addable) module archetype.
    return CoreConstants;
}());

//# sourceMappingURL=constants.js.map

/***/ }),
/* 40 */,
/* 41 */,
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFormatTextDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_iframe__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__directives_link__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__directives_external_content__ = __webpack_require__(236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_contentlinks_providers_helper__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__components_split_view_split_view__ = __webpack_require__(34);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};

















/**
 * Directive to format text rendered. It renders the HTML and treats all links and media, using CoreLinkDirective
 * and CoreExternalContentDirective.
 *
 * Example usage:
 * <core-format-text [text]="myText" [component]="component" [componentId]="componentId"></core-format-text>
 *
 */
var CoreFormatTextDirective = /** @class */ (function () {
    function CoreFormatTextDirective(element, sitesProvider, domUtils, textUtils, translate, platform, utils, urlUtils, loggerProvider, filepoolProvider, appProvider, contentLinksHelper, navCtrl, content, svComponent, iframeUtils, eventsProvider) {
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        this.translate = translate;
        this.platform = platform;
        this.utils = utils;
        this.urlUtils = urlUtils;
        this.loggerProvider = loggerProvider;
        this.filepoolProvider = filepoolProvider;
        this.appProvider = appProvider;
        this.contentLinksHelper = contentLinksHelper;
        this.navCtrl = navCtrl;
        this.content = content;
        this.svComponent = svComponent;
        this.iframeUtils = iframeUtils;
        this.eventsProvider = eventsProvider;
        this.adaptImg = true; // Whether to adapt images to screen width.
        this.element = element.nativeElement;
        this.element.classList.add('opacity-hide'); // Hide contents until they're treated.
        this.afterRender = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.element.addEventListener('click', this.elementClicked.bind(this));
    }
    /**
     * Detect changes on input properties.
     */
    CoreFormatTextDirective.prototype.ngOnChanges = function (changes) {
        if (changes.text) {
            this.hideShowMore();
            this.formatAndRenderContents();
        }
    };
    /**
     * Apply CoreExternalContentDirective to a certain element.
     *
     * @param {HTMLElement} element Element to add the attributes to.
     */
    CoreFormatTextDirective.prototype.addExternalContent = function (element) {
        // Angular 2 doesn't let adding directives dynamically. Create the CoreExternalContentDirective manually.
        var extContent = new __WEBPACK_IMPORTED_MODULE_14__directives_external_content__["a" /* CoreExternalContentDirective */](element, this.loggerProvider, this.filepoolProvider, this.platform, this.sitesProvider, this.domUtils, this.urlUtils, this.appProvider, this.utils);
        extContent.component = this.component;
        extContent.componentId = this.componentId;
        extContent.siteId = this.siteId;
        extContent.src = element.getAttribute('src');
        extContent.href = element.getAttribute('href');
        extContent.targetSrc = element.getAttribute('target-src');
        extContent.poster = element.getAttribute('poster');
        extContent.ngAfterViewInit();
    };
    /**
     * Add class to adapt media to a certain element.
     *
     * @param {HTMLElement} element Element to add the class to.
     */
    CoreFormatTextDirective.prototype.addMediaAdaptClass = function (element) {
        element.classList.add('core-media-adapt-width');
    };
    /**
     * Wrap an image with a container to adapt its width and, if needed, add an anchor to view it in full size.
     *
     * @param {number} elWidth Width of the directive's element.
     * @param {HTMLElement} img Image to adapt.
     */
    CoreFormatTextDirective.prototype.adaptImage = function (elWidth, img) {
        var imgWidth = this.getElementWidth(img), 
        // Element to wrap the image.
        container = document.createElement('span'), originalWidth = img.attributes.getNamedItem('width');
        var forcedWidth = parseInt(originalWidth && originalWidth.value);
        if (!isNaN(forcedWidth)) {
            if (originalWidth.value.indexOf('%') < 0) {
                img.style.width = forcedWidth + 'px';
            }
            else {
                img.style.width = forcedWidth + '%';
            }
        }
        container.classList.add('core-adapted-img-container');
        container.style.cssFloat = img.style.cssFloat; // Copy the float to correctly position the search icon.
        if (img.classList.contains('atto_image_button_right')) {
            container.classList.add('atto_image_button_right');
        }
        else if (img.classList.contains('atto_image_button_left')) {
            container.classList.add('atto_image_button_left');
        }
        else if (img.classList.contains('atto_image_button_text-top')) {
            container.classList.add('atto_image_button_text-top');
        }
        else if (img.classList.contains('atto_image_button_middle')) {
            container.classList.add('atto_image_button_middle');
        }
        else if (img.classList.contains('atto_image_button_text-bottom')) {
            container.classList.add('atto_image_button_text-bottom');
        }
        this.domUtils.wrapElement(img, container);
        if (imgWidth > elWidth) {
            // The image has been adapted, add an anchor to view it in full size.
            this.addMagnifyingGlass(container, img);
        }
    };
    /**
     * Add a magnifying glass icon to view an image at full size.
     *
     * @param {HTMLElement} container The container of the image.
     * @param {HTMLElement} img The image.
     */
    CoreFormatTextDirective.prototype.addMagnifyingGlass = function (container, img) {
        var _this = this;
        var imgSrc = this.textUtils.escapeHTML(img.getAttribute('src')), label = this.textUtils.escapeHTML(this.translate.instant('core.openfullimage')), anchor = document.createElement('a');
        anchor.classList.add('core-image-viewer-icon');
        anchor.setAttribute('aria-label', label);
        // Add an ion-icon item to apply the right styles, but the ion-icon component won't be executed.
        anchor.innerHTML = '<ion-icon name="search" class="icon icon-md ion-md-search"></ion-icon>';
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            _this.domUtils.viewImage(imgSrc, img.getAttribute('alt'), _this.component, _this.componentId);
        });
        container.appendChild(anchor);
    };
    /**
     * Calculate the height and check if we need to display show more or not.
     */
    CoreFormatTextDirective.prototype.calculateHeight = function () {
        // @todo: Work on calculate this height better.
        // Remove max-height (if any) to calculate the real height.
        var initialMaxHeight = this.element.style.maxHeight;
        this.element.style.maxHeight = null;
        var height = this.getElementHeight(this.element);
        // Restore the max height now.
        this.element.style.maxHeight = initialMaxHeight;
        // If cannot calculate height, shorten always.
        if (!height || height > this.maxHeight) {
            if (!this.showMoreDisplayed) {
                this.displayShowMore();
            }
        }
        else if (this.showMoreDisplayed) {
            this.hideShowMore();
        }
    };
    /**
     * Display the "Show more" in the element.
     */
    CoreFormatTextDirective.prototype.displayShowMore = function () {
        var expandInFullview = this.utils.isTrueOrOne(this.fullOnClick) || false, showMoreDiv = document.createElement('div');
        showMoreDiv.classList.add('core-show-more');
        showMoreDiv.innerHTML = this.translate.instant('core.showmore');
        this.element.appendChild(showMoreDiv);
        if (expandInFullview) {
            this.element.classList.add('core-expand-in-fullview');
        }
        this.element.classList.add('core-text-formatted');
        this.element.classList.add('core-shortened');
        this.element.style.maxHeight = this.maxHeight + 'px';
        this.showMoreDisplayed = true;
    };
    /**
     * Listener to call when the element is clicked.
     *
     * @param {MouseEvent} e Click event.
     */
    CoreFormatTextDirective.prototype.elementClicked = function (e) {
        if (e.defaultPrevented) {
            // Ignore it if the event was prevented by some other listener.
            return;
        }
        var expandInFullview = this.utils.isTrueOrOne(this.fullOnClick) || false;
        if (!expandInFullview && !this.showMoreDisplayed) {
            // Nothing to do on click, just stop.
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        if (!expandInFullview) {
            // Change class.
            this.element.classList.toggle('core-shortened');
            return;
        }
        else {
            // Open a new state with the contents.
            this.textUtils.expandText(this.fullTitle || this.translate.instant('core.description'), this.text, this.component, this.componentId);
        }
    };
    /**
     * Finish the rendering, displaying the element again and calling afterRender.
     */
    CoreFormatTextDirective.prototype.finishRender = function () {
        // Show the element again.
        this.element.classList.remove('opacity-hide');
        // Emit the afterRender output.
        this.afterRender.emit();
    };
    /**
     * Format contents and render.
     */
    CoreFormatTextDirective.prototype.formatAndRenderContents = function () {
        var _this = this;
        if (!this.text) {
            this.element.innerHTML = ''; // Remove current contents.
            this.finishRender();
            return;
        }
        // In AOT the inputs and ng-reflect aren't in the DOM sometimes. Add them so styles are applied.
        if (this.maxHeight && !this.element.getAttribute('maxHeight')) {
            this.element.setAttribute('maxHeight', String(this.maxHeight));
        }
        if (!this.element.getAttribute('singleLine')) {
            this.element.setAttribute('singleLine', String(this.utils.isTrueOrOne(this.singleLine)));
        }
        this.text = this.text ? this.text.trim() : '';
        this.formatContents().then(function (div) {
            // Disable media adapt to correctly calculate the height.
            _this.element.classList.add('core-disable-media-adapt');
            _this.element.innerHTML = ''; // Remove current contents.
            if (_this.maxHeight && div.innerHTML != '') {
                // Move the children to the current element to be able to calculate the height.
                _this.domUtils.moveChildren(div, _this.element);
                // Calculate the height now.
                _this.calculateHeight();
                // Wait for images to load and calculate the height again if needed.
                _this.domUtils.waitForImages(_this.element).then(function (hasImgToLoad) {
                    if (hasImgToLoad) {
                        _this.calculateHeight();
                    }
                });
                if (!_this.loadingChangedListener) {
                    // Recalculate the height if a parent core-loading displays the content.
                    _this.loadingChangedListener = _this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].CORE_LOADING_CHANGED, function (data) {
                        if (data.loaded && _this.domUtils.closest(_this.element.parentElement, '#' + data.uniqueId)) {
                            // The format-text is inside the loading, re-calculate the height.
                            _this.calculateHeight();
                        }
                    });
                }
            }
            else {
                _this.domUtils.moveChildren(div, _this.element);
            }
            _this.element.classList.remove('core-disable-media-adapt');
            _this.finishRender();
        });
    };
    /**
     * Apply formatText and set sub-directives.
     *
     * @return {Promise<HTMLElement>} Promise resolved with a div element containing the code.
     */
    CoreFormatTextDirective.prototype.formatContents = function () {
        var _this = this;
        var site;
        // Retrieve the site since it might be needed later.
        return this.sitesProvider.getSite(this.siteId).catch(function () {
            // Error getting the site. This probably means that there is no current site and no siteId was supplied.
        }).then(function (siteInstance) {
            site = siteInstance;
            // Apply format text function.
            return _this.textUtils.formatText(_this.text, _this.utils.isTrueOrOne(_this.clean), _this.utils.isTrueOrOne(_this.singleLine), undefined, _this.highlight);
        }).then(function (formatted) {
            var div = document.createElement('div'), canTreatVimeo = site && site.isVersionGreaterEqualThan(['3.3.4', '3.4']);
            var images, anchors, audios, videos, iframes, buttons, elementsWithInlineStyles, stopClicksElements, frames;
            div.innerHTML = formatted;
            images = Array.from(div.querySelectorAll('img'));
            anchors = Array.from(div.querySelectorAll('a'));
            audios = Array.from(div.querySelectorAll('audio'));
            videos = Array.from(div.querySelectorAll('video'));
            iframes = Array.from(div.querySelectorAll('iframe'));
            buttons = Array.from(div.querySelectorAll('.button'));
            elementsWithInlineStyles = Array.from(div.querySelectorAll('*[style]'));
            stopClicksElements = Array.from(div.querySelectorAll('button,input,select,textarea'));
            frames = Array.from(div.querySelectorAll(__WEBPACK_IMPORTED_MODULE_9__providers_utils_iframe__["a" /* CoreIframeUtilsProvider */].FRAME_TAGS.join(',').replace(/iframe,?/, '')));
            // Walk through the content to find the links and add our directive to it.
            // Important: We need to look for links first because in 'img' we add new links without core-link.
            anchors.forEach(function (anchor) {
                // Angular 2 doesn't let adding directives dynamically. Create the CoreLinkDirective manually.
                var linkDir = new __WEBPACK_IMPORTED_MODULE_13__directives_link__["a" /* CoreLinkDirective */](anchor, _this.domUtils, _this.utils, _this.sitesProvider, _this.urlUtils, _this.contentLinksHelper, _this.navCtrl, _this.content, _this.svComponent);
                linkDir.capture = true;
                linkDir.ngOnInit();
                _this.addExternalContent(anchor);
            });
            if (images && images.length > 0) {
                // If cannot calculate element's width, use a medium number to avoid false adapt image icons appearing.
                var elWidth_1 = _this.getElementWidth(_this.element) || 100;
                // Walk through the content to find images, and add our directive.
                images.forEach(function (img) {
                    _this.addMediaAdaptClass(img);
                    _this.addExternalContent(img);
                    if (_this.utils.isTrueOrOne(_this.adaptImg) && !img.classList.contains('icon')) {
                        _this.adaptImage(elWidth_1, img);
                    }
                });
            }
            audios.forEach(function (audio) {
                _this.treatMedia(audio);
            });
            videos.forEach(function (video) {
                _this.treatVideoFilters(video);
                _this.treatMedia(video);
            });
            iframes.forEach(function (iframe) {
                _this.treatIframe(iframe, site, canTreatVimeo);
            });
            // Handle buttons with inner links.
            buttons.forEach(function (button) {
                // Check if it has a link inside.
                if (button.querySelector('a')) {
                    button.classList.add('core-button-with-inner-link');
                }
            });
            // Handle inline styles.
            elementsWithInlineStyles.forEach(function (el) {
                // Only add external content for tags that haven't been treated already.
                if (el.tagName != 'A' && el.tagName != 'IMG' && el.tagName != 'AUDIO' && el.tagName != 'VIDEO'
                    && el.tagName != 'SOURCE' && el.tagName != 'TRACK') {
                    _this.addExternalContent(el);
                }
            });
            // Stop propagating click events.
            stopClicksElements.forEach(function (element) {
                element.addEventListener('click', function (e) {
                    e.stopPropagation();
                });
            });
            // Handle all kind of frames.
            frames.forEach(function (frame) {
                _this.iframeUtils.treatFrame(frame);
            });
            _this.domUtils.handleBootstrapTooltips(div);
            return div;
        });
    };
    /**
     * Returns the element width in pixels.
     *
     * @param {HTMLElement} element Element to get width from.
     * @return {number} The width of the element in pixels. When 0 is returned it means the element is not visible.
     */
    CoreFormatTextDirective.prototype.getElementWidth = function (element) {
        var width = this.domUtils.getElementWidth(element);
        if (!width) {
            // All elements inside are floating or inline. Change display mode to allow calculate the width.
            var parentWidth = this.domUtils.getElementWidth(element.parentNode, true, false, false, true), previousDisplay = getComputedStyle(element, null).display;
            element.style.display = 'inline-block';
            width = this.domUtils.getElementWidth(element);
            // If width is incorrectly calculated use parent width instead.
            if (parentWidth > 0 && (!width || width > parentWidth)) {
                width = parentWidth;
            }
            element.style.display = previousDisplay;
        }
        return width;
    };
    /**
     * Returns the element height in pixels.
     *
     * @param {HTMLElement} elementAng Element to get height from.
     * @return {number} The height of the element in pixels. When 0 is returned it means the element is not visible.
     */
    CoreFormatTextDirective.prototype.getElementHeight = function (element) {
        return this.domUtils.getElementHeight(element) || 0;
    };
    /**
     * "Hide" the "Show more" in the element if it's shown.
     */
    CoreFormatTextDirective.prototype.hideShowMore = function () {
        var showMoreDiv = this.element.querySelector('div.core-show-more');
        if (showMoreDiv) {
            showMoreDiv.remove();
        }
        this.element.classList.remove('core-expand-in-fullview');
        this.element.classList.remove('core-text-formatted');
        this.element.classList.remove('core-shortened');
        this.element.style.maxHeight = null;
        this.showMoreDisplayed = false;
    };
    /**
     * Treat video filters. Currently only treating youtube video using video JS.
     *
     * @param {HTMLElement} el Video element.
     */
    CoreFormatTextDirective.prototype.treatVideoFilters = function (video) {
        // Treat Video JS Youtube video links and translate them to iframes.
        if (!video.classList.contains('video-js')) {
            return;
        }
        var data = this.textUtils.parseJSON(video.getAttribute('data-setup') || video.getAttribute('data-setup-lazy') || '{}'), youtubeData = data.techOrder && data.techOrder[0] && data.techOrder[0] == 'youtube' &&
            this.parseYoutubeUrl(data.sources && data.sources[0] && data.sources[0].src);
        if (!youtubeData || !youtubeData.videoId) {
            return;
        }
        var iframe = document.createElement('iframe');
        iframe.id = video.id;
        iframe.src = 'https://www.youtube.com/embed/' + youtubeData.videoId; // Don't apply other params to align with Moodle web.
        iframe.setAttribute('frameborder', '0');
        iframe.setAttribute('allowfullscreen', '1');
        iframe.width = '100%';
        iframe.height = '300';
        // Replace video tag by the iframe.
        video.parentNode.replaceChild(iframe, video);
        this.iframeUtils.treatFrame(iframe);
    };
    /**
     * Add media adapt class and apply CoreExternalContentDirective to the media element and its sources and tracks.
     *
     * @param {HTMLElement} element Video or audio to treat.
     */
    CoreFormatTextDirective.prototype.treatMedia = function (element) {
        var _this = this;
        this.addMediaAdaptClass(element);
        this.addExternalContent(element);
        var sources = Array.from(element.querySelectorAll('source')), tracks = Array.from(element.querySelectorAll('track'));
        sources.forEach(function (source) {
            source.setAttribute('target-src', source.getAttribute('src'));
            source.removeAttribute('src');
            _this.addExternalContent(source);
        });
        tracks.forEach(function (track) {
            _this.addExternalContent(track);
        });
        // Stop propagating click events.
        element.addEventListener('click', function (e) {
            e.stopPropagation();
        });
    };
    /**
     * Add media adapt class and treat the iframe source.
     *
     * @param {HTMLIFrameElement} iframe Iframe to treat.
     * @param {CoreSite} site Site instance.
     * @param {boolean} canTreatVimeo Whether Vimeo videos can be treated in the site.
     */
    CoreFormatTextDirective.prototype.treatIframe = function (iframe, site, canTreatVimeo) {
        var _this = this;
        var src = iframe.src, currentSite = this.sitesProvider.getCurrentSite();
        this.addMediaAdaptClass(iframe);
        if (currentSite && currentSite.containsUrl(src)) {
            // URL points to current site, try to use auto-login.
            currentSite.getAutoLoginUrl(src, false).then(function (finalUrl) {
                iframe.src = finalUrl;
                _this.iframeUtils.treatFrame(iframe);
            });
            return;
        }
        if (src && canTreatVimeo) {
            // Check if it's a Vimeo video. If it is, use the wsplayer script instead to make restricted videos work.
            var matches = iframe.src.match(/https?:\/\/player\.vimeo\.com\/video\/([0-9]+)/);
            if (matches && matches[1]) {
                var newUrl = this.textUtils.concatenatePaths(site.getURL(), '/media/player/vimeo/wsplayer.php?video=') +
                    matches[1] + '&token=' + site.getToken();
                // Width and height are mandatory, we need to calculate them.
                var width = void 0, height = void 0;
                if (iframe.width) {
                    width = iframe.width;
                }
                else {
                    width = this.getElementWidth(iframe);
                    if (!width) {
                        width = window.innerWidth;
                    }
                }
                if (iframe.height) {
                    height = iframe.height;
                }
                else {
                    height = this.getElementHeight(iframe);
                    if (!height) {
                        height = width;
                    }
                }
                // Width and height parameters are required in 3.6 and older sites.
                if (!site.isVersionGreaterEqualThan('3.7')) {
                    newUrl += '&width=' + width + '&height=' + height;
                }
                iframe.src = newUrl;
                if (!iframe.width) {
                    iframe.width = width;
                }
                if (!iframe.height) {
                    iframe.height = height;
                }
                // Do the iframe responsive.
                if (iframe.parentElement.classList.contains('embed-responsive')) {
                    iframe.addEventListener('load', function () {
                        if (iframe.contentDocument) {
                            var css = document.createElement('style');
                            css.setAttribute('type', 'text/css');
                            css.innerHTML = 'iframe {width: 100%;height: 100%;}';
                            iframe.contentDocument.head.appendChild(css);
                        }
                    });
                }
            }
        }
        this.iframeUtils.treatFrame(iframe);
    };
    /**
     * Parse a YouTube URL.
     * Based on Youtube.parseUrl from Moodle media/player/videojs/amd/src/Youtube-lazy.js
     *
     * @param {string} url URL of the video.
     */
    CoreFormatTextDirective.prototype.parseYoutubeUrl = function (url) {
        var result = {
            videoId: null,
            listId: null,
            start: null
        };
        if (!url) {
            return result;
        }
        url = this.textUtils.decodeHTML(url);
        // Get the video ID.
        var match = url.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/);
        if (match && match[2].length === 11) {
            result.videoId = match[2];
        }
        // Now get the playlist (if any).
        match = url.match(/[?&]list=([^#\&\?]+)/);
        if (match && match[1]) {
            result.listId = match[1];
        }
        // Now get the start time (if any).
        match = url.match(/[?&]start=(\d+)/);
        if (match && match[1]) {
            result.start = parseInt(match[1], 10);
        }
        else {
            // No start param, but it could have a time param.
            match = url.match(/[?&]t=(\d+h)?(\d+m)?(\d+s)?/);
            if (match) {
                result.start = (match[1] ? parseInt(match[1], 10) * 3600 : 0) + (match[2] ? parseInt(match[2], 10) * 60 : 0) +
                    (match[3] ? parseInt(match[3], 10) : 0);
            }
        }
        return result;
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "text", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "siteId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "adaptImg", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "clean", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "singleLine", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreFormatTextDirective.prototype, "maxHeight", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "fullOnClick", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "fullTitle", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "highlight", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreFormatTextDirective.prototype, "afterRender", void 0);
    CoreFormatTextDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: 'core-format-text'
        }),
        __param(12, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __param(13, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()), __param(14, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_11__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_15__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["f" /* Content */], __WEBPACK_IMPORTED_MODULE_16__components_split_view_split_view__["a" /* CoreSplitViewComponent */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_iframe__["a" /* CoreIframeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreFormatTextDirective);
    return CoreFormatTextDirective;
}());

//# sourceMappingURL=format-text.js.map

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__offline__ = __webpack_require__(426);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_pushnotifications_providers_pushnotifications__ = __webpack_require__(140);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service to provide user functionalities.
 */
var CoreUserProvider = /** @class */ (function () {
    function CoreUserProvider(logger, sitesProvider, utils, filepoolProvider, appProvider, userOffline, pushNotificationsProvider) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.filepoolProvider = filepoolProvider;
        this.appProvider = appProvider;
        this.userOffline = userOffline;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.ROOT_CACHE_KEY = 'mmUser:';
        // Variables for database.
        this.USERS_TABLE = 'users';
        this.siteSchema = {
            name: 'CoreUserProvider',
            version: 1,
            canBeCleared: [this.USERS_TABLE],
            tables: [
                {
                    name: this.USERS_TABLE,
                    columns: [
                        {
                            name: 'id',
                            type: 'INTEGER',
                            primaryKey: true
                        },
                        {
                            name: 'fullname',
                            type: 'TEXT'
                        },
                        {
                            name: 'profileimageurl',
                            type: 'TEXT'
                        }
                    ],
                }
            ]
        };
        this.logger = logger.getInstance('CoreUserProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    CoreUserProvider_1 = CoreUserProvider;
    /**
     * Change the given user profile picture.
     *
     * @param  {number} draftItemId New picture draft item id.
     * @param  {number} userId      User ID.
     * @return {Promise<string>}       Promise resolve with the new profileimageurl
     */
    CoreUserProvider.prototype.changeProfilePicture = function (draftItemId, userId) {
        var data = {
            draftitemid: draftItemId,
            delete: 0,
            userid: userId
        };
        return this.sitesProvider.getCurrentSite().write('core_user_update_picture', data).then(function (result) {
            if (!result.success) {
                return Promise.reject(null);
            }
            return result.profileimageurl;
        });
    };
    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @param  {number} userId  User ID.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}   Promise resolve when the user is deleted.
     */
    CoreUserProvider.prototype.deleteStoredUser = function (userId, siteId) {
        var _this = this;
        if (isNaN(userId)) {
            return Promise.reject(null);
        }
        var promises = [];
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Invalidate WS calls.
        promises.push(this.invalidateUserCache(userId, siteId));
        promises.push(this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(_this.USERS_TABLE, { id: userId });
        }));
        return Promise.all(promises);
    };
    /**
     * Get participants for a certain course.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} limitFrom   Position of the first participant to get.
     * @param  {number} limitNumber Number of participants to get.
     * @param  {string} [siteId]    Site Id. If not defined, use current site.
     * @param  {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<{participants: any[], canLoadMore: boolean}>} Promise resolved when the participants are retrieved.
     */
    CoreUserProvider.prototype.getParticipants = function (courseId, limitFrom, limitNumber, siteId, ignoreCache) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNumber === void 0) { limitNumber = CoreUserProvider_1.PARTICIPANTS_LIST_LIMIT; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug("Get participants for course '" + courseId + "' starting at '" + limitFrom + "'");
            var data = {
                courseid: courseId,
                options: [
                    {
                        name: 'limitfrom',
                        value: limitFrom
                    },
                    {
                        name: 'limitnumber',
                        value: limitNumber
                    },
                    {
                        name: 'sortby',
                        value: 'siteorder'
                    }
                ]
            }, preSets = {
                cacheKey: _this.getParticipantsListCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('core_enrol_get_enrolled_users', data, preSets).then(function (users) {
                var canLoadMore = users.length >= limitNumber;
                _this.storeUsers(users, siteId);
                return { participants: users, canLoadMore: canLoadMore };
            });
        });
    };
    /**
     * Get cache key for participant list WS calls.
     *
     * @param  {number} courseId Course ID.
     * @return {string}          Cache key.
     */
    CoreUserProvider.prototype.getParticipantsListCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'list:' + courseId;
    };
    /**
     * Get user profile. The type of profile retrieved depends on the params.
     *
     * @param  {number} userId      User's ID.
     * @param  {number} [courseId]  Course ID to get course profile, undefined or 0 to get site profile.
     * @param  {boolean} [forceLocal] True to retrieve the user data from local DB, false to retrieve it from WS.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}            Promise resolved with the user data.
     */
    CoreUserProvider.prototype.getProfile = function (userId, courseId, forceLocal, siteId) {
        var _this = this;
        if (forceLocal === void 0) { forceLocal = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (forceLocal) {
            return this.getUserFromLocalDb(userId, siteId).catch(function () {
                return _this.getUserFromWS(userId, courseId, siteId);
            });
        }
        return this.getUserFromWS(userId, courseId, siteId).catch(function () {
            return _this.getUserFromLocalDb(userId, siteId);
        });
    };
    /**
     * Get cache key for a user WS call.
     *
     * @param  {number} userId User ID.
     * @return {string}        Cache key.
     */
    CoreUserProvider.prototype.getUserCacheKey = function (userId) {
        return this.ROOT_CACHE_KEY + 'data:' + userId;
    };
    /**
     * Get user basic information from local DB.
     *
     * @param {number} userId User ID.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}   Promise resolve when the user is retrieved.
     */
    CoreUserProvider.prototype.getUserFromLocalDb = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.USERS_TABLE, { id: userId });
        });
    };
    /**
     * Get user profile from WS.
     *
     * @param {number} userId         User ID.
     * @param {number} [courseId] Course ID to get course profile, undefined or 0 to get site profile.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}           Promise resolve when the user is retrieved.
     */
    CoreUserProvider.prototype.getUserFromWS = function (userId, courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var presets = {
                cacheKey: _this.getUserCacheKey(userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            var wsName, data;
            // Determine WS and data to use.
            if (courseId && courseId != site.getSiteHomeId()) {
                _this.logger.debug("Get participant with ID '" + userId + "' in course '" + courseId);
                wsName = 'core_user_get_course_user_profiles';
                data = {
                    userlist: [
                        {
                            userid: userId,
                            courseid: courseId
                        }
                    ]
                };
            }
            else {
                _this.logger.debug("Get user with ID '" + userId + "'");
                wsName = 'core_user_get_users_by_field';
                data = {
                    field: 'id',
                    values: [userId]
                };
            }
            return site.read(wsName, data, presets).then(function (users) {
                if (users.length == 0) {
                    return Promise.reject('Cannot retrieve user info.');
                }
                var user = users.shift();
                if (user.country) {
                    user.country = _this.utils.getCountryName(user.country);
                }
                _this.storeUser(user.id, user.fullname, user.profileimageurl);
                return user;
            });
        });
    };
    /**
     * Get a user preference (online or offline).
     *
     * @param {string} name Name of the preference.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {string} Preference value or null if preference not set.
     */
    CoreUserProvider.prototype.getUserPreference = function (name, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.userOffline.getPreference(name, siteId).catch(function () {
            return null;
        }).then(function (preference) {
            if (preference && !_this.appProvider.isOnline()) {
                // Offline, return stored value.
                return preference.value;
            }
            return _this.getUserPreferenceOnline(name, siteId).then(function (wsValue) {
                if (preference && preference.value != preference.onlinevalue && preference.onlinevalue == wsValue) {
                    // Sync is pending for this preference, return stored value.
                    return preference.value;
                }
                return _this.userOffline.setPreference(name, wsValue, wsValue).then(function () {
                    return wsValue;
                });
            });
        });
    };
    /**
     * Get cache key for a user preference WS call.
     *
     * @param {string} name Preference name.
     * @return {string} Cache key.
     */
    CoreUserProvider.prototype.getUserPreferenceCacheKey = function (name) {
        return this.ROOT_CACHE_KEY + 'preference:' + name;
    };
    /**
     * Get a user preference online.
     *
     * @param {string} name Name of the preference.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {string} Preference value or null if preference not set.
     */
    CoreUserProvider.prototype.getUserPreferenceOnline = function (name, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = { name: name };
            var preSets = {
                cacheKey: _this.getUserPreferenceCacheKey(data.name),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('core_user_get_user_preferences', data, preSets).then(function (result) {
                return result.preferences[0] ? result.preferences[0].value : null;
            });
        });
    };
    /**
     * Invalidates user WS calls.
     *
     * @param {number} userId User ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>}       Promise resolved when the data is invalidated.
     */
    CoreUserProvider.prototype.invalidateUserCache = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserCacheKey(userId));
        });
    };
    /**
     * Invalidates participant list for a certain course.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>}         Promise resolved when the list is invalidated.
     */
    CoreUserProvider.prototype.invalidateParticipantsList = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getParticipantsListCacheKey(courseId));
        });
    };
    /**
     * Invalidate user preference.
     *
     * @param {string} name Name of the preference.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreUserProvider.prototype.invalidateUserPreference = function (name, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserPreferenceCacheKey(name));
        });
    };
    /**
     * Check if course participants is disabled in a certain site.
     *
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>}     Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreUserProvider.prototype.isParticipantsDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isParticipantsDisabledInSite(site);
        });
    };
    /**
     * Check if course participants is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreUserProvider.prototype.isParticipantsDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('CoreCourseOptionsDelegate_CoreUserParticipants');
    };
    /**
     * Returns whether or not participants is enabled for a certain course.
     *
     * @param {number} courseId Course ID.
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>}    Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    CoreUserProvider.prototype.isPluginEnabledForCourse = function (courseId, siteId) {
        if (!courseId) {
            return Promise.reject(null);
        }
        // Retrieving one participant will fail if browsing users is disabled by capabilities.
        return this.utils.promiseWorks(this.getParticipants(courseId, 0, 1, siteId));
    };
    /**
     * Check if update profile picture is disabled in a certain site.
     *
     * @param  {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean}       True if disabled, false otherwise.
     */
    CoreUserProvider.prototype.isUpdatePictureDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('CoreUserDelegate_picture');
    };
    /**
     * Log User Profile View in Moodle.
     * @param  {number}       userId   User ID.
     * @param  {number}       [courseId] Course ID.
     * @param  {string}       [name] Name of the user.
     * @return {Promise<any>}          Promise resolved when done.
     */
    CoreUserProvider.prototype.logView = function (userId, courseId, name) {
        var params = {
            userid: userId
        }, wsName = 'core_user_view_user_profile';
        if (courseId) {
            params['courseid'] = courseId;
        }
        this.pushNotificationsProvider.logViewEvent(userId, name, 'user', wsName, { courseid: courseId });
        return this.sitesProvider.getCurrentSite().write(wsName, params);
    };
    /**
     * Log Participants list view in Moodle.
     * @param  {number}       courseId Course ID.
     * @return {Promise<any>}          Promise resolved when done.
     */
    CoreUserProvider.prototype.logParticipantsView = function (courseId) {
        var params = {
            courseid: courseId
        };
        this.pushNotificationsProvider.logViewListEvent('user', 'core_user_view_user_list', params);
        return this.sitesProvider.getCurrentSite().write('core_user_view_user_list', params);
    };
    /**
     * Prefetch user profiles and their images from a certain course. It prevents duplicates.
     *
     * @param {number[]} userIds List of user IDs.
     * @param {number} [courseId] Course the users belong to.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when prefetched.
     */
    CoreUserProvider.prototype.prefetchProfiles = function (userIds, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var treated = {}, promises = [];
        userIds.forEach(function (userId) {
            if (userId === null) {
                return;
            }
            userId = Number(userId); // Make sure it's a number.
            // Prevent repeats and errors.
            if (!isNaN(userId) && !treated[userId] && userId > 0) {
                treated[userId] = true;
                promises.push(_this.getProfile(userId, courseId, false, siteId).then(function (profile) {
                    if (profile.profileimageurl) {
                        _this.filepoolProvider.addToQueueByUrl(siteId, profile.profileimageurl);
                    }
                }));
            }
        });
        return Promise.all(promises);
    };
    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @param {number} userId   User ID.
     * @param {string} fullname User full name.
     * @param {string} avatar   User avatar URL.
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}         Promise resolve when the user is stored.
     */
    CoreUserProvider.prototype.storeUser = function (userId, fullname, avatar, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userRecord = {
                id: userId,
                fullname: fullname,
                profileimageurl: avatar
            };
            return site.getDb().insertRecord(_this.USERS_TABLE, userRecord);
        });
    };
    /**
     * Store users basic information in local DB.
     *
     * @param  {any[]} users     Users to store. Fields stored: id, fullname, profileimageurl.
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}        Promise resolve when the user is stored.
     */
    CoreUserProvider.prototype.storeUsers = function (users, siteId) {
        var _this = this;
        var promises = [];
        users.forEach(function (user) {
            if (typeof user.id != 'undefined' && !isNaN(parseInt(user.id, 10))) {
                promises.push(_this.storeUser(parseInt(user.id, 10), user.fullname, user.profileimageurl, siteId));
            }
        });
        return Promise.all(promises);
    };
    /**
     * Set a user preference (online or offline).
     *
     * @param {string} name Name of the preference.
     * @param {string} value Value of the preference.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreUserProvider.prototype.setUserPreference = function (name, value, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var isOnline = this.appProvider.isOnline();
        var promise;
        if (isOnline) {
            var preferences = [{ type: name, value: value }];
            promise = this.updateUserPreferences(preferences, undefined, undefined, siteId).catch(function (error) {
                // Preference not saved online.
                isOnline = false;
                return Promise.reject(error);
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise.finally(function () {
            // Update stored online value if saved online.
            var onlineValue = isOnline ? value : undefined;
            return Promise.all([
                _this.userOffline.setPreference(name, value, onlineValue),
                _this.invalidateUserPreference(name).catch(function () {
                    // Ignore error.
                })
            ]);
        });
    };
    /**
     * Update a preference for a user.
     *
     * @param  {string} name     Preference name.
     * @param  {any} value       Preference new value.
     * @param  {number} [userId] User ID. If not defined, site's current user.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if success.
     */
    CoreUserProvider.prototype.updateUserPreference = function (name, value, userId, siteId) {
        var preferences = [
            {
                type: name,
                value: value
            }
        ];
        return this.updateUserPreferences(preferences, undefined, userId, siteId);
    };
    /**
     * Update some preferences for a user.
     *
     * @param  {{name: string, value: string}[]} preferences List of preferences.
     * @param  {boolean} [disableNotifications] Whether to disable all notifications. Undefined to not update this value.
     * @param  {number} [userId]                User ID. If not defined, site's current user.
     * @param  {string} [siteId]                Site ID. If not defined, current site.
     * @return {Promise<any>}                   Promise resolved if success.
     */
    CoreUserProvider.prototype.updateUserPreferences = function (preferences, disableNotifications, userId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var data = {
                userid: userId,
                preferences: preferences
            }, preSets = {
                responseExpected: false
            };
            if (typeof disableNotifications != 'undefined') {
                data['emailstop'] = disableNotifications ? 1 : 0;
            }
            return site.write('core_user_update_user_preferences', data, preSets);
        });
    };
    CoreUserProvider.PARTICIPANTS_LIST_LIMIT = 50; // Max of participants to retrieve in each WS call.
    CoreUserProvider.PROFILE_REFRESHED = 'CoreUserProfileRefreshed';
    CoreUserProvider.PROFILE_PICTURE_UPDATED = 'CoreUserProfilePictureUpdated';
    CoreUserProvider = CoreUserProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__offline__["a" /* CoreUserOfflineProvider */], __WEBPACK_IMPORTED_MODULE_8__core_pushnotifications_providers_pushnotifications__["a" /* CorePushNotificationsProvider */]])
    ], CoreUserProvider);
    return CoreUserProvider;
    var CoreUserProvider_1;
}());

//# sourceMappingURL=user.js.map

/***/ }),
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModulePrefetchDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__classes_cache__ = __webpack_require__(1016);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__classes_delegate__ = __webpack_require__(111);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/**
 * Delegate to register module prefetch handlers.
 */
var CoreCourseModulePrefetchDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseModulePrefetchDelegate, _super);
    function CoreCourseModulePrefetchDelegate(loggerProvider, sitesProvider, utils, courseProvider, filepoolProvider, timeUtils, fileProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreCourseModulePrefetchDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.utils = utils;
        _this.courseProvider = courseProvider;
        _this.filepoolProvider = filepoolProvider;
        _this.timeUtils = timeUtils;
        _this.fileProvider = fileProvider;
        _this.eventsProvider = eventsProvider;
        // Variables for database.
        _this.CHECK_UPDATES_TIMES_TABLE = 'check_updates_times';
        _this.siteSchema = {
            name: 'CoreCourseModulePrefetchDelegate',
            version: 1,
            tables: [
                {
                    name: _this.CHECK_UPDATES_TIMES_TABLE,
                    columns: [
                        {
                            name: 'courseId',
                            type: 'INTEGER',
                            primaryKey: true
                        },
                        {
                            name: 'time',
                            type: 'INTEGER',
                            notNull: true
                        }
                    ]
                }
            ]
        };
        _this.ROOT_CACHE_KEY = 'mmCourse:';
        _this.statusCache = new __WEBPACK_IMPORTED_MODULE_9__classes_cache__["a" /* CoreCache */]();
        _this.handlerNameProperty = 'modName';
        // Promises for check updates, to prevent performing the same request twice at the same time.
        _this.courseUpdatesPromises = {};
        // Promises and observables for prefetching, to prevent downloading same section twice at the same time and notify progress.
        _this.prefetchData = {};
        _this.sitesProvider.registerSiteSchema(_this.siteSchema);
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].LOGOUT, _this.clearStatusCache.bind(_this));
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].PACKAGE_STATUS_CHANGED, function (data) {
            _this.updateStatusCache(data.status, data.component, data.componentId);
        }, _this.sitesProvider.getCurrentSiteId());
        return _this;
    }
    /**
     * Check if current site can check updates using core_course_check_updates.
     *
     * @return {boolean} True if can check updates, false otherwise.
     */
    CoreCourseModulePrefetchDelegate.prototype.canCheckUpdates = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_course_check_updates');
    };
    /**
     * Check if a certain module can use core_course_check_updates.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the module can use check updates WS.
     */
    CoreCourseModulePrefetchDelegate.prototype.canModuleUseCheckUpdates = function (module, courseId) {
        var handler = this.getPrefetchHandlerFor(module);
        if (!handler) {
            // Module not supported, cannot use check updates.
            return Promise.resolve(false);
        }
        if (handler.canUseCheckUpdates) {
            return Promise.resolve(handler.canUseCheckUpdates(module, courseId));
        }
        // By default, modules can use check updates.
        return Promise.resolve(true);
    };
    /**
     * Clear the status cache.
     */
    CoreCourseModulePrefetchDelegate.prototype.clearStatusCache = function () {
        this.statusCache.clear();
    };
    /**
     * Creates the list of modules to check for get course updates.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId Course ID the modules belong to.
     * @return {Promise<{toCheck: any[], cannotUse: any[]}>} Promise resolved with the lists.
     */
    CoreCourseModulePrefetchDelegate.prototype.createToCheckList = function (modules, courseId) {
        var _this = this;
        var result = {
            toCheck: [],
            cannotUse: []
        }, promises = [];
        modules.forEach(function (module) {
            promises.push(_this.getModuleStatusAndDownloadTime(module, courseId).then(function (data) {
                if (data.status == __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED) {
                    // Module is downloaded and not outdated. Check if it can check updates.
                    return _this.canModuleUseCheckUpdates(module, courseId).then(function (canUse) {
                        if (canUse) {
                            // Can use check updates, add it to the tocheck list.
                            result.toCheck.push({
                                contextlevel: 'module',
                                id: module.id,
                                since: data.downloadTime || 0
                            });
                        }
                        else {
                            // Cannot use check updates, add it to the cannotUse array.
                            result.cannotUse.push(module);
                        }
                    });
                }
            }).catch(function () {
                // Ignore errors.
            }));
        });
        return Promise.all(promises).then(function () {
            // Sort toCheck list.
            result.toCheck.sort(function (a, b) {
                return a.id >= b.id ? 1 : -1;
            });
            return result;
        });
    };
    /**
     * Determines a module status based on current status, restoring downloads if needed.
     *
     * @param {any} module Module.
     * @param {string} status Current status.
     * @param {boolean} [canCheck] True if updates can be checked using core_course_check_updates.
     * @return {string} Module status.
     */
    CoreCourseModulePrefetchDelegate.prototype.determineModuleStatus = function (module, status, canCheck) {
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId();
        if (handler) {
            if (status == __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADING) {
                // Check if the download is being handled.
                if (!this.filepoolProvider.getPackageDownloadPromise(siteId, handler.component, module.id)) {
                    // Not handled, the app was probably restarted or something weird happened.
                    // Re-start download (files already on queue or already downloaded will be skipped).
                    handler.prefetch(module);
                }
            }
            else if (handler.determineStatus) {
                // The handler implements a determineStatus function. Apply it.
                canCheck = canCheck || this.canCheckUpdates();
                return handler.determineStatus(module, status, canCheck);
            }
        }
        return status;
    };
    /**
     * Check for updates in a course.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId  Course ID the modules belong to.
     * @return {Promise<any>} Promise resolved with the updates. If a module is set to false, it means updates cannot be
     *                        checked for that module in the current site.
     */
    CoreCourseModulePrefetchDelegate.prototype.getCourseUpdates = function (modules, courseId) {
        var _this = this;
        if (!this.canCheckUpdates()) {
            return Promise.reject(null);
        }
        // Check if there's already a getCourseUpdates in progress.
        var id = __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__["Md5"].hashAsciiStr(courseId + '#' + JSON.stringify(modules)), siteId = this.sitesProvider.getCurrentSiteId();
        if (this.courseUpdatesPromises[siteId] && this.courseUpdatesPromises[siteId][id]) {
            // There's already a get updates ongoing, return the promise.
            return this.courseUpdatesPromises[siteId][id];
        }
        else if (!this.courseUpdatesPromises[siteId]) {
            this.courseUpdatesPromises[siteId] = {};
        }
        this.courseUpdatesPromises[siteId][id] = this.createToCheckList(modules, courseId).then(function (data) {
            var result = {};
            // Mark as false the modules that cannot use check updates WS.
            data.cannotUse.forEach(function (module) {
                result[module.id] = false;
            });
            if (!data.toCheck.length) {
                // Nothing to check, no need to call the WS.
                return result;
            }
            // Get the site, maybe the user changed site.
            return _this.sitesProvider.getSite(siteId).then(function (site) {
                var params = {
                    courseid: courseId,
                    tocheck: data.toCheck
                }, preSets = {
                    cacheKey: _this.getCourseUpdatesCacheKey(courseId),
                    emergencyCache: false,
                    uniqueCacheKey: true
                };
                return site.read('core_course_check_updates', params, preSets).then(function (response) {
                    if (!response || typeof response.instances == 'undefined') {
                        return Promise.reject(null);
                    }
                    // Store the last execution of the check updates call.
                    var entry = {
                        courseId: courseId,
                        time: _this.timeUtils.timestamp()
                    };
                    site.getDb().insertRecord(_this.CHECK_UPDATES_TIMES_TABLE, entry).catch(function () {
                        // Ignore errors.
                    });
                    return _this.treatCheckUpdatesResult(data.toCheck, response, result);
                }).catch(function (error) {
                    // Cannot get updates.
                    // Get cached entries but discard modules with a download time higher than the last execution of check updates.
                    return site.getDb().getRecord(_this.CHECK_UPDATES_TIMES_TABLE, { courseId: courseId }).then(function (entry) {
                        preSets.getCacheUsingCacheKey = true;
                        preSets.omitExpires = true;
                        return site.read('core_course_check_updates', params, preSets).then(function (response) {
                            if (!response || typeof response.instances == 'undefined') {
                                return Promise.reject(error);
                            }
                            return _this.treatCheckUpdatesResult(data.toCheck, response, result, entry.time);
                        });
                    }, function () {
                        // No previous executions, return result as it is.
                        return result;
                    });
                });
            });
        }).finally(function () {
            // Get updates finished, delete the promise.
            delete _this.courseUpdatesPromises[siteId][id];
        });
        return this.courseUpdatesPromises[siteId][id];
    };
    /**
     * Check for updates in a course.
     *
     * @param {number} courseId Course ID the modules belong to.
     * @return {Promise<any>} Promise resolved with the updates.
     */
    CoreCourseModulePrefetchDelegate.prototype.getCourseUpdatesByCourseId = function (courseId) {
        var _this = this;
        if (!this.canCheckUpdates()) {
            return Promise.reject(null);
        }
        // Get course sections and all their modules.
        return this.courseProvider.getSections(courseId, false, true, { omitExpires: true }).then(function (sections) {
            return _this.getCourseUpdates(_this.courseProvider.getSectionsModules(sections), courseId);
        });
    };
    /**
     * Get cache key for course updates WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    CoreCourseModulePrefetchDelegate.prototype.getCourseUpdatesCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'courseUpdates:' + courseId;
    };
    /**
     * Get modules download size. Only treat the modules with status not downloaded or outdated.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId Course ID the modules belong to.
     * @return {Promise<{size: number, total: boolean}>} Promise resolved with the size and a boolean indicating if it was able
     *                                                   to calculate the total size.
     */
    CoreCourseModulePrefetchDelegate.prototype.getDownloadSize = function (modules, courseId) {
        var _this = this;
        // Get the status of each module.
        return this.getModulesStatus(modules, courseId).then(function (data) {
            var downloadableModules = data[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED].concat(data[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED]), promises = [], result = {
                size: 0,
                total: true
            };
            downloadableModules.forEach(function (module) {
                promises.push(_this.getModuleDownloadSize(module, courseId).then(function (size) {
                    result.total = result.total && size.total;
                    result.size += size.size;
                }));
            });
            return Promise.all(promises).then(function () {
                return result;
            });
        });
    };
    /**
     * Get the download size of a module.
     *
     * @param {any} module Module to get size.
     * @param {Number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<{size: number, total: boolean}>} Promise resolved with the size and a boolean indicating if it was able
     *                                                   to calculate the total size.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleDownloadSize = function (module, courseId, single) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module);
        var downloadSize, packageId;
        // Check if the module has a prefetch handler.
        if (handler) {
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return { size: 0, total: true };
                }
                packageId = _this.filepoolProvider.getPackageId(handler.component, module.id);
                downloadSize = _this.statusCache.getValue(packageId, 'downloadSize');
                if (typeof downloadSize != 'undefined') {
                    return downloadSize;
                }
                return Promise.resolve(handler.getDownloadSize(module, courseId, single)).then(function (size) {
                    return _this.statusCache.setValue(packageId, 'downloadSize', size);
                }).catch(function (error) {
                    var cachedSize = _this.statusCache.getValue(packageId, 'downloadSize', true);
                    if (cachedSize) {
                        return cachedSize;
                    }
                    return Promise.reject(error);
                });
            });
        }
        return Promise.resolve({ size: 0, total: false });
    };
    /**
     * Get the download size of a module.
     *
     * @param {any} module Module to get size.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<number>} Promise resolved with the size.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleDownloadedSize = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module);
        var downloadedSize, packageId, promise;
        // Check if the module has a prefetch handler.
        if (handler) {
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return 0;
                }
                packageId = _this.filepoolProvider.getPackageId(handler.component, module.id);
                downloadedSize = _this.statusCache.getValue(packageId, 'downloadedSize');
                if (typeof downloadedSize != 'undefined') {
                    return downloadedSize;
                }
                if (handler.getDownloadedSize) {
                    // Handler implements a method to calculate the downloaded size, use it.
                    promise = Promise.resolve(handler.getDownloadedSize(module, courseId));
                }
                else {
                    // Handler doesn't implement it, get the module files and check if they're downloaded.
                    promise = _this.getModuleFiles(module, courseId).then(function (files) {
                        var siteId = _this.sitesProvider.getCurrentSiteId(), promises = [];
                        var size = 0;
                        // Retrieve file size if it's downloaded.
                        files.forEach(function (file) {
                            var fileUrl = file.url || file.fileurl;
                            promises.push(_this.filepoolProvider.getFilePathByUrl(siteId, fileUrl).then(function (path) {
                                return _this.fileProvider.getFileSize(path).catch(function () {
                                    // Error getting size. Check if the file is being downloaded.
                                    return _this.filepoolProvider.isFileDownloadingByUrl(siteId, fileUrl).then(function () {
                                        // If downloading, count as downloaded.
                                        return file.filesize;
                                    }).catch(function () {
                                        // Not downloading and not found in disk.
                                        return 0;
                                    });
                                }).then(function (fs) {
                                    size += fs;
                                });
                            }));
                        });
                        return Promise.all(promises).then(function () {
                            return size;
                        });
                    });
                }
                return promise.then(function (size) {
                    return _this.statusCache.setValue(packageId, 'downloadedSize', size);
                }).catch(function () {
                    return _this.statusCache.getValue(packageId, 'downloadedSize', true);
                });
            });
        }
        return Promise.resolve(0);
    };
    /**
     * Get module files.
     *
     * @param {any} module Module to get the files.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleFiles = function (module, courseId) {
        var handler = this.getPrefetchHandlerFor(module);
        if (handler.getFiles) {
            // The handler defines a function to get files, use it.
            return Promise.resolve(handler.getFiles(module, courseId));
        }
        else if (handler.loadContents) {
            // The handler defines a function to load contents, use it before returning module contents.
            return handler.loadContents(module, courseId).then(function () {
                return module.contents;
            });
        }
        else {
            return Promise.resolve(module.contents || []);
        }
    };
    /**
     * Get the module status.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {any} [updates] Result of getCourseUpdates for all modules in the course. If not provided, it will be
     *                        calculated (slower). If it's false it means the site doesn't support check updates.
     * @param {boolean} [refresh] True if it should ignore the cache.
     * @param {number} [sectionId] ID of the section the module belongs to.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleStatus = function (module, courseId, updates, refresh, sectionId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId(), canCheck = this.canCheckUpdates();
        if (handler) {
            // Check if the status is cached.
            var component_1 = handler.component, packageId_1 = this.filepoolProvider.getPackageId(component_1, module.id);
            var status_1 = this.statusCache.getValue(packageId_1, 'status'), updateStatus_1 = true, promise_1;
            if (!refresh && typeof status_1 != 'undefined') {
                this.storeCourseAndSection(packageId_1, courseId, sectionId);
                return Promise.resolve(this.determineModuleStatus(module, status_1, canCheck));
            }
            // Check if the module is downloadable.
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE;
                }
                // Get the saved package status.
                return _this.filepoolProvider.getPackageStatus(siteId, component_1, module.id).then(function (currentStatus) {
                    status_1 = handler.determineStatus ? handler.determineStatus(module, currentStatus, canCheck) : currentStatus;
                    if (status_1 != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED) {
                        return status_1;
                    }
                    // Module is downloaded. Determine if there are updated in the module to show them outdated.
                    if (typeof updates == 'undefined') {
                        // We don't have course updates, calculate them.
                        promise_1 = _this.getCourseUpdatesByCourseId(courseId);
                    }
                    else if (updates === false) {
                        // Cannot check updates.
                        return status_1;
                    }
                    else {
                        promise_1 = Promise.resolve(updates);
                    }
                    return promise_1.then(function (updates) {
                        if (!updates || updates[module.id] === false) {
                            // Cannot check updates, always show outdated.
                            return __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED;
                        }
                        // Check if the module has any update.
                        return _this.moduleHasUpdates(module, courseId, updates).then(function (hasUpdates) {
                            if (!hasUpdates) {
                                // No updates, keep current status.
                                return status_1;
                            }
                            // Has updates, mark the module as outdated.
                            status_1 = __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED;
                            return _this.filepoolProvider.storePackageStatus(siteId, status_1, component_1, module.id).catch(function () {
                                // Ignore errors.
                            }).then(function () {
                                return status_1;
                            });
                        }).catch(function () {
                            // Error checking if module has updates.
                            var status = _this.statusCache.getValue(packageId_1, 'status', true);
                            return _this.determineModuleStatus(module, status, canCheck);
                        });
                    }, function () {
                        // Error getting updates, show the stored status.
                        updateStatus_1 = false;
                        _this.storeCourseAndSection(packageId_1, courseId, sectionId);
                        return currentStatus;
                    });
                });
            }).then(function (status) {
                if (updateStatus_1) {
                    _this.updateStatusCache(status, component_1, module.id, courseId, sectionId);
                }
                return _this.determineModuleStatus(module, status, canCheck);
            });
        }
        // No handler found, module not downloadable.
        return Promise.resolve(__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE);
    };
    /**
     * Get the status of a list of modules, along with the lists of modules for each status.
     * @see {@link CoreFilepoolProvider.determinePackagesStatus}
     *
     * @param {any[]} modules List of modules to prefetch.
     * @param {number} courseId Course ID the modules belong to.
     * @param {number} [sectionId] ID of the section the modules belong to.
     * @param {boolean} [refresh] True if it should always check the DB (slower).
     * @param {boolean} [onlyToDisplay] True if the status will only be used to determine which button should be displayed.
     * @return {Promise<any>} Promise resolved with an object with the following properties:
     *                                - status (string) Status of the module.
     *                                - total (number) Number of modules.
     *                                - CoreConstants.NOT_DOWNLOADED (any[]) Modules with state NOT_DOWNLOADED.
     *                                - CoreConstants.DOWNLOADED (any[]) Modules with state DOWNLOADED.
     *                                - CoreConstants.DOWNLOADING (any[]) Modules with state DOWNLOADING.
     *                                - CoreConstants.OUTDATED (any[]) Modules with state OUTDATED.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModulesStatus = function (modules, courseId, sectionId, refresh, onlyToDisplay) {
        var _this = this;
        var promises = [], result = {
            total: 0
        };
        var status = __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE;
        // Init result.
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED] = [];
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED] = [];
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADING] = [];
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED] = [];
        // Check updates in course. Don't use getCourseUpdates because the list of modules might not be the whole course list.
        return this.getCourseUpdatesByCourseId(courseId).catch(function () {
            // Cannot get updates.
            return false;
        }).then(function (updates) {
            modules.forEach(function (module) {
                // Check if the module has a prefetch handler.
                var handler = _this.getPrefetchHandlerFor(module);
                if (handler) {
                    if (onlyToDisplay && handler.skipListStatus) {
                        // Skip this module.
                        return;
                    }
                    var packageId_2 = _this.filepoolProvider.getPackageId(handler.component, module.id);
                    promises.push(_this.getModuleStatus(module, courseId, updates, refresh).then(function (modStatus) {
                        if (result[modStatus]) {
                            status = _this.filepoolProvider.determinePackagesStatus(status, modStatus);
                            result[modStatus].push(module);
                            result.total++;
                        }
                    }).catch(function (error) {
                        var cacheStatus = _this.statusCache.getValue(packageId_2, 'status', true);
                        if (typeof cacheStatus == 'undefined') {
                            return Promise.reject(error);
                        }
                        if (result[cacheStatus]) {
                            status = _this.filepoolProvider.determinePackagesStatus(status, cacheStatus);
                            result[cacheStatus].push(module);
                            result.total++;
                        }
                    }));
                }
            });
            return Promise.all(promises).then(function () {
                result.status = status;
                return result;
            });
        });
    };
    /**
     * Get a module status and download time. It will only return the download time if the module is downloaded or outdated.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<{status: string, downloadTime?: number}>} Promise resolved with the data.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleStatusAndDownloadTime = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId();
        if (handler) {
            // Get the status from the cache.
            var packageId = this.filepoolProvider.getPackageId(handler.component, module.id), status_2 = this.statusCache.getValue(packageId, 'status');
            if (typeof status_2 != 'undefined' && status_2 != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED && status_2 != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED) {
                // Module isn't downloaded, just return the status.
                return Promise.resolve({
                    status: status_2
                });
            }
            // Check if the module is downloadable.
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return {
                        status: __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE
                    };
                }
                // Get the stored data to get the status and downloadTime.
                return _this.filepoolProvider.getPackageData(siteId, handler.component, module.id).then(function (data) {
                    return {
                        status: data.status,
                        downloadTime: data.downloadTime || 0
                    };
                });
            });
        }
        // No handler found, module not downloadable.
        return Promise.resolve({
            status: __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE
        });
    };
    /**
     * Get updates for a certain module.
     * It will only return the updates if the module can use check updates and it's downloaded or outdated.
     *
     * @param {any} module Module to check.
     * @param {number} courseId Course the module belongs to.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the updates.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleUpdates = function (module, courseId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Get the status and download time of the module.
            return _this.getModuleStatusAndDownloadTime(module, courseId).then(function (data) {
                if (data.status != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED && data.status != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED) {
                    // Not downloaded, no updates.
                    return {};
                }
                // Module is downloaded. Check if it can check updates.
                return _this.canModuleUseCheckUpdates(module, courseId).then(function (canUse) {
                    if (!canUse) {
                        // Can't use check updates, no updates.
                        return {};
                    }
                    var params = {
                        courseid: courseId,
                        tocheck: [
                            {
                                contextlevel: 'module',
                                id: module.id,
                                since: data.downloadTime || 0
                            }
                        ]
                    }, preSets = {
                        cacheKey: _this.getModuleUpdatesCacheKey(courseId, module.id),
                    };
                    if (ignoreCache) {
                        preSets.getFromCache = false;
                        preSets.emergencyCache = false;
                    }
                    return site.read('core_course_check_updates', params, preSets).then(function (response) {
                        if (!response || !response.instances || !response.instances[0]) {
                            return Promise.reject(null);
                        }
                        return response.instances[0];
                    });
                });
            });
        });
    };
    /**
     * Get cache key for module updates WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} moduleId Module ID.
     * @return {string} Cache key.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleUpdatesCacheKey = function (courseId, moduleId) {
        return this.getCourseUpdatesCacheKey(courseId) + ':' + moduleId;
    };
    /**
     * Get a prefetch handler.
     *
     * @param {any} module The module to work on.
     * @return {CoreCourseModulePrefetchHandler} Prefetch handler.
     */
    CoreCourseModulePrefetchDelegate.prototype.getPrefetchHandlerFor = function (module) {
        return this.getHandler(module.modname, true);
    };
    /**
     * Invalidate check updates WS call.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when data is invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateCourseUpdates = function (courseId) {
        return this.sitesProvider.getCurrentSite().invalidateWsCacheForKey(this.getCourseUpdatesCacheKey(courseId));
    };
    /**
     * Invalidate a list of modules in a course. This should only invalidate WS calls, not downloaded files.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when modules are invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateModules = function (modules, courseId) {
        var _this = this;
        var promises = [];
        modules.forEach(function (module) {
            var handler = _this.getPrefetchHandlerFor(module);
            if (handler) {
                if (handler.invalidateModule) {
                    promises.push(handler.invalidateModule(module, courseId).catch(function () {
                        // Ignore errors.
                    }));
                }
                // Invalidate cache.
                _this.invalidateModuleStatusCache(module);
            }
        });
        promises.push(this.invalidateCourseUpdates(courseId));
        return Promise.all(promises);
    };
    /**
     * Invalidates the cache for a given module.
     *
     * @param {any} module Module to be invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateModuleStatusCache = function (module) {
        var handler = this.getPrefetchHandlerFor(module);
        if (handler) {
            this.statusCache.invalidate(this.filepoolProvider.getPackageId(handler.component, module.id));
        }
    };
    /**
     * Invalidate check updates WS call for a certain module.
     *
     * @param {number} courseId Course ID.
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data is invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateModuleUpdates = function (courseId, moduleId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getModuleUpdatesCacheKey(courseId, moduleId));
        });
    };
    /**
     * Check if a list of modules is being downloaded.
     *
     * @param {string} id An ID to identify the download.
     * @return {boolean} True if it's being downloaded, false otherwise.
     */
    CoreCourseModulePrefetchDelegate.prototype.isBeingDownloaded = function (id) {
        var siteId = this.sitesProvider.getCurrentSiteId();
        return !!(this.prefetchData[siteId] && this.prefetchData[siteId][id]);
    };
    /**
     * Check if a module is downloadable.
     *
     * @param {any} module Module.
     * @param {Number} courseId Course ID the module belongs to.
     * @return {Promise<boolean>} Promise resolved with true if downloadable, false otherwise.
     */
    CoreCourseModulePrefetchDelegate.prototype.isModuleDownloadable = function (module, courseId) {
        var _this = this;
        if (module.uservisible === false) {
            // Module isn't visible by the user, cannot be downloaded.
            return Promise.resolve(false);
        }
        var handler = this.getPrefetchHandlerFor(module);
        if (handler) {
            if (typeof handler.isDownloadable == 'function') {
                var packageId_3 = this.filepoolProvider.getPackageId(handler.component, module.id), downloadable = this.statusCache.getValue(packageId_3, 'downloadable');
                if (typeof downloadable != 'undefined') {
                    return Promise.resolve(downloadable);
                }
                else {
                    return Promise.resolve(handler.isDownloadable(module, courseId)).then(function (downloadable) {
                        return _this.statusCache.setValue(packageId_3, 'downloadable', downloadable);
                    }).catch(function () {
                        // Something went wrong, assume it's not downloadable.
                        return false;
                    });
                }
            }
            else {
                // Function not defined, assume it's not downloadable.
                return Promise.resolve(true);
            }
        }
        else {
            // No handler for module, so it's not downloadable.
            return Promise.resolve(false);
        }
    };
    /**
     * Check if a module has updates based on the result of getCourseUpdates.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {any} updates Result of getCourseUpdates.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the module has updates.
     */
    CoreCourseModulePrefetchDelegate.prototype.moduleHasUpdates = function (module, courseId, updates) {
        var handler = this.getPrefetchHandlerFor(module), moduleUpdates = updates[module.id];
        if (handler && handler.hasUpdates) {
            // Handler implements its own function to check the updates, use it.
            return Promise.resolve(handler.hasUpdates(module, courseId, moduleUpdates));
        }
        else if (!moduleUpdates || !moduleUpdates.updates || !moduleUpdates.updates.length) {
            // Module doesn't have any update.
            return Promise.resolve(false);
        }
        else if (handler && handler.updatesNames && handler.updatesNames.test) {
            // Check the update names defined by the handler.
            for (var i = 0, len = moduleUpdates.updates.length; i < len; i++) {
                if (handler.updatesNames.test(moduleUpdates.updates[i].name)) {
                    return Promise.resolve(true);
                }
            }
            return Promise.resolve(false);
        }
        // Handler doesn't define hasUpdates or updatesNames and there is at least 1 update. Assume it has updates.
        return Promise.resolve(true);
    };
    /**
     * Prefetch a module.
     *
     * @param {any} module Module to prefetch.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<any>} Promise resolved when finished.
     */
    CoreCourseModulePrefetchDelegate.prototype.prefetchModule = function (module, courseId, single) {
        var handler = this.getPrefetchHandlerFor(module);
        // Check if the module has a prefetch handler.
        if (handler) {
            return this.syncModule(module, courseId).then(function () {
                return handler.prefetch(module, courseId, single);
            });
        }
        return Promise.resolve();
    };
    /**
     * Sync a group of modules.
     *
     * @param  {any[]}        modules Array of modules to sync.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>}         Promise resolved when finished.
     */
    CoreCourseModulePrefetchDelegate.prototype.syncModules = function (modules, courseId) {
        var _this = this;
        return Promise.all(modules.map(function (module) {
            return _this.syncModule(module, courseId).then(function () {
                // Invalidate course updates.
                return _this.invalidateCourseUpdates(courseId).catch(function () {
                    // Ignore errors.
                });
            });
        }));
    };
    /**
     * Sync a module.
     *
     * @param {any} module Module to sync.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when finished.
     */
    CoreCourseModulePrefetchDelegate.prototype.syncModule = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module);
        if (handler && handler.sync) {
            return handler.sync(module, courseId).then(function (result) {
                // Always invalidate status cache for this module. We cannot know if data was sent to server or not.
                _this.invalidateModuleStatusCache(module);
                return result;
            }).catch(function () {
                // Ignore errors.
            });
        }
        return Promise.resolve();
    };
    /**
     * Prefetches a list of modules using their prefetch handlers.
     * If a prefetch already exists for this site and id, returns the current promise.
     *
     * @param {string} id An ID to identify the download. It can be used to retrieve the download promise.
     * @param {any[]} modules List of modules to prefetch.
     * @param {number} courseId Course ID the modules belong to.
     * @param {CoreCourseModulesProgressFunction} [onProgress] Function to call everytime a module is downloaded.
     * @return {Promise<any>} Promise resolved when all modules have been prefetched.
     */
    CoreCourseModulePrefetchDelegate.prototype.prefetchModules = function (id, modules, courseId, onProgress) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId(), currentData = this.prefetchData[siteId] && this.prefetchData[siteId][id];
        if (currentData) {
            // There's a prefetch ongoing, return the current promise.
            if (onProgress) {
                currentData.subscriptions.push(currentData.observable.subscribe(onProgress));
            }
            return currentData.promise;
        }
        var count = 0;
        var promises = [], total = modules.length, moduleIds = modules.map(function (module) {
            return module.id;
        }), prefetchData = {
            observable: new __WEBPACK_IMPORTED_MODULE_12_rxjs__["BehaviorSubject"]({ count: count, total: total }),
            promise: undefined,
            subscriptions: []
        };
        if (onProgress) {
            prefetchData.observable.subscribe(onProgress);
        }
        modules.forEach(function (module) {
            // Check if the module has a prefetch handler.
            var handler = _this.getPrefetchHandlerFor(module);
            if (handler) {
                promises.push(_this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                    if (!downloadable) {
                        return;
                    }
                    return handler.prefetch(module, courseId).then(function () {
                        var index = moduleIds.indexOf(module.id);
                        if (index > -1) {
                            // It's one of the modules we were expecting to download.
                            moduleIds.splice(index, 1);
                            count++;
                            prefetchData.observable.next({ count: count, total: total });
                        }
                    });
                }));
            }
        });
        // Set the promise.
        prefetchData.promise = this.utils.allPromises(promises).finally(function () {
            // Unsubscribe all observers.
            prefetchData.subscriptions.forEach(function (subscription) {
                subscription.unsubscribe();
            });
            delete _this.prefetchData[siteId][id];
        });
        // Store the prefetch data in the list.
        if (!this.prefetchData[siteId]) {
            this.prefetchData[siteId] = {};
        }
        this.prefetchData[siteId][id] = prefetchData;
        return prefetchData.promise;
    };
    /**
     * Remove module Files from handler.
     *
     * @param {any} module Module to remove the files.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<void>} Promise resolved when done.
     */
    CoreCourseModulePrefetchDelegate.prototype.removeModuleFiles = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId();
        var promise;
        if (handler && handler.removeFiles) {
            // Handler implements a method to remove the files, use it.
            promise = handler.removeFiles(module, courseId);
        }
        else {
            // No method to remove files, use get files to try to remove the files.
            promise = this.getModuleFiles(module, courseId).then(function (files) {
                var promises = [];
                files.forEach(function (file) {
                    promises.push(_this.filepoolProvider.removeFileByUrl(siteId, file.url || file.fileurl).catch(function () {
                        // Ignore errors.
                    }));
                });
                return Promise.all(promises);
            });
        }
        return promise.then(function () {
            if (handler) {
                // Update status of the module.
                var packageId = _this.filepoolProvider.getPackageId(handler.component, module.id);
                _this.statusCache.setValue(packageId, 'downloadedSize', 0);
                return _this.filepoolProvider.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED, handler.component, module.id);
            }
        });
    };
    /**
     * Set an on progress function for the download of a list of modules.
     *
     * @param {string} id An ID to identify the download.
     * @param {CoreCourseModulesProgressFunction} onProgress Function to call everytime a module is downloaded.
     */
    CoreCourseModulePrefetchDelegate.prototype.setOnProgress = function (id, onProgress) {
        var siteId = this.sitesProvider.getCurrentSiteId(), currentData = this.prefetchData[siteId] && this.prefetchData[siteId][id];
        if (currentData) {
            // There's a prefetch ongoing, return the current promise.
            currentData.subscriptions.push(currentData.observable.subscribe(onProgress));
        }
    };
    /**
     * If courseId or sectionId is set, save them in the cache.
     *
     * @param {string} packageId The package ID.
     * @param {number} [courseId] Course ID.
     * @param {number} [sectionId] Section ID.
     */
    CoreCourseModulePrefetchDelegate.prototype.storeCourseAndSection = function (packageId, courseId, sectionId) {
        if (courseId) {
            this.statusCache.setValue(packageId, 'courseId', courseId);
        }
        if (sectionId && sectionId > 0) {
            this.statusCache.setValue(packageId, 'sectionId', sectionId);
        }
    };
    /**
     * Treat the result of the check updates WS call.
     *
     * @param {any[]} toCheckList List of modules to check (from createToCheckList).
     * @param {any} response WS call response.
     * @param {any} result Object where to store the result.
     * @param {number} [previousTime] Time of the previous check updates execution. If set, modules downloaded
     *                                after this time will be ignored.
     * @return {any} Result.
     */
    CoreCourseModulePrefetchDelegate.prototype.treatCheckUpdatesResult = function (toCheckList, response, result, previousTime) {
        // Format the response to index it by module ID.
        this.utils.arrayToObject(response.instances, 'id', result);
        // Treat warnings, adding the not supported modules.
        response.warnings.forEach(function (warning) {
            if (warning.warningcode == 'missingcallback') {
                result[warning.itemid] = false;
            }
        });
        if (previousTime) {
            // Remove from the list the modules downloaded after previousTime.
            toCheckList.forEach(function (entry) {
                if (result[entry.id] && entry.since > previousTime) {
                    delete result[entry.id];
                }
            });
        }
        return result;
    };
    /**
     * Update the status of a module in the "cache".
     *
     * @param {string} status New status.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [courseId] Course ID of the module.
     * @param {number} [sectionId] Section ID of the module.
     */
    CoreCourseModulePrefetchDelegate.prototype.updateStatusCache = function (status, component, componentId, courseId, sectionId) {
        var packageId = this.filepoolProvider.getPackageId(component, componentId), cachedStatus = this.statusCache.getValue(packageId, 'status', true);
        var notify;
        // If the status has changed, notify that the section has changed.
        notify = typeof cachedStatus != 'undefined' && cachedStatus !== status;
        // If courseId/sectionId is set, store it.
        this.storeCourseAndSection(packageId, courseId, sectionId);
        if (notify) {
            if (!courseId) {
                courseId = this.statusCache.getValue(packageId, 'courseId', true);
            }
            if (!sectionId) {
                sectionId = this.statusCache.getValue(packageId, 'sectionId', true);
            }
            // Invalidate and set again.
            this.statusCache.invalidate(packageId);
            this.statusCache.setValue(packageId, 'status', status);
            if (sectionId) {
                this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].SECTION_STATUS_CHANGED, {
                    sectionId: sectionId,
                    courseId: courseId
                }, this.sitesProvider.getCurrentSiteId());
            }
        }
        else {
            this.statusCache.setValue(packageId, 'status', status);
        }
    };
    CoreCourseModulePrefetchDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreCourseModulePrefetchDelegate);
    return CoreCourseModulePrefetchDelegate;
}(__WEBPACK_IMPORTED_MODULE_13__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=module-prefetch-delegate.js.map

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoadingComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_animations__ = __webpack_require__(1481);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Component to show a loading spinner and message while data is being loaded.
 *
 * It will show a spinner with a message and hide all the content until 'dataLoaded' variable is set to true.
 * If 'message' and 'dynMessage' attributes aren't set, default message "Loading" is shown.
 * 'message' attribute accepts hardcoded strings, variables, filters, etc. E.g. message="'core.loading' | translate".
 *
 * Usage:
 * <core-loading [message]="loadingMessage" [hideUntil]="dataLoaded">
 *     <!-- CONTENT TO HIDE UNTIL LOADED -->
 * </core-loading>
 *
 * IMPORTANT: Due to how ng-content works in Angular, the content of core-loading will be executed as soon as your view
 * is loaded, even if the content hidden. So if you have the following code:
 * <core-loading [hideUntil]="dataLoaded"><my-component></my-component></core-loading>
 *
 * The component "my-component" will be initialized immediately, even if dataLoaded is false, but it will be hidden. If you want
 * your component to be initialized only if dataLoaded is true, then you should use ngIf:
 * <core-loading [hideUntil]="dataLoaded"><my-component *ngIf="dataLoaded"></my-component></core-loading>
 */
var CoreLoadingComponent = /** @class */ (function () {
    function CoreLoadingComponent(translate, element, eventsProvider, utils) {
        this.translate = translate;
        this.eventsProvider = eventsProvider;
        this.element = element.nativeElement;
        // Calculate the unique ID.
        this.uniqueId = 'core-loading-content-' + utils.getUniqueId('CoreLoadingComponent');
    }
    /**
     * Component being initialized.
     */
    CoreLoadingComponent.prototype.ngOnInit = function () {
        if (!this.message) {
            // Default loading message.
            this.message = this.translate.instant('core.loading');
        }
        // Add class if loaded on init.
        if (this.hideUntil) {
            this.element.classList.add('core-loading-loaded');
            this.content.nativeElement.classList.add('core-loading-content');
        }
    };
    CoreLoadingComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.hideUntil) {
            if (changes.hideUntil.currentValue === true) {
                setTimeout(function () {
                    // Content is loaded so, center the spinner on the content itself.
                    _this.element.classList.add('core-loading-loaded');
                    setTimeout(function () {
                        // Change CSS to force calculate height.
                        _this.content.nativeElement.classList.add('core-loading-content');
                    }, 500);
                });
            }
            else {
                this.element.classList.remove('core-loading-loaded');
                this.content.nativeElement.classList.remove('core-loading-content');
            }
            // Trigger the event after a timeout since the elements inside ngIf haven't been added to DOM yet.
            setTimeout(function () {
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].CORE_LOADING_CHANGED, {
                    loaded: changes.hideUntil.currentValue,
                    uniqueId: _this.uniqueId
                });
            });
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreLoadingComponent.prototype, "hideUntil", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreLoadingComponent.prototype, "message", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('content'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreLoadingComponent.prototype, "content", void 0);
    CoreLoadingComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-loading',
            templateUrl: 'core-loading.html',
            animations: [__WEBPACK_IMPORTED_MODULE_2__classes_animations__["a" /* coreShowHideAnimation */]]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreLoadingComponent);
    return CoreLoadingComponent;
}());

//# sourceMappingURL=loading.js.map

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service that provides some features regarding lists of courses and categories.
 */
var CoreCoursesProvider = /** @class */ (function () {
    function CoreCoursesProvider(logger, sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.ROOT_CACHE_KEY = 'mmCourses:';
        this.logger = logger.getInstance('CoreCoursesProvider');
    }
    CoreCoursesProvider_1 = CoreCoursesProvider;
    /**
     * Whether current site supports getting course options.
     *
     * @return {boolean} Whether current site supports getting course options.
     */
    CoreCoursesProvider.prototype.canGetAdminAndNavOptions = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_course_get_user_navigation_options') &&
            this.sitesProvider.wsAvailableInCurrentSite('core_course_get_user_administration_options');
    };
    /**
     * Get categories. They can be filtered by id.
     *
     * @param {number} categoryId Category ID to get.
     * @param {boolean} [addSubcategories] If it should add subcategories to the list.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with the categories.
     */
    CoreCoursesProvider.prototype.getCategories = function (categoryId, addSubcategories, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Get parent when id is the root category.
            var criteriaKey = categoryId == 0 ? 'parent' : 'id', data = {
                criteria: [
                    { key: criteriaKey, value: categoryId }
                ],
                addsubcategories: addSubcategories ? 1 : 0
            }, preSets = {
                cacheKey: _this.getCategoriesCacheKey(categoryId, addSubcategories),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_course_get_categories', data, preSets);
        });
    };
    /**
     * Get cache key for get categories methods WS call.
     *
     * @param {number} categoryId Category ID to get.
     * @param {boolean} [addSubcategories] If add subcategories to the list.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCategoriesCacheKey = function (categoryId, addSubcategories) {
        return this.ROOT_CACHE_KEY + 'categories:' + categoryId + ':' + !!addSubcategories;
    };
    /**
     * Given a list of course IDs to get course admin and nav options, return the list of courseIds to use.
     *
     * @param {number[]} courseIds Course IDs.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise}            Promise resolved with the list of course IDs.
     */
    CoreCoursesProvider.prototype.getCourseIdsForAdminAndNavOptions = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var siteHomeId = site.getSiteHomeId();
            if (courseIds.length == 1) {
                // Only 1 course, check if it belongs to the user courses. If so, use all user courses.
                return _this.getUserCourses(true, siteId).then(function (courses) {
                    var courseId = courseIds[0];
                    var useAllCourses = false;
                    if (courseId == siteHomeId) {
                        // It's site home, use all courses.
                        useAllCourses = true;
                    }
                    else {
                        for (var i = 0; i < courses.length; i++) {
                            if (courses[i].id == courseId) {
                                useAllCourses = true;
                                break;
                            }
                        }
                    }
                    if (useAllCourses) {
                        // User is enrolled, retrieve all the courses.
                        courseIds = courses.map(function (course) {
                            return course.id;
                        });
                        // Always add the site home ID.
                        courseIds.push(siteHomeId);
                        // Sort the course IDs.
                        courseIds.sort(function (a, b) {
                            return b - a;
                        });
                    }
                    return courseIds;
                }).catch(function () {
                    // Ignore errors.
                    return courseIds;
                });
            }
            else {
                if (courseIds.length > 1 && courseIds.indexOf(siteHomeId) == -1) {
                    courseIds.push(siteHomeId);
                }
                // Sort the course IDs.
                courseIds.sort(function (a, b) {
                    return b - a;
                });
                return courseIds;
            }
        });
    };
    /**
     * Check if download a whole course is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreCoursesProvider.prototype.isDownloadCourseDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isDownloadCoursesDisabledInSite(site);
        });
    };
    /**
     * Check if download a whole course is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesProvider.prototype.isDownloadCourseDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isOfflineDisabled() || site.isFeatureDisabled('NoDelegate_CoreCourseDownload');
    };
    /**
     * Check if download all courses is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreCoursesProvider.prototype.isDownloadCoursesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isDownloadCoursesDisabledInSite(site);
        });
    };
    /**
     * Check if download all courses is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesProvider.prototype.isDownloadCoursesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isOfflineDisabled() || site.isFeatureDisabled('NoDelegate_CoreCoursesDownload');
    };
    /**
     * Check if My Courses is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreCoursesProvider.prototype.isMyCoursesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isMyCoursesDisabledInSite(site);
        });
    };
    /**
     * Check if My Courses is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesProvider.prototype.isMyCoursesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('CoreMainMenuDelegate_CoreCourses');
    };
    /**
     * Check if Search Courses is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreCoursesProvider.prototype.isSearchCoursesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isSearchCoursesDisabledInSite(site);
        });
    };
    /**
     * Check if Search Courses is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesProvider.prototype.isSearchCoursesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('CoreCourseOptionsDelegate_search');
    };
    /**
     * Get course.
     *
     * @param {number} id ID of the course to get.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the course.
     */
    CoreCoursesProvider.prototype.getCourse = function (id, siteId) {
        return this.getCourses([id], siteId).then(function (courses) {
            if (courses && courses.length > 0) {
                return courses[0];
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get the enrolment methods from a course.
     *
     * @param {number} id ID of the course.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any[]} Promise resolved with the methods.
     */
    CoreCoursesProvider.prototype.getCourseEnrolmentMethods = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseid: id
            }, preSets = {
                cacheKey: _this.getCourseEnrolmentMethodsCacheKey(id),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_enrol_get_course_enrolment_methods', params, preSets);
        });
    };
    /**
     * Get cache key for get course enrolment methods WS call.
     *
     * @param {number} id Course ID.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCourseEnrolmentMethodsCacheKey = function (id) {
        return this.ROOT_CACHE_KEY + 'enrolmentmethods:' + id;
    };
    /**
     * Get info from a course guest enrolment method.
     *
     * @param {number} instanceId Guest instance ID.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the info is retrieved.
     */
    CoreCoursesProvider.prototype.getCourseGuestEnrolmentInfo = function (instanceId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                instanceid: instanceId
            }, preSets = {
                cacheKey: _this.getCourseGuestEnrolmentInfoCacheKey(instanceId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('enrol_guest_get_instance_info', params, preSets).then(function (response) {
                return response.instanceinfo;
            });
        });
    };
    /**
     * Get cache key for get course guest enrolment methods WS call.
     *
     * @param {number} instanceId Guest instance ID.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCourseGuestEnrolmentInfoCacheKey = function (instanceId) {
        return this.ROOT_CACHE_KEY + 'guestinfo:' + instanceId;
    };
    /**
     * Get courses.
     * Warning: if the user doesn't have permissions to view some of the courses passed the WS call will fail.
     * The user must be able to view ALL the courses passed.
     *
     * @param {number[]} ids List of IDs of the courses to get.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any[]>}  Promise resolved with the courses.
     */
    CoreCoursesProvider.prototype.getCourses = function (ids, siteId) {
        var _this = this;
        if (!Array.isArray(ids)) {
            return Promise.reject(null);
        }
        else if (ids.length === 0) {
            return Promise.resolve([]);
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                options: {
                    ids: ids
                }
            }, preSets = {
                cacheKey: _this.getCoursesCacheKey(ids),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_course_get_courses', data, preSets);
        });
    };
    /**
     * Get cache key for get courses WS call.
     *
     * @param {number[]} ids Courses IDs.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCoursesCacheKey = function (ids) {
        return this.ROOT_CACHE_KEY + 'course:' + JSON.stringify(ids);
    };
    /**
     * This function is meant to decrease WS calls.
     * When requesting a single course that belongs to enrolled courses, request all enrolled courses because
     * the WS call is probably cached.
     *
     * @param {string} [field] The field to search.
     * @param {any} [value] The value to match.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{field: string, value: any}>} Promise resolved with the field and value to use.
     */
    CoreCoursesProvider.prototype.fixCoursesByFieldParams = function (field, value, siteId) {
        if (field == 'id' || field == 'ids') {
            var courseIds = String(value).split(',');
            // Use the same optimization as in get admin and nav options. This will return the course IDs to use.
            return this.getCourseIdsForAdminAndNavOptions(courseIds, siteId).then(function (courseIds) {
                if (courseIds.length > 1) {
                    return { field: 'ids', value: courseIds.join(',') };
                }
                else {
                    return { field: 'id', value: Number(courseIds[0]) };
                }
            });
        }
        else {
            // Nothing to do.
            return Promise.resolve({ field: field, value: value });
        }
    };
    /**
     * Get the first course returned by getCoursesByField.
     *
     * @param {string} [field] The field to search. Can be left empty for all courses or:
     *                             id: course id.
     *                             ids: comma separated course ids.
     *                             shortname: course short name.
     *                             idnumber: course id number.
     *                             category: category id the course belongs to.
     * @param {any} [value] The value to match.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the first course.
     * @since 3.2
     */
    CoreCoursesProvider.prototype.getCourseByField = function (field, value, siteId) {
        return this.getCoursesByField(field, value, siteId).then(function (courses) {
            if (courses && courses.length > 0) {
                return courses[0];
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get courses. They can be filtered by field.
     *
     * @param {string} [field] The field to search. Can be left empty for all courses or:
     *                             id: course id.
     *                             ids: comma separated course ids.
     *                             shortname: course short name.
     *                             idnumber: course id number.
     *                             category: category id the course belongs to.
     * @param {any} [value] The value to match.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with the courses.
     * @since 3.2
     */
    CoreCoursesProvider.prototype.getCoursesByField = function (field, value, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var originalValue = value;
        var hasChanged = false;
        return this.fixCoursesByFieldParams(field, value, siteId).then(function (result) {
            hasChanged = result.field != field || result.value != value;
            field = result.field;
            value = result.value;
            return _this.sitesProvider.getSite(siteId);
        }).then(function (site) {
            var data = {
                field: field || '',
                value: field ? value : ''
            }, preSets = {
                cacheKey: _this.getCoursesByFieldCacheKey(field, value),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_course_get_courses_by_field', data, preSets).then(function (courses) {
                if (courses.courses) {
                    if (field == 'ids' && hasChanged) {
                        // The list of courses requestes was changed to optimize it.
                        // Return only the ones that were being requested.
                        var courseIds_1 = String(originalValue).split(','), finalCourses_1 = [];
                        courses.courses.forEach(function (course) {
                            var position = courseIds_1.indexOf(String(course.id));
                            if (position != -1) {
                                // Course is in the original list, take it.
                                finalCourses_1.push(course);
                                courseIds_1.splice(position, 1);
                            }
                        });
                        courses.courses = finalCourses_1;
                    }
                    // Courses will be sorted using sortorder if avalaible.
                    return courses.courses.sort(function (a, b) {
                        if (typeof a.sortorder == 'undefined' && typeof b.sortorder == 'undefined') {
                            return b.id - a.id;
                        }
                        if (typeof a.sortorder == 'undefined') {
                            return 1;
                        }
                        if (typeof b.sortorder == 'undefined') {
                            return -1;
                        }
                        return a.sortorder - b.sortorder;
                    });
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get courses WS call.
     *
     * @param {string} [field] The field to search.
     * @param {any} [value] The value to match.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCoursesByFieldCacheKey = function (field, value) {
        field = field || '';
        value = field ? value : '';
        return this.ROOT_CACHE_KEY + 'coursesbyfield:' + field + ':' + value;
    };
    /**
     * Check if get courses by field WS is available in a certain site.
     *
     * @param {CoreSite} [site] Site to check.
     * @return {boolean} Whether get courses by field is available.
     * @since 3.2
     */
    CoreCoursesProvider.prototype.isGetCoursesByFieldAvailable = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.wsAvailable('core_course_get_courses_by_field');
    };
    /**
     * Check if get courses by field WS is available in a certain site, by site ID.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether get courses by field is available.
     * @since 3.2
     */
    CoreCoursesProvider.prototype.isGetCoursesByFieldAvailableInSite = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isGetCoursesByFieldAvailable(site);
        });
    };
    /**
     * Get the navigation and administration options for the given courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{navOptions: any, admOptions: any}>} Promise resolved with the options for each course.
     */
    CoreCoursesProvider.prototype.getCoursesAdminAndNavOptions = function (courseIds, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get the list of courseIds to use based on the param.
        return this.getCourseIdsForAdminAndNavOptions(courseIds, siteId).then(function (courseIds) {
            var promises = [];
            var navOptions, admOptions;
            // Get user navigation and administration options.
            promises.push(_this.getUserNavigationOptions(courseIds, siteId).catch(function () {
                // Couldn't get it, return empty options.
                return {};
            }).then(function (options) {
                navOptions = options;
            }));
            promises.push(_this.getUserAdministrationOptions(courseIds, siteId).catch(function () {
                // Couldn't get it, return empty options.
                return {};
            }).then(function (options) {
                admOptions = options;
            }));
            return Promise.all(promises).then(function () {
                return { navOptions: navOptions, admOptions: admOptions };
            });
        });
    };
    /**
     * Get the common part of the cache keys for user administration options WS calls.
     *
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserAdministrationOptionsCommonCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'administrationOptions:';
    };
    /**
     * Get cache key for get user administration options WS call.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserAdministrationOptionsCacheKey = function (courseIds) {
        return this.getUserAdministrationOptionsCommonCacheKey() + courseIds.join(',');
    };
    /**
     * Get user administration options for a set of courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with administration options for each course.
     */
    CoreCoursesProvider.prototype.getUserAdministrationOptions = function (courseIds, siteId) {
        var _this = this;
        if (!courseIds || courseIds.length == 0) {
            return Promise.resolve({});
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: courseIds
            }, preSets = {
                cacheKey: _this.getUserAdministrationOptionsCacheKey(courseIds),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_course_get_user_administration_options', params, preSets).then(function (response) {
                // Format returned data.
                return _this.formatUserAdminOrNavOptions(response.courses);
            });
        });
    };
    /**
     * Get the common part of the cache keys for user navigation options WS calls.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserNavigationOptionsCommonCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'navigationOptions:';
    };
    /**
     * Get cache key for get user navigation options WS call.
     *
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserNavigationOptionsCacheKey = function (courseIds) {
        return this.getUserNavigationOptionsCommonCacheKey() + courseIds.join(',');
    };
    /**
     * Get user navigation options for a set of courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with navigation options for each course.
     */
    CoreCoursesProvider.prototype.getUserNavigationOptions = function (courseIds, siteId) {
        var _this = this;
        if (!courseIds || courseIds.length == 0) {
            return Promise.resolve({});
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: courseIds
            }, preSets = {
                cacheKey: _this.getUserNavigationOptionsCacheKey(courseIds),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_course_get_user_navigation_options', params, preSets).then(function (response) {
                // Format returned data.
                return _this.formatUserAdminOrNavOptions(response.courses);
            });
        });
    };
    /**
     * Format user navigation or administration options.
     *
     * @param {any[]} courses Navigation or administration options for each course.
     * @return {any} Formatted options.
     */
    CoreCoursesProvider.prototype.formatUserAdminOrNavOptions = function (courses) {
        var result = {};
        courses.forEach(function (course) {
            var options = {};
            if (course.options) {
                course.options.forEach(function (option) {
                    options[option.name] = option.available;
                });
            }
            result[course.id] = options;
        });
        return result;
    };
    /**
     * Get a course the user is enrolled in. This function relies on getUserCourses.
     * preferCache=true will try to speed up the response, but the data returned might not be updated.
     *
     * @param {number} id ID of the course to get.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the course.
     */
    CoreCoursesProvider.prototype.getUserCourse = function (id, preferCache, siteId) {
        if (!id) {
            return Promise.reject(null);
        }
        return this.getUserCourses(preferCache, siteId).then(function (courses) {
            var course;
            for (var i in courses) {
                if (courses[i].id == id) {
                    course = courses[i];
                    break;
                }
            }
            return course ? course : Promise.reject(null);
        });
    };
    /**
     * Get user courses.
     *
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with the courses.
     */
    CoreCoursesProvider.prototype.getUserCourses = function (preferCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userId = site.getUserId(), data = {
                userid: userId
            }, preSets = {
                cacheKey: _this.getUserCoursesCacheKey(),
                getCacheUsingCacheKey: true,
                omitExpires: !!preferCache,
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (site.isVersionGreaterEqualThan('3.7')) {
                data.returnusercount = 0;
            }
            return site.read('core_enrol_get_users_courses', data, preSets);
        });
    };
    /**
     * Get cache key for get user courses WS call.
     *
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserCoursesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'usercourses';
    };
    /**
     * Invalidates get categories WS call.
     *
     * @param {number} categoryId Category ID to get.
     * @param {boolean} [addSubcategories] If it should add subcategories to the list.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCategories = function (categoryId, addSubcategories, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCategoriesCacheKey(categoryId, addSubcategories));
        });
    };
    /**
     * Invalidates get course WS call.
     *
     * @param {number} id Course ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourse = function (id, siteId) {
        return this.invalidateCourses([id], siteId);
    };
    /**
     * Invalidates get course enrolment methods WS call.
     *
     * @param {number} id Course ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourseEnrolmentMethods = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseEnrolmentMethodsCacheKey(id));
        });
    };
    /**
     * Invalidates get course guest enrolment info WS call.
     *
     * @param {number} instanceId Guest instance ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourseGuestEnrolmentInfo = function (instanceId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseGuestEnrolmentInfoCacheKey(instanceId));
        });
    };
    /**
     * Invalidates the navigation and administration options for the given courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCoursesAdminAndNavOptions = function (courseIds, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getCourseIdsForAdminAndNavOptions(courseIds, siteId).then(function (ids) {
            var promises = [];
            promises.push(_this.invalidateUserAdministrationOptionsForCourses(ids, siteId));
            promises.push(_this.invalidateUserNavigationOptionsForCourses(ids, siteId));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates get courses WS call.
     *
     * @param {number[]} ids Courses IDs.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourses = function (ids, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCoursesCacheKey(ids));
        });
    };
    /**
     * Invalidates get courses by field WS call.
     *
     * @param {string} [field] See getCoursesByField for info.
     * @param {any} [value] The value to match.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCoursesByField = function (field, value, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.fixCoursesByFieldParams(field, value, siteId).then(function (result) {
            field = result.field;
            value = result.value;
            return _this.sitesProvider.getSite(siteId);
        }).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCoursesByFieldCacheKey(field, value));
        });
    };
    /**
     * Invalidates all user administration options.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserAdministrationOptions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserAdministrationOptionsCommonCacheKey());
        });
    };
    /**
     * Invalidates user administration options for certain courses.
     *
     * @param {number[]} courseIds IDs of courses.
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserAdministrationOptionsForCourses = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserAdministrationOptionsCacheKey(courseIds));
        });
    };
    /**
     * Invalidates get user courses WS call.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserCourses = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserCoursesCacheKey());
        });
    };
    /**
     * Invalidates all user navigation options.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserNavigationOptions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserNavigationOptionsCommonCacheKey());
        });
    };
    /**
     * Invalidates user navigation options for certain courses.
     *
     * @param {number[]} courseIds IDs of courses.
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserNavigationOptionsForCourses = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserNavigationOptionsCacheKey(courseIds));
        });
    };
    /**
     * Check if WS to retrieve guest enrolment data is available.
     *
     * @return {boolean} Whether guest WS is available.
     */
    CoreCoursesProvider.prototype.isGuestWSAvailable = function () {
        var currentSite = this.sitesProvider.getCurrentSite();
        return currentSite && currentSite.wsAvailable('enrol_guest_get_instance_info');
    };
    /**
     * Search courses.
     *
     * @param {string} text Text to search.
     * @param {number} [page=0] Page to get.
     * @param {number} [perPage] Number of courses per page. Defaults to CoreCoursesProvider.SEARCH_PER_PAGE.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{total: number, courses: any[]}>} Promise resolved with the courses and the total of matches.
     */
    CoreCoursesProvider.prototype.search = function (text, page, perPage, siteId) {
        if (page === void 0) { page = 0; }
        perPage = perPage || CoreCoursesProvider_1.SEARCH_PER_PAGE;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                criterianame: 'search',
                criteriavalue: text,
                page: page,
                perpage: perPage
            }, preSets = {
                getFromCache: false
            };
            return site.read('core_course_search_courses', params, preSets).then(function (response) {
                return { total: response.total, courses: response.courses };
            });
        });
    };
    /**
     * Self enrol current user in a certain course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [password] Password to use.
     * @param {number} [instanceId] Enrol instance ID.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved if the user is enrolled. If the password is invalid, the promise is rejected
     *                        with an object with code = CoreCoursesProvider.ENROL_INVALID_KEY.
     */
    CoreCoursesProvider.prototype.selfEnrol = function (courseId, password, instanceId, siteId) {
        if (password === void 0) { password = ''; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseid: courseId,
                password: password
            };
            if (instanceId) {
                params.instanceid = instanceId;
            }
            return site.write('enrol_self_enrol_user', params).then(function (response) {
                if (response) {
                    if (response.status) {
                        return true;
                    }
                    else if (response.warnings && response.warnings.length) {
                        var message_1;
                        response.warnings.forEach(function (warning) {
                            // Invalid password warnings.
                            if (warning.warningcode == '2' || warning.warningcode == '3' || warning.warningcode == '4') {
                                message_1 = warning.message;
                            }
                        });
                        if (message_1) {
                            return Promise.reject({ code: CoreCoursesProvider_1.ENROL_INVALID_KEY, message: message_1 });
                        }
                        else {
                            return Promise.reject(response.warnings[0]);
                        }
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Set favourite property on a course.
     *
     * @param {number} courseId   Course ID.
     * @param {boolean} favourite If favourite or unfavourite.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCoursesProvider.prototype.setFavouriteCourse = function (courseId, favourite, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courses: [
                    {
                        id: courseId,
                        favourite: favourite ? 1 : 0
                    }
                ]
            };
            return site.write('core_course_set_favourite_courses', params);
        });
    };
    CoreCoursesProvider.SEARCH_PER_PAGE = 20;
    CoreCoursesProvider.ENROL_INVALID_KEY = 'CoreCoursesEnrolInvalidKey';
    CoreCoursesProvider.EVENT_MY_COURSES_UPDATED = 'courses_my_courses_updated';
    CoreCoursesProvider.EVENT_MY_COURSES_REFRESHED = 'courses_my_courses_refreshed';
    CoreCoursesProvider.EVENT_DASHBOARD_DOWNLOAD_ENABLED_CHANGED = 'dashboard_download_enabled_changed';
    CoreCoursesProvider = CoreCoursesProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreCoursesProvider);
    return CoreCoursesProvider;
    var CoreCoursesProvider_1;
}());

//# sourceMappingURL=courses.js.map

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSite; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_db__ = __webpack_require__(406);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_ws__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__configconstants__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
















/**
 * Class that represents a site (combination of site + user).
 * It will have all the site data and provide utility functions regarding a site.
 * To add tables to the site's database, please use CoreSitesProvider.createTablesFromSchema. This will make sure that
 * the tables are created in all the sites, not just the current one.
 */
var CoreSite = /** @class */ (function () {
    /**
     * Create a site.
     *
     * @param {Injector} injector Angular injector to prevent having to pass all the required services.
     * @param {string} id Site ID.
     * @param {string} siteUrl Site URL.
     * @param {string} [token] Site's WS token.
     * @param {any} [info] Site info.
     * @param {string} [privateToken] Private token.
     * @param {any} [config] Site public config.
     * @param {boolean} [loggedOut] Whether user is logged out.
     */
    function CoreSite(injector, id, siteUrl, token, infos, privateToken, config, loggedOut) {
        this.id = id;
        this.siteUrl = siteUrl;
        this.token = token;
        this.infos = infos;
        this.privateToken = privateToken;
        this.config = config;
        this.loggedOut = loggedOut;
        // Versions of Moodle releases.
        this.MOODLE_RELEASES = {
            3.1: 2016052300,
            3.2: 2016120500,
            3.3: 2017051503,
            3.4: 2017111300,
            3.5: 2018051700,
            3.6: 2018120300,
            3.7: 2019052000
        };
        // Possible cache update frequencies.
        this.UPDATE_FREQUENCIES = [
            __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].cache_update_frequency_usually || 420000,
            __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].cache_update_frequency_often || 1200000,
            __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].cache_update_frequency_sometimes || 3600000,
            __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].cache_update_frequency_rarely || 43200000
        ];
        this.cleanUnicode = false;
        this.lastAutoLogin = 0;
        this.offlineDisabled = false;
        this.ongoingRequests = {};
        this.requestQueue = [];
        this.requestQueueTimeout = null;
        // Inject the required services.
        var logger = injector.get(__WEBPACK_IMPORTED_MODULE_6__providers_logger__["a" /* CoreLoggerProvider */]);
        this.appProvider = injector.get(__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */]);
        this.dbProvider = injector.get(__WEBPACK_IMPORTED_MODULE_3__providers_db__["a" /* CoreDbProvider */]);
        this.domUtils = injector.get(__WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */]);
        this.eventsProvider = injector.get(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */]);
        this.fileProvider = injector.get(__WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */]);
        this.http = injector.get(__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpClient */]);
        this.textUtils = injector.get(__WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */]);
        this.timeUtils = injector.get(__WEBPACK_IMPORTED_MODULE_10__providers_utils_time__["a" /* CoreTimeUtilsProvider */]);
        this.translate = injector.get(__WEBPACK_IMPORTED_MODULE_0__ngx_translate_core__["c" /* TranslateService */]);
        this.utils = injector.get(__WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__["a" /* CoreUtilsProvider */]);
        this.urlUtils = injector.get(__WEBPACK_IMPORTED_MODULE_11__providers_utils_url__["a" /* CoreUrlUtilsProvider */]);
        this.wsProvider = injector.get(__WEBPACK_IMPORTED_MODULE_7__providers_ws__["a" /* CoreWSProvider */]);
        this.logger = logger.getInstance('CoreWSProvider');
        this.setInfo(infos);
        this.calculateOfflineDisabled();
        if (this.id) {
            this.initDB();
        }
    }
    /**
     * Initialize the database.
     */
    CoreSite.prototype.initDB = function () {
        this.db = this.dbProvider.getDB('Site-' + this.id);
    };
    /**
     * Get site ID.
     *
     * @return {string} Site ID.
     */
    CoreSite.prototype.getId = function () {
        return this.id;
    };
    /**
     * Get site URL.
     *
     * @return {string} Site URL.
     */
    CoreSite.prototype.getURL = function () {
        return this.siteUrl;
    };
    /**
     * Get site token.
     *
     * @return {string} Site token.
     */
    CoreSite.prototype.getToken = function () {
        return this.token;
    };
    /**
     * Get site info.
     *
     * @return {any} Site info.
     */
    CoreSite.prototype.getInfo = function () {
        return this.infos;
    };
    /**
     * Get site private token.
     *
     * @return {string} Site private token.
     */
    CoreSite.prototype.getPrivateToken = function () {
        return this.privateToken;
    };
    /**
     * Get site DB.
     *
     * @return {SQLiteDB} Site DB.
     */
    CoreSite.prototype.getDb = function () {
        return this.db;
    };
    /**
     * Get site user's ID.
     *
     * @return {number} User's ID.
     */
    CoreSite.prototype.getUserId = function () {
        if (typeof this.infos != 'undefined' && typeof this.infos.userid != 'undefined') {
            return this.infos.userid;
        }
    };
    /**
     * Get site Course ID for frontpage course. If not declared it will return 1 as default.
     *
     * @return {number} Site Home ID.
     */
    CoreSite.prototype.getSiteHomeId = function () {
        return this.infos && this.infos.siteid || 1;
    };
    /**
     * Get site name.
     *
     * @return {string} Site name.
     */
    CoreSite.prototype.getSiteName = function () {
        if (__WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].sitename) {
            // Overridden by config.
            return __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].sitename;
        }
        else {
            return this.infos && this.infos.sitename || '';
        }
    };
    /**
     * Set site ID.
     *
     * @param {string} New ID.
     */
    CoreSite.prototype.setId = function (id) {
        this.id = id;
        this.initDB();
    };
    /**
     * Set site token.
     *
     * @param {string} New token.
     */
    CoreSite.prototype.setToken = function (token) {
        this.token = token;
    };
    /**
     * Set site private token.
     *
     * @param {string} privateToken New private token.
     */
    CoreSite.prototype.setPrivateToken = function (privateToken) {
        this.privateToken = privateToken;
    };
    /**
     * Check if user logged out from the site and needs to authenticate again.
     *
     * @return {boolean} Whether is logged out.
     */
    CoreSite.prototype.isLoggedOut = function () {
        return !!this.loggedOut;
    };
    /**
     * Set site info.
     *
     * @param {any} New info.
     */
    CoreSite.prototype.setInfo = function (infos) {
        this.infos = infos;
        // Index function by name to speed up wsAvailable method.
        if (infos && infos.functions) {
            infos.functionsByName = {};
            infos.functions.forEach(function (func) {
                infos.functionsByName[func.name] = func;
            });
        }
    };
    /**
     * Set site config.
     *
     * @param {any} Config.
     */
    CoreSite.prototype.setConfig = function (config) {
        if (config) {
            config.tool_mobile_disabledfeatures = this.textUtils.treatDisabledFeatures(config.tool_mobile_disabledfeatures);
        }
        this.config = config;
        this.calculateOfflineDisabled();
    };
    /**
     * Set site logged out.
     *
     * @param {boolean} loggedOut True if logged out and needs to authenticate again, false otherwise.
     */
    CoreSite.prototype.setLoggedOut = function (loggedOut) {
        this.loggedOut = !!loggedOut;
    };
    /**
     * Can the user access their private files?
     *
     * @return {boolean} Whether can access my files.
     */
    CoreSite.prototype.canAccessMyFiles = function () {
        var infos = this.getInfo();
        return infos && (typeof infos.usercanmanageownfiles === 'undefined' || infos.usercanmanageownfiles);
    };
    /**
     * Can the user download files?
     *
     * @return {boolean} Whether can download files.
     */
    CoreSite.prototype.canDownloadFiles = function () {
        var infos = this.getInfo();
        return infos && infos.downloadfiles;
    };
    /**
     * Can the user use an advanced feature?
     *
     * @param {string} feature The name of the feature.
     * @param {boolean} [whenUndefined=true] The value to return when the parameter is undefined.
     * @return {boolean} Whether can use advanced feature.
     */
    CoreSite.prototype.canUseAdvancedFeature = function (feature, whenUndefined) {
        if (whenUndefined === void 0) { whenUndefined = true; }
        var infos = this.getInfo();
        var canUse = true;
        if (typeof infos.advancedfeatures === 'undefined') {
            canUse = whenUndefined;
        }
        else {
            for (var i in infos.advancedfeatures) {
                var item = infos.advancedfeatures[i];
                if (item.name === feature && parseInt(item.value, 10) === 0) {
                    canUse = false;
                }
            }
        }
        return canUse;
    };
    /**
     * Can the user upload files?
     *
     * @return {boolean} Whether can upload files.
     */
    CoreSite.prototype.canUploadFiles = function () {
        var infos = this.getInfo();
        return infos && infos.uploadfiles;
    };
    /**
     * Fetch site info from the Moodle site.
     *
     * @return {Promise<any>} A promise to be resolved when the site info is retrieved.
     */
    CoreSite.prototype.fetchSiteInfo = function () {
        // The get_site_info WS call won't be cached.
        var preSets = {
            getFromCache: false,
            saveToCache: false,
            skipQueue: true
        };
        // Reset clean Unicode to check if it's supported again.
        this.cleanUnicode = false;
        return this.read('core_webservice_get_site_info', {}, preSets);
    };
    /**
     * Read some data from the Moodle site using WS. Requests are cached by default.
     *
     * @param {string} method WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @return {Promise<any>} Promise resolved with the response, rejected with CoreWSError if it fails.
     */
    CoreSite.prototype.read = function (method, data, preSets) {
        preSets = preSets || {};
        if (typeof preSets.getFromCache == 'undefined') {
            preSets.getFromCache = true;
        }
        if (typeof preSets.saveToCache == 'undefined') {
            preSets.saveToCache = true;
        }
        if (typeof preSets.reusePending == 'undefined') {
            preSets.reusePending = true;
        }
        return this.request(method, data, preSets);
    };
    /**
     * Sends some data to the Moodle site using WS. Requests are NOT cached by default.
     *
     * @param {string} method  WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @return {Promise<any>} Promise resolved with the response, rejected with CoreWSError if it fails.
     */
    CoreSite.prototype.write = function (method, data, preSets) {
        preSets = preSets || {};
        if (typeof preSets.getFromCache == 'undefined') {
            preSets.getFromCache = false;
        }
        if (typeof preSets.saveToCache == 'undefined') {
            preSets.saveToCache = false;
        }
        if (typeof preSets.emergencyCache == 'undefined') {
            preSets.emergencyCache = false;
        }
        return this.request(method, data, preSets);
    };
    /**
     * WS request to the site.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @param {boolean} [retrying] True if we're retrying the call for some reason. This is to prevent infinite loops.
     * @return {Promise<any>} Promise resolved with the response, rejected with CoreWSError if it fails.
     * @description
     *
     * Sends a webservice request to the site. This method will automatically add the
     * required parameters and pass it on to the low level API in CoreWSProvider.call().
     *
     * Caching is also implemented, when enabled this method will returned a cached version of the request if the
     * data hasn't expired.
     *
     * This method is smart which means that it will try to map the method to a compatibility one if need be, usually this
     * means that it will fallback on the 'local_mobile_' prefixed function if it is available and the non-prefixed is not.
     */
    CoreSite.prototype.request = function (method, data, preSets, retrying) {
        var _this = this;
        var initialToken = this.token;
        data = data || {};
        if (!this.appProvider.isOnline() && this.offlineDisabled) {
            return Promise.reject(this.wsProvider.createFakeWSError('core.errorofflinedisabled', true));
        }
        // Check if the method is available, use a prefixed version if possible.
        // We ignore this check when we do not have the site info, as the list of functions is not loaded yet.
        if (this.getInfo() && !this.wsAvailable(method, false)) {
            var compatibilityMethod = __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX + method;
            if (this.wsAvailable(compatibilityMethod, false)) {
                this.logger.info("Using compatibility WS method '" + compatibilityMethod + "'");
                method = compatibilityMethod;
            }
            else {
                this.logger.error("WS function '" + method + "' is not available, even in compatibility mode.");
                return Promise.reject(this.utils.createFakeWSError('core.wsfunctionnotavailable', true));
            }
        }
        var wsPreSets = {
            wsToken: this.token,
            siteUrl: this.siteUrl,
            cleanUnicode: this.cleanUnicode,
            typeExpected: preSets.typeExpected,
            responseExpected: preSets.responseExpected
        };
        if (wsPreSets.cleanUnicode && this.textUtils.hasUnicodeData(data)) {
            // Data will be cleaned, notify the user.
            this.domUtils.showToast('core.unicodenotsupported', true, 3000);
        }
        else {
            // No need to clean data in this call.
            wsPreSets.cleanUnicode = false;
        }
        if (this.offlineDisabled) {
            // Offline is disabled, don't use cache.
            preSets.getFromCache = false;
            preSets.saveToCache = false;
            preSets.emergencyCache = false;
        }
        // Enable text filtering by default.
        data.moodlewssettingfilter = preSets.filter === false ? false : true;
        data.moodlewssettingfileurl = preSets.rewriteurls === false ? false : true;
        var originalData = data;
        // Convert arguments to strings before starting the cache process.
        data = this.wsProvider.convertValuesToString(data, wsPreSets.cleanUnicode);
        if (data == null) {
            // Empty cleaned text found.
            return Promise.reject(this.utils.createFakeWSError('core.unicodenotsupportedcleanerror', true));
        }
        var cacheId = this.getCacheId(method, data);
        // Check for an ongoing identical request if we're not ignoring cache.
        if (preSets.getFromCache && this.ongoingRequests[cacheId]) {
            return this.ongoingRequests[cacheId].then(function (response) {
                // Clone the data, this may prevent errors if in the callback the object is modified.
                return _this.utils.clone(response);
            });
        }
        var promise = this.getFromCache(method, data, preSets, false, originalData).catch(function () {
            // Do not pass those options to the core WS factory.
            return _this.callOrEnqueueRequest(method, data, preSets, wsPreSets).then(function (response) {
                if (preSets.saveToCache) {
                    _this.saveToCache(method, data, response, preSets);
                }
                return response;
            }).catch(function (error) {
                if (error.errorcode == 'invalidtoken' ||
                    (error.errorcode == 'accessexception' && error.message.indexOf('Invalid token - token expired') > -1)) {
                    if (initialToken !== _this.token && !retrying) {
                        // Token has changed, retry with the new token.
                        preSets.getFromCache = false; // Don't check cache now. Also, it will skip ongoingRequests.
                        return _this.request(method, data, preSets, true);
                    }
                    else if (_this.appProvider.isSSOAuthenticationOngoing()) {
                        // There's an SSO authentication ongoing, wait for it to finish and try again.
                        return _this.appProvider.waitForSSOAuthentication().then(function () {
                            return _this.request(method, data, preSets, true);
                        });
                    }
                    // Session expired, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {}, _this.id);
                    // Change error message. Try to get data from cache, the event will handle the error.
                    error.message = _this.translate.instant('core.lostconnection');
                }
                else if (error.errorcode === 'userdeleted') {
                    // User deleted, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].USER_DELETED, { params: data }, _this.id);
                    error.message = _this.translate.instant('core.userdeleted');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'forcepasswordchangenotice') {
                    // Password Change Forced, trigger event. Try to get data from cache, the event will handle the error.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].PASSWORD_CHANGE_FORCED, {}, _this.id);
                    error.message = _this.translate.instant('core.forcepasswordchangenotice');
                }
                else if (error.errorcode === 'usernotfullysetup') {
                    // User not fully setup, trigger event. Try to get data from cache, the event will handle the error.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].USER_NOT_FULLY_SETUP, {}, _this.id);
                    error.message = _this.translate.instant('core.usernotfullysetup');
                }
                else if (error.errorcode === 'sitepolicynotagreed') {
                    // Site policy not agreed, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].SITE_POLICY_NOT_AGREED, {}, _this.id);
                    error.message = _this.translate.instant('core.login.sitepolicynotagreederror');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'dmlwriteexception' && _this.textUtils.hasUnicodeData(data)) {
                    if (!_this.cleanUnicode) {
                        // Try again cleaning unicode.
                        _this.cleanUnicode = true;
                        return _this.request(method, data, preSets);
                    }
                    // This should not happen.
                    error.message = _this.translate.instant('core.unicodenotsupported');
                    return Promise.reject(error);
                }
                else if (error.exception === 'required_capability_exception' || error.errorcode === 'nopermission' ||
                    error.errorcode === 'notingroup') {
                    // Translate error messages with missing strings.
                    if (error.message === 'error/nopermission') {
                        error.message = _this.translate.instant('core.nopermissionerror');
                    }
                    else if (error.message === 'error/notingroup') {
                        error.message = _this.translate.instant('core.notingroup');
                    }
                    // Save the error instead of deleting the cache entry so the same content is displayed in offline.
                    _this.saveToCache(method, data, error, preSets);
                    return Promise.reject(error);
                }
                else if (typeof preSets.emergencyCache !== 'undefined' && !preSets.emergencyCache) {
                    _this.logger.debug("WS call '" + method + "' failed. Emergency cache is forbidden, rejecting.");
                    return Promise.reject(error);
                }
                else if (preSets.cacheErrors && preSets.cacheErrors.indexOf(error.errorcode) != -1) {
                    // Save the error instead of deleting the cache entry so the same content is displayed in offline.
                    _this.saveToCache(method, data, error, preSets);
                    return Promise.reject(error);
                }
                if (preSets.deleteCacheIfWSError && _this.utils.isWebServiceError(error)) {
                    // Delete the cache entry and return the entry. Don't block the user with the delete.
                    _this.deleteFromCache(method, data, preSets).catch(function () {
                        // Ignore errors.
                    });
                    return Promise.reject(error);
                }
                _this.logger.debug("WS call '" + method + "' failed. Trying to use the emergency cache.");
                preSets.omitExpires = true;
                preSets.getFromCache = true;
                return _this.getFromCache(method, data, preSets, true, originalData).catch(function () {
                    return Promise.reject(error);
                });
            });
        }).then(function (response) {
            // Check if the response is an error, this happens if the error was stored in the cache.
            if (response && (typeof response.exception != 'undefined' || typeof response.errorcode != 'undefined')) {
                return Promise.reject(response);
            }
            return response;
        });
        this.ongoingRequests[cacheId] = promise;
        // Clear ongoing request after setting the promise (just in case it's already resolved).
        return promise.finally(function () {
            // Make sure we don't clear the promise of a newer request that ignores the cache.
            if (_this.ongoingRequests[cacheId] === promise) {
                delete _this.ongoingRequests[cacheId];
            }
        }).then(function (response) {
            // We pass back a clone of the original object, this may prevent errors if in the callback the object is modified.
            return _this.utils.clone(response);
        });
    };
    /**
     * Adds a request to the queue or calls it immediately when not using the queue.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options related to the site.
     * @param {CoreWSPreSets} wsPreSets Extra options related to the WS call.
     * @returns {Promise<any>} Promise resolved with the response when the WS is called.
     */
    CoreSite.prototype.callOrEnqueueRequest = function (method, data, preSets, wsPreSets) {
        if (preSets.skipQueue || !this.wsAvailable('tool_mobile_call_external_functions')) {
            return this.wsProvider.call(method, data, wsPreSets);
        }
        var cacheId = this.getCacheId(method, data);
        // Check if there is an identical request waiting in the queue (read requests only by default).
        if (preSets.reusePending) {
            var request_1 = this.requestQueue.find(function (request) { return request.cacheId == cacheId; });
            if (request_1) {
                return request_1.deferred.promise;
            }
        }
        var request = {
            cacheId: cacheId,
            method: method,
            data: data,
            preSets: preSets,
            wsPreSets: wsPreSets,
            deferred: {}
        };
        request.deferred.promise = new Promise(function (resolve, reject) {
            request.deferred.resolve = resolve;
            request.deferred.reject = reject;
        });
        return this.enqueueRequest(request);
    };
    /**
     * Adds a request to the queue.
     *
     * @param {RequestQueueItem} request The request to enqueue.
     * @returns {Promise<any>} Promise resolved with the response when the WS is called.
     */
    CoreSite.prototype.enqueueRequest = function (request) {
        this.requestQueue.push(request);
        if (this.requestQueue.length >= CoreSite.REQUEST_QUEUE_LIMIT) {
            this.processRequestQueue();
        }
        else if (!this.requestQueueTimeout) {
            this.requestQueueTimeout = setTimeout(this.processRequestQueue.bind(this), CoreSite.REQUEST_QUEUE_DELAY);
        }
        return request.deferred.promise;
    };
    /**
     * Call the enqueued web service requests.
     */
    CoreSite.prototype.processRequestQueue = function () {
        var _this = this;
        this.logger.debug("Processing request queue (" + this.requestQueue.length + " requests)");
        // Clear timeout if set.
        if (this.requestQueueTimeout) {
            clearTimeout(this.requestQueueTimeout);
            this.requestQueueTimeout = null;
        }
        // Extract all requests from the queue.
        var requests = this.requestQueue;
        this.requestQueue = [];
        if (requests.length == 1 && !CoreSite.REQUEST_QUEUE_FORCE_WS) {
            // Only one request, do a regular web service call.
            this.wsProvider.call(requests[0].method, requests[0].data, requests[0].wsPreSets).then(function (data) {
                requests[0].deferred.resolve(data);
            }).catch(function (error) {
                requests[0].deferred.reject(error);
            });
            return;
        }
        var data = {
            requests: requests.map(function (request) {
                var args = {};
                var settings = {};
                // Separate WS settings from function arguments.
                Object.keys(request.data).forEach(function (key) {
                    var value = request.data[key];
                    var match = /^moodlews(setting.*)$/.exec(key);
                    if (match) {
                        if (match[1] == 'settingfilter' || match[1] == 'settingfileurl') {
                            // Undo special treatment of these settings in CoreWSProvider.convertValuesToString.
                            value = (value == 'true' ? '1' : '0');
                        }
                        settings[match[1]] = value;
                    }
                    else {
                        args[key] = value;
                    }
                });
                return __assign({ function: request.method, arguments: JSON.stringify(args) }, settings);
            })
        };
        var wsPresets = {
            siteUrl: this.siteUrl,
            wsToken: this.token,
        };
        this.wsProvider.call('tool_mobile_call_external_functions', data, wsPresets).then(function (data) {
            if (!data || !data.responses) {
                return Promise.reject(null);
            }
            requests.forEach(function (request, i) {
                var response = data.responses[i];
                if (!response) {
                    // Request not executed, enqueue again.
                    _this.enqueueRequest(request);
                }
                else if (response.error) {
                    request.deferred.reject(_this.textUtils.parseJSON(response.exception));
                }
                else {
                    var responseData = _this.textUtils.parseJSON(response.data);
                    // Match the behaviour of CoreWSProvider.call when no response is expected.
                    var responseExpected = typeof wsPresets.responseExpected == 'undefined' || wsPresets.responseExpected;
                    if (!responseExpected && (responseData == null || responseData === '')) {
                        responseData = {};
                    }
                    request.deferred.resolve(responseData);
                }
            });
        }).catch(function (error) {
            // Error not specific to a single request, reject all promises.
            requests.forEach(function (request) {
                request.deferred.reject(error);
            });
        });
    };
    /**
     * Check if a WS is available in this site.
     *
     * @param {string} method WS name.
     * @param {boolean} [checkPrefix=true] When true also checks with the compatibility prefix.
     * @return {boolean} Whether the WS is available.
     */
    CoreSite.prototype.wsAvailable = function (method, checkPrefix) {
        if (checkPrefix === void 0) { checkPrefix = true; }
        if (typeof this.infos == 'undefined') {
            return false;
        }
        if (this.infos.functionsByName[method]) {
            return true;
        }
        // Let's try again with the compatibility prefix.
        if (checkPrefix) {
            return this.wsAvailable(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX + method, false);
        }
        return false;
    };
    /**
     * Get cache ID.
     *
     * @param {string} method The WebService method.
     * @param {any} data Arguments to pass to the method.
     * @return {string} Cache ID.
     */
    CoreSite.prototype.getCacheId = function (method, data) {
        return __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__["Md5"].hashAsciiStr(method + ':' + this.utils.sortAndStringify(data));
    };
    /**
     * Get the cache ID used in Ionic 1 version of the app.
     *
     * @param {string} method The WebService method.
     * @param {any} data Arguments to pass to the method.
     * @return {string} Cache ID.
     */
    CoreSite.prototype.getCacheOldId = function (method, data) {
        return __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__["Md5"].hashAsciiStr(method + ':' + JSON.stringify(data));
    };
    /**
     * Get a WS response from cache.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @param {boolean} [emergency] Whether it's an "emergency" cache call (WS call failed).
     * @param {any} [originalData] Arguments to pass to the method before being converted to strings.
     * @return {Promise<any>} Promise resolved with the WS response.
     */
    CoreSite.prototype.getFromCache = function (method, data, preSets, emergency, originalData) {
        var _this = this;
        if (!this.db || !preSets.getFromCache) {
            return Promise.reject(null);
        }
        var id = this.getCacheId(method, data);
        var promise;
        if (preSets.getCacheUsingCacheKey || (emergency && preSets.getEmergencyCacheUsingCacheKey)) {
            promise = this.db.getRecords(CoreSite.WS_CACHE_TABLE, { key: preSets.cacheKey }).then(function (entries) {
                if (!entries.length) {
                    // Cache key not found, get by params sent.
                    return _this.db.getRecord(CoreSite.WS_CACHE_TABLE, { id: id });
                }
                else if (entries.length > 1) {
                    // More than one entry found. Search the one with same ID as this call.
                    for (var i = 0, len = entries.length; i < len; i++) {
                        var entry = entries[i];
                        if (entry.id == id) {
                            return entry;
                        }
                    }
                }
                return entries[0];
            });
        }
        else {
            promise = this.db.getRecord(CoreSite.WS_CACHE_TABLE, { id: id }).catch(function () {
                // Entry not found, try to get it using the old ID.
                var oldId = _this.getCacheOldId(method, originalData || {});
                return _this.db.getRecord(CoreSite.WS_CACHE_TABLE, { id: oldId }).then(function (entry) {
                    // Update the entry ID to use the new one.
                    _this.db.updateRecords(CoreSite.WS_CACHE_TABLE, { id: id }, { id: oldId });
                    return entry;
                });
            });
        }
        return promise.then(function (entry) {
            var now = Date.now();
            var expirationTime;
            preSets.omitExpires = preSets.omitExpires || !_this.appProvider.isOnline();
            if (!preSets.omitExpires) {
                var expirationDelay = _this.UPDATE_FREQUENCIES[preSets.updateFrequency] ||
                    _this.UPDATE_FREQUENCIES[CoreSite.FREQUENCY_USUALLY];
                if (_this.appProvider.isNetworkAccessLimited()) {
                    // Not WiFi, increase the expiration delay a 50% to decrease the data usage in this case.
                    expirationDelay *= 1.5;
                }
                expirationTime = entry.expirationTime + expirationDelay;
                if (now > expirationTime) {
                    _this.logger.debug('Cached element found, but it is expired');
                    return Promise.reject(null);
                }
            }
            if (typeof entry != 'undefined' && typeof entry.data != 'undefined') {
                if (!expirationTime) {
                    _this.logger.info("Cached element found, id: " + id + ". Expiration time ignored.");
                }
                else {
                    var expires = (expirationTime - now) / 1000;
                    _this.logger.info("Cached element found, id: " + id + ". Expires in expires in " + expires + " seconds");
                }
                return _this.textUtils.parseJSON(entry.data, {});
            }
            return Promise.reject(null);
        });
    };
    /**
     * Save a WS response to cache.
     *
     * @param {string} method The WebService method.
     * @param {any} data Arguments to pass to the method.
     * @param {any} response The WS response.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @return {Promise<any>} Promise resolved when the response is saved.
     */
    CoreSite.prototype.saveToCache = function (method, data, response, preSets) {
        var _this = this;
        if (!this.db) {
            return Promise.reject(null);
        }
        var promise;
        if (preSets.uniqueCacheKey) {
            // Cache key must be unique, delete all entries with same cache key.
            promise = this.deleteFromCache(method, data, preSets, true).catch(function () {
                // Ignore errors.
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            // Since 3.7, the expiration time contains the time the entry is modified instead of the expiration time.
            // We decided to reuse this field to prevent modifying the database table.
            var id = _this.getCacheId(method, data), entry = {
                id: id,
                data: JSON.stringify(response),
                expirationTime: Date.now()
            };
            if (preSets.cacheKey) {
                entry.key = preSets.cacheKey;
            }
            return _this.db.insertRecord(CoreSite.WS_CACHE_TABLE, entry);
        });
    };
    /**
     * Delete a WS cache entry or entries.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @param {boolean} [allCacheKey] True to delete all entries with the cache key, false to delete only by ID.
     * @return {Promise<any>} Promise resolved when the entries are deleted.
     */
    CoreSite.prototype.deleteFromCache = function (method, data, preSets, allCacheKey) {
        if (!this.db) {
            return Promise.reject(null);
        }
        var id = this.getCacheId(method, data);
        if (allCacheKey) {
            return this.db.deleteRecords(CoreSite.WS_CACHE_TABLE, { key: preSets.cacheKey });
        }
        return this.db.deleteRecords(CoreSite.WS_CACHE_TABLE, { id: id });
    };
    /*
     * Uploads a file using Cordova File API.
     *
     * @param {string} filePath File path.
     * @param {CoreWSFileUploadOptions} options File upload options.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when uploaded.
     */
    CoreSite.prototype.uploadFile = function (filePath, options, onProgress) {
        if (!options.fileArea) {
            options.fileArea = 'draft';
        }
        return this.wsProvider.uploadFile(filePath, options, {
            siteUrl: this.siteUrl,
            wsToken: this.token
        }, onProgress);
    };
    /**
     * Invalidates all the cache entries.
     *
     * @return {Promise<any>} Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateWsCache = function () {
        if (!this.db) {
            return Promise.reject(null);
        }
        this.logger.debug('Invalidate all the cache for site: ' + this.id);
        return this.db.updateRecords(CoreSite.WS_CACHE_TABLE, { expirationTime: 0 });
    };
    /**
     * Invalidates all the cache entries with a certain key.
     *
     * @param {string} key Key to search.
     * @return {Promise<any>} Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateWsCacheForKey = function (key) {
        if (!this.db) {
            return Promise.reject(null);
        }
        if (!key) {
            return Promise.resolve();
        }
        this.logger.debug('Invalidate cache for key: ' + key);
        return this.db.updateRecords(CoreSite.WS_CACHE_TABLE, { expirationTime: 0 }, { key: key });
    };
    /**
     * Invalidates all the cache entries in an array of keys.
     *
     * @param {string[]} keys Keys to search.
     * @return {Promise<any>} Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateMultipleWsCacheForKey = function (keys) {
        var _this = this;
        if (!this.db) {
            return Promise.reject(null);
        }
        if (!keys || !keys.length) {
            return Promise.resolve();
        }
        var promises = [];
        this.logger.debug('Invalidating multiple cache keys');
        keys.forEach(function (key) {
            promises.push(_this.invalidateWsCacheForKey(key));
        });
        return Promise.all(promises);
    };
    /**
     * Invalidates all the cache entries whose key starts with a certain value.
     *
     * @param {string} key Key to search.
     * @return {Promise}    Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateWsCacheForKeyStartingWith = function (key) {
        if (!this.db) {
            return Promise.reject(null);
        }
        if (!key) {
            return Promise.resolve();
        }
        this.logger.debug('Invalidate cache for key starting with: ' + key);
        var sql = 'UPDATE ' + CoreSite.WS_CACHE_TABLE + ' SET expirationTime=0 WHERE key LIKE ?';
        return this.db.execute(sql, [key + '%']);
    };
    /**
     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
     * Uses CoreUtilsProvider.fixPluginfileURL, passing site's token.
     *
     * @param {string} url The url to be fixed.
     * @return {string} Fixed URL.
     */
    CoreSite.prototype.fixPluginfileURL = function (url) {
        return this.urlUtils.fixPluginfileURL(url, this.token, this.siteUrl);
    };
    /**
     * Deletes site's DB.
     *
     * @return {Promise<any>} Promise to be resolved when the DB is deleted.
     */
    CoreSite.prototype.deleteDB = function () {
        return this.dbProvider.deleteDB('Site-' + this.id);
    };
    /**
     * Deletes site's folder.
     *
     * @return {Promise<any>} Promise to be resolved when the DB is deleted.
     */
    CoreSite.prototype.deleteFolder = function () {
        if (this.fileProvider.isAvailable()) {
            var siteFolder = this.fileProvider.getSiteFolder(this.id);
            return this.fileProvider.removeDir(siteFolder).catch(function () {
                // Ignore any errors, CoreFileProvider.removeDir fails if folder doesn't exists.
            });
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Get space usage of the site.
     *
     * @return {Promise<number>} Promise resolved with the site space usage (size).
     */
    CoreSite.prototype.getSpaceUsage = function () {
        if (this.fileProvider.isAvailable()) {
            var siteFolderPath = this.fileProvider.getSiteFolder(this.id);
            return this.fileProvider.getDirectorySize(siteFolderPath).catch(function () {
                return 0;
            });
        }
        else {
            return Promise.resolve(0);
        }
    };
    /**
     * Returns the URL to the documentation of the app, based on Moodle version and current language.
     *
     * @param {string} [page] Docs page to go to.
     * @return {Promise<string>} Promise resolved with the Moodle docs URL.
     */
    CoreSite.prototype.getDocsUrl = function (page) {
        var release = this.infos.release ? this.infos.release : undefined;
        return this.urlUtils.getDocsUrl(release, page);
    };
    /**
     * Check if the local_mobile plugin is installed in the Moodle site.
     *
     * @param {boolean} [retrying] True if we're retrying the check.
     * @return {Promise<LocalMobileResponse>} Promise resolved when the check is done.
     */
    CoreSite.prototype.checkLocalMobilePlugin = function (retrying) {
        var _this = this;
        var checkUrl = this.siteUrl + '/local/mobile/check.php', service = __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].wsextservice;
        if (!service) {
            // External service not defined.
            return Promise.resolve({ code: 0 });
        }
        var promise = this.http.post(checkUrl, { service: service }).timeout(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
        return promise.then(function (data) {
            if (typeof data != 'undefined' && data.errorcode === 'requirecorrectaccess') {
                if (!retrying) {
                    _this.siteUrl = _this.urlUtils.addOrRemoveWWW(_this.siteUrl);
                    return _this.checkLocalMobilePlugin(true);
                }
                else {
                    return Promise.reject(data.error);
                }
            }
            else if (typeof data == 'undefined' || typeof data.code == 'undefined') {
                // The local_mobile returned something we didn't expect. Let's assume it's not installed.
                return { code: 0, warning: 'core.login.localmobileunexpectedresponse' };
            }
            var code = parseInt(data.code, 10);
            if (data.error) {
                switch (code) {
                    case 1:
                        // Site in maintenance mode.
                        return Promise.reject(_this.translate.instant('core.login.siteinmaintenance'));
                    case 2:
                        // Web services not enabled.
                        return Promise.reject(_this.translate.instant('core.login.webservicesnotenabled'));
                    case 3:
                        // Extended service not enabled, but the official is enabled.
                        return { code: 0 };
                    case 4:
                        // Neither extended or official services enabled.
                        return Promise.reject(_this.translate.instant('core.login.mobileservicesnotenabled'));
                    default:
                        return Promise.reject(_this.translate.instant('core.unexpectederror'));
                }
            }
            else {
                return { code: code, service: service, coreSupported: !!data.coresupported };
            }
        }, function () {
            return { code: 0 };
        });
    };
    /**
     * Check if local_mobile has been installed in Moodle.
     *
     * @return {boolean} Whether the App is able to use local_mobile plugin for this site.
     */
    CoreSite.prototype.checkIfAppUsesLocalMobile = function () {
        var appUsesLocalMobile = false;
        if (!this.infos || !this.infos.functions) {
            return appUsesLocalMobile;
        }
        this.infos.functions.forEach(function (func) {
            if (func.name.indexOf(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX) != -1) {
                appUsesLocalMobile = true;
            }
        });
        return appUsesLocalMobile;
    };
    /**
     * Check if local_mobile has been installed in Moodle but the app is not using it.
     *
     * @return {Promise<any>} Promise resolved it local_mobile was added, rejected otherwise.
     */
    CoreSite.prototype.checkIfLocalMobileInstalledAndNotUsed = function () {
        var appUsesLocalMobile = this.checkIfAppUsesLocalMobile();
        if (appUsesLocalMobile) {
            // App already uses local_mobile, it wasn't added.
            return Promise.reject(null);
        }
        return this.checkLocalMobilePlugin().then(function (data) {
            if (typeof data.service == 'undefined') {
                // The local_mobile NOT installed. Reject.
                return Promise.reject(null);
            }
            return data;
        });
    };
    /**
     * Check if a URL belongs to this site.
     *
     * @param {string} url URL to check.
     * @return {boolean} Whether the URL belongs to this site.
     */
    CoreSite.prototype.containsUrl = function (url) {
        if (!url) {
            return false;
        }
        var siteUrl = this.textUtils.removeEndingSlash(this.urlUtils.removeProtocolAndWWW(this.siteUrl));
        url = this.urlUtils.removeProtocolAndWWW(url);
        return url.indexOf(siteUrl) == 0;
    };
    /**
     * Get the public config of this site.
     *
     * @return {Promise<any>} Promise resolved with public config. Rejected with an object if error, see CoreWSProvider.callAjax.
     */
    CoreSite.prototype.getPublicConfig = function () {
        var _this = this;
        return this.wsProvider.callAjax('tool_mobile_get_public_config', {}, { siteUrl: this.siteUrl }).then(function (config) {
            // Use the wwwroot returned by the server.
            if (config.httpswwwroot) {
                _this.siteUrl = config.httpswwwroot;
            }
            return config;
        });
    };
    /**
     * Open a URL in browser using auto-login in the Moodle site if available.
     *
     * @param {string} url The URL to open.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser.
     * @return {Promise<any>} Promise resolved when done, rejected otherwise.
     */
    CoreSite.prototype.openInBrowserWithAutoLogin = function (url, alertMessage) {
        return this.openWithAutoLogin(false, url, undefined, alertMessage);
    };
    /**
     * Open a URL in browser using auto-login in the Moodle site if available and the URL belongs to the site.
     *
     * @param {string} url The URL to open.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser.
     * @return {Promise<any>} Promise resolved when done, rejected otherwise.
     */
    CoreSite.prototype.openInBrowserWithAutoLoginIfSameSite = function (url, alertMessage) {
        return this.openWithAutoLoginIfSameSite(false, url, undefined, alertMessage);
    };
    /**
     * Open a URL in inappbrowser using auto-login in the Moodle site if available.
     *
     * @param {string} url The URL to open.
     * @param {any} [options] Override default options passed to InAppBrowser.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the inappbrowser.
     * @return {Promise<InAppBrowserObject|void>} Promise resolved when done.
     */
    CoreSite.prototype.openInAppWithAutoLogin = function (url, options, alertMessage) {
        return this.openWithAutoLogin(true, url, options, alertMessage);
    };
    /**
     * Open a URL in inappbrowser using auto-login in the Moodle site if available and the URL belongs to the site.
     *
     * @param {string} url The URL to open.
     * @param {object} [options] Override default options passed to inappbrowser.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the inappbrowser.
     * @return {Promise<InAppBrowserObject|void>} Promise resolved when done.
     */
    CoreSite.prototype.openInAppWithAutoLoginIfSameSite = function (url, options, alertMessage) {
        return this.openWithAutoLoginIfSameSite(true, url, options, alertMessage);
    };
    /**
     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available.
     *
     * @param {boolean} inApp True to open it in InAppBrowser, false to open in browser.
     * @param {string} url The URL to open.
     * @param {object} [options] Override default options passed to $cordovaInAppBrowser#open.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser/inappbrowser.
     * @return {Promise<InAppBrowserObject|void>} Promise resolved when done. Resolve param is returned only if inApp=true.
     */
    CoreSite.prototype.openWithAutoLogin = function (inApp, url, options, alertMessage) {
        var _this = this;
        // Get the URL to open.
        return this.getAutoLoginUrl(url).then(function (url) {
            if (!alertMessage) {
                // Just open the URL.
                if (inApp) {
                    return _this.utils.openInApp(url, options);
                }
                else {
                    return _this.utils.openInBrowser(url);
                }
            }
            // Show an alert first.
            return _this.domUtils.showAlert(_this.translate.instant('core.notice'), alertMessage, undefined, 3000).then(function (alert) {
                return new Promise(function (resolve, reject) {
                    var subscription = alert.didDismiss.subscribe(function () {
                        subscription && subscription.unsubscribe();
                        if (inApp) {
                            resolve(_this.utils.openInApp(url, options));
                        }
                        else {
                            resolve(_this.utils.openInBrowser(url));
                        }
                    });
                });
            });
        });
    };
    /**
     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available and the URL belongs to the site.
     *
     * @param {boolean} inApp True to open it in InAppBrowser, false to open in browser.
     * @param {string} url The URL to open.
     * @param {object} [options] Override default options passed to inappbrowser.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser/inappbrowser.
     * @return {Promise<InAppBrowserObject|void>} Promise resolved when done. Resolve param is returned only if inApp=true.
     */
    CoreSite.prototype.openWithAutoLoginIfSameSite = function (inApp, url, options, alertMessage) {
        if (this.containsUrl(url)) {
            return this.openWithAutoLogin(inApp, url, options, alertMessage);
        }
        else {
            if (inApp) {
                this.utils.openInApp(url, options);
            }
            else {
                this.utils.openInBrowser(url);
            }
            return Promise.resolve(null);
        }
    };
    /**
     * Get the config of this site.
     * It is recommended to use getStoredConfig instead since it's faster and doesn't use network.
     *
     * @param {string} [name] Name of the setting to get. If not set or false, all settings will be returned.
     * @param {boolean} [ignoreCache] True if it should ignore cached data.
     * @return {Promise<any>} Promise resolved with site config.
     */
    CoreSite.prototype.getConfig = function (name, ignoreCache) {
        var preSets = {
            cacheKey: this.getConfigCacheKey()
        };
        if (ignoreCache) {
            preSets.getFromCache = false;
            preSets.emergencyCache = false;
        }
        return this.read('tool_mobile_get_config', {}, preSets).then(function (config) {
            if (name) {
                // Return the requested setting.
                for (var x in config.settings) {
                    if (config.settings[x].name == name) {
                        return config.settings[x].value;
                    }
                }
                return Promise.reject(null);
            }
            else {
                // Return all settings in the same array.
                var settings_1 = {};
                config.settings.forEach(function (setting) {
                    settings_1[setting.name] = setting.value;
                });
                return settings_1;
            }
        });
    };
    /**
     * Invalidates config WS call.
     *
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSite.prototype.invalidateConfig = function () {
        return this.invalidateWsCacheForKey(this.getConfigCacheKey());
    };
    /**
     * Get cache key for getConfig WS calls.
     *
     * @return {string} Cache key.
     */
    CoreSite.prototype.getConfigCacheKey = function () {
        return 'tool_mobile_get_config';
    };
    /**
     * Get the stored config of this site.
     *
     * @param {string} [name] Name of the setting to get. If not set, all settings will be returned.
     * @return {any} Site config or a specific setting.
     */
    CoreSite.prototype.getStoredConfig = function (name) {
        if (!this.config) {
            return;
        }
        if (name) {
            return this.config[name];
        }
        else {
            return this.config;
        }
    };
    /**
     * Check if a certain feature is disabled in the site.
     *
     * @param {string} name Name of the feature to check.
     * @return {boolean} Whether it's disabled.
     */
    CoreSite.prototype.isFeatureDisabled = function (name) {
        var disabledFeatures = this.getStoredConfig('tool_mobile_disabledfeatures');
        if (!disabledFeatures) {
            return false;
        }
        var regEx = new RegExp('(,|^)' + this.textUtils.escapeForRegex(name) + '(,|$)', 'g');
        return !!disabledFeatures.match(regEx);
    };
    /**
     * Calculate if offline is disabled in the site.
     */
    CoreSite.prototype.calculateOfflineDisabled = function () {
        this.offlineDisabled = this.isFeatureDisabled('NoDelegate_CoreOffline');
    };
    /**
     * Get whether offline is disabled in the site.
     *
     * @return {boolean} Whether it's disabled.
     */
    CoreSite.prototype.isOfflineDisabled = function () {
        return this.offlineDisabled;
    };
    /**
     * Check if the site version is greater than one or several versions.
     * This function accepts a string or an array of strings. If array, the last version must be the highest.
     *
     * @param {string | string[]} versions Version or list of versions to check.
     * @return {boolean} Whether it's greater or equal, false otherwise.
     * @description
     * If a string is supplied (e.g. '3.2.1'), it will check if the site version is greater or equal than this version.
     *
     * If an array of versions is supplied, it will check if the site version is greater or equal than the last version,
     * or if it's higher or equal than any of the other releases supplied but lower than the next major release. The last
     * version of the array must be the highest version.
     * For example, if the values supplied are ['3.0.5', '3.2.3', '3.3.1'] the function will return true if the site version
     * is either:
     *     - Greater or equal than 3.3.1.
     *     - Greater or equal than 3.2.3 but lower than 3.3.
     *     - Greater or equal than 3.0.5 but lower than 3.1.
     *
     * This function only accepts versions from 2.4.0 and above. If any of the versions supplied isn't found, it will assume
     * it's the last released major version.
     */
    CoreSite.prototype.isVersionGreaterEqualThan = function (versions) {
        var siteVersion = parseInt(this.getInfo().version, 10);
        if (Array.isArray(versions)) {
            if (!versions.length) {
                return false;
            }
            for (var i = 0; i < versions.length; i++) {
                var versionNumber = this.getVersionNumber(versions[i]);
                if (i == versions.length - 1) {
                    // It's the last version, check only if site version is greater than this one.
                    return siteVersion >= versionNumber;
                }
                else {
                    // Check if site version if bigger than this number but lesser than next major.
                    if (siteVersion >= versionNumber && siteVersion < this.getNextMajorVersionNumber(versions[i])) {
                        return true;
                    }
                }
            }
        }
        else if (typeof versions == 'string') {
            // Compare with this version.
            return siteVersion >= this.getVersionNumber(versions);
        }
        return false;
    };
    /**
     * Given a URL, convert it to a URL that will auto-login if supported.
     *
     * @param {string} url The URL to convert.
     * @param {boolean} [showModal=true] Whether to show a loading modal.
     * @return {Promise<string>} Promise resolved with the converted URL.
     */
    CoreSite.prototype.getAutoLoginUrl = function (url, showModal) {
        var _this = this;
        if (showModal === void 0) { showModal = true; }
        if (!this.privateToken || !this.wsAvailable('tool_mobile_get_autologin_key') ||
            (this.lastAutoLogin && this.timeUtils.timestamp() - this.lastAutoLogin < __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE * 6)) {
            // No private token, WS not available or last auto-login was less than 6 minutes ago. Don't change the URL.
            return Promise.resolve(url);
        }
        var userId = this.getUserId(), params = {
            privatetoken: this.privateToken
        };
        var modal;
        if (showModal) {
            modal = this.domUtils.showModalLoading();
        }
        // Use write to not use cache.
        return this.write('tool_mobile_get_autologin_key', params).then(function (data) {
            if (!data.autologinurl || !data.key) {
                // Not valid data, return the same URL.
                return url;
            }
            _this.lastAutoLogin = _this.timeUtils.timestamp();
            return data.autologinurl + '?userid=' + userId + '&key=' + data.key + '&urltogo=' + url;
        }).catch(function () {
            // Couldn't get autologin key, return the same URL.
            return url;
        }).finally(function () {
            modal && modal.dismiss();
        });
    };
    /**
     * Get a version number from a release version.
     * If release version is valid but not found in the list of Moodle releases, it will use the last released major version.
     *
     * @param {string} version Release version to convert to version number.
     * @return {number} Version number, 0 if invalid.
     */
    CoreSite.prototype.getVersionNumber = function (version) {
        var data = this.getMajorAndMinor(version);
        if (!data) {
            // Invalid version.
            return 0;
        }
        if (typeof this.MOODLE_RELEASES[data.major] == 'undefined') {
            // Major version not found. Use the last one.
            data.major = Object.keys(this.MOODLE_RELEASES).slice(-1);
        }
        return this.MOODLE_RELEASES[data.major] + data.minor;
    };
    /**
     * Given a release version, return the major and minor versions.
     *
     * @param {string} version Release version (e.g. '3.1.0').
     * @return {object} Object with major and minor. Returns false if invalid version.
     */
    CoreSite.prototype.getMajorAndMinor = function (version) {
        var match = version.match(/(\d)+(?:\.(\d)+)?(?:\.(\d)+)?/);
        if (!match || !match[1]) {
            // Invalid version.
            return false;
        }
        return {
            major: match[1] + '.' + (match[2] || '0'),
            minor: parseInt(match[3], 10) || 0
        };
    };
    /**
     * Given a release version, return the next major version number.
     *
     * @param {string} version Release version (e.g. '3.1.0').
     * @return {number} Next major version number.
     */
    CoreSite.prototype.getNextMajorVersionNumber = function (version) {
        var data = this.getMajorAndMinor(version), releases = Object.keys(this.MOODLE_RELEASES);
        var position;
        if (!data) {
            // Invalid version.
            return 0;
        }
        position = releases.indexOf(data.major);
        if (position == -1 || position == releases.length - 1) {
            // Major version not found or it's the last one. Use the last one.
            return this.MOODLE_RELEASES[releases[position]];
        }
        return this.MOODLE_RELEASES[releases[position + 1]];
    };
    /**
     * Deletes a site setting.
     *
     * @param {string} name The config name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSite.prototype.deleteSiteConfig = function (name) {
        return this.db.deleteRecords(CoreSite.CONFIG_TABLE, { name: name });
    };
    /**
     * Get a site setting on local device.
     *
     * @param {string} name The config name.
     * @param {any} [defaultValue] Default value to use if the entry is not found.
     * @return {Promise<any>} Resolves upon success along with the config data. Reject on failure.
     */
    CoreSite.prototype.getLocalSiteConfig = function (name, defaultValue) {
        return this.db.getRecord(CoreSite.CONFIG_TABLE, { name: name }).then(function (entry) {
            return entry.value;
        }).catch(function (error) {
            if (typeof defaultValue != 'undefined') {
                return defaultValue;
            }
            return Promise.reject(error);
        });
    };
    /**
     * Set a site setting on local device.
     *
     * @param {string} name The config name.
     * @param {number|string} value The config value. Can only store number or strings.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSite.prototype.setLocalSiteConfig = function (name, value) {
        return this.db.insertRecord(CoreSite.CONFIG_TABLE, { name: name, value: value });
    };
    CoreSite.REQUEST_QUEUE_DELAY = 50; // Maximum number of miliseconds to wait before processing the queue.
    CoreSite.REQUEST_QUEUE_LIMIT = 10; // Maximum number of requests allowed in the queue.
    CoreSite.REQUEST_QUEUE_FORCE_WS = false; // Use "tool_mobile_call_external_functions" even for calling a single function.
    // Constants for cache update frequency.
    CoreSite.FREQUENCY_USUALLY = 0;
    CoreSite.FREQUENCY_OFTEN = 1;
    CoreSite.FREQUENCY_SOMETIMES = 2;
    CoreSite.FREQUENCY_RARELY = 3;
    // Variables for the database.
    CoreSite.WS_CACHE_TABLE = 'wscache';
    CoreSite.CONFIG_TABLE = 'core_site_config';
    return CoreSite;
}());

//# sourceMappingURL=site.js.map

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreLoadingComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreLoadingComponent_0;
/* unused harmony export View_CoreLoadingComponent_Host_0 */
/* unused harmony export CoreLoadingComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_spinner_spinner_ngfactory__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular_components_spinner_spinner__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__loading__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ngx_translate_core_src_translate_service__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(2);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 









var styles_CoreLoadingComponent = [];
var RenderType_CoreLoadingComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreLoadingComponent, data: { "animation": [{ type: 7, name: "coreShowHideAnimation", definitions: [{ type: 1, expr: ":enter", animation: [{ type: 6, styles: { opacity: 0 }, offset: null }, { type: 4, styles: { type: 6, styles: { opacity: 1 }, offset: null }, timings: "500ms ease-in-out" }], options: null }, { type: 1, expr: ":leave", animation: [{ type: 6, styles: { opacity: 1 }, offset: null }, { type: 4, styles: { type: 6, styles: { opacity: 0 }, offset: null }, timings: "500ms ease-in-out" }], options: null }], options: {} }] } });

function View_CoreLoadingComponent_2(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "p", [["class", "core-loading-message"], ["role", "status"]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](1, null, ["", ""]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.message; _ck(_v, 1, 0, currVal_0); }); }
function View_CoreLoadingComponent_1(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 10, "div", [["class", "core-loading-container"], ["role", "status"]], [[24, "@coreShowHideAnimation", 0]], null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](2, 0, null, null, 7, "span", [["class", "core-loading-spinner"]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](4, 0, null, null, 1, "ion-spinner", [], [[2, "spinner-paused", null]], null, null, __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_spinner_spinner_ngfactory__["b" /* View_Spinner_0 */], __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_spinner_spinner_ngfactory__["a" /* RenderType_Spinner */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](5, 114688, null, 0, __WEBPACK_IMPORTED_MODULE_2_ionic_angular_components_spinner_spinner__["a" /* Spinner */], [__WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */]], null, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreLoadingComponent_2)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](8, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_4__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"]))], function (_ck, _v) { var _co = _v.component; _ck(_v, 5, 0); var currVal_2 = _co.message; _ck(_v, 8, 0, currVal_2); }, function (_ck, _v) { var currVal_0 = undefined; _ck(_v, 0, 0, currVal_0); var currVal_1 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 5)._paused; _ck(_v, 4, 0, currVal_1); }); }
function View_CoreLoadingComponent_3(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_43" /* ɵncd */](null, 0), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](0, null, null, 0))], null, null); }
function View_CoreLoadingComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](402653184, 1, { content: 0 }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreLoadingComponent_1)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](2, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_4__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](4, 0, [[1, 0], ["content", 1]], null, 4, "div", [["class", "core-loading-content"]], [[8, "id", 0], [1, "aria-busy", 0]], null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreLoadingComponent_3)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](7, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_4__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.hideUntil; _ck(_v, 2, 0, currVal_0); var currVal_3 = _co.hideUntil; _ck(_v, 7, 0, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_1 = _co.uniqueId; var currVal_2 = _co.hideUntil; _ck(_v, 4, 0, currVal_1, currVal_2); }); }
function View_CoreLoadingComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-loading", [], null, null, null, View_CoreLoadingComponent_0, RenderType_CoreLoadingComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 638976, null, 0, __WEBPACK_IMPORTED_MODULE_5__loading__["a" /* CoreLoadingComponent */], [__WEBPACK_IMPORTED_MODULE_6__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_7__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }
var CoreLoadingComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-loading", __WEBPACK_IMPORTED_MODULE_5__loading__["a" /* CoreLoadingComponent */], View_CoreLoadingComponent_Host_0, { hideUntil: "hideUntil", message: "message" }, {}, ["*"]);

//# sourceMappingURL=loading.ngfactory.js.map

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_file__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_mimetype__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_zip__ = __webpack_require__(414);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Factory to interact with the file system.
 */
var CoreFileProvider = /** @class */ (function () {
    function CoreFileProvider(logger, platform, file, appProvider, textUtils, zip, mimeUtils) {
        this.platform = platform;
        this.file = file;
        this.appProvider = appProvider;
        this.textUtils = textUtils;
        this.zip = zip;
        this.mimeUtils = mimeUtils;
        this.initialized = false;
        this.basePath = '';
        this.isHTMLAPI = false;
        this.CHUNK_SIZE = 10485760; // 10 MB.
        this.logger = logger.getInstance('CoreFileProvider');
        if (platform.is('android') && !Object.getOwnPropertyDescriptor(FileReader.prototype, 'onloadend')) {
            // Cordova File plugin creates some getters and setter for FileReader, but Ionic's polyfills override them in Android.
            // Create the getters and setters again. This code comes from FileReader.js in cordova-plugin-file.
            this.defineGetterSetter(FileReader.prototype, 'readyState', function () {
                return this._localURL ? this._readyState : this._realReader.readyState;
            });
            this.defineGetterSetter(FileReader.prototype, 'error', function () {
                return this._localURL ? this._error : this._realReader.error;
            });
            this.defineGetterSetter(FileReader.prototype, 'result', function () {
                return this._localURL ? this._result : this._realReader.result;
            });
            this.defineEvent('onloadstart');
            this.defineEvent('onprogress');
            this.defineEvent('onload');
            this.defineEvent('onerror');
            this.defineEvent('onloadend');
            this.defineEvent('onabort');
        }
    }
    CoreFileProvider_1 = CoreFileProvider;
    /**
     * Define an event for FileReader.
     *
     * @param {string} eventName Name of the event.
     */
    CoreFileProvider.prototype.defineEvent = function (eventName) {
        this.defineGetterSetter(FileReader.prototype, eventName, function () {
            return this._realReader[eventName] || null;
        }, function (value) {
            this._realReader[eventName] = value;
        });
    };
    /**
     * Define a getter and, optionally, a setter for a certain property in an object.
     *
     * @param {any} obj Object to set the getter/setter for.
     * @param {string} key Name of the property where to set them.
     * @param {Function} getFunc The getter function.
     * @param {Function} [setFunc] The setter function.
     */
    CoreFileProvider.prototype.defineGetterSetter = function (obj, key, getFunc, setFunc) {
        if (Object.defineProperty) {
            var desc = {
                get: getFunc,
                configurable: true
            };
            if (setFunc) {
                desc.set = setFunc;
            }
            Object.defineProperty(obj, key, desc);
        }
        else {
            obj.__defineGetter__(key, getFunc);
            if (setFunc) {
                obj.__defineSetter__(key, setFunc);
            }
        }
    };
    /**
     * Sets basePath to use with HTML API. Reserved for core use.
     *
     * @param {string} path Base path to use.
     */
    CoreFileProvider.prototype.setHTMLBasePath = function (path) {
        this.isHTMLAPI = true;
        this.basePath = path;
    };
    /**
     * Checks if we're using HTML API.
     *
     * @return {boolean} True if uses HTML API, false otherwise.
     */
    CoreFileProvider.prototype.usesHTMLAPI = function () {
        return this.isHTMLAPI;
    };
    /**
     * Initialize basePath based on the OS if it's not initialized already.
     *
     * @return {Promise<void>} Promise to be resolved when the initialization is finished.
     */
    CoreFileProvider.prototype.init = function () {
        var _this = this;
        if (this.initialized) {
            return Promise.resolve();
        }
        return this.platform.ready().then(function () {
            if (_this.platform.is('android')) {
                _this.basePath = _this.file.externalApplicationStorageDirectory || _this.basePath;
            }
            else if (_this.platform.is('ios')) {
                _this.basePath = _this.file.documentsDirectory || _this.basePath;
            }
            else if (!_this.isAvailable() || _this.basePath === '') {
                _this.logger.error('Error getting device OS.');
                return Promise.reject(null);
            }
            _this.initialized = true;
            _this.logger.debug('FS initialized: ' + _this.basePath);
        });
    };
    /**
     * Check if the plugin is available.
     *
     * @return {boolean} Whether the plugin is available.
     */
    CoreFileProvider.prototype.isAvailable = function () {
        return typeof window.resolveLocalFileSystemURL !== 'undefined';
    };
    /**
     * Get a file.
     *
     * @param {string} path Relative path to the file.
     * @return {Promise<FileEntry>} Promise resolved when the file is retrieved.
     */
    CoreFileProvider.prototype.getFile = function (path) {
        var _this = this;
        return this.init().then(function () {
            _this.logger.debug('Get file: ' + path);
            return _this.file.resolveLocalFilesystemUrl(_this.addBasePathIfNeeded(path));
        }).then(function (entry) {
            return entry;
        });
    };
    /**
     * Get a directory.
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<DirectoryEntry>} Promise resolved when the directory is retrieved.
     */
    CoreFileProvider.prototype.getDir = function (path) {
        var _this = this;
        return this.init().then(function () {
            _this.logger.debug('Get directory: ' + path);
            return _this.file.resolveDirectoryUrl(_this.addBasePathIfNeeded(path));
        });
    };
    /**
     * Get site folder path.
     *
     * @param {string} siteId Site ID.
     * @return {string} Site folder path.
     */
    CoreFileProvider.prototype.getSiteFolder = function (siteId) {
        return CoreFileProvider_1.SITESFOLDER + '/' + siteId;
    };
    /**
     * Create a directory or a file.
     *
     * @param {boolean} isDirectory True if a directory should be created, false if it should create a file.
     * @param {string} path Relative path to the dir/file.
     * @param {boolean} [failIfExists] True if it should fail if the dir/file exists, false otherwise.
     * @param {string} [base] Base path to create the dir/file in. If not set, use basePath.
     * @return {Promise<any>} Promise to be resolved when the dir/file is created.
     */
    CoreFileProvider.prototype.create = function (isDirectory, path, failIfExists, base) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            base = base || _this.basePath;
            if (path.indexOf('/') == -1) {
                if (isDirectory) {
                    _this.logger.debug('Create dir ' + path + ' in ' + base);
                    return _this.file.createDir(base, path, !failIfExists);
                }
                else {
                    _this.logger.debug('Create file ' + path + ' in ' + base);
                    return _this.file.createFile(base, path, !failIfExists);
                }
            }
            else {
                // The file plugin doesn't allow creating more than 1 level at a time (e.g. tmp/folder).
                // We need to create them 1 by 1.
                var firstDir_1 = path.substr(0, path.indexOf('/')), restOfPath_1 = path.substr(path.indexOf('/') + 1);
                _this.logger.debug('Create dir ' + firstDir_1 + ' in ' + base);
                return _this.file.createDir(base, firstDir_1, true).then(function (newDirEntry) {
                    return _this.create(isDirectory, restOfPath_1, failIfExists, newDirEntry.toURL());
                }).catch(function (error) {
                    _this.logger.error('Error creating directory ' + firstDir_1 + ' in ' + base);
                    return Promise.reject(error);
                });
            }
        });
    };
    /**
     * Create a directory.
     *
     * @param {string} path Relative path to the directory.
     * @param {boolean} [failIfExists] True if it should fail if the directory exists, false otherwise.
     * @return {Promise<DirectoryEntry>} Promise to be resolved when the directory is created.
     */
    CoreFileProvider.prototype.createDir = function (path, failIfExists) {
        return this.create(true, path, failIfExists);
    };
    /**
     * Create a file.
     *
     * @param {string} path Relative path to the file.
     * @param {boolean} [failIfExists] True if it should fail if the file exists, false otherwise..
     * @return {Promise<FileEntry>} Promise to be resolved when the file is created.
     */
    CoreFileProvider.prototype.createFile = function (path, failIfExists) {
        return this.create(false, path, failIfExists);
    };
    /**
     * Removes a directory and all its contents.
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<any>} Promise to be resolved when the directory is deleted.
     */
    CoreFileProvider.prototype.removeDir = function (path) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Remove directory: ' + path);
            return _this.file.removeRecursively(_this.basePath, path);
        });
    };
    /**
     * Removes a file and all its contents.
     *
     * @param {string} path Relative path to the file.
     * @return {Promise<any>} Promise to be resolved when the file is deleted.
     */
    CoreFileProvider.prototype.removeFile = function (path) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Remove file: ' + path);
            return _this.file.removeFile(_this.basePath, path).catch(function (error) {
                // The delete can fail if the path has encoded characters. Try again if that's the case.
                var decodedPath = decodeURI(path);
                if (decodedPath != path) {
                    return _this.file.removeFile(_this.basePath, decodedPath);
                }
                else {
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Removes a file given its FileEntry.
     *
     * @param {FileEntry} fileEntry File Entry.
     * @return {Promise<any>} Promise resolved when the file is deleted.
     */
    CoreFileProvider.prototype.removeFileByFileEntry = function (fileEntry) {
        return new Promise(function (resolve, reject) {
            fileEntry.remove(resolve, reject);
        });
    };
    /**
     * Retrieve the contents of a directory (not subdirectories).
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<any>} Promise to be resolved when the contents are retrieved.
     */
    CoreFileProvider.prototype.getDirectoryContents = function (path) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Get contents of dir: ' + path);
            return _this.file.listDir(_this.basePath, path);
        });
    };
    /**
     * Calculate the size of a directory or a file.
     *
     * @param {any} entry Directory or file.
     * @return {Promise<number>} Promise to be resolved when the size is calculated.
     */
    CoreFileProvider.prototype.getSize = function (entry) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (entry.isDirectory) {
                var directoryReader = entry.createReader();
                directoryReader.readEntries(function (entries) {
                    var promises = [];
                    for (var i = 0; i < entries.length; i++) {
                        promises.push(_this.getSize(entries[i]));
                    }
                    Promise.all(promises).then(function (sizes) {
                        var directorySize = 0;
                        for (var i = 0; i < sizes.length; i++) {
                            var fileSize = parseInt(sizes[i]);
                            if (isNaN(fileSize)) {
                                reject();
                                return;
                            }
                            directorySize += fileSize;
                        }
                        resolve(directorySize);
                    }, reject);
                }, reject);
            }
            else if (entry.isFile) {
                entry.file(function (file) {
                    resolve(file.size);
                }, reject);
            }
        });
    };
    /**
     * Calculate the size of a directory.
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<number>} Promise to be resolved when the size is calculated.
     */
    CoreFileProvider.prototype.getDirectorySize = function (path) {
        var _this = this;
        // Remove basePath if it's in the path.
        path = this.removeStartingSlash(path.replace(this.basePath, ''));
        this.logger.debug('Get size of dir: ' + path);
        return this.getDir(path).then(function (dirEntry) {
            return _this.getSize(dirEntry);
        });
    };
    /**
     * Calculate the size of a file.
     *
     * @param {string} path Relative path to the file.
     * @return {Promise<number>} Promise to be resolved when the size is calculated.
     */
    CoreFileProvider.prototype.getFileSize = function (path) {
        var _this = this;
        // Remove basePath if it's in the path.
        path = this.removeStartingSlash(path.replace(this.basePath, ''));
        this.logger.debug('Get size of file: ' + path);
        return this.getFile(path).then(function (fileEntry) {
            return _this.getSize(fileEntry);
        });
    };
    /**
     * Get file object from a FileEntry.
     *
     * @param {FileEntry} path Relative path to the file.
     * @return {Promise<any>} Promise to be resolved when the file is retrieved.
     */
    CoreFileProvider.prototype.getFileObjectFromFileEntry = function (entry) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.debug('Get file object of: ' + entry.fullPath);
            entry.file(resolve, reject);
        });
    };
    /**
     * Calculate the free space in the disk.
     * Please notice that this function isn't reliable and it's not documented in the Cordova File plugin.
     *
     * @return {Promise<number>} Promise resolved with the estimated free space in bytes.
     */
    CoreFileProvider.prototype.calculateFreeSpace = function () {
        var _this = this;
        return this.file.getFreeDiskSpace().then(function (size) {
            if (_this.platform.is('ios')) {
                // In iOS the size is in bytes.
                return Number(size);
            }
            // The size is in KB, convert it to bytes.
            return Number(size) * 1024;
        });
    };
    /**
     * Normalize a filename that usually comes URL encoded.
     *
     * @param {string} filename The file name.
     * @return {string} The file name normalized.
     */
    CoreFileProvider.prototype.normalizeFileName = function (filename) {
        filename = this.textUtils.decodeURIComponent(filename);
        return filename;
    };
    /**
     * Read a file from local file system.
     *
     * @param {string} path Relative path to the file.
     * @param {number} [format=FORMATTEXT] Format to read the file. Must be one of:
     *                                  FORMATTEXT
     *                                  FORMATDATAURL
     *                                  FORMATBINARYSTRING
     *                                  FORMATARRAYBUFFER
     * @return {Promise<any>} Promise to be resolved when the file is read.
     */
    CoreFileProvider.prototype.readFile = function (path, format) {
        if (format === void 0) { format = CoreFileProvider_1.FORMATTEXT; }
        // Remove basePath if it's in the path.
        path = this.removeStartingSlash(path.replace(this.basePath, ''));
        this.logger.debug('Read file ' + path + ' with format ' + format);
        switch (format) {
            case CoreFileProvider_1.FORMATDATAURL:
                return this.file.readAsDataURL(this.basePath, path);
            case CoreFileProvider_1.FORMATBINARYSTRING:
                return this.file.readAsBinaryString(this.basePath, path);
            case CoreFileProvider_1.FORMATARRAYBUFFER:
                return this.file.readAsArrayBuffer(this.basePath, path);
            default:
                return this.file.readAsText(this.basePath, path);
        }
    };
    /**
     * Read file contents from a file data object.
     *
     * @param {any} fileData File's data.
     * @param {number} [format=FORMATTEXT] Format to read the file. Must be one of:
     *                                  FORMATTEXT
     *                                  FORMATDATAURL
     *                                  FORMATBINARYSTRING
     *                                  FORMATARRAYBUFFER
     * @return {Promise<any>} Promise to be resolved when the file is read.
     */
    CoreFileProvider.prototype.readFileData = function (fileData, format) {
        if (format === void 0) { format = CoreFileProvider_1.FORMATTEXT; }
        format = format || CoreFileProvider_1.FORMATTEXT;
        this.logger.debug('Read file from file data with format ' + format);
        return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.onloadend = function (evt) {
                var target = evt.target; // Convert to <any> to be able to use non-standard properties.
                if (target.result !== undefined || target.result !== null) {
                    resolve(target.result);
                }
                else if (target.error !== undefined || target.error !== null) {
                    reject(target.error);
                }
                else {
                    reject({ code: null, message: 'READER_ONLOADEND_ERR' });
                }
            };
            // Check if the load starts. If it doesn't start in 3 seconds, reject.
            // Sometimes in Android the read doesn't start for some reason, so the promise never finishes.
            var hasStarted = false;
            reader.onloadstart = function (evt) {
                hasStarted = true;
            };
            setTimeout(function () {
                if (!hasStarted) {
                    reject('Upload cannot start.');
                }
            }, 3000);
            switch (format) {
                case CoreFileProvider_1.FORMATDATAURL:
                    reader.readAsDataURL(fileData);
                    break;
                case CoreFileProvider_1.FORMATBINARYSTRING:
                    reader.readAsBinaryString(fileData);
                    break;
                case CoreFileProvider_1.FORMATARRAYBUFFER:
                    reader.readAsArrayBuffer(fileData);
                    break;
                default:
                    reader.readAsText(fileData);
            }
        });
    };
    /**
     * Writes some data in a file.
     *
     * @param {string} path Relative path to the file.
     * @param {any} data Data to write.
     * @param {boolean} [append] Whether to append the data to the end of the file.
     * @return {Promise<any>} Promise to be resolved when the file is written.
     */
    CoreFileProvider.prototype.writeFile = function (path, data, append) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Write file: ' + path);
            // Create file (and parent folders) to prevent errors.
            return _this.createFile(path).then(function (fileEntry) {
                if (_this.isHTMLAPI && !_this.appProvider.isDesktop() &&
                    (typeof data == 'string' || data.toString() == '[object ArrayBuffer]')) {
                    // We need to write Blobs.
                    var type = _this.mimeUtils.getMimeType(_this.mimeUtils.getFileExtension(path));
                    data = new Blob([data], { type: type || 'text/plain' });
                }
                return _this.file.writeFile(_this.basePath, path, data, { replace: !append, append: !!append }).then(function () {
                    return fileEntry;
                });
            });
        });
    };
    /**
     * Write some file data into a filesystem file.
     * It's done in chunks to prevent crashing the app for big files.
     *
     * @param {any} file The data to write.
     * @param {string} path Path where to store the data.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {number} [offset=0] Offset where to start reading from.
     * @param {boolean} [append] Whether to append the data to the end of the file.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileProvider.prototype.writeFileDataInFile = function (file, path, onProgress, offset, append) {
        var _this = this;
        if (offset === void 0) { offset = 0; }
        offset = offset || 0;
        // Get the chunk to read.
        var blob = file.slice(offset, Math.min(offset + this.CHUNK_SIZE, file.size));
        return this.writeFileDataInFileChunk(blob, path, append).then(function (fileEntry) {
            offset += _this.CHUNK_SIZE;
            onProgress && onProgress({
                lengthComputable: true,
                loaded: offset,
                total: file.size
            });
            if (offset >= file.size) {
                // Done, stop.
                return fileEntry;
            }
            // Read the next chunk.
            return _this.writeFileDataInFile(file, path, onProgress, offset, true);
        });
    };
    /**
     * Write a chunk of data into a file.
     *
     * @param {any} chunkData The chunk of data.
     * @param {string} path Path where to store the data.
     * @param {boolean} [append] Whether to append the data to the end of the file.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileProvider.prototype.writeFileDataInFileChunk = function (chunkData, path, append) {
        var _this = this;
        // Read the chunk data.
        return this.readFileData(chunkData, CoreFileProvider_1.FORMATARRAYBUFFER).then(function (fileData) {
            // Write the data in the file.
            return _this.writeFile(path, fileData, append);
        });
    };
    /**
     * Gets a file that might be outside the app's folder.
     *
     * @param {string} fullPath Absolute path to the file.
     * @return {Promise<FileEntry>} Promise to be resolved when the file is retrieved.
     */
    CoreFileProvider.prototype.getExternalFile = function (fullPath) {
        return this.file.resolveLocalFilesystemUrl(fullPath).then(function (entry) {
            return entry;
        });
    };
    /**
     * Removes a file that might be outside the app's folder.
     *
     * @param {string} fullPath Absolute path to the file.
     * @return {Promise<any>} Promise to be resolved when the file is removed.
     */
    CoreFileProvider.prototype.removeExternalFile = function (fullPath) {
        var directory = fullPath.substring(0, fullPath.lastIndexOf('/')), filename = fullPath.substr(fullPath.lastIndexOf('/') + 1);
        return this.file.removeFile(directory, filename);
    };
    /**
     * Get the base path where the application files are stored.
     *
     * @return {Promise<string>} Promise to be resolved when the base path is retrieved.
     */
    CoreFileProvider.prototype.getBasePath = function () {
        var _this = this;
        return this.init().then(function () {
            if (_this.basePath.slice(-1) == '/') {
                return _this.basePath;
            }
            else {
                return _this.basePath + '/';
            }
        });
    };
    /**
     * Get the base path where the application files are stored in the format to be used for downloads.
     * iOS: Internal URL (cdvfile://).
     * Others: basePath (file://)
     *
     * @return {Promise<string>} Promise to be resolved when the base path is retrieved.
     */
    CoreFileProvider.prototype.getBasePathToDownload = function () {
        var _this = this;
        return this.init().then(function () {
            if (_this.platform.is('ios')) {
                // In iOS we want the internal URL (cdvfile://localhost/persistent/...).
                return _this.file.resolveDirectoryUrl(_this.basePath).then(function (dirEntry) {
                    return dirEntry.toInternalURL();
                });
            }
            else {
                // In the other platforms we use the basePath as it is (file://...).
                return _this.basePath;
            }
        });
    };
    /**
     * Get the base path where the application files are stored. Returns the value instantly, without waiting for it to be ready.
     *
     * @return {string} Base path. If the service hasn't been initialized it will return an invalid value.
     */
    CoreFileProvider.prototype.getBasePathInstant = function () {
        if (!this.basePath) {
            return this.basePath;
        }
        else if (this.basePath.slice(-1) == '/') {
            return this.basePath;
        }
        else {
            return this.basePath + '/';
        }
    };
    /**
     * Move a file.
     *
     * @param {string} [originalPath] Path to the file to move.
     * @param {string} [newPath] New path of the file.
     * @return {Promise<any>} Promise resolved when the entry is moved.
     */
    CoreFileProvider.prototype.moveFile = function (originalPath, newPath) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the paths.
            originalPath = _this.removeStartingSlash(originalPath.replace(_this.basePath, ''));
            newPath = _this.removeStartingSlash(newPath.replace(_this.basePath, ''));
            if (_this.isHTMLAPI) {
                // In Cordova API we need to calculate the longest matching path to make it work.
                // The function this.file.moveFile('a/', 'b/c.ext', 'a/', 'b/d.ext') doesn't work.
                // The function this.file.moveFile('a/b/', 'c.ext', 'a/b/', 'd.ext') works.
                var dirsA = originalPath.split('/'), dirsB = newPath.split('/');
                var commonPath = _this.basePath;
                for (var i = 0; i < dirsA.length; i++) {
                    var dir = dirsA[i];
                    if (dirsB[i] === dir) {
                        // Found a common folder, add it to common path and remove it from each specific path.
                        dir = dir + '/';
                        commonPath = _this.textUtils.concatenatePaths(commonPath, dir);
                        originalPath = originalPath.replace(dir, '');
                        newPath = newPath.replace(dir, '');
                    }
                    else {
                        // Folder doesn't match, stop searching.
                        break;
                    }
                }
                return _this.file.moveFile(commonPath, originalPath, commonPath, newPath);
            }
            else {
                return _this.file.moveFile(_this.basePath, originalPath, _this.basePath, newPath).catch(function (error) {
                    // The move can fail if the path has encoded characters. Try again if that's the case.
                    var decodedOriginal = decodeURI(originalPath), decodedNew = decodeURI(newPath);
                    if (decodedOriginal != originalPath || decodedNew != newPath) {
                        return _this.file.moveFile(_this.basePath, decodedOriginal, _this.basePath, decodedNew);
                    }
                    else {
                        return Promise.reject(error);
                    }
                });
            }
        });
    };
    /**
     * Copy a file.
     *
     * @param {string} from Path to the file to move.
     * @param {string} to New path of the file.
     * @return {Promise<any>} Promise resolved when the entry is copied.
     */
    CoreFileProvider.prototype.copyFile = function (from, to) {
        var _this = this;
        var fromFileAndDir, toFileAndDir;
        return this.init().then(function () {
            // Paths cannot start with "/". Remove basePath if present.
            from = _this.removeStartingSlash(from.replace(_this.basePath, ''));
            to = _this.removeStartingSlash(to.replace(_this.basePath, ''));
            fromFileAndDir = _this.getFileAndDirectoryFromPath(from);
            toFileAndDir = _this.getFileAndDirectoryFromPath(to);
            if (toFileAndDir.directory) {
                // Create the target directory if it doesn't exist.
                return _this.createDir(toFileAndDir.directory);
            }
        }).then(function () {
            if (_this.isHTMLAPI) {
                // In HTML API, the file name cannot include a directory, otherwise it fails.
                var fromDir = _this.textUtils.concatenatePaths(_this.basePath, fromFileAndDir.directory), toDir = _this.textUtils.concatenatePaths(_this.basePath, toFileAndDir.directory);
                return _this.file.copyFile(fromDir, fromFileAndDir.name, toDir, toFileAndDir.name);
            }
            else {
                return _this.file.copyFile(_this.basePath, from, _this.basePath, to).catch(function (error) {
                    // The copy can fail if the path has encoded characters. Try again if that's the case.
                    var decodedFrom = decodeURI(from), decodedTo = decodeURI(to);
                    if (from != decodedFrom || to != decodedTo) {
                        return _this.file.copyFile(_this.basePath, decodedFrom, _this.basePath, decodedTo);
                    }
                    else {
                        return Promise.reject(error);
                    }
                });
            }
        });
    };
    /**
     * Extract the file name and directory from a given path.
     *
     * @param {string} path Path to be extracted.
     * @return {any} Plain object containing the file name and directory.
     * @description
     * file.pdf         -> directory: '', name: 'file.pdf'
     * /file.pdf        -> directory: '', name: 'file.pdf'
     * path/file.pdf    -> directory: 'path', name: 'file.pdf'
     * path/            -> directory: 'path', name: ''
     * path             -> directory: '', name: 'path'
     */
    CoreFileProvider.prototype.getFileAndDirectoryFromPath = function (path) {
        var file = {
            directory: '',
            name: ''
        };
        file.directory = path.substring(0, path.lastIndexOf('/'));
        file.name = path.substr(path.lastIndexOf('/') + 1);
        return file;
    };
    /**
     * Get the internal URL of a file.
     *
     * @param {FileEntry} fileEntry File Entry.
     * @return {string} Internal URL.
     */
    CoreFileProvider.prototype.getInternalURL = function (fileEntry) {
        if (!fileEntry.toInternalURL) {
            // File doesn't implement toInternalURL, use toURL.
            return fileEntry.toURL();
        }
        return fileEntry.toInternalURL();
    };
    /**
     * Adds the basePath to a path if it doesn't have it already.
     *
     * @param {string} path Path to treat.
     * @return {string} Path with basePath added.
     */
    CoreFileProvider.prototype.addBasePathIfNeeded = function (path) {
        if (path.indexOf(this.basePath) > -1) {
            return path;
        }
        else {
            return this.textUtils.concatenatePaths(this.basePath, path);
        }
    };
    /**
     * Remove the base path from a path. If basePath isn't found, return false.
     *
     * @param {string} path Path to treat.
     * @return {string} Path without basePath if basePath was found, undefined otherwise.
     */
    CoreFileProvider.prototype.removeBasePath = function (path) {
        if (path.indexOf(this.basePath) > -1) {
            return path.replace(this.basePath, '');
        }
    };
    /**
     * Unzips a file.
     *
     * @param {string} path Path to the ZIP file.
     * @param {string} [destFolder] Path to the destination folder. If not defined, a new folder will be created with the
     *                     same location and name as the ZIP file (without extension).
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when the file is unzipped.
     */
    CoreFileProvider.prototype.unzipFile = function (path, destFolder, onProgress) {
        var _this = this;
        // Get the source file.
        return this.getFile(path).then(function (fileEntry) {
            // If destFolder is not set, use same location as ZIP file. We need to use absolute paths (including basePath).
            destFolder = _this.addBasePathIfNeeded(destFolder || _this.mimeUtils.removeExtension(path));
            return _this.zip.unzip(fileEntry.toURL(), destFolder, onProgress);
        }).then(function (result) {
            if (result == -1) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Search a string or regexp in a file contents and replace it. The result is saved in the same file.
     *
     * @param {string} path Path to the file.
     * @param {string|RegExp} search Value to search.
     * @param {string} newValue New value.
     * @return {Promise<any>} Promise resolved in success.
     */
    CoreFileProvider.prototype.replaceInFile = function (path, search, newValue) {
        var _this = this;
        return this.readFile(path).then(function (content) {
            if (typeof content == 'undefined' || content === null || !content.replace) {
                return Promise.reject(null);
            }
            if (content.match(search)) {
                content = content.replace(search, newValue);
                return _this.writeFile(path, content);
            }
        });
    };
    /**
     * Get a file/dir metadata given the file's entry.
     *
     * @param {Entry} fileEntry FileEntry retrieved from getFile or similar.
     * @return {Promise<any>} Promise resolved with metadata.
     */
    CoreFileProvider.prototype.getMetadata = function (fileEntry) {
        if (!fileEntry || !fileEntry.getMetadata) {
            return Promise.reject(null);
        }
        return new Promise(function (resolve, reject) {
            fileEntry.getMetadata(resolve, reject);
        });
    };
    /**
     * Get a file/dir metadata given the path.
     *
     * @param {string} path Path to the file/dir.
     * @param {boolean} [isDir] True if directory, false if file.
     * @return {Promise<any>} Promise resolved with metadata.
     */
    CoreFileProvider.prototype.getMetadataFromPath = function (path, isDir) {
        var _this = this;
        var promise;
        if (isDir) {
            promise = this.getDir(path);
        }
        else {
            promise = this.getFile(path);
        }
        return promise.then(function (entry) {
            return _this.getMetadata(entry);
        });
    };
    /**
     * Remove the starting slash of a path if it's there. E.g. '/sites/filepool' -> 'sites/filepool'.
     *
     * @param {string} path Path.
     * @return {string} Path without a slash in the first position.
     */
    CoreFileProvider.prototype.removeStartingSlash = function (path) {
        if (path[0] == '/') {
            return path.substr(1);
        }
        return path;
    };
    /**
     * Convenience function to copy or move an external file.
     *
     * @param {string} from Absolute path to the file to copy/move.
     * @param {string} to Relative new path of the file (inside the app folder).
     * @param {boolean} copy True to copy, false to move.
     * @return {Promise<any>} Promise resolved when the entry is copied/moved.
     */
    CoreFileProvider.prototype.copyOrMoveExternalFile = function (from, to, copy) {
        var _this = this;
        // Get the file to copy/move.
        return this.getExternalFile(from).then(function (fileEntry) {
            // Create the destination dir if it doesn't exist.
            var dirAndFile = _this.getFileAndDirectoryFromPath(to);
            return _this.createDir(dirAndFile.directory).then(function (dirEntry) {
                // Now copy/move the file.
                return new Promise(function (resolve, reject) {
                    if (copy) {
                        fileEntry.copyTo(dirEntry, dirAndFile.name, resolve, reject);
                    }
                    else {
                        fileEntry.moveTo(dirEntry, dirAndFile.name, resolve, reject);
                    }
                });
            });
        });
    };
    /**
     * Copy a file from outside of the app folder to somewhere inside the app folder.
     *
     * @param {string} from Absolute path to the file to copy.
     * @param {string} to Relative new path of the file (inside the app folder).
     * @return {Promise<any>} Promise resolved when the entry is copied.
     */
    CoreFileProvider.prototype.copyExternalFile = function (from, to) {
        return this.copyOrMoveExternalFile(from, to, true);
    };
    /**
     * Move a file from outside of the app folder to somewhere inside the app folder.
     *
     * @param {string} from Absolute path to the file to move.
     * @param {string} to Relative new path of the file (inside the app folder).
     * @return {Promise<any>} Promise resolved when the entry is moved.
     */
    CoreFileProvider.prototype.moveExternalFile = function (from, to) {
        return this.copyOrMoveExternalFile(from, to, false);
    };
    /**
     * Get a unique file name inside a folder, adding numbers to the file name if needed.
     *
     * @param {string} dirPath Path to the destination folder.
     * @param {string} fileName File name that wants to be used.
     * @param {string} [defaultExt] Default extension to use if no extension found in the file.
     * @return {Promise<string>} Promise resolved with the unique file name.
     */
    CoreFileProvider.prototype.getUniqueNameInFolder = function (dirPath, fileName, defaultExt) {
        var _this = this;
        // Get existing files in the folder.
        return this.getDirectoryContents(dirPath).then(function (entries) {
            var files = {};
            var num = 1, fileNameWithoutExtension = _this.mimeUtils.removeExtension(fileName), extension = _this.mimeUtils.getFileExtension(fileName) || defaultExt, newName;
            // Clean the file name.
            fileNameWithoutExtension = _this.textUtils.removeSpecialCharactersForFiles(_this.textUtils.decodeURIComponent(fileNameWithoutExtension));
            // Index the files by name.
            entries.forEach(function (entry) {
                files[entry.name.toLowerCase()] = entry;
            });
            // Format extension.
            if (extension) {
                extension = '.' + extension;
            }
            else {
                extension = '';
            }
            newName = fileNameWithoutExtension + extension;
            if (typeof files[newName.toLowerCase()] == 'undefined') {
                // No file with the same name.
                return newName;
            }
            else {
                // Repeated name. Add a number until we find a free name.
                do {
                    newName = fileNameWithoutExtension + '(' + num + ')' + extension;
                    num++;
                } while (typeof files[newName] != 'undefined');
                // Ask the user what he wants to do.
                return newName;
            }
        }).catch(function () {
            // Folder doesn't exist, name is unique. Clean it and return it.
            return _this.textUtils.removeSpecialCharactersForFiles(_this.textUtils.decodeURIComponent(fileName));
        });
    };
    /**
     * Remove app temporary folder.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileProvider.prototype.clearTmpFolder = function () {
        return this.removeDir(CoreFileProvider_1.TMPFOLDER).catch(function () {
            // Ignore errors because the folder might not exist.
        });
    };
    /**
     * Given a folder path and a list of used files, remove all the files of the folder that aren't on the list of used files.
     *
     * @param {string} dirPath Folder path.
     * @param {any[]} files List of used files.
     * @return {Promise<any>} Promise resolved when done, rejected if failure.
     */
    CoreFileProvider.prototype.removeUnusedFiles = function (dirPath, files) {
        var _this = this;
        // Get the directory contents.
        return this.getDirectoryContents(dirPath).then(function (contents) {
            if (!contents.length) {
                return;
            }
            var filesMap = {}, promises = [];
            // Index the received files by fullPath and ignore the invalid ones.
            files.forEach(function (file) {
                if (file.fullPath) {
                    filesMap[file.fullPath] = file;
                }
            });
            // Check which of the content files aren't used anymore and delete them.
            contents.forEach(function (file) {
                if (!filesMap[file.fullPath]) {
                    // File isn't used, delete it.
                    promises.push(_this.removeFileByFileEntry(file));
                }
            });
            return Promise.all(promises);
        }).catch(function () {
            // Ignore errors, maybe it doesn't exist.
        });
    };
    /**
     * Check if a file is inside the app's folder.
     *
     * @param {string} path The absolute path of the file to check.
     * @return {boolean} Whether the file is in the app's folder.
     */
    CoreFileProvider.prototype.isFileInAppFolder = function (path) {
        return path.indexOf(this.basePath) != -1;
    };
    // Formats to read a file.
    CoreFileProvider.FORMATTEXT = 0;
    CoreFileProvider.FORMATDATAURL = 1;
    CoreFileProvider.FORMATBINARYSTRING = 2;
    CoreFileProvider.FORMATARRAYBUFFER = 3;
    // Folders.
    CoreFileProvider.SITESFOLDER = 'sites';
    CoreFileProvider.TMPFOLDER = 'tmp';
    CoreFileProvider = CoreFileProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_3__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__ionic_native_zip__["a" /* Zip */], __WEBPACK_IMPORTED_MODULE_5__utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], CoreFileProvider);
    return CoreFileProvider;
    var CoreFileProvider_1;
}());

//# sourceMappingURL=file.js.map

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksHandlerBase; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Base handler to be registered in CoreContentLinksHandler. It is useful to minimize the amount of
 * functions that handlers need to implement.
 *
 * It allows you to specify a "pattern" (RegExp) that will be used to check if the handler handles a URL and to get its site URL.
 */
var CoreContentLinksHandlerBase = /** @class */ (function () {
    function CoreContentLinksHandlerBase() {
        /**
         * A name to identify the handler.
         * @type {string}
         */
        this.name = 'CoreContentLinksHandlerBase';
        /**
         * Handler's priority. The highest priority is treated first.
         * @type {number}
         */
        this.priority = 0;
        /**
         * Whether the isEnabled function should be called for all the users in a site. It should be true only if the isEnabled call
         * can return different values for different users in same site.
         * @type {boolean}
         */
        this.checkAllUsers = false;
        /**
         * Name of the feature this handler is related to.
         * It will be used to check if the feature is disabled (@see CoreSite.isFeatureDisabled).
         * @type {string}
         */
        this.featureName = '';
        // Nothing to do.
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreContentLinksHandlerBase.prototype.getActions = function (siteIds, url, params, courseId) {
        return [];
    };
    /**
     * Check if a URL is handled by this handler.
     *
     * @param {string} url The URL to check.
     * @return {boolean} Whether the URL is handled by this handler
     */
    CoreContentLinksHandlerBase.prototype.handles = function (url) {
        return this.pattern && url.search(this.pattern) >= 0;
    };
    /**
     * If the URL is handled by this handler, return the site URL.
     *
     * @param {string} url The URL to check.
     * @return {string} Site URL if it is handled, undefined otherwise.
     */
    CoreContentLinksHandlerBase.prototype.getSiteUrl = function (url) {
        if (this.pattern) {
            var position = url.search(this.pattern);
            if (position > -1) {
                return url.substr(0, position);
            }
        }
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreContentLinksHandlerBase.prototype.isEnabled = function (siteId, url, params, courseId) {
        return true;
    };
    return CoreContentLinksHandlerBase;
}());

//# sourceMappingURL=base-handler.js.map

/***/ }),
/* 54 */,
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_lang__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__configconstants__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_courses_providers_courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_events__ = __webpack_require__(11);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * Service to provide functionalities regarding site plugins.
 */
var CoreSitePluginsProvider = /** @class */ (function () {
    function CoreSitePluginsProvider(logger, sitesProvider, utils, langProvider, appProvider, platform, filepoolProvider, coursesProvider, textUtils, eventsProvider) {
        var _this = this;
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.langProvider = langProvider;
        this.appProvider = appProvider;
        this.platform = platform;
        this.filepoolProvider = filepoolProvider;
        this.coursesProvider = coursesProvider;
        this.textUtils = textUtils;
        this.eventsProvider = eventsProvider;
        this.ROOT_CACHE_KEY = 'CoreSitePlugins:';
        this.sitePlugins = {}; // Site plugins registered.
        this.sitePluginPromises = {}; // Promises of loading plugins.
        this.hasSitePluginsLoaded = false;
        this.sitePluginsFinishedLoading = false;
        this.logger = logger.getInstance('CoreUserProvider');
        var observer = this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_12__providers_events__["a" /* CoreEventsProvider */].SITE_PLUGINS_LOADED, function () {
            _this.sitePluginsFinishedLoading = true;
            observer && observer.off();
        });
        // Initialize deferred at start and on logout.
        this.fetchPluginsDeferred = this.utils.promiseDefer();
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_12__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function () {
            _this.fetchPluginsDeferred = _this.utils.promiseDefer();
        });
    }
    /**
     * Add some params that will always be sent for get content.
     *
     * @param {any} args Original params.
     * @param {CoreSite} [site] Site. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the new params.
     */
    CoreSitePluginsProvider.prototype.addDefaultArgs = function (args, site) {
        var _this = this;
        args = args || {};
        site = site || this.sitesProvider.getCurrentSite();
        return this.langProvider.getCurrentLanguage().then(function (lang) {
            // Clone the object so the original one isn't modified.
            var argsToSend = _this.utils.clone(args);
            argsToSend.userid = args.userid || site.getUserId();
            argsToSend.appid = __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].app_id;
            argsToSend.appversioncode = __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].versioncode;
            argsToSend.appversionname = __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].versionname;
            argsToSend.applang = lang;
            argsToSend.appcustomurlscheme = __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].customurlscheme;
            argsToSend.appisdesktop = _this.appProvider.isDesktop();
            argsToSend.appismobile = _this.appProvider.isMobile();
            argsToSend.appiswide = _this.appProvider.isWide();
            if (argsToSend.appisdevice) {
                if (_this.platform.is('ios')) {
                    argsToSend.appplatform = 'ios';
                }
                else {
                    argsToSend.appplatform = 'android';
                }
            }
            else if (argsToSend.appisdesktop) {
                if (_this.appProvider.isMac()) {
                    argsToSend.appplatform = 'mac';
                }
                else if (_this.appProvider.isLinux()) {
                    argsToSend.appplatform = 'linux';
                }
                else {
                    argsToSend.appplatform = 'windows';
                }
            }
            else {
                argsToSend.appplatform = 'browser';
            }
            return argsToSend;
        });
    };
    /**
     * Call a WS for a site plugin.
     *
     * @param {string} method WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the response.
     */
    CoreSitePluginsProvider.prototype.callWS = function (method, data, preSets, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            preSets = preSets || {};
            preSets.cacheKey = preSets.cacheKey || _this.getCallWSCacheKey(method, data);
            return site.read(method, data, preSets);
        });
    };
    /**
     * Given the result of a init get_content and, optionally, the result of another get_content,
     * build an object with the data to pass to the JS of the get_content.
     *
     * @param {any} initResult Result of the init WS call.
     * @param {any} [contentResult] Result of the content WS call (if any).
     * @return {any} An object with the data to pass to the JS.
     */
    CoreSitePluginsProvider.prototype.createDataForJS = function (initResult, contentResult) {
        var data;
        if (initResult) {
            // First of all, add the data returned by the init JS (if any).
            data = this.utils.clone(initResult.jsResult || {});
            if (typeof data == 'boolean') {
                data = {};
            }
            // Now add some data returned by the init WS call.
            data.INIT_TEMPLATES = this.utils.objectToKeyValueMap(initResult.templates, 'id', 'html');
            data.INIT_OTHERDATA = initResult.otherdata;
        }
        if (contentResult) {
            // Now add the data returned by the content WS call.
            data.CONTENT_TEMPLATES = this.utils.objectToKeyValueMap(contentResult.templates, 'id', 'html');
            data.CONTENT_OTHERDATA = contentResult.otherdata;
        }
        return data;
    };
    /**
     * Get cache key for a WS call.
     *
     * @param {string} method Name of the method.
     * @param {any} data Data to identify the WS call.
     * @return {string} Cache key.
     */
    CoreSitePluginsProvider.prototype.getCallWSCacheKey = function (method, data) {
        return this.getCallWSCommonCacheKey(method) + ':' + this.utils.sortAndStringify(data);
    };
    /**
     * Get common cache key for a WS call.
     *
     * @param {string} method Name of the method.
     * @return {string} Cache key.
     */
    CoreSitePluginsProvider.prototype.getCallWSCommonCacheKey = function (method) {
        return this.ROOT_CACHE_KEY + 'ws:' + method;
    };
    /**
     * Get a certain content for a site plugin.
     *
     * @param {string} component Component where the class is. E.g. mod_assign.
     * @param {string} method Method to execute in the class.
     * @param {any} args The params for the method.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the result.
     */
    CoreSitePluginsProvider.prototype.getContent = function (component, method, args, preSets, siteId) {
        var _this = this;
        this.logger.debug("Get content for component '" + component + "' and method '" + method + "'");
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Add some params that will always be sent.
            return _this.addDefaultArgs(args, site).then(function (argsToSend) {
                // Now call the WS.
                var data = {
                    component: component,
                    method: method,
                    args: _this.utils.objectToArrayOfObjects(argsToSend, 'name', 'value', true)
                };
                preSets = preSets || {};
                preSets.cacheKey = _this.getContentCacheKey(component, method, args);
                preSets.updateFrequency = typeof preSets.updateFrequency != 'undefined' ? preSets.updateFrequency :
                    __WEBPACK_IMPORTED_MODULE_6__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN;
                return _this.sitesProvider.getCurrentSite().read('tool_mobile_get_content', data, preSets);
            }).then(function (result) {
                if (result.otherdata) {
                    result.otherdata = _this.utils.objectToKeyValueMap(result.otherdata, 'name', 'value');
                    // Try to parse all properties that could be JSON encoded strings.
                    for (var name_1 in result.otherdata) {
                        var value = result.otherdata[name_1];
                        if (typeof value == 'string' && (value[0] == '{' || value[0] == '[')) {
                            result.otherdata[name_1] = _this.textUtils.parseJSON(value);
                        }
                    }
                }
                else {
                    result.otherdata = {};
                }
                return result;
            });
        });
    };
    /**
     * Get cache key for get content WS calls.
     *
     * @param {string} component Component where the class is. E.g. mod_assign.
     * @param {string} method Method to execute in the class.
     * @param {any} args The params for the method.
     * @return {string} Cache key.
     */
    CoreSitePluginsProvider.prototype.getContentCacheKey = function (component, method, args) {
        return this.ROOT_CACHE_KEY + 'content:' + component + ':' + method + ':' + this.utils.sortAndStringify(args);
    };
    /**
     * Get the value of a WS param for prefetch.
     *
     * @param {string} component The component of the handler.
     * @param {string} paramName Name of the param as defined by the handler.
     * @param {number} [courseId] Course ID (if prefetching a course).
     * @param {any} [module] The module object returned by WS (if prefetching a module).
     * @return {any} The value.
     */
    CoreSitePluginsProvider.prototype.getDownloadParam = function (component, paramName, courseId, module) {
        switch (paramName) {
            case 'courseids':
                // The WS needs the list of course IDs. Create the list.
                return [courseId];
            case component + 'id':
                // The WS needs the instance id.
                return module && module.instance;
            default:
        }
    };
    /**
     * Get the unique name of a handler (plugin + handler).
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} handlerName Name of the handler inside the plugin.
     * @return {string} Unique name.
     */
    CoreSitePluginsProvider.prototype.getHandlerUniqueName = function (plugin, handlerName) {
        return plugin.addon + '_' + handlerName;
    };
    /**
     * Get a site plugin handler.
     *
     * @param {string} name Unique name of the handler.
     * @return {CoreSitePluginsHandler} Handler.
     */
    CoreSitePluginsProvider.prototype.getSitePluginHandler = function (name) {
        return this.sitePlugins[name];
    };
    /**
     * Invalidate all WS call to a certain method.
     *
     * @param {string} method WS method to use.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSitePluginsProvider.prototype.invalidateAllCallWSForMethod = function (method, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getCallWSCommonCacheKey(method));
        });
    };
    /**
     * Invalidate a WS call.
     *
     * @param {string} method WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSitePluginsProvider.prototype.invalidateCallWS = function (method, data, preSets, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(preSets.cacheKey || _this.getCallWSCacheKey(method, data));
        });
    };
    /**
     * Invalidate a page content.
     *
     * @param {string} component Component where the class is. E.g. mod_assign.
     * @param {string} method Method to execute in the class.
     * @param {any} args The params for the method.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSitePluginsProvider.prototype.invalidateContent = function (component, callback, args, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getContentCacheKey(component, callback, args));
        });
    };
    /**
     * Check if the get content WS is available.
     *
     * @param {CoreSite} site The site to check. If not defined, current site.
     */
    CoreSitePluginsProvider.prototype.isGetContentAvailable = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.wsAvailable('tool_mobile_get_content');
    };
    /**
     * Check if a handler is enabled for a certain course.
     *
     * @param {number} courseId Course ID to check.
     * @param {boolean} [restrictEnrolled] If true or undefined, handler is only enabled for courses the user is enrolled in.
     * @param {any} [restrict] Users and courses the handler is restricted to.
     * @return {boolean | Promise<boolean>} Whether the handler is enabled.
     */
    CoreSitePluginsProvider.prototype.isHandlerEnabledForCourse = function (courseId, restrictEnrolled, restrict) {
        if (restrict && restrict.courses && restrict.courses.indexOf(courseId) == -1) {
            // Course is not in the list of restricted courses.
            return false;
        }
        if (restrictEnrolled || typeof restrictEnrolled == 'undefined') {
            // Only enabled for courses the user is enrolled to. Check if the user is enrolled in the course.
            return this.coursesProvider.getUserCourse(courseId, true).then(function () {
                return true;
            }).catch(function () {
                return false;
            });
        }
        return true;
    };
    /**
     * Check if a handler is enabled for a certain user.
     *
     * @param {number} userId User ID to check.
     * @param {boolean} [restrictCurrent] Whether handler is only enabled for current user.
     * @param {any} [restrict] Users and courses the handler is restricted to.
     * @return {boolean} Whether the handler is enabled.
     */
    CoreSitePluginsProvider.prototype.isHandlerEnabledForUser = function (userId, restrictCurrent, restrict) {
        if (restrictCurrent && userId != this.sitesProvider.getCurrentSite().getUserId()) {
            // Only enabled for current user.
            return false;
        }
        if (restrict && restrict.users && restrict.users.indexOf(userId) == -1) {
            // User is not in the list of restricted users.
            return false;
        }
        return true;
    };
    /**
     * Load other data into args as determined by useOtherData list.
     * If useOtherData is undefined, it won't add any data.
     * If useOtherData is defined but empty (null, false or empty string) it will copy all the data from otherData to args.
     * If useOtherData is an array, it will only copy the properties whose names are in the array.
     *
     * @param {any} args The current args.
     * @param {any} otherData All the other data.
     * @param {any[]} useOtherData Names of the attributes to include.
     * @return {any} New args.
     */
    CoreSitePluginsProvider.prototype.loadOtherDataInArgs = function (args, otherData, useOtherData) {
        if (!args) {
            args = {};
        }
        else {
            args = this.utils.clone(args);
        }
        otherData = otherData || {};
        if (typeof useOtherData == 'undefined') {
            // No need to add other data, return args as they are.
            return args;
        }
        else if (!useOtherData) {
            // Use other data is defined but empty. Add all the data to args.
            for (var name_2 in otherData) {
                args[name_2] = otherData[name_2];
            }
        }
        else {
            for (var i in useOtherData) {
                var name_3 = useOtherData[i];
                args[name_3] = otherData[name_3];
            }
        }
        return args;
    };
    /**
     * Prefetch offline functions for a site plugin handler.
     *
     * @param {string} component The component of the handler.
     * @param {any} args Params to send to the get_content calls.
     * @param {any} handlerSchema The handler schema.
     * @param {number} [courseId] Course ID (if prefetching a course).
     * @param {any} [module] The module object returned by WS (if prefetching a module).
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files.
     * @param {CoreSite} [site] Site. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsProvider.prototype.prefetchFunctions = function (component, args, handlerSchema, courseId, module, prefetch, dirPath, site) {
        var _this = this;
        site = site || this.sitesProvider.getCurrentSite();
        var promises = [];
        for (var method in handlerSchema.offlinefunctions) {
            if (site.wsAvailable(method)) {
                // The method is a WS.
                var paramsList = handlerSchema.offlinefunctions[method], cacheKey = this.getCallWSCacheKey(method, args);
                var params = {};
                if (!paramsList.length) {
                    // No params defined, send the default ones.
                    params = args;
                }
                else {
                    for (var i in paramsList) {
                        var paramName = paramsList[i];
                        if (typeof args[paramName] != 'undefined') {
                            params[paramName] = args[paramName];
                        }
                        else {
                            // The param is not one of the default ones. Try to calculate the param to use.
                            var value = this.getDownloadParam(component, paramName, courseId, module);
                            if (typeof value != 'undefined') {
                                params[paramName] = value;
                            }
                        }
                    }
                }
                promises.push(this.callWS(method, params, { cacheKey: cacheKey }));
            }
            else {
                // It's a method to get content.
                promises.push(this.getContent(component, method, args).then(function (result) {
                    var subPromises = [];
                    // Prefetch the files in the content.
                    if (result.files && result.files.length) {
                        subPromises.push(_this.filepoolProvider.downloadOrPrefetchFiles(site.id, result.files, prefetch, false, component, module.id, dirPath));
                    }
                    return Promise.all(subPromises);
                }));
            }
        }
        return Promise.all(promises);
    };
    /**
     * Store a site plugin handler.
     *
     * @param {string} name A unique name to identify the handler.
     * @param {CoreSitePluginsHandler} handler Handler to set.
     */
    CoreSitePluginsProvider.prototype.setSitePluginHandler = function (name, handler) {
        this.sitePlugins[name] = handler;
    };
    /**
     * Store the promise for a plugin that is being initialised.
     *
     * @param {String} component
     * @param {Promise<any>} promise
     */
    CoreSitePluginsProvider.prototype.registerSitePluginPromise = function (component, promise) {
        this.sitePluginPromises[component] = promise;
    };
    /**
     * Set plugins fetched.
     */
    CoreSitePluginsProvider.prototype.setPluginsFetched = function () {
        this.fetchPluginsDeferred.resolve();
    };
    /**
     * Is a plugin being initialised for the specified component?
     *
     * @param {String} component
     * @return {boolean}
     */
    CoreSitePluginsProvider.prototype.sitePluginPromiseExists = function (component) {
        return this.sitePluginPromises.hasOwnProperty(component);
    };
    /**
     * Get the promise for a plugin that is being initialised.
     *
     * @param {String} component
     * @return {Promise<any>}
     */
    CoreSitePluginsProvider.prototype.sitePluginLoaded = function (component) {
        return this.sitePluginPromises[component];
    };
    /**
     * Wait for fetch plugins to be done.
     *
     * @return {Promise<any>} Promise resolved when site plugins have been fetched.
     */
    CoreSitePluginsProvider.prototype.waitFetchPlugins = function () {
        return this.fetchPluginsDeferred.promise;
    };
    CoreSitePluginsProvider.COMPONENT = 'CoreSitePlugins';
    CoreSitePluginsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_11__core_courses_providers_courses__["a" /* CoreCoursesProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_12__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreSitePluginsProvider);
    return CoreSitePluginsProvider;
}());

//# sourceMappingURL=siteplugins.js.map

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__default_module__ = __webpack_require__(559);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__classes_delegate__ = __webpack_require__(111);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Delegate to register module handlers.
 */
var CoreCourseModuleDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseModuleDelegate, _super);
    function CoreCourseModuleDelegate(loggerProvider, sitesProvider, eventsProvider, courseProvider, defaultHandler) {
        var _this = _super.call(this, 'CoreCourseModuleDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.courseProvider = courseProvider;
        _this.defaultHandler = defaultHandler;
        _this.featurePrefix = 'CoreCourseModuleDelegate_';
        _this.handlerNameProperty = 'modName';
        return _this;
    }
    /**
     * Get the component to render the module.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseModuleDelegate.prototype.getMainComponent = function (injector, course, module) {
        var _this = this;
        return Promise.resolve(this.executeFunctionOnEnabled(module.modname, 'getMainComponent', [injector, course, module]))
            .catch(function (err) {
            _this.logger.error('Error getting main component', err);
        });
    };
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {string} modname The name of the module type.
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    CoreCourseModuleDelegate.prototype.getModuleDataFor = function (modname, module, courseId, sectionId) {
        return this.executeFunctionOnEnabled(modname, 'getData', [module, courseId, sectionId]);
    };
    /**
     * Check if a certain module type is disabled in a site.
     *
     * @param {string} modname The name of the module type.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether module is disabled.
     */
    CoreCourseModuleDelegate.prototype.isModuleDisabled = function (modname, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isModuleDisabledInSite(modname, site);
        });
    };
    /**
     * Check if a certain module type is disabled in a site.
     *
     * @param {string} modname The name of the module type.
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether module is disabled.
     */
    CoreCourseModuleDelegate.prototype.isModuleDisabledInSite = function (modname, site) {
        var handler = this.getHandler(modname, true);
        if (handler) {
            site = site || this.sitesProvider.getCurrentSite();
            return this.isFeatureDisabled(handler, site);
        }
        return false;
    };
    /**
     * Whether to display the course refresher in single activity course format. If it returns false, a refresher must be
     * included in the template that calls the doRefresh method of the component. Defaults to true.
     *
     * @param {any} modname The name of the module type.
     * @return {boolean} Whether the refresher should be displayed.
     */
    CoreCourseModuleDelegate.prototype.displayRefresherInSingleActivity = function (modname) {
        return this.executeFunctionOnEnabled(modname, 'displayRefresherInSingleActivity');
    };
    /**
     * Get the icon src for a certain type of module.
     *
     * @param {any} modname The name of the module type.
     * @param {string} [modicon] The mod icon string.
     * @return {string} The icon src.
     */
    CoreCourseModuleDelegate.prototype.getModuleIconSrc = function (modname, modicon) {
        return this.executeFunctionOnEnabled(modname, 'getIconSrc') || this.courseProvider.getModuleIconSrc(modname, modicon);
    };
    /**
     * Check if a certain type of module supports a certain feature.
     *
     * @param {string} modname The modname.
     * @param {string} feature The feature to check.
     * @param {any} defaultValue Value to return if the module is not supported or doesn't know if it's supported.
     * @return {any} The result of the supports check.
     */
    CoreCourseModuleDelegate.prototype.supportsFeature = function (modname, feature, defaultValue) {
        var handler = this.enabledHandlers[modname];
        var result;
        if (handler) {
            if (handler['supportsFeature']) {
                // The handler specified a function to determine the feature, use it.
                result = handler['supportsFeature'].apply(handler, [feature]);
            }
            else if (handler['supportedFeatures']) {
                // Handler has an object to determine the feature, use it.
                result = handler['supportedFeatures'][feature];
            }
        }
        if (result === null || typeof result == 'undefined') {
            // Not supported or doesn't know, return defaul.
            return defaultValue;
        }
        else {
            return result;
        }
    };
    CoreCourseModuleDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_5__default_module__["a" /* CoreCourseModuleDefaultHandler */]])
    ], CoreCourseModuleDelegate);
    return CoreCourseModuleDelegate;
}(__WEBPACK_IMPORTED_MODULE_6__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=module-delegate.js.map

/***/ }),
/* 57 */,
/* 58 */,
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseLogHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_pushnotifications_providers_pushnotifications__ = __webpack_require__(140);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Helper to manage logging to Moodle.
 */
var CoreCourseLogHelperProvider = /** @class */ (function () {
    function CoreCourseLogHelperProvider(sitesProvider, timeUtils, textUtils, utils, appProvider, pushNotificationsProvider) {
        this.sitesProvider = sitesProvider;
        this.timeUtils = timeUtils;
        this.textUtils = textUtils;
        this.utils = utils;
        this.appProvider = appProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.siteSchema = {
            name: 'CoreCourseLogHelperProvider',
            version: 1,
            tables: [
                {
                    name: CoreCourseLogHelperProvider_1.ACTIVITY_LOG_TABLE,
                    columns: [
                        {
                            name: 'component',
                            type: 'TEXT'
                        },
                        {
                            name: 'componentid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'ws',
                            type: 'TEXT'
                        },
                        {
                            name: 'data',
                            type: 'TEXT'
                        },
                        {
                            name: 'time',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['component', 'componentid', 'ws', 'time']
                }
            ]
        };
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    CoreCourseLogHelperProvider_1 = CoreCourseLogHelperProvider;
    /**
     * Delete the offline saved activity logs.
     *
     * @param  {string}         component   Component name.
     * @param  {number}         componentId Component ID.
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when deleted, rejected if failure.
     */
    CoreCourseLogHelperProvider.prototype.deleteLogs = function (component, componentId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(CoreCourseLogHelperProvider_1.ACTIVITY_LOG_TABLE, { component: component, componentid: componentId });
        });
    };
    /**
     * Delete a WS based log.
     *
     * @param  {string}         component   Component name.
     * @param  {number}         componentId Component ID.
     * @param  {string}         ws          WS name.
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when deleted, rejected if failure.
     */
    CoreCourseLogHelperProvider.prototype.deleteWSLogsByComponent = function (component, componentId, ws, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(CoreCourseLogHelperProvider_1.ACTIVITY_LOG_TABLE, { component: component, componentid: componentId, ws: ws });
        });
    };
    /**
     * Delete the offline saved activity logs using call data.
     *
     * @param  {string}         ws          WS name.
     * @param  {any}            data        Data to send to the WS.
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when deleted, rejected if failure.
     */
    CoreCourseLogHelperProvider.prototype.deleteWSLogs = function (ws, data, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(CoreCourseLogHelperProvider_1.ACTIVITY_LOG_TABLE, { ws: ws, data: _this.utils.sortAndStringify(data) });
        });
    };
    /**
     * Get all the offline saved activity logs.
     *
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of offline logs.
     */
    CoreCourseLogHelperProvider.prototype.getAllLogs = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getAllRecords(CoreCourseLogHelperProvider_1.ACTIVITY_LOG_TABLE);
        });
    };
    /**
     * Get the offline saved activity logs.
     *
     * @param  {string}         component   Component name.
     * @param  {number}         componentId Component ID.
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of offline logs.
     */
    CoreCourseLogHelperProvider.prototype.getLogs = function (component, componentId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(CoreCourseLogHelperProvider_1.ACTIVITY_LOG_TABLE, { component: component, componentid: componentId });
        });
    };
    /**
     * Perform log online. Data will be saved offline for syncing.
     *
     * @param  {string}         ws          WS name.
     * @param  {any}            data        Data to send to the WS.
     * @param  {string}         component   Component name.
     * @param  {number}         componentId Component ID.
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseLogHelperProvider.prototype.log = function (ws, data, component, componentId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!_this.appProvider.isOnline()) {
                // App is offline, store the action.
                return _this.storeOffline(ws, data, component, componentId, site.getId());
            }
            return _this.logOnline(ws, data, site.getId()).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means that responses cannot be submitted.
                    return Promise.reject(error);
                }
                // Couldn't connect to server, store in offline.
                return _this.storeOffline(ws, data, component, componentId, site.getId());
            });
        });
    };
    /**
     * Perform the log online.
     *
     * @param  {string}       ws       WS name.
     * @param  {any}          data     Data to send to the WS.
     * @param  {string}       [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when log is successfully submitted. Rejected with object containing
     *                            the error message (if any) and a boolean indicating if the error was returned by WS.
     */
    CoreCourseLogHelperProvider.prototype.logOnline = function (ws, data, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.write(ws, data).then(function (response) {
                if (!response.status) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                // Remove all the logs performed.
                // TODO: Remove this lines when time is accepted in logs.
                return _this.deleteWSLogs(ws, data);
            });
        });
    };
    /**
     * Perform log online. Data will be saved offline for syncing.
     * It also triggers a Firebase view_item event.
     *
     * @param  {string}         ws          WS name.
     * @param  {any}            data        Data to send to the WS.
     * @param  {string}         component   Component name.
     * @param  {number}         componentId Component ID.
     * @param  {string}         [name] Name of the viewed item.
     * @param  {string}         [category] Category of the viewed item.
     * @param  {string}         [eventData] Data to pass to the Firebase event.
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseLogHelperProvider.prototype.logSingle = function (ws, data, component, componentId, name, category, eventData, siteId) {
        this.pushNotificationsProvider.logViewEvent(componentId, name, category, ws, eventData, siteId);
        return this.log(ws, data, component, componentId, siteId);
    };
    /**
     * Perform log online. Data will be saved offline for syncing.
     * It also triggers a Firebase view_item_list event.
     *
     * @param  {string}         ws          WS name.
     * @param  {any}            data        Data to send to the WS.
     * @param  {string}         component   Component name.
     * @param  {number}         componentId Component ID.
     * @param  {string}         category    Category of the viewed item.
     * @param  {string}         [eventData] Data to pass to the Firebase event.
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseLogHelperProvider.prototype.logList = function (ws, data, component, componentId, category, eventData, siteId) {
        this.pushNotificationsProvider.logViewListEvent(category, ws, eventData, siteId);
        return this.log(ws, data, component, componentId, siteId);
    };
    /**
     * Save activity log for offline sync.
     *
     * @param  {string}         ws          WS name.
     * @param  {any}            data        Data to send to the WS.
     * @param  {string}         component   Component name.
     * @param  {number}         componentId Component ID.
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<number>} Resolved with the inserted rowId field.
     */
    CoreCourseLogHelperProvider.prototype.storeOffline = function (ws, data, component, componentId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var log = {
                ws: ws,
                data: _this.utils.sortAndStringify(data),
                component: component,
                componentid: componentId,
                time: _this.timeUtils.timestamp()
            };
            return site.getDb().insertRecord(CoreCourseLogHelperProvider_1.ACTIVITY_LOG_TABLE, log);
        });
    };
    /**
     * Sync all the offline saved activity logs.
     *
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when done.
     */
    CoreCourseLogHelperProvider.prototype.syncSite = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var siteId = site.getId();
            return _this.getAllLogs(siteId).then(function (logs) {
                var unique = [];
                // TODO: When time is accepted on log, do not discard same logs.
                logs.forEach(function (log) {
                    // Just perform unique syncs.
                    var found = unique.find(function (doneLog) {
                        return log.component == doneLog.component && log.componentid == doneLog.componentid &&
                            log.ws == doneLog.ws && log.data == doneLog.data;
                    });
                    if (!found) {
                        unique.push(log);
                    }
                });
                return _this.syncLogs(unique, siteId);
            });
        });
    };
    /**
     * Sync the offline saved activity logs.
     *
     * @param  {string}         component   Component name.
     * @param  {number}         componentId Component ID.
     * @param  {string}         [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when done.
     */
    CoreCourseLogHelperProvider.prototype.syncIfNeeded = function (component, componentId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var siteId = site.getId();
            return _this.getLogs(component, componentId, siteId).then(function (logs) {
                var unique = [];
                // TODO: When time is accepted on log, do not discard same logs.
                logs.forEach(function (log) {
                    // Just perform unique syncs.
                    var found = unique.find(function (doneLog) {
                        return log.ws == doneLog.ws && log.data == doneLog.data;
                    });
                    if (!found) {
                        unique.push(log);
                    }
                });
                return _this.syncLogs(unique, siteId);
            });
        });
    };
    /**
     * Sync and delete given logs.
     *
     * @param  {any[]}        logs   Array of log objects.
     * @param  {string}       siteId Site Id.
     * @return {Promise<any>}        Promise resolved when done.
     */
    CoreCourseLogHelperProvider.prototype.syncLogs = function (logs, siteId) {
        var _this = this;
        return Promise.all(logs.map(function (log) {
            return _this.logOnline(log.ws, _this.textUtils.parseJSON(log.data), siteId).then(function () {
                return _this.deleteWSLogsByComponent(log.component, log.componentid, log.ws);
            });
        }));
    };
    // Variables for database.
    CoreCourseLogHelperProvider.ACTIVITY_LOG_TABLE = 'course_activity_log';
    CoreCourseLogHelperProvider = CoreCourseLogHelperProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_6__core_pushnotifications_providers_pushnotifications__["a" /* CorePushNotificationsProvider */]])
    ], CoreCourseLogHelperProvider);
    return CoreCourseLogHelperProvider;
    var CoreCourseLogHelperProvider_1;
}());

//# sourceMappingURL=log-helper.js.map

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Delegate to register handlers to handle links.
 */
var CoreContentLinksDelegate = /** @class */ (function () {
    function CoreContentLinksDelegate(logger, sitesProvider, urlUtils, utils) {
        this.sitesProvider = sitesProvider;
        this.urlUtils = urlUtils;
        this.utils = utils;
        this.handlers = {}; // All registered handlers.
        this.logger = logger.getInstance('CoreContentLinksDelegate');
    }
    /**
     * Get the list of possible actions to do for a URL.
     *
     * @param {string} url URL to handle.
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @param {string} [username] Username to use to filter sites.
     * @param {any} [data] Extra data to handle the URL.
     * @return {Promise<CoreContentLinksAction[]>}  Promise resolved with the actions.
     */
    CoreContentLinksDelegate.prototype.getActionsFor = function (url, courseId, username, data) {
        var _this = this;
        if (!url) {
            return Promise.resolve([]);
        }
        // Get the list of sites the URL belongs to.
        return this.sitesProvider.getSiteIdsFromUrl(url, true, username).then(function (siteIds) {
            var linkActions = [], promises = [], params = _this.urlUtils.extractUrlParams(url);
            var _loop_1 = function (name_1) {
                var handler = _this.handlers[name_1], checkAll = handler.checkAllUsers, isEnabledFn = _this.isHandlerEnabled.bind(_this, handler, url, params, courseId);
                if (!handler.handles(url)) {
                    return "continue";
                }
                // Filter the site IDs using the isEnabled function.
                promises.push(_this.utils.filterEnabledSites(siteIds, isEnabledFn, checkAll).then(function (siteIds) {
                    if (!siteIds.length) {
                        // No sites supported, no actions.
                        return;
                    }
                    return Promise.resolve(handler.getActions(siteIds, url, params, courseId, data)).then(function (actions) {
                        if (actions && actions.length) {
                            // Set default values if any value isn't supplied.
                            actions.forEach(function (action) {
                                action.message = action.message || 'core.view';
                                action.icon = action.icon || 'eye';
                                action.sites = action.sites || siteIds;
                            });
                            // Add them to the list.
                            linkActions.push({
                                priority: handler.priority,
                                actions: actions
                            });
                        }
                    });
                }));
            };
            for (var name_1 in _this.handlers) {
                _loop_1(name_1);
            }
            return _this.utils.allPromises(promises).catch(function () {
                // Ignore errors.
            }).then(function () {
                // Sort link actions by priority.
                return _this.sortActionsByPriority(linkActions);
            });
        });
    };
    /**
     * Get the site URL if the URL is supported by any handler.
     *
     * @param {string} url URL to handle.
     * @return {string} Site URL if the URL is supported by any handler, undefined otherwise.
     */
    CoreContentLinksDelegate.prototype.getSiteUrl = function (url) {
        if (!url) {
            return;
        }
        // Check if any handler supports this URL.
        for (var name_2 in this.handlers) {
            var handler = this.handlers[name_2], siteUrl = handler.getSiteUrl(url);
            if (siteUrl) {
                return siteUrl;
            }
        }
    };
    /**
     * Check if a handler is enabled for a certain site and URL.
     *
     * @param {CoreContentLinksHandler} handler Handler to check.
     * @param {string} url The URL to check.
     * @param {any} params The params of the URL
     * @param {number} courseId Course ID the URL belongs to (can be undefined).
     * @param {string} siteId The site ID to check.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the handler is enabled.
     */
    CoreContentLinksDelegate.prototype.isHandlerEnabled = function (handler, url, params, courseId, siteId) {
        var promise;
        if (handler.featureName) {
            // Check if the feature is disabled.
            promise = this.sitesProvider.isFeatureDisabled(handler.featureName, siteId);
        }
        else {
            promise = Promise.resolve(false);
        }
        return promise.then(function (disabled) {
            if (disabled) {
                return false;
            }
            if (!handler.isEnabled) {
                // Handler doesn't implement isEnabled, assume it's enabled.
                return true;
            }
            return handler.isEnabled(siteId, url, params, courseId);
        });
    };
    /**
     * Register a handler.
     *
     * @param {CoreContentLinksHandler} handler The handler to register.
     * @return {boolean} True if registered successfully, false otherwise.
     */
    CoreContentLinksDelegate.prototype.registerHandler = function (handler) {
        if (typeof this.handlers[handler.name] !== 'undefined') {
            this.logger.log("Addon '" + handler.name + "' already registered");
            return false;
        }
        this.logger.log("Registered addon '" + handler.name + "'");
        this.handlers[handler.name] = handler;
        return true;
    };
    /**
     * Sort actions by priority.
     *
     * @param {CoreContentLinksHandlerActions[]} actions Actions to sort.
     * @return {CoreContentLinksAction[]} Sorted actions.
     */
    CoreContentLinksDelegate.prototype.sortActionsByPriority = function (actions) {
        var sorted = [];
        // Sort by priority.
        actions = actions.sort(function (a, b) {
            return a.priority <= b.priority ? 1 : -1;
        });
        // Fill result array.
        actions.forEach(function (entry) {
            sorted = sorted.concat(entry.actions);
        });
        return sorted;
    };
    CoreContentLinksDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreContentLinksDelegate);
    return CoreContentLinksDelegate;
}());

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMimetypeUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__text__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/*
 * "Utils" service with helper functions for mimetypes and extensions.
 */
var CoreMimetypeUtilsProvider = /** @class */ (function () {
    function CoreMimetypeUtilsProvider(http, logger, translate, textUtils) {
        var _this = this;
        this.translate = translate;
        this.textUtils = textUtils;
        this.extToMime = {}; // Object to map extensions -> mimetypes.
        this.mimeToExt = {}; // Object to map mimetypes -> extensions.
        this.groupsMimeInfo = {}; // Object to hold extensions and mimetypes that belong to a certain "group" (audio, video, ...).
        this.extensionRegex = /^[a-z0-9]+$/;
        this.logger = logger.getInstance('CoreMimetypeUtilsProvider');
        http.get('assets/exttomime.json').subscribe(function (result) {
            _this.extToMime = result;
        }, function (err) {
            // Error, shouldn't happen.
        });
        http.get('assets/mimetoext.json').subscribe(function (result) {
            _this.mimeToExt = result;
        }, function (err) {
            // Error, shouldn't happen.
        });
    }
    /**
     * Check if a file extension can be embedded without using iframes.
     *
     * @param {string} extension Extension.
     * @return {boolean} Whether it can be embedded.
     */
    CoreMimetypeUtilsProvider.prototype.canBeEmbedded = function (extension) {
        return this.isExtensionInGroup(extension, ['web_image', 'web_video', 'web_audio']);
    };
    /**
     * Clean a extension, removing the dot, hash, extra params...
     *
     * @param {string} extension Extension to clean.
     * @return {string} Clean extension.
     */
    CoreMimetypeUtilsProvider.prototype.cleanExtension = function (extension) {
        if (!extension) {
            return extension;
        }
        // If the extension has parameters, remove them.
        var position = extension.indexOf('?');
        if (position > -1) {
            extension = extension.substr(0, position);
        }
        // Remove hash in extension if there's any (added by filepool).
        extension = extension.replace(/_.{32}$/, '');
        // Remove dot from the extension if found.
        if (extension && extension[0] == '.') {
            extension = extension.substr(1);
        }
        return extension;
    };
    /**
     * Fill the mimetypes and extensions info for a certain group.
     *
     * @param {string} group Group name.
     */
    CoreMimetypeUtilsProvider.prototype.fillGroupMimeInfo = function (group) {
        var mimetypes = {}, // Use an object to prevent duplicates.
        extensions = []; // Extensions are unique.
        for (var extension in this.extToMime) {
            var data = this.extToMime[extension];
            if (data.type && data.groups && data.groups.indexOf(group) != -1) {
                // This extension has the group, add it to the list.
                mimetypes[data.type] = true;
                extensions.push(extension);
            }
        }
        this.groupsMimeInfo[group] = {
            mimetypes: Object.keys(mimetypes),
            extensions: extensions
        };
    };
    /**
     * Get the extension of a mimetype. Returns undefined if not found.
     *
     * @param {string} mimetype Mimetype.
     * @param {string} [url] URL of the file. It will be used if there's more than one possible extension.
     * @return {string} Extension.
     */
    CoreMimetypeUtilsProvider.prototype.getExtension = function (mimetype, url) {
        mimetype = mimetype || '';
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        if (mimetype == 'application/x-forcedownload' || mimetype == 'application/forcedownload') {
            // Couldn't get the right mimetype, try to guess it.
            return this.guessExtensionFromUrl(url);
        }
        var extensions = this.mimeToExt[mimetype];
        if (extensions && extensions.length) {
            if (extensions.length > 1 && url) {
                // There's more than one possible extension. Check if the URL has extension.
                var candidate = this.guessExtensionFromUrl(url);
                if (extensions.indexOf(candidate) != -1) {
                    return candidate;
                }
            }
            return extensions[0];
        }
    };
    /**
     * Get the URL of the icon of an extension.
     *
     * @param {string} extension Extension.
     * @return {string} Icon URL.
     */
    CoreMimetypeUtilsProvider.prototype.getExtensionIcon = function (extension) {
        var icon = this.getExtensionIconName(extension) || 'unknown';
        return this.getFileIconForType(icon);
    };
    /**
     * Get the name of the icon of an extension.
     *
     * @param {string} extension Extension.
     * @return {string} Icon. Undefined if not found.
     */
    CoreMimetypeUtilsProvider.prototype.getExtensionIconName = function (extension) {
        if (this.extToMime[extension]) {
            if (this.extToMime[extension].icon) {
                return this.extToMime[extension].icon;
            }
            else {
                var type = this.extToMime[extension].type.split('/')[0];
                if (type == 'video' || type == 'text' || type == 'image' || type == 'document' || type == 'audio') {
                    return type;
                }
            }
        }
    };
    /**
     * Get the "type" (string) of an extension, something like "image", "video" or "audio".
     *
     * @param {string} extension Extension.
     * @return {string} Type of the extension.
     */
    CoreMimetypeUtilsProvider.prototype.getExtensionType = function (extension) {
        extension = this.cleanExtension(extension);
        if (this.extToMime[extension] && this.extToMime[extension].string) {
            return this.extToMime[extension].string;
        }
    };
    /**
     * Get all the possible extensions of a mimetype. Returns empty array if not found.
     *
     * @param {string} mimetype Mimetype.
     * @return {string[]} Extensions.
     */
    CoreMimetypeUtilsProvider.prototype.getExtensions = function (mimetype) {
        mimetype = mimetype || '';
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        return this.mimeToExt[mimetype] || [];
    };
    /**
     * Get a file icon URL based on its file name.
     *
     * @param {string} The name of the file.
     * @return {string} The path to a file icon.
     */
    CoreMimetypeUtilsProvider.prototype.getFileIcon = function (filename) {
        var ext = this.getFileExtension(filename), icon = this.getExtensionIconName(ext) || 'unknown';
        return this.getFileIconForType(icon);
    };
    /**
     * Get the folder icon URL.
     *
     * @return {string} The path to a folder icon.
     */
    CoreMimetypeUtilsProvider.prototype.getFolderIcon = function () {
        return 'assets/img/files/folder-64.png';
    };
    /**
     * Given a type (audio, video, html, ...), return its file icon path.
     *
     * @param {string} type The type to get the icon.
     * @return {string} The icon path.
     */
    CoreMimetypeUtilsProvider.prototype.getFileIconForType = function (type) {
        return 'assets/img/files/' + type + '-64.png';
    };
    /**
     * Guess the extension of a file from its URL.
     * This is very weak and unreliable.
     *
     * @param {string} fileUrl The file URL.
     * @return {string} The lowercased extension without the dot, or undefined.
     */
    CoreMimetypeUtilsProvider.prototype.guessExtensionFromUrl = function (fileUrl) {
        var split = fileUrl.split('.');
        var candidate, extension, position;
        if (split.length > 1) {
            candidate = split.pop().toLowerCase();
            // Remove params if any.
            position = candidate.indexOf('?');
            if (position > -1) {
                candidate = candidate.substr(0, position);
            }
            if (this.extensionRegex.test(candidate)) {
                extension = candidate;
            }
        }
        // Check extension corresponds to a mimetype to know if it's valid.
        if (extension && typeof this.getMimeType(extension) == 'undefined') {
            this.logger.warn('Guess file extension: Not valid extension ' + extension);
            return;
        }
        return extension;
    };
    /**
     * Returns the file extension of a file.
     * When the file does not have an extension, it returns undefined.
     *
     * @param {string} filename The file name.
     * @return {string} The lowercased extension, or undefined.
     */
    CoreMimetypeUtilsProvider.prototype.getFileExtension = function (filename) {
        var dot = filename.lastIndexOf('.');
        var ext;
        if (dot > -1) {
            ext = filename.substr(dot + 1).toLowerCase();
            ext = this.cleanExtension(ext);
            // Check extension corresponds to a mimetype to know if it's valid.
            if (typeof this.getMimeType(ext) == 'undefined') {
                this.logger.warn('Get file extension: Not valid extension ' + ext);
                return;
            }
        }
        return ext;
    };
    /**
     * Get the mimetype/extension info belonging to a certain group.
     *
     * @param {string} group Group name.
     * @param {string} [field] The field to get. If not supplied, all the info will be returned.
     * @return {any} Info for the group.
     */
    CoreMimetypeUtilsProvider.prototype.getGroupMimeInfo = function (group, field) {
        if (typeof this.groupsMimeInfo[group] == 'undefined') {
            this.fillGroupMimeInfo(group);
        }
        if (field) {
            return this.groupsMimeInfo[group][field];
        }
        return this.groupsMimeInfo[group];
    };
    /**
     * Get the mimetype of an extension. Returns undefined if not found.
     *
     * @param {string} extension Extension.
     * @return {string} Mimetype.
     */
    CoreMimetypeUtilsProvider.prototype.getMimeType = function (extension) {
        extension = this.cleanExtension(extension);
        if (this.extToMime[extension] && this.extToMime[extension].type) {
            return this.extToMime[extension].type;
        }
    };
    /**
     * Obtains descriptions for file types (e.g. 'Microsoft Word document') from the language file.
     * Based on Moodle's get_mimetype_description.
     *
     * @param {any} obj Instance of FileEntry OR object with 'filename' and 'mimetype' OR string with mimetype.
     * @param {boolean} [capitalise] If true, capitalises first character of result.
     * @return {string} Type description.
     */
    CoreMimetypeUtilsProvider.prototype.getMimetypeDescription = function (obj, capitalise) {
        var langPrefix = 'assets.mimetypes.';
        var filename = '', mimetype = '', extension = '';
        if (typeof obj == 'object' && typeof obj.file == 'function') {
            // It's a FileEntry. Don't use the file function because it's asynchronous and the type isn't reliable.
            filename = obj.name;
        }
        else if (typeof obj == 'object') {
            filename = obj.filename || '';
            mimetype = obj.mimetype || '';
        }
        else {
            mimetype = obj;
        }
        if (filename) {
            extension = this.getFileExtension(filename);
            if (!mimetype) {
                // Try to calculate the mimetype using the extension.
                mimetype = this.getMimeType(extension);
            }
        }
        if (!mimetype) {
            // Don't have the mimetype, stop.
            return '';
        }
        if (!extension) {
            extension = this.getExtension(mimetype);
        }
        var mimetypeStr = this.getMimetypeType(mimetype) || '', chunks = mimetype.split('/'), attr = {
            mimetype: mimetype,
            ext: extension || '',
            mimetype1: chunks[0],
            mimetype2: chunks[1] || '',
        }, translateParams = {};
        for (var key in attr) {
            var value = attr[key];
            translateParams[key] = value;
            translateParams[key.toUpperCase()] = value.toUpperCase();
            translateParams[this.textUtils.ucFirst(key)] = this.textUtils.ucFirst(value);
        }
        // MIME types may include + symbol but this is not permitted in string ids.
        var safeMimetype = mimetype.replace(/\+/g, '_'), safeMimetypeStr = mimetypeStr.replace(/\+/g, '_'), safeMimetypeTrns = this.translate.instant(langPrefix + safeMimetype, { $a: translateParams }), safeMimetypeStrTrns = this.translate.instant(langPrefix + safeMimetypeStr, { $a: translateParams }), defaultTrns = this.translate.instant(langPrefix + 'default', { $a: translateParams });
        var result = mimetype;
        if (safeMimetypeTrns != langPrefix + safeMimetype) {
            result = safeMimetypeTrns;
        }
        else if (safeMimetypeStrTrns != langPrefix + safeMimetypeStr) {
            result = safeMimetypeStrTrns;
        }
        else if (defaultTrns != langPrefix + 'default') {
            result = defaultTrns;
        }
        if (capitalise) {
            result = this.textUtils.ucFirst(result);
        }
        return result;
    };
    /**
     * Get the "type" (string) of a mimetype, something like "image", "video" or "audio".
     *
     * @param {string} mimetype Mimetype.
     * @return {string} Type of the mimetype.
     */
    CoreMimetypeUtilsProvider.prototype.getMimetypeType = function (mimetype) {
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        var extensions = this.mimeToExt[mimetype];
        if (!extensions) {
            return;
        }
        for (var i = 0; i < extensions.length; i++) {
            var extension = extensions[i];
            if (this.extToMime[extension] && this.extToMime[extension].string) {
                return this.extToMime[extension].string;
            }
        }
    };
    /**
     * Get the icon of a mimetype.
     *
     * @param {string} mimetype Mimetype.
     * @return {string} Type of the mimetype.
     */
    CoreMimetypeUtilsProvider.prototype.getMimetypeIcon = function (mimetype) {
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        var extensions = this.mimeToExt[mimetype] || [];
        var icon = 'unknown';
        for (var i = 0; i < extensions.length; i++) {
            var iconName = this.getExtensionIconName(extensions[i]);
            if (iconName) {
                icon = iconName;
                break;
            }
        }
        return this.getFileIconForType(icon);
    };
    /**
     * Given a group name, return the translated name.
     *
     * @param {string} name Group name.
     * @return {string} Translated name.
     */
    CoreMimetypeUtilsProvider.prototype.getTranslatedGroupName = function (name) {
        var key = 'assets.mimetypes.group:' + name, translated = this.translate.instant(key);
        return translated != key ? translated : name;
    };
    /**
     * Check if an extension belongs to at least one of the groups.
     * Similar to Moodle's file_mimetype_in_typegroup, but using the extension instead of mimetype.
     *
     * @param {string} extension Extension.
     * @param {string[]} groups List of groups to check.
     * @return {boolean} Whether the extension belongs to any of the groups.
     */
    CoreMimetypeUtilsProvider.prototype.isExtensionInGroup = function (extension, groups) {
        extension = this.cleanExtension(extension);
        if (groups && groups.length && this.extToMime[extension] && this.extToMime[extension].groups) {
            for (var i = 0; i < this.extToMime[extension].groups.length; i++) {
                var group = this.extToMime[extension].groups[i];
                if (groups.indexOf(group) != -1) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Remove the extension from a path (if any).
     *
     * @param {string} path Path.
     * @return {string} Path without extension.
     */
    CoreMimetypeUtilsProvider.prototype.removeExtension = function (path) {
        var position = path.lastIndexOf('.');
        var extension;
        if (position > -1) {
            // Check extension corresponds to a mimetype to know if it's valid.
            extension = path.substr(position + 1).toLowerCase();
            if (typeof this.getMimeType(extension) != 'undefined') {
                return path.substr(0, position); // Remove extension.
            }
        }
        return path;
    };
    CoreMimetypeUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_2__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_4__text__["a" /* CoreTextUtilsProvider */]])
    ], CoreMimetypeUtilsProvider);
    return CoreMimetypeUtilsProvider;
}());

//# sourceMappingURL=mimetype.js.map

/***/ }),
/* 65 */,
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGroupsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/*
 * Service to handle groups.
*/
var CoreGroupsProvider = /** @class */ (function () {
    function CoreGroupsProvider(sitesProvider, translate, coursesProvider) {
        this.sitesProvider = sitesProvider;
        this.translate = translate;
        this.coursesProvider = coursesProvider;
        this.ROOT_CACHE_KEY = 'mmGroups:';
    }
    CoreGroupsProvider_1 = CoreGroupsProvider;
    /**
     * Check if group mode of an activity is enabled.
     *
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<boolean>} Promise resolved with true if the activity has groups, resolved with false otherwise.
     */
    CoreGroupsProvider.prototype.activityHasGroups = function (cmId, siteId, ignoreCache) {
        return this.getActivityGroupMode(cmId, siteId, ignoreCache).then(function (groupmode) {
            return groupmode === CoreGroupsProvider_1.SEPARATEGROUPS || groupmode === CoreGroupsProvider_1.VISIBLEGROUPS;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Get the groups allowed in an activity.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getActivityAllowedGroups = function (cmId, userId, siteId, ignoreCache) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                cmid: cmId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getActivityAllowedGroupsCacheKey(cmId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_4__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('core_group_get_activity_allowed_groups', params, preSets).then(function (response) {
                if (!response || !response.groups) {
                    return Promise.reject(null);
                }
                return response.groups;
            });
        });
    };
    /**
     * Get cache key for group mode WS calls.
     *
     * @param {number} cmId Course module ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    CoreGroupsProvider.prototype.getActivityAllowedGroupsCacheKey = function (cmId, userId) {
        return this.ROOT_CACHE_KEY + 'allowedgroups:' + cmId + ':' + userId;
    };
    /**
     * Get the groups allowed in an activity if they are allowed.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved. If not allowed, empty array will be returned.
     */
    CoreGroupsProvider.prototype.getActivityAllowedGroupsIfEnabled = function (cmId, userId, siteId, ignoreCache) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get real groupmode, in case it's forced by the course.
        return this.activityHasGroups(cmId, siteId, ignoreCache).then(function (hasGroups) {
            if (hasGroups) {
                // Get the groups available for the user.
                return _this.getActivityAllowedGroups(cmId, userId, siteId, ignoreCache);
            }
            return [];
        });
    };
    /**
     * Helper function to get activity group info (group mode and list of groups).
     *
     * @param {number} cmId Course module ID.
     * @param {boolean} [addAllParts=true] Whether to add the all participants option. Always true for visible groups.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<CoreGroupInfo>} Promise resolved with the group info.
     */
    CoreGroupsProvider.prototype.getActivityGroupInfo = function (cmId, addAllParts, userId, siteId, ignoreCache) {
        var _this = this;
        if (addAllParts === void 0) { addAllParts = true; }
        var groupInfo = {
            groups: []
        };
        return this.getActivityGroupMode(cmId, siteId, ignoreCache).then(function (groupMode) {
            groupInfo.separateGroups = groupMode === CoreGroupsProvider_1.SEPARATEGROUPS;
            groupInfo.visibleGroups = groupMode === CoreGroupsProvider_1.VISIBLEGROUPS;
            if (groupInfo.separateGroups || groupInfo.visibleGroups) {
                return _this.getActivityAllowedGroups(cmId, userId, siteId, ignoreCache);
            }
            return [];
        }).then(function (groups) {
            if (groups.length <= 0) {
                groupInfo.separateGroups = false;
                groupInfo.visibleGroups = false;
            }
            else {
                if (addAllParts || groupInfo.visibleGroups) {
                    groupInfo.groups.push({ id: 0, name: _this.translate.instant('core.allparticipants') });
                }
                groupInfo.groups = groupInfo.groups.concat(groups);
            }
            return groupInfo;
        });
    };
    /**
     * Get the group mode of an activity.
     *
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<number>} Promise resolved when the group mode is retrieved.
     */
    CoreGroupsProvider.prototype.getActivityGroupMode = function (cmId, siteId, ignoreCache) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                cmid: cmId
            }, preSets = {
                cacheKey: _this.getActivityGroupModeCacheKey(cmId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_4__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('core_group_get_activity_groupmode', params, preSets).then(function (response) {
                if (!response || typeof response.groupmode == 'undefined') {
                    return Promise.reject(null);
                }
                return response.groupmode;
            });
        });
    };
    /**
     * Get cache key for group mode WS calls.
     *
     * @param {number} cmId Course module ID.
     * @return {string} Cache key.
     */
    CoreGroupsProvider.prototype.getActivityGroupModeCacheKey = function (cmId) {
        return this.ROOT_CACHE_KEY + 'groupmode:' + cmId;
    };
    /**
     * Get user groups in all the user enrolled courses.
     *
     * @param {string} [siteId] Site to get the groups from. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getAllUserGroups = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            siteId = siteId || site.getId();
            if (site.isVersionGreaterEqualThan('3.6')) {
                return _this.getUserGroupsInCourse(0, siteId);
            }
            return _this.coursesProvider.getUserCourses(false, siteId).then(function (courses) {
                courses.push({ id: site.getSiteHomeId() }); // Add front page.
                return _this.getUserGroups(courses, siteId);
            });
        });
    };
    /**
     * Get user groups in all the supplied courses.
     *
     * @param {any[]} courses List of courses or course ids to get the groups from.
     * @param {string} [siteId] Site to get the groups from. If not defined, use current site.
     * @param {number} [userId] ID of the user. If not defined, use the userId related to siteId.
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getUserGroups = function (courses, siteId, userId) {
        var _this = this;
        // Get all courses one by one.
        var promises = courses.map(function (course) {
            var courseId = typeof course == 'object' ? course.id : course;
            return _this.getUserGroupsInCourse(courseId, siteId, userId);
        });
        return Promise.all(promises).then(function (courseGroups) {
            return [].concat.apply([], courseGroups);
        });
    };
    /**
     * Get user groups in a course.
     *
     * @param {number} courseId ID of the course. 0 to get all enrolled courses groups (Moodle version > 3.6).
     * @param {string} [siteId] Site to get the groups from. If not defined, use current site.
     * @param {number} [userId] ID of the user. If not defined, use ID related to siteid.
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getUserGroupsInCourse = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var data = {
                userid: userId,
                courseid: courseId
            }, preSets = {
                cacheKey: _this.getUserGroupsInCourseCacheKey(courseId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_4__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_group_get_course_user_groups', data, preSets).then(function (response) {
                if (response && response.groups) {
                    return response.groups;
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Get prefix cache key for  user groups in course WS calls.
     *
     * @return {string} Prefix Cache key.
     */
    CoreGroupsProvider.prototype.getUserGroupsInCoursePrefixCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'courseGroups:';
    };
    /**
     * Get cache key for user groups in course WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    CoreGroupsProvider.prototype.getUserGroupsInCourseCacheKey = function (courseId, userId) {
        return this.getUserGroupsInCoursePrefixCacheKey() + courseId + ':' + userId;
    };
    /**
     * Invalidates activity allowed groups.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateActivityAllowedGroups = function (cmId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getActivityAllowedGroupsCacheKey(cmId, userId));
        });
    };
    /**
     * Invalidates activity group mode.
     *
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateActivityGroupMode = function (cmId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getActivityGroupModeCacheKey(cmId));
        });
    };
    /**
     * Invalidates all activity group info: mode and allowed groups.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateActivityGroupInfo = function (cmId, userId, siteId) {
        var promises = [];
        promises.push(this.invalidateActivityAllowedGroups(cmId, userId, siteId));
        promises.push(this.invalidateActivityGroupMode(cmId, siteId));
        return Promise.all(promises);
    };
    /**
     * Invalidates user groups in all user enrolled courses.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateAllUserGroups = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (site.isVersionGreaterEqualThan('3.6')) {
                return _this.invalidateUserGroupsInCourse(0, siteId);
            }
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserGroupsInCoursePrefixCacheKey());
        });
    };
    /**
     * Invalidates user groups in courses.
     *
     * @param {any[]} courses List of courses or course ids.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateUserGroups = function (courses, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var promises = courses.map(function (course) {
                var courseId = typeof course == 'object' ? course.id : course;
                return _this.invalidateUserGroupsInCourse(courseId, site.id, userId);
            });
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates user groups in course.
     *
     * @param {number} courseId ID of the course. 0 to get all enrolled courses groups (Moodle version > 3.6).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateUserGroupsInCourse = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getUserGroupsInCourseCacheKey(courseId, userId));
        });
    };
    // Group mode constants.
    CoreGroupsProvider.NOGROUPS = 0;
    CoreGroupsProvider.SEPARATEGROUPS = 1;
    CoreGroupsProvider.VISIBLEGROUPS = 2;
    CoreGroupsProvider = CoreGroupsProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreGroupsProvider);
    return CoreGroupsProvider;
    var CoreGroupsProvider_1;
}());

//# sourceMappingURL=groups.js.map

/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_camera__ = __webpack_require__(338);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_media_capture__ = __webpack_require__(421);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_mimetype__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/**
 * Service to upload files.
 */
var CoreFileUploaderProvider = /** @class */ (function () {
    function CoreFileUploaderProvider(logger, fileProvider, textUtils, utils, sitesProvider, timeUtils, mimeUtils, filepoolProvider, platform, translate, mediaCapture, camera) {
        this.fileProvider = fileProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.sitesProvider = sitesProvider;
        this.timeUtils = timeUtils;
        this.mimeUtils = mimeUtils;
        this.filepoolProvider = filepoolProvider;
        this.platform = platform;
        this.translate = translate;
        this.mediaCapture = mediaCapture;
        this.camera = camera;
        // Observers to notify when a media file starts/stops being recorded/selected.
        this.onGetPicture = new __WEBPACK_IMPORTED_MODULE_13_rxjs__["Subject"]();
        this.onAudioCapture = new __WEBPACK_IMPORTED_MODULE_13_rxjs__["Subject"]();
        this.onVideoCapture = new __WEBPACK_IMPORTED_MODULE_13_rxjs__["Subject"]();
        this.logger = logger.getInstance('CoreFileUploaderProvider');
    }
    /**
     * Add a dot to the beginning of an extension.
     *
     * @param {string} extension Extension.
     * @return {string}           Treated extension.
     */
    CoreFileUploaderProvider.prototype.addDot = function (extension) {
        return '.' + extension;
    };
    /**
     * Compares two file lists and returns if they are different.
     *
     * @param {any[]} a First file list.
     * @param {any[]} b Second file list.
     * @return {boolean} Whether both lists are different.
     */
    CoreFileUploaderProvider.prototype.areFileListDifferent = function (a, b) {
        a = a || [];
        b = b || [];
        if (a.length != b.length) {
            return true;
        }
        // Currently we are going to compare the order of the files as well.
        // This function can be improved comparing more fields or not comparing the order.
        for (var i = 0; i < a.length; i++) {
            if ((a[i].name || a[i].filename) != (b[i].name || b[i].filename)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Start the audio recorder application and return information about captured audio clip files.
     *
     * @param {CaptureAudioOptions} options Options.
     * @return {Promise<MediaFile[] | CaptureError>} Promise resolved with the result.
     */
    CoreFileUploaderProvider.prototype.captureAudio = function (options) {
        var _this = this;
        this.onAudioCapture.next(true);
        return this.mediaCapture.captureAudio(options).finally(function () {
            _this.onAudioCapture.next(false);
        });
    };
    /**
     * Start the video recorder application and return information about captured video clip files.
     *
     * @param {CaptureVideoOptions} options Options.
     * @return {Promise<MediaFile[] | CaptureError>} Promise resolved with the result.
     */
    CoreFileUploaderProvider.prototype.captureVideo = function (options) {
        var _this = this;
        this.onVideoCapture.next(true);
        return this.mediaCapture.captureVideo(options).finally(function () {
            _this.onVideoCapture.next(false);
        });
    };
    /**
     * Clear temporary attachments to be uploaded.
     * Attachments already saved in an offline store will NOT be deleted.
     *
     * @param {any[]} files List of files.
     */
    CoreFileUploaderProvider.prototype.clearTmpFiles = function (files) {
        // Delete the local files.
        files.forEach(function (file) {
            if (!file.offline && file.remove) {
                // Pass an empty function to prevent missing parameter error.
                file.remove(function () {
                    // Nothing to do.
                });
            }
        });
    };
    /**
     * Get the upload options for a file taken with the Camera Cordova plugin.
     *
     * @param {string} uri File URI.
     * @param {boolean} [isFromAlbum] True if the image was taken from album, false if it's a new image taken with camera.
     * @return {CoreFileUploaderOptions} Options.
     */
    CoreFileUploaderProvider.prototype.getCameraUploadOptions = function (uri, isFromAlbum) {
        var extension = this.mimeUtils.getExtension(uri), mimetype = this.mimeUtils.getMimeType(extension), isIOS = this.platform.is('ios'), options = {
            deleteAfterUpload: !isFromAlbum,
            mimeType: mimetype
        };
        if (isIOS && (mimetype == 'image/jpeg' || mimetype == 'image/png')) {
            // In iOS, the pictures can have repeated names, even if they come from the album.
            options.fileName = 'image_' + this.timeUtils.readableTimestamp() + '.' + extension;
        }
        else {
            // Use the same name that the file already has.
            options.fileName = this.fileProvider.getFileAndDirectoryFromPath(uri).name;
        }
        if (isFromAlbum) {
            // If the file was picked from the album, delete it only if it was copied to the app's folder.
            options.deleteAfterUpload = this.fileProvider.isFileInAppFolder(uri);
            if (this.platform.is('android')) {
                // Picking an image from album in Android adds a timestamp at the end of the file. Delete it.
                options.fileName = options.fileName.replace(/(\.[^\.]*)\?[^\.]*$/, '$1');
            }
        }
        return options;
    };
    /**
     * Get the upload options for a file of any type.
     *
     * @param {string} uri File URI.
     * @param {string} name File name.
     * @param {string} type File type.
     * @param {boolean} [deleteAfterUpload] Whether the file should be deleted after upload.
     * @param {string} [fileArea] File area to upload the file to. It defaults to 'draft'.
     * @param {number} [itemId] Draft ID to upload the file to, 0 to create new.
     * @return {CoreFileUploaderOptions} Options.
     */
    CoreFileUploaderProvider.prototype.getFileUploadOptions = function (uri, name, type, deleteAfterUpload, fileArea, itemId) {
        var options = {};
        options.fileName = name;
        options.mimeType = type || this.mimeUtils.getMimeType(this.mimeUtils.getFileExtension(options.fileName));
        options.deleteAfterUpload = !!deleteAfterUpload;
        options.itemId = itemId || 0;
        options.fileArea = fileArea;
        return options;
    };
    /**
     * Get the upload options for a file taken with the media capture Cordova plugin.
     *
     * @param {MediaFile} mediaFile File object to upload.
     * @return {CoreFileUploaderOptions} Options.
     */
    CoreFileUploaderProvider.prototype.getMediaUploadOptions = function (mediaFile) {
        var options = {};
        var filename = mediaFile.name, split;
        // Add a timestamp to the filename to make it unique.
        split = filename.split('.');
        split[0] += '_' + this.timeUtils.readableTimestamp();
        filename = split.join('.');
        options.fileName = filename;
        options.deleteAfterUpload = true;
        if (mediaFile.type) {
            options.mimeType = mediaFile.type;
        }
        else {
            options.mimeType = this.mimeUtils.getMimeType(this.mimeUtils.getFileExtension(options.fileName));
        }
        return options;
    };
    /**
     * Take a picture or video, or load one from the library.
     *
     * @param {CameraOptions} options Options.
     * @return {Promise<any>} Promise resolved with the result.
     */
    CoreFileUploaderProvider.prototype.getPicture = function (options) {
        var _this = this;
        this.onGetPicture.next(true);
        return this.camera.getPicture(options).finally(function () {
            _this.onGetPicture.next(false);
        });
    };
    /**
     * Get the files stored in a folder, marking them as offline.
     *
     * @param {string} folderPath Folder where to get the files.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    CoreFileUploaderProvider.prototype.getStoredFiles = function (folderPath) {
        var _this = this;
        return this.fileProvider.getDirectoryContents(folderPath).then(function (files) {
            return _this.markOfflineFiles(files);
        });
    };
    /**
     * Get stored files from combined online and offline file object.
     *
     * @param {{online: any[], offline: number}} filesObject The combined offline and online files object.
     * @param {string} folderPath Folder path to get files from.
     * @return {Promise<any[]>} Promise resolved with files.
     */
    CoreFileUploaderProvider.prototype.getStoredFilesFromOfflineFilesObject = function (filesObject, folderPath) {
        var files = [];
        if (filesObject) {
            if (filesObject.online && filesObject.online.length > 0) {
                files = this.utils.clone(filesObject.online);
            }
            if (filesObject.offline > 0) {
                return this.getStoredFiles(folderPath).then(function (offlineFiles) {
                    return files.concat(offlineFiles);
                }).catch(function () {
                    // Ignore not found files.
                    return files;
                });
            }
        }
        return Promise.resolve(files);
    };
    /**
     * Check if a file's mimetype is invalid based on the list of accepted mimetypes. This function needs either the file's
     * mimetype or the file's path/name.
     *
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @param {string} [path] File's path or name.
     * @param {string} [mimetype] File's mimetype.
     * @return {string} Undefined if file is valid, error message if file is invalid.
     */
    CoreFileUploaderProvider.prototype.isInvalidMimetype = function (mimetypes, path, mimetype) {
        var extension;
        if (mimetypes) {
            // Verify that the mimetype of the file is supported.
            if (mimetype) {
                extension = this.mimeUtils.getExtension(mimetype);
            }
            else {
                extension = this.mimeUtils.getFileExtension(path);
                mimetype = this.mimeUtils.getMimeType(extension);
            }
            if (mimetype && mimetypes.indexOf(mimetype) == -1) {
                extension = extension || this.translate.instant('core.unknown');
                return this.translate.instant('core.fileuploader.invalidfiletype', { $a: extension });
            }
        }
    };
    /**
     * Mark files as offline.
     *
     * @param {any[]} files Files to mark as offline.
     * @return {any[]} Files marked as offline.
     */
    CoreFileUploaderProvider.prototype.markOfflineFiles = function (files) {
        // Mark the files as pending offline.
        files.forEach(function (file) {
            file.offline = true;
            file.filename = file.name;
        });
        return files;
    };
    /**
     * Parse filetypeList to get the list of allowed mimetypes and the data to render information.
     *
     * @param {string} filetypeList Formatted string list where the mimetypes can be checked.
     * @return {{info: any[], mimetypes: string[]}}  Mimetypes and the filetypes informations. Undefined if all types supported.
     */
    CoreFileUploaderProvider.prototype.prepareFiletypeList = function (filetypeList) {
        var _this = this;
        filetypeList = filetypeList && filetypeList.trim();
        if (!filetypeList || filetypeList == '*') {
            // All types supported, return undefined.
            return undefined;
        }
        var filetypes = filetypeList.split(/[;, ]+/g), mimetypes = {}, // Use an object to prevent duplicates.
        typesInfo = [];
        filetypes.forEach(function (filetype) {
            filetype = filetype.trim();
            if (filetype) {
                if (filetype.indexOf('/') != -1) {
                    // It's a mimetype.
                    typesInfo.push({
                        name: _this.mimeUtils.getMimetypeDescription(filetype),
                        extlist: _this.mimeUtils.getExtensions(filetype).map(_this.addDot).join(' ')
                    });
                    mimetypes[filetype] = true;
                }
                else if (filetype.indexOf('.') === 0) {
                    // It's an extension.
                    var mimetype = _this.mimeUtils.getMimeType(filetype);
                    typesInfo.push({
                        name: mimetype ? _this.mimeUtils.getMimetypeDescription(mimetype) : false,
                        extlist: filetype
                    });
                    if (mimetype) {
                        mimetypes[mimetype] = true;
                    }
                }
                else {
                    // It's a group.
                    var groupExtensions = _this.mimeUtils.getGroupMimeInfo(filetype, 'extensions'), groupMimetypes = _this.mimeUtils.getGroupMimeInfo(filetype, 'mimetypes');
                    if (groupExtensions.length > 0) {
                        typesInfo.push({
                            name: _this.mimeUtils.getTranslatedGroupName(filetype),
                            extlist: groupExtensions ? groupExtensions.map(_this.addDot).join(' ') : ''
                        });
                        groupMimetypes.forEach(function (mimetype) {
                            if (mimetype) {
                                mimetypes[mimetype] = true;
                            }
                        });
                    }
                    else {
                        // Treat them as extensions.
                        filetype = _this.addDot(filetype);
                        var mimetype = _this.mimeUtils.getMimeType(filetype);
                        typesInfo.push({
                            name: mimetype ? _this.mimeUtils.getMimetypeDescription(mimetype) : false,
                            extlist: filetype
                        });
                        if (mimetype) {
                            mimetypes[mimetype] = true;
                        }
                    }
                }
            }
        });
        return {
            info: typesInfo,
            mimetypes: Object.keys(mimetypes)
        };
    };
    /**
     * Given a list of files (either online files or local files), store the local files in a local folder
     * to be uploaded later.
     *
     * @param {string} folderPath Path of the folder where to store the files.
     * @param {any[]} files List of files.
     * @return {Promise<{online: any[], offline: number}>} Promise resolved if success.
     */
    CoreFileUploaderProvider.prototype.storeFilesToUpload = function (folderPath, files) {
        var _this = this;
        var result = {
            online: [],
            offline: 0
        };
        if (!files || !files.length) {
            return Promise.resolve(result);
        }
        // Remove unused files from previous saves.
        return this.fileProvider.removeUnusedFiles(folderPath, files).then(function () {
            var promises = [];
            files.forEach(function (file) {
                if (file.filename && !file.name) {
                    // It's an online file, add it to the result and ignore it.
                    result.online.push({
                        filename: file.filename,
                        fileurl: file.fileurl
                    });
                }
                else if (!file.name) {
                    // Error.
                    promises.push(Promise.reject(null));
                }
                else if (file.fullPath && file.fullPath.indexOf(folderPath) != -1) {
                    // File already in the submission folder.
                    result.offline++;
                }
                else {
                    // Local file, copy it.
                    // Use copy instead of move to prevent having a unstable state if some copies succeed and others don't.
                    var destFile = _this.textUtils.concatenatePaths(folderPath, file.name);
                    promises.push(_this.fileProvider.copyFile(file.toURL(), destFile));
                    result.offline++;
                }
            });
            return Promise.all(promises).then(function () {
                return result;
            });
        });
    };
    /**
     * Upload a file.
     *
     * @param {string} uri File URI.
     * @param {CoreFileUploaderOptions} [options] Options for the upload.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {string} [siteId] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderProvider.prototype.uploadFile = function (uri, options, onProgress, siteId) {
        var _this = this;
        options = options || {};
        var deleteAfterUpload = options.deleteAfterUpload, ftOptions = this.utils.clone(options);
        delete ftOptions.deleteAfterUpload;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.uploadFile(uri, ftOptions, onProgress);
        }).then(function (result) {
            if (deleteAfterUpload) {
                setTimeout(function () {
                    // Use set timeout, otherwise in Electron the upload threw an error sometimes.
                    _this.fileProvider.removeExternalFile(uri);
                }, 500);
            }
            return result;
        });
    };
    /**
     * Upload a file to a draft area and return the draft ID.
     *
     * If the file is an online file it will be downloaded and then re-uploaded.
     * If the file is a local file it will not be deleted from the device after upload.
     *
     * @param {any} file Online file or local FileEntry.
     * @param {number} [itemId] Draft ID to use. Undefined or 0 to create a new draft ID.
     * @param {string} [component] The component to set to the downloaded files.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the itemId.
     */
    CoreFileUploaderProvider.prototype.uploadOrReuploadFile = function (file, itemId, component, componentId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promise, fileName;
        var isOnline = file.filename && !file.name;
        if (isOnline) {
            // It's an online file. We need to download it and re-upload it.
            fileName = file.filename;
            promise = this.filepoolProvider.downloadUrl(siteId, file.url || file.fileurl, false, component, componentId, file.timemodified, undefined, undefined, file).then(function (path) {
                return _this.fileProvider.getExternalFile(path);
            });
        }
        else {
            // Local file, we already have the file entry.
            fileName = file.name;
            promise = Promise.resolve(file);
        }
        return promise.then(function (fileEntry) {
            // Now upload the file.
            var options = _this.getFileUploadOptions(fileEntry.toURL(), fileName, fileEntry.type, isOnline, 'draft', itemId);
            return _this.uploadFile(fileEntry.toURL(), options, undefined, siteId).then(function (result) {
                return result.itemid;
            });
        });
    };
    /**
     * Given a list of files (either online files or local files), upload them to a draft area and return the draft ID.
     *
     * Online files will be downloaded and then re-uploaded.
     * Local files are not deleted from the device after upload.
     * If there are no files to upload it will return a fake draft ID (1).
     *
     * @param {any[]} files List of files.
     * @param {string} [component] The component to set to the downloaded files.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the itemId.
     */
    CoreFileUploaderProvider.prototype.uploadOrReuploadFiles = function (files, component, componentId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!files || !files.length) {
            // Return fake draft ID.
            return Promise.resolve(1);
        }
        // Upload only the first file first to get a draft id.
        return this.uploadOrReuploadFile(files[0], 0, component, componentId, siteId).then(function (itemId) {
            var promises = [];
            for (var i = 1; i < files.length; i++) {
                var file = files[i];
                promises.push(_this.uploadOrReuploadFile(file, itemId, component, componentId, siteId));
            }
            return Promise.all(promises).then(function () {
                return itemId;
            });
        });
    };
    CoreFileUploaderProvider.LIMITED_SIZE_WARNING = 1048576; // 1 MB.
    CoreFileUploaderProvider.WIFI_SIZE_WARNING = 10485760; // 10 MB.
    CoreFileUploaderProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_11__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_media_capture__["a" /* MediaCapture */],
            __WEBPACK_IMPORTED_MODULE_2__ionic_native_camera__["a" /* Camera */]])
    ], CoreFileUploaderProvider);
    return CoreFileUploaderProvider;
}());

//# sourceMappingURL=fileuploader.js.map

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreQuestionDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__default_question_handler__ = __webpack_require__(577);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Delegate to register question handlers.
 */
var CoreQuestionDelegate = /** @class */ (function (_super) {
    __extends(CoreQuestionDelegate, _super);
    function CoreQuestionDelegate(logger, sitesProvider, eventsProvider, defaultHandler) {
        var _this = _super.call(this, 'CoreQuestionDelegate', logger, sitesProvider, eventsProvider) || this;
        _this.defaultHandler = defaultHandler;
        _this.handlerNameProperty = 'type';
        return _this;
    }
    /**
     * Get the behaviour to use for a certain question type.
     * E.g. 'qtype_essay' uses 'manualgraded'.
     *
     * @param {any} question The question.
     * @param {string} behaviour The default behaviour.
     * @return {string} The behaviour to use.
     */
    CoreQuestionDelegate.prototype.getBehaviourForQuestion = function (question, behaviour) {
        var type = this.getTypeName(question), questionBehaviour = this.executeFunctionOnEnabled(type, 'getBehaviour', [question, behaviour]);
        return questionBehaviour || behaviour;
    };
    /**
     * Get the directive to use for a certain question type.
     *
     * @param {Injector} injector Injector.
     * @param {any} question The question to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreQuestionDelegate.prototype.getComponentForQuestion = function (injector, question) {
        var type = this.getTypeName(question);
        return Promise.resolve(this.executeFunctionOnEnabled(type, 'getComponent', [injector, question]));
    };
    /**
     * Check if a question can be submitted.
     * If a question cannot be submitted it should return a message explaining why (translated or not).
     *
     * @param {any} question Question.
     * @return {string} Prevent submit message. Undefined or empty if can be submitted.
     */
    CoreQuestionDelegate.prototype.getPreventSubmitMessage = function (question) {
        var type = this.getTypeName(question);
        return this.executeFunctionOnEnabled(type, 'getPreventSubmitMessage', [question]);
    };
    /**
     * Given a type name, return the full name of that type. E.g. 'calculated' -> 'qtype_calculated'.
     *
     * @param {string} type Type to treat.
     * @return {string} Type full name.
     */
    CoreQuestionDelegate.prototype.getFullTypeName = function (type) {
        return 'qtype_' + type;
    };
    /**
     * Given a question, return the full name of its question type.
     *
     * @param {any} question Question.
     * @return {string} Type name.
     */
    CoreQuestionDelegate.prototype.getTypeName = function (question) {
        return this.getFullTypeName(question.type);
    };
    /**
     * Check if a response is complete.
     *
     * @param {any} question The question.
     * @param {any} answers Object with the question answers (without prefix).
     * @return {number} 1 if complete, 0 if not complete, -1 if cannot determine.
     */
    CoreQuestionDelegate.prototype.isCompleteResponse = function (question, answers) {
        var type = this.getTypeName(question);
        return this.executeFunctionOnEnabled(type, 'isCompleteResponse', [question, answers]);
    };
    /**
     * Check if a student has provided enough of an answer for the question to be graded automatically,
     * or whether it must be considered aborted.
     *
     * @param {any} question The question.
     * @param {any} answers Object with the question answers (without prefix).
     * @return {number} 1 if gradable, 0 if not gradable, -1 if cannot determine.
     */
    CoreQuestionDelegate.prototype.isGradableResponse = function (question, answers) {
        var type = this.getTypeName(question);
        return this.executeFunctionOnEnabled(type, 'isGradableResponse', [question, answers]);
    };
    /**
     * Check if two responses are the same.
     *
     * @param {any} question Question.
     * @param {any} prevAnswers Object with the previous question answers.
     * @param {any} newAnswers Object with the new question answers.
     * @return {boolean} Whether they're the same.
     */
    CoreQuestionDelegate.prototype.isSameResponse = function (question, prevAnswers, newAnswers) {
        var type = this.getTypeName(question);
        return this.executeFunctionOnEnabled(type, 'isSameResponse', [question, prevAnswers, newAnswers]);
    };
    /**
     * Check if a question type is supported.
     *
     * @param {string} type Question type.
     * @return {boolean} Whether it's supported.
     */
    CoreQuestionDelegate.prototype.isQuestionSupported = function (type) {
        return this.hasHandler(this.getFullTypeName(type), true);
    };
    /**
     * Prepare the answers for a certain question.
     *
     * @param {any} question Question.
     * @param {any} answers The answers retrieved from the form. Prepared answers must be stored in this object.
     * @param {boolean} [offline] Whether the data should be saved in offline.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data has been prepared.
     */
    CoreQuestionDelegate.prototype.prepareAnswersForQuestion = function (question, answers, offline, siteId) {
        var type = this.getTypeName(question);
        return Promise.resolve(this.executeFunctionOnEnabled(type, 'prepareAnswers', [question, answers, offline, siteId]));
    };
    /**
     * Validate if an offline sequencecheck is valid compared with the online one.
     *
     * @param {any} question The question.
     * @param {string} offlineSequenceCheck Sequence check stored in offline.
     * @return {boolean} Whether sequencecheck is valid.
     */
    CoreQuestionDelegate.prototype.validateSequenceCheck = function (question, offlineSequenceCheck) {
        var type = this.getTypeName(question);
        return this.executeFunctionOnEnabled(type, 'validateSequenceCheck', [question, offlineSequenceCheck]);
    };
    /**
     * Get the list of files that needs to be downloaded in addition to the files embedded in the HTML.
     *
     * @param {any} question Question.
     * @param {number} usageId Usage ID.
     * @return {string[]} List of URLs.
     */
    CoreQuestionDelegate.prototype.getAdditionalDownloadableFiles = function (question, usageId) {
        var type = this.getTypeName(question);
        return this.executeFunctionOnEnabled(type, 'getAdditionalDownloadableFiles', [question, usageId]) || [];
    };
    CoreQuestionDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__default_question_handler__["a" /* CoreQuestionDefaultHandler */]])
    ], CoreQuestionDelegate);
    return CoreQuestionDelegate;
}(__WEBPACK_IMPORTED_MODULE_4__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 69 */,
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__format_format__ = __webpack_require__(472);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__module_module__ = __webpack_require__(463);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__module_completion_module_completion__ = __webpack_require__(560);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__module_description_module_description__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__unsupported_module_unsupported_module__ = __webpack_require__(376);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











var CoreCourseComponentsModule = /** @class */ (function () {
    function CoreCourseComponentsModule() {
    }
    CoreCourseComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_6__format_format__["a" /* CoreCourseFormatComponent */],
                __WEBPACK_IMPORTED_MODULE_7__module_module__["a" /* CoreCourseModuleComponent */],
                __WEBPACK_IMPORTED_MODULE_8__module_completion_module_completion__["a" /* CoreCourseModuleCompletionComponent */],
                __WEBPACK_IMPORTED_MODULE_9__module_description_module_description__["a" /* CoreCourseModuleDescriptionComponent */],
                __WEBPACK_IMPORTED_MODULE_10__unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_6__format_format__["a" /* CoreCourseFormatComponent */],
                __WEBPACK_IMPORTED_MODULE_7__module_module__["a" /* CoreCourseModuleComponent */],
                __WEBPACK_IMPORTED_MODULE_8__module_completion_module_completion__["a" /* CoreCourseModuleCompletionComponent */],
                __WEBPACK_IMPORTED_MODULE_9__module_description_module_description__["a" /* CoreCourseModuleDescriptionComponent */],
                __WEBPACK_IMPORTED_MODULE_10__unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_10__unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */]
            ]
        })
    ], CoreCourseComponentsModule);
    return CoreCourseComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModAssignProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_comments_providers_comments__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_grades_providers_grades__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__submission_delegate__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__assign_offline__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__classes_interceptor__ = __webpack_require__(419);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};















/**
 * Service that provides some functions for assign.
 */
var AddonModAssignProvider = /** @class */ (function () {
    function AddonModAssignProvider(logger, sitesProvider, textUtils, timeUtils, appProvider, utils, submissionDelegate, gradesProvider, filepoolProvider, assignOffline, commentsProvider, logHelper) {
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.timeUtils = timeUtils;
        this.appProvider = appProvider;
        this.utils = utils;
        this.submissionDelegate = submissionDelegate;
        this.gradesProvider = gradesProvider;
        this.filepoolProvider = filepoolProvider;
        this.assignOffline = assignOffline;
        this.commentsProvider = commentsProvider;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModAssign:';
        this.gradingOfflineEnabled = {};
        this.logger = logger.getInstance('AddonModAssignProvider');
    }
    AddonModAssignProvider_1 = AddonModAssignProvider;
    /**
     * Check if the user can submit in offline. This should only be used if submissionStatus.lastattempt.cansubmit cannot
     * be used (offline usage).
     * This function doesn't check if the submission is empty, it should be checked before calling this function.
     *
     * @param {any} assign  Assignment instance.
     * @param {any} submissionStatus Submission status returned by getSubmissionStatus.
     * @return {boolean} Whether it can submit.
     */
    AddonModAssignProvider.prototype.canSubmitOffline = function (assign, submissionStatus) {
        if (!this.isSubmissionOpen(assign, submissionStatus)) {
            return false;
        }
        var userSubmission = submissionStatus.lastattempt.submission, teamSubmission = submissionStatus.lastattempt.teamsubmission;
        if (teamSubmission) {
            if (teamSubmission.status === AddonModAssignProvider_1.SUBMISSION_STATUS_SUBMITTED) {
                // The assignment submission has been completed.
                return false;
            }
            else if (userSubmission && userSubmission.status === AddonModAssignProvider_1.SUBMISSION_STATUS_SUBMITTED) {
                // The user has already clicked the submit button on the team submission.
                return false;
            }
            else if (assign.preventsubmissionnotingroup && !submissionStatus.lastattempt.submissiongroup) {
                return false;
            }
        }
        else if (userSubmission) {
            if (userSubmission.status === AddonModAssignProvider_1.SUBMISSION_STATUS_SUBMITTED) {
                // The assignment submission has been completed.
                return false;
            }
        }
        else {
            // No valid submission or team submission.
            return false;
        }
        // Last check is that this instance allows drafts.
        return assign.submissiondrafts;
    };
    /**
     * Get an assignment by course module ID.
     *
     * @param {number} courseId Course ID the assignment belongs to.
     * @param {number} cmId Assignment module ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the assignment.
     */
    AddonModAssignProvider.prototype.getAssignment = function (courseId, cmId, ignoreCache, siteId) {
        return this.getAssignmentByField(courseId, 'cmid', cmId, ignoreCache, siteId);
    };
    /**
     * Get an assigment with key=value. If more than one is found, only the first will be returned.
     *
     * @param {number} courseId Course ID.
     * @param {string} key Name of the property to check.
     * @param {any} value Value to search.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the assignment is retrieved.
     */
    AddonModAssignProvider.prototype.getAssignmentByField = function (courseId, key, value, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId],
                includenotenrolledcourses: 1
            }, preSets = {
                cacheKey: _this.getAssignmentCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_13__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_assign_get_assignments', params, preSets).catch(function () {
                // In 3.6 we added a new parameter includenotenrolledcourses that could cause offline data not to be found.
                // Retry again without the param to check if the request is already cached.
                delete params.includenotenrolledcourses;
                return site.read('mod_assign_get_assignments', params, preSets);
            }).then(function (response) {
                // Search the assignment to return.
                if (response.courses && response.courses.length) {
                    var assignments = response.courses[0].assignments;
                    for (var i = 0; i < assignments.length; i++) {
                        if (assignments[i][key] == value) {
                            return assignments[i];
                        }
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get an assignment by instance ID.
     *
     * @param {number} courseId Course ID the assignment belongs to.
     * @param {number} cmId Assignment instance ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved with the assignment.
     */
    AddonModAssignProvider.prototype.getAssignmentById = function (courseId, id, ignoreCache, siteId) {
        return this.getAssignmentByField(courseId, 'id', id, ignoreCache, siteId);
    };
    /**
     * Get cache key for assignment data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModAssignProvider.prototype.getAssignmentCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'assignment:' + courseId;
    };
    /**
     * Get an assignment user mapping for blind marking.
     *
     * @param {number} assignId Assignment Id.
     * @param {number} userId User Id to be blinded.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the user blind id.
     */
    AddonModAssignProvider.prototype.getAssignmentUserMappings = function (assignId, userId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assignmentids: [assignId]
            }, preSets = {
                cacheKey: _this.getAssignmentUserMappingsCacheKey(assignId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_13__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_assign_get_user_mappings', params, preSets).then(function (response) {
                // Search the user.
                if (response.assignments && response.assignments.length) {
                    if (!userId || userId < 0) {
                        // User not valid, stop.
                        return -1;
                    }
                    var assignment = response.assignments[0];
                    if (assignment.assignmentid == assignId) {
                        var mappings = assignment.mappings;
                        for (var i = 0; i < mappings.length; i++) {
                            if (mappings[i].userid == userId) {
                                return mappings[i].id;
                            }
                        }
                    }
                }
                else if (response.warnings && response.warnings.length) {
                    return Promise.reject(response.warnings[0]);
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for assignment user mappings data WS calls.
     *
     * @param {number} assignId Assignment ID.
     * @return {string} Cache key.
     */
    AddonModAssignProvider.prototype.getAssignmentUserMappingsCacheKey = function (assignId) {
        return this.ROOT_CACHE_KEY + 'usermappings:' + assignId;
    };
    /**
     * Returns grade information from assign_grades for the requested assignment id
     *
     * @param {number} assignId Assignment Id.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Resolved with requested info when done.
     */
    AddonModAssignProvider.prototype.getAssignmentGrades = function (assignId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assignmentids: [assignId]
            }, preSets = {
                cacheKey: _this.getAssignmentGradesCacheKey(assignId)
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_assign_get_grades', params, preSets).then(function (response) {
                // Search the assignment.
                if (response.assignments && response.assignments.length) {
                    var assignment = response.assignments[0];
                    if (assignment.assignmentid == assignId) {
                        return assignment.grades;
                    }
                }
                else if (response.warnings && response.warnings.length) {
                    if (response.warnings[0].warningcode == 3) {
                        // No grades found.
                        return [];
                    }
                    return Promise.reject(response.warnings[0]);
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for assignment grades data WS calls.
     *
     * @param {number} assignId Assignment ID.
     * @return {string} Cache key.
     */
    AddonModAssignProvider.prototype.getAssignmentGradesCacheKey = function (assignId) {
        return this.ROOT_CACHE_KEY + 'assigngrades:' + assignId;
    };
    /**
     * Returns the color name for a given grading status name.
     *
     * @param {string} status Grading status name
     * @return {string} The color name.
     */
    AddonModAssignProvider.prototype.getSubmissionGradingStatusColor = function (status) {
        if (!status) {
            return '';
        }
        if (status == AddonModAssignProvider_1.GRADING_STATUS_GRADED ||
            status == AddonModAssignProvider_1.MARKING_WORKFLOW_STATE_RELEASED) {
            return 'success';
        }
        return 'danger';
    };
    /**
     * Returns the translation id for a given grading status name.
     *
     * @param {string} status Grading Status name
     * @return {string} The status translation identifier.
     */
    AddonModAssignProvider.prototype.getSubmissionGradingStatusTranslationId = function (status) {
        if (!status) {
            return;
        }
        if (status == AddonModAssignProvider_1.GRADING_STATUS_GRADED || status == AddonModAssignProvider_1.GRADING_STATUS_NOT_GRADED
            || status == AddonModAssignProvider_1.GRADED_FOLLOWUP_SUBMIT) {
            return 'addon.mod_assign.' + status;
        }
        return 'addon.mod_assign.markingworkflowstate' + status;
    };
    /**
     * Get the submission object from an attempt.
     *
     * @param {any} assign Assign.
     * @param {any} attempt Attempt.
     * @return {any} Submission object or null.
     */
    AddonModAssignProvider.prototype.getSubmissionObjectFromAttempt = function (assign, attempt) {
        if (!attempt) {
            return null;
        }
        return assign.teamsubmission ? attempt.teamsubmission : attempt.submission;
    };
    /**
     * Get attachments of a submission plugin.
     *
     * @param {any} submissionPlugin Submission plugin.
     * @return {any[]} Submission plugin attachments.
     */
    AddonModAssignProvider.prototype.getSubmissionPluginAttachments = function (submissionPlugin) {
        var files = [];
        if (submissionPlugin.fileareas) {
            submissionPlugin.fileareas.forEach(function (filearea) {
                if (!filearea || !filearea.files) {
                    // No files to get.
                    return;
                }
                filearea.files.forEach(function (file) {
                    if (!file.filename) {
                        // We don't have filename, extract it from the path.
                        file.filename = file.filepath[0] == '/' ? file.filepath.substr(1) : file.filepath;
                    }
                    files.push(file);
                });
            });
        }
        return files;
    };
    /**
     * Get text of a submission plugin.
     *
     * @param {any} submissionPlugin Submission plugin.
     * @param {boolean} [keepUrls] True if it should keep original URLs, false if they should be replaced.
     * @return {string} Submission text.
     */
    AddonModAssignProvider.prototype.getSubmissionPluginText = function (submissionPlugin, keepUrls) {
        var text = '';
        if (submissionPlugin.editorfields) {
            submissionPlugin.editorfields.forEach(function (field) {
                text += field.text;
            });
            if (!keepUrls && submissionPlugin.fileareas && submissionPlugin.fileareas[0]) {
                text = this.textUtils.replacePluginfileUrls(text, submissionPlugin.fileareas[0].files);
            }
        }
        return text;
    };
    /**
     * Get an assignment submissions.
     *
     * @param {number} assignId Assignment id.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{canviewsubmissions: boolean, submissions?: any[]}>} Promise resolved when done.
     */
    AddonModAssignProvider.prototype.getSubmissions = function (assignId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assignmentids: [assignId]
            }, preSets = {
                cacheKey: _this.getSubmissionsCacheKey(assignId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_13__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_assign_get_submissions', params, preSets).then(function (response) {
                // Check if we can view submissions, with enough permissions.
                if (response.warnings.length > 0 && response.warnings[0].warningcode == 1) {
                    return { canviewsubmissions: false };
                }
                if (response.assignments && response.assignments.length) {
                    return {
                        canviewsubmissions: true,
                        submissions: response.assignments[0].submissions
                    };
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for assignment submissions data WS calls.
     *
     * @param {number} assignId Assignment id.
     * @return {string} Cache key.
     */
    AddonModAssignProvider.prototype.getSubmissionsCacheKey = function (assignId) {
        return this.ROOT_CACHE_KEY + 'submissions:' + assignId;
    };
    /**
     * Get information about an assignment submission status for a given user.
     *
     * @param {number} assignId Assignment instance id.
     * @param {number} [userId] User Id (empty for current user).
     * @param {number} [groupId] Group Id (empty for all participants).
     * @param {boolean} [isBlind] If blind marking is enabled or not.
     * @param {number} [filter=true] True to filter WS response and rewrite URLs, false otherwise.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site id (empty for current site).
     * @return {Promise<any>} Promise always resolved with the user submission status.
     */
    AddonModAssignProvider.prototype.getSubmissionStatus = function (assignId, userId, groupId, isBlind, filter, ignoreCache, siteId) {
        var _this = this;
        if (filter === void 0) { filter = true; }
        userId = userId || 0;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            groupId = site.isVersionGreaterEqualThan('3.5') ? groupId || 0 : 0;
            var params = {
                assignid: assignId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getSubmissionStatusCacheKey(assignId, userId, groupId, isBlind),
                getCacheUsingCacheKey: true,
                filter: filter,
                rewriteurls: filter
            };
            if (groupId) {
                params['groupid'] = groupId;
            }
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            if (!filter) {
                // Don't cache when getting text without filters.
                // @todo Change this to support offline editing.
                preSets.saveToCache = false;
            }
            return site.read('mod_assign_get_submission_status', params, preSets);
        });
    };
    /**
     * Get information about an assignment submission status for a given user.
     * If the data doesn't include the user submission, retry ignoring cache.
     *
     * @param {any} assign Assignment.
     * @param {number} [userId] User id (empty for current user).
     * @param {number} [groupId] Group Id (empty for all participants).
     * @param {boolean} [isBlind] If blind marking is enabled or not.
     * @param {number} [filter=true] True to filter WS response and rewrite URLs, false otherwise.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site id (empty for current site).
     * @return {Promise<any>} Promise always resolved with the user submission status.
     */
    AddonModAssignProvider.prototype.getSubmissionStatusWithRetry = function (assign, userId, groupId, isBlind, filter, ignoreCache, siteId) {
        var _this = this;
        if (filter === void 0) { filter = true; }
        return this.getSubmissionStatus(assign.id, userId, groupId, isBlind, filter, ignoreCache, siteId).then(function (response) {
            var userSubmission = _this.getSubmissionObjectFromAttempt(assign, response.lastattempt);
            if (!userSubmission) {
                // Try again, ignoring cache.
                return _this.getSubmissionStatus(assign.id, userId, groupId, isBlind, filter, true, siteId).catch(function () {
                    // Error, return the first result even if it doesn't have the user submission.
                    return response;
                });
            }
            return response;
        });
    };
    /**
     * Get cache key for get submission status data WS calls.
     *
     * @param {number} assignId Assignment instance id.
     * @param {number} [userId] User id (empty for current user).
     * @param {number} [groupId] Group Id (empty for all participants).
     * @param {number} [isBlind] If blind marking is enabled or not.
     * @return {string} Cache key.
     */
    AddonModAssignProvider.prototype.getSubmissionStatusCacheKey = function (assignId, userId, groupId, isBlind) {
        if (!userId) {
            isBlind = false;
            userId = this.sitesProvider.getCurrentSiteUserId();
        }
        return this.getSubmissionsCacheKey(assignId) + ':' + userId + ':' + (isBlind ? 1 : 0) + ':' + groupId;
    };
    /**
     * Returns the color name for a given status name.
     *
     * @param {string} status Status name
     * @return {string} The color name.
     */
    AddonModAssignProvider.prototype.getSubmissionStatusColor = function (status) {
        switch (status) {
            case 'submitted':
                return 'success';
            case 'draft':
                return 'info';
            case 'new':
            case 'noattempt':
            case 'noonlinesubmissions':
            case 'nosubmission':
            case 'gradedfollowupsubmit':
                return 'danger';
            default:
                return 'light';
        }
    };
    /**
     * Given a list of plugins, returns the plugin names that aren't supported for editing.
     *
     * @param {any[]} plugins Plugins to check.
     * @return {Promise<string[]>} Promise resolved with unsupported plugin names.
     */
    AddonModAssignProvider.prototype.getUnsupportedEditPlugins = function (plugins) {
        var _this = this;
        var notSupported = [], promises = [];
        plugins.forEach(function (plugin) {
            promises.push(_this.submissionDelegate.isPluginSupportedForEdit(plugin.type).then(function (enabled) {
                if (!enabled) {
                    notSupported.push(plugin.name);
                }
            }));
        });
        return Promise.all(promises).then(function () {
            return notSupported;
        });
    };
    /**
     * List the participants for a single assignment, with some summary info about their submissions.
     *
     * @param {number} assignId Assignment id.
     * @param {number} [groupId] Group id. If not defined, 0.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of participants and summary of submissions.
     */
    AddonModAssignProvider.prototype.listParticipants = function (assignId, groupId, ignoreCache, siteId) {
        var _this = this;
        groupId = groupId || 0;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.wsAvailable('mod_assign_list_participants')) {
                // Silently fail if is not available. (needs Moodle version >= 3.2)
                return Promise.reject(null);
            }
            var params = {
                assignid: assignId,
                groupid: groupId,
                filter: ''
            }, preSets = {
                cacheKey: _this.listParticipantsCacheKey(assignId, groupId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_13__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_assign_list_participants', params, preSets);
        });
    };
    /**
     * Get cache key for assignment list participants data WS calls.
     *
     * @param {number} assignId Assignment id.
     * @param {number} groupId Group id.
     * @return {string} Cache key.
     */
    AddonModAssignProvider.prototype.listParticipantsCacheKey = function (assignId, groupId) {
        return this.listParticipantsPrefixCacheKey(assignId) + ':' + groupId;
    };
    /**
     * Get prefix cache key for assignment list participants data WS calls.
     *
     * @param {number} assignId Assignment id.
     * @return {string} Cache key.
     */
    AddonModAssignProvider.prototype.listParticipantsPrefixCacheKey = function (assignId) {
        return this.ROOT_CACHE_KEY + 'participants:' + assignId;
    };
    /**
     * Invalidates all submission status data.
     *
     * @param {number} assignId Assignment instance id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModAssignProvider.prototype.invalidateAllSubmissionData = function (assignId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getSubmissionsCacheKey(assignId));
        });
    };
    /**
     * Invalidates assignment data WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModAssignProvider.prototype.invalidateAssignmentData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAssignmentCacheKey(courseId));
        });
    };
    /**
     * Invalidates assignment user mappings data WS calls.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModAssignProvider.prototype.invalidateAssignmentUserMappingsData = function (assignId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAssignmentUserMappingsCacheKey(assignId));
        });
    };
    /**
     * Invalidates assignment grades data WS calls.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModAssignProvider.prototype.invalidateAssignmentGradesData = function (assignId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAssignmentGradesCacheKey(assignId));
        });
    };
    /**
     * Invalidate the prefetched content except files.
     * To invalidate files, use AddonModAssignProvider.invalidateFiles.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModAssignProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getAssignment(courseId, moduleId, false, siteId).then(function (assign) {
            var promises = [];
            // Do not invalidate assignment data before getting assignment info, we need it!
            promises.push(_this.invalidateAllSubmissionData(assign.id, siteId));
            promises.push(_this.invalidateAssignmentUserMappingsData(assign.id, siteId));
            promises.push(_this.invalidateAssignmentGradesData(assign.id, siteId));
            promises.push(_this.invalidateListParticipantsData(assign.id, siteId));
            promises.push(_this.commentsProvider.invalidateCommentsByInstance('module', assign.id, siteId));
            promises.push(_this.invalidateAssignmentData(courseId, siteId));
            promises.push(_this.gradesProvider.invalidateAllCourseGradesData(courseId));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidate the prefetched files.
     *
     * @param {number} moduleId The module ID.
     * @return {Promise<any>} Promise resolved when the files are invalidated.
     */
    AddonModAssignProvider.prototype.invalidateFiles = function (moduleId) {
        return this.filepoolProvider.invalidateFilesByComponent(this.sitesProvider.getCurrentSiteId(), AddonModAssignProvider_1.COMPONENT, moduleId);
    };
    /**
     * Invalidates assignment submissions data WS calls.
     *
     * @param {number} assignId Assignment instance id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModAssignProvider.prototype.invalidateSubmissionData = function (assignId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getSubmissionsCacheKey(assignId));
        });
    };
    /**
     * Invalidates submission status data.
     *
     * @param {number} assignId Assignment instance id.
     * @param {number} [userId] User id (empty for current user).
     * @param {number} [groupId] Group Id (empty for all participants).
     * @param {boolean} [isBlind] Whether blind marking is enabled or not.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModAssignProvider.prototype.invalidateSubmissionStatusData = function (assignId, userId, groupId, isBlind, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getSubmissionStatusCacheKey(assignId, userId, groupId, isBlind));
        });
    };
    /**
     * Invalidates assignment participants data.
     *
     * @param {number} assignId Assignment instance id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModAssignProvider.prototype.invalidateListParticipantsData = function (assignId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.listParticipantsPrefixCacheKey(assignId));
        });
    };
    /**
     * Convenience function to check if grading offline is enabled.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether grading offline is enabled.
     */
    AddonModAssignProvider.prototype.isGradingOfflineEnabled = function (siteId) {
        var _this = this;
        if (typeof this.gradingOfflineEnabled[siteId] != 'undefined') {
            return Promise.resolve(this.gradingOfflineEnabled[siteId]);
        }
        return this.gradesProvider.isGradeItemsAvalaible(siteId).then(function (enabled) {
            _this.gradingOfflineEnabled[siteId] = enabled;
            return enabled;
        });
    };
    /**
     * Outcomes only can be edited if mod_assign_submit_grading_form is avalaible.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if outcomes edit is enabled, rejected or resolved with false otherwise.
     * @since 3.2
     */
    AddonModAssignProvider.prototype.isOutcomesEditEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('mod_assign_submit_grading_form');
        });
    };
    /**
     * Check if assignments plugin is enabled in a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {boolean} Whether the plugin is enabled.
     */
    AddonModAssignProvider.prototype.isPluginEnabled = function (siteId) {
        return true;
    };
    /**
     * Check if a submission is open. This function is based on Moodle's submissions_open.
     *
     * @param {any} assign Assignment instance.
     * @param {any} submissionStatus Submission status returned by getSubmissionStatus.
     * @return {boolean} Whether submission is open.
     */
    AddonModAssignProvider.prototype.isSubmissionOpen = function (assign, submissionStatus) {
        if (!assign || !submissionStatus) {
            return false;
        }
        var time = this.timeUtils.timestamp(), lastAttempt = submissionStatus.lastattempt, submission = this.getSubmissionObjectFromAttempt(assign, lastAttempt);
        var dateOpen = true, finalDate;
        if (assign.cutoffdate) {
            finalDate = assign.cutoffdate;
        }
        if (lastAttempt && lastAttempt.locked) {
            return false;
        }
        // User extensions.
        if (finalDate) {
            if (lastAttempt && lastAttempt.extensionduedate) {
                // Extension can be before cut off date.
                if (lastAttempt.extensionduedate > finalDate) {
                    finalDate = lastAttempt.extensionduedate;
                }
            }
        }
        if (finalDate) {
            dateOpen = assign.allowsubmissionsfromdate <= time && time <= finalDate;
        }
        else {
            dateOpen = assign.allowsubmissionsfromdate <= time;
        }
        if (!dateOpen) {
            return false;
        }
        if (submission) {
            if (assign.submissiondrafts && submission.status == AddonModAssignProvider_1.SUBMISSION_STATUS_SUBMITTED) {
                // Drafts are tracked and the student has submitted the assignment.
                return false;
            }
        }
        return true;
    };
    /**
     * Report an assignment submission as being viewed.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} [name] Name of the assign.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModAssignProvider.prototype.logSubmissionView = function (assignId, name, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assignid: assignId
            };
            return _this.logHelper.logSingle('mod_assign_view_submission_status', params, AddonModAssignProvider_1.COMPONENT, assignId, name, 'assign', {}, siteId);
        });
    };
    /**
     * Report an assignment grading table is being viewed.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} [name] Name of the assign.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModAssignProvider.prototype.logGradingView = function (assignId, name, siteId) {
        var params = {
            assignid: assignId
        };
        return this.logHelper.logSingle('mod_assign_view_grading_table', params, AddonModAssignProvider_1.COMPONENT, assignId, name, 'assign', {}, siteId);
    };
    /**
     * Report an assign as being viewed.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} [name] Name of the assign.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModAssignProvider.prototype.logView = function (assignId, name, siteId) {
        var params = {
            assignid: assignId
        };
        return this.logHelper.logSingle('mod_assign_view_assign', params, AddonModAssignProvider_1.COMPONENT, assignId, name, 'assign', {}, siteId);
    };
    /**
     * Returns if a submissions needs to be graded.
     *
     * @param {any} submission Submission.
     * @param {number} assignId Assignment ID.
     * @return {Promise<boolean>} Promise resolved with boolean: whether it needs to be graded or not.
     */
    AddonModAssignProvider.prototype.needsSubmissionToBeGraded = function (submission, assignId) {
        if (!submission.gradingstatus) {
            // This should not happen, but it's better to show rather than not showing any of the submissions.
            return Promise.resolve(true);
        }
        if (submission.gradingstatus != AddonModAssignProvider_1.GRADING_STATUS_GRADED &&
            submission.gradingstatus != AddonModAssignProvider_1.MARKING_WORKFLOW_STATE_RELEASED) {
            // Not graded.
            return Promise.resolve(true);
        }
        // We need more data to decide that.
        return this.getSubmissionStatus(assignId, submission.submitid, undefined, submission.blindid).then(function (response) {
            if (!response.feedback || !response.feedback.gradeddate) {
                // Not graded.
                return true;
            }
            // Submitted after grading?
            return response.feedback.gradeddate < submission.timemodified;
        });
    };
    /**
     * Save current user submission for a certain assignment.
     *
     * @param {number} assignId Assign ID.
     * @param {number} courseId Course ID the assign belongs to.
     * @param {any} pluginData Data to save.
     * @param {boolean} allowOffline Whether to allow offline usage.
     * @param {number} timemodified The time the submission was last modified in online.
     * @param {boolean} [allowsDrafts] Whether the assignment allows submission drafts.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if sent to server, resolved with false if stored in offline.
     */
    AddonModAssignProvider.prototype.saveSubmission = function (assignId, courseId, pluginData, allowOffline, timemodified, allowsDrafts, userId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Function to store the submission to be synchronized later.
        var storeOffline = function () {
            return _this.assignOffline.saveSubmission(assignId, courseId, pluginData, timemodified, !allowsDrafts, userId, siteId)
                .then(function () {
                return false;
            });
        };
        if (allowOffline && !this.appProvider.isOnline()) {
            // App is offline, store the action.
            return storeOffline();
        }
        // If there's already a submission to be sent to the server, discard it first.
        return this.assignOffline.deleteSubmission(assignId, userId, siteId).then(function () {
            return _this.saveSubmissionOnline(assignId, pluginData, siteId).then(function () {
                return true;
            }).catch(function (error) {
                if (allowOffline && error && !_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Save current user submission for a certain assignment. It will fail if offline or cannot connect.
     *
     * @param {number} assignId Assign ID.
     * @param {any} pluginData Data to save.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when saved, rejected otherwise.
     */
    AddonModAssignProvider.prototype.saveSubmissionOnline = function (assignId, pluginData, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assignmentid: assignId,
                plugindata: pluginData
            };
            return site.write('mod_assign_save_submission', params).then(function (warnings) {
                if (warnings && warnings.length) {
                    // The WebService returned warnings, reject.
                    return Promise.reject(warnings[0]);
                }
            });
        });
    };
    /**
     * Submit the current user assignment for grading.
     *
     * @param {number} assignId Assign ID.
     * @param {number} courseId Course ID the assign belongs to.
     * @param {boolean} acceptStatement True if submission statement is accepted, false otherwise.
     * @param {number} timemodified The time the submission was last modified in online.
     * @param {boolean} [forceOffline] True to always mark it in offline.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if sent to server, resolved with false if stored in offline.
     */
    AddonModAssignProvider.prototype.submitForGrading = function (assignId, courseId, acceptStatement, timemodified, forceOffline, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Function to store the submission to be synchronized later.
        var storeOffline = function () {
            return _this.assignOffline.markSubmitted(assignId, courseId, true, acceptStatement, timemodified, undefined, siteId)
                .then(function () {
                return false;
            });
        };
        if (forceOffline || !this.appProvider.isOnline()) {
            // App is offline, store the action.
            return storeOffline();
        }
        // If there's already a submission to be sent to the server, discard it first.
        return this.assignOffline.deleteSubmission(assignId, undefined, siteId).then(function () {
            return _this.submitForGradingOnline(assignId, acceptStatement, siteId).then(function () {
                return true;
            }).catch(function (error) {
                if (error && !_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Submit the current user assignment for grading. It will fail if offline or cannot connect.
     *
     * @param {number} assignId Assign ID.
     * @param {boolean} acceptStatement True if submission statement is accepted, false otherwise.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when submitted, rejected otherwise.
     */
    AddonModAssignProvider.prototype.submitForGradingOnline = function (assignId, acceptStatement, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assignmentid: assignId,
                acceptsubmissionstatement: acceptStatement ? 1 : 0
            };
            return site.write('mod_assign_submit_for_grading', params).then(function (warnings) {
                if (warnings && warnings.length) {
                    // The WebService returned warnings, reject.
                    return Promise.reject(warnings[0]);
                }
            });
        });
    };
    /**
     * Submit the grading for the current user and assignment. It will use old or new WS depending on availability.
     *
     * @param {number} assignId Assign ID.
     * @param {number} userId User ID.
     * @param {number} courseId Course ID the assign belongs to.
     * @param {number} grade Grade to submit.
     * @param {number} attemptNumber Number of the attempt being graded.
     * @param {boolean} addAttempt Admit the user to attempt again.
     * @param {string} workflowState Next workflow State.
     * @param {boolean} applyToAll If it's a team submission, whether the grade applies to all group members.
     * @param {any} outcomes Object including all outcomes values. If empty, any of them will be sent.
     * @param {any} pluginData Feedback plugin data to save.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if sent to server, resolved with false if stored offline.
     */
    AddonModAssignProvider.prototype.submitGradingForm = function (assignId, userId, courseId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Function to store the grading to be synchronized later.
        var storeOffline = function () {
            return _this.assignOffline.submitGradingForm(assignId, userId, courseId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId).then(function () {
                return false;
            });
        };
        // Grading offline is only allowed if WS of grade items is enabled to avoid inconsistency.
        return this.isGradingOfflineEnabled(siteId).then(function (enabled) {
            if (!enabled) {
                return _this.submitGradingFormOnline(assignId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId);
            }
            if (!_this.appProvider.isOnline()) {
                // App is offline, store the action.
                return storeOffline();
            }
            // If there's already a grade to be sent to the server, discard it first.
            return _this.assignOffline.deleteSubmissionGrade(assignId, userId, siteId).then(function () {
                return _this.submitGradingFormOnline(assignId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId).then(function () {
                    return true;
                }).catch(function (error) {
                    if (error && !_this.utils.isWebServiceError(error)) {
                        // Couldn't connect to server, store in offline.
                        return storeOffline();
                    }
                    else {
                        // The WebService has thrown an error, reject.
                        return Promise.reject(error);
                    }
                });
            });
        });
    };
    /**
     * Submit the grading for the current user and assignment. It will use old or new WS depending on availability.
     * It will fail if offline or cannot connect.
     *
     * @param {number} assignId Assign ID.
     * @param {number} userId User ID.
     * @param {number} grade Grade to submit.
     * @param {number} attemptNumber Number of the attempt being graded.
     * @param {number} addAttempt Allow the user to attempt again.
     * @param {string} workflowState Next workflow State.
     * @param {boolean} applyToAll If it's a team submission, if the grade applies to all group members.
     * @param {any} outcomes Object including all outcomes values. If empty, any of them will be sent.
     * @param {any} pluginData Feedback plugin data to save.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when submitted, rejected otherwise.
     */
    AddonModAssignProvider.prototype.submitGradingFormOnline = function (assignId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            if (site.wsAvailable('mod_assign_submit_grading_form')) {
                // WS available @since 3.2.
                var jsonData = {
                    grade: grade,
                    attemptnumber: attemptNumber,
                    addattempt: addAttempt ? 1 : 0,
                    workflowstate: workflowState,
                    applytoall: applyToAll ? 1 : 0
                };
                for (var index in outcomes) {
                    jsonData['outcome_' + index + '[' + userId + ']'] = outcomes[index];
                }
                for (var index in pluginData) {
                    jsonData[index] = pluginData[index];
                }
                var serialized = __WEBPACK_IMPORTED_MODULE_14__classes_interceptor__["a" /* CoreInterceptor */].serialize(jsonData, true), params = {
                    assignmentid: assignId,
                    userid: userId,
                    jsonformdata: JSON.stringify(serialized)
                };
                return site.write('mod_assign_submit_grading_form', params).then(function (warnings) {
                    if (warnings && warnings.length) {
                        // The WebService returned warnings, reject.
                        return Promise.reject(warnings[0]);
                    }
                });
            }
            else {
                // WS not available, fallback to save_grade.
                var params = {
                    assignmentid: assignId,
                    userid: userId,
                    grade: grade,
                    attemptnumber: attemptNumber,
                    addattempt: addAttempt ? 1 : 0,
                    workflowstate: workflowState,
                    applytoall: applyToAll ? 1 : 0,
                    plugindata: pluginData
                }, preSets = {
                    responseExpected: false
                };
                return site.write('mod_assign_save_grade', params, preSets);
            }
        });
    };
    AddonModAssignProvider.COMPONENT = 'mmaModAssign';
    AddonModAssignProvider.SUBMISSION_COMPONENT = 'mmaModAssignSubmission';
    AddonModAssignProvider.UNLIMITED_ATTEMPTS = -1;
    // Submission status.
    AddonModAssignProvider.SUBMISSION_STATUS_NEW = 'new';
    AddonModAssignProvider.SUBMISSION_STATUS_REOPENED = 'reopened';
    AddonModAssignProvider.SUBMISSION_STATUS_DRAFT = 'draft';
    AddonModAssignProvider.SUBMISSION_STATUS_SUBMITTED = 'submitted';
    // "Re-open" methods (to retry the assign).
    AddonModAssignProvider.ATTEMPT_REOPEN_METHOD_NONE = 'none';
    AddonModAssignProvider.ATTEMPT_REOPEN_METHOD_MANUAL = 'manual';
    // Grading status.
    AddonModAssignProvider.GRADING_STATUS_GRADED = 'graded';
    AddonModAssignProvider.GRADING_STATUS_NOT_GRADED = 'notgraded';
    AddonModAssignProvider.MARKING_WORKFLOW_STATE_RELEASED = 'released';
    AddonModAssignProvider.NEED_GRADING = 'needgrading';
    AddonModAssignProvider.GRADED_FOLLOWUP_SUBMIT = 'gradedfollowupsubmit';
    // Events.
    AddonModAssignProvider.SUBMISSION_SAVED_EVENT = 'addon_mod_assign_submission_saved';
    AddonModAssignProvider.SUBMITTED_FOR_GRADING_EVENT = 'addon_mod_assign_submitted_for_grading';
    AddonModAssignProvider.GRADED_EVENT = 'addon_mod_assign_graded';
    AddonModAssignProvider = AddonModAssignProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__submission_delegate__["a" /* AddonModAssignSubmissionDelegate */],
            __WEBPACK_IMPORTED_MODULE_9__core_grades_providers_grades__["a" /* CoreGradesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_12__assign_offline__["a" /* AddonModAssignOfflineProvider */], __WEBPACK_IMPORTED_MODULE_8__core_comments_providers_comments__["a" /* CoreCommentsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModAssignProvider);
    return AddonModAssignProvider;
    var AddonModAssignProvider_1;
}());

//# sourceMappingURL=assign.js.map

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTabComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tabs__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * A tab to use inside core-tabs. The content of this tab will be displayed when the tab is selected.
 *
 * You must provide either a title or an icon for the tab.
 *
 * The tab content MUST be surrounded by ng-template. This component uses ngTemplateOutlet instead of ng-content because the
 * latter executes all the code immediately. This means that all the tabs would be initialized as soon as your view is
 * loaded, leading to performance issues.
 *
 * Example usage:
 *
 * <core-tabs selectedIndex="1">
 *     <core-tab [title]="'core.courses.timeline' | translate" (ionSelect)="switchTab('timeline')">
 *         <ng-template> <!-- This ng-template is required. -->
 *             <!-- Tab contents. -->
 *         </ng-template>
 *     </core-tab>
 * </core-tabs>
 */
var CoreTabComponent = /** @class */ (function () {
    function CoreTabComponent(tabs, element, domUtils, utils) {
        this.tabs = tabs;
        this.domUtils = domUtils;
        this.enabled = true; // Whether the tab is enabled.
        this.ionSelect = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.loaded = false;
        this.initialized = false;
        this._show = true;
        this.element = element.nativeElement;
        this.element.setAttribute('role', 'tabpanel');
        this.element.setAttribute('tabindex', '0');
        this.id = this.id || 'core-tab-' + utils.getUniqueId('CoreTabComponent');
    }
    Object.defineProperty(CoreTabComponent.prototype, "show", {
        get: function () {
            return this._show;
        },
        set: function (val) {
            if (typeof val != 'undefined') {
                var hasChanged = this._show != val;
                this._show = val;
                if (this.initialized && hasChanged) {
                    this.tabs.tabVisibilityChanged();
                    this.updateAriaHidden();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Component being initialized.
     */
    CoreTabComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.element.setAttribute('aria-labelledby', this.id + '-tab');
        this.element.setAttribute('id', this.id);
        this.tabs.addTab(this);
        this.initialized = true;
        setTimeout(function () {
            _this.updateAriaHidden();
        }, 1000);
    };
    /**
     * Component destroyed.
     */
    CoreTabComponent.prototype.ngOnDestroy = function () {
        this.tabs.removeTab(this);
    };
    /**
     * Select tab.
     */
    CoreTabComponent.prototype.selectTab = function () {
        var _this = this;
        this.element.classList.add('selected');
        this.tabElement = this.tabElement || document.getElementById(this.id + '-tab');
        this.updateAriaHidden();
        this.tabElement && this.tabElement.setAttribute('aria-selected', true);
        this.loaded = true;
        this.ionSelect.emit(this);
        this.showHideNavBarButtons(true);
        // Setup tab scrolling.
        setTimeout(function () {
            // Workaround to solve undefined this.scroll on tab change.
            var scroll = _this.content ? _this.content.getScrollElement() :
                _this.element.querySelector('ion-content > .scroll-content');
            if (scroll) {
                scroll.onscroll = function (e) {
                    _this.tabs.showHideTabs(e.target);
                };
                _this.tabs.showHideTabs(scroll);
            }
        }, 1);
    };
    /**
     * Unselect tab.
     */
    CoreTabComponent.prototype.unselectTab = function () {
        this.updateAriaHidden();
        this.tabElement && this.tabElement.setAttribute('aria-selected', false);
        this.element.classList.remove('selected');
        this.showHideNavBarButtons(false);
    };
    /**
     * Get all child core-navbar-buttons. We need to use querySelectorAll because ContentChildren doesn't work with ng-template.
     * https://github.com/angular/angular/issues/14842
     *
     * @return {CoreNavBarButtonsComponent[]} List of component instances.
     */
    CoreTabComponent.prototype.getChildrenNavBarButtons = function () {
        var elements = this.element.querySelectorAll('core-navbar-buttons'), instances = [];
        for (var i = 0; i < elements.length; i++) {
            var instance = this.domUtils.getInstanceByElement(elements[i]);
            if (instance) {
                instances.push(instance);
            }
        }
        return instances;
    };
    /**
     * Show all hide all children navbar buttons.
     *
     * @param {boolean} show Whether to show or hide the buttons.
     */
    CoreTabComponent.prototype.showHideNavBarButtons = function (show) {
        var instances = this.getChildrenNavBarButtons();
        for (var i in instances) {
            instances[i].forceHide(!show);
        }
    };
    /**
     * Update aria hidden attribute.
     */
    CoreTabComponent.prototype.updateAriaHidden = function () {
        if (!this.tabElement) {
            this.tabElement = document.getElementById(this.id + '-tab');
        }
        if (this.tabElement) {
            this.tabElement && this.tabElement.setAttribute('aria-hidden', !this._show);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "title", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "icon", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "badge", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "badgeStyle", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabComponent.prototype, "enabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], CoreTabComponent.prototype, "show", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "id", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreTabComponent.prototype, "ionSelect", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["q" /* ContentChild */])(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */])
    ], CoreTabComponent.prototype, "template", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["q" /* ContentChild */])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["f" /* Content */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["f" /* Content */])
    ], CoreTabComponent.prototype, "content", void 0);
    CoreTabComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-tab',
            template: '<ng-container *ngIf="loaded" [ngTemplateOutlet]="template"></ng-container>'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__tabs__["a" /* CoreTabsComponent */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreTabComponent);
    return CoreTabComponent;
}());

//# sourceMappingURL=tab.js.map

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContextMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__context_menu_popover__ = __webpack_require__(542);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_tabs_tab__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};








/**
 * This component adds a button (usually in the navigation bar) that displays a context menu popover.
 */
var CoreContextMenuComponent = /** @class */ (function () {
    function CoreContextMenuComponent(translate, popoverCtrl, elementRef, domUtils, coreTab, utils) {
        var _this = this;
        this.translate = translate;
        this.popoverCtrl = popoverCtrl;
        this.domUtils = domUtils;
        this.coreTab = coreTab;
        this.hideMenu = true; // It will be unhidden when items are added.
        this.expanded = false;
        this.items = [];
        this.itemsMovedToParent = [];
        // Create the stream and subscribe to it. We ignore successive changes during 250ms.
        this.itemsChangedStream = new __WEBPACK_IMPORTED_MODULE_7_rxjs__["Subject"]();
        this.itemsChangedStream.auditTime(250).subscribe(function () {
            // Hide the menu if all items are hidden.
            _this.hideMenu = !_this.items.some(function (item) {
                return !item.hidden;
            });
            // Sort the items by priority.
            _this.items.sort(function (a, b) {
                return a.priority <= b.priority ? 1 : -1;
            });
        });
        // Calculate the unique ID.
        this.uniqueId = 'core-context-menu-' + utils.getUniqueId('CoreContextMenuComponent');
        this.instanceId = this.domUtils.storeInstanceByElement(elementRef.nativeElement, this);
    }
    /**
     * Component being initialized.
     */
    CoreContextMenuComponent.prototype.ngOnInit = function () {
        this.icon = this.icon || 'more';
        this.ariaLabel = this.ariaLabel || this.title || this.translate.instant('core.info');
    };
    /**
     * Add a context menu item.
     *
     * @param {CoreContextMenuItemComponent} item The item to add.
     */
    CoreContextMenuComponent.prototype.addItem = function (item) {
        if (this.parentContextMenu) {
            // All items were moved to the "parent" menu. Add the item in there.
            this.parentContextMenu.addItem(item);
            if (this.itemsMovedToParent.indexOf(item) == -1) {
                this.itemsMovedToParent.push(item);
            }
        }
        else if (this.items.indexOf(item) == -1) {
            this.items.push(item);
            this.itemsChanged();
        }
    };
    /**
     * Function called when the items change.
     */
    CoreContextMenuComponent.prototype.itemsChanged = function () {
        if (this.parentContextMenu) {
            // All items were moved to the "parent" menu, call the function in there.
            this.parentContextMenu.itemsChanged();
        }
        else {
            this.itemsChangedStream.next();
        }
    };
    /**
     * Merge the current context menu with the one passed as parameter. All the items in this menu will be moved to the
     * one passed as parameter.
     *
     * @param {CoreContextMenuComponent} contextMenu The context menu where to move the items.
     */
    CoreContextMenuComponent.prototype.mergeContextMenus = function (contextMenu) {
        this.parentContextMenu = contextMenu;
        // Add all the items to the other menu.
        for (var i = 0; i < this.items.length; i++) {
            var item = this.items[i];
            contextMenu.addItem(item);
            this.itemsMovedToParent.push(item);
        }
        // Remove all items from the current menu.
        this.items = [];
        this.itemsChanged();
    };
    /**
     * Remove an item from the context menu.
     *
     * @param {CoreContextMenuItemComponent} item The item to remove.
     */
    CoreContextMenuComponent.prototype.removeItem = function (item) {
        if (this.parentContextMenu) {
            // All items were moved to the "parent" menu. Remove the item from there.
            this.parentContextMenu.removeItem(item);
            var index = this.itemsMovedToParent.indexOf(item);
            if (index >= 0) {
                this.itemsMovedToParent.splice(index, 1);
            }
        }
        else {
            var index = this.items.indexOf(item);
            if (index >= 0) {
                this.items.splice(index, 1);
            }
            this.itemsChanged();
        }
    };
    /**
     * Remove the items that were merged to a parent context menu.
     */
    CoreContextMenuComponent.prototype.removeMergedItems = function () {
        if (this.parentContextMenu) {
            for (var i = 0; i < this.itemsMovedToParent.length; i++) {
                this.parentContextMenu.removeItem(this.itemsMovedToParent[i]);
            }
        }
    };
    /**
     * Restore the items that were merged to a parent context menu.
     */
    CoreContextMenuComponent.prototype.restoreMergedItems = function () {
        if (this.parentContextMenu) {
            for (var i = 0; i < this.itemsMovedToParent.length; i++) {
                this.parentContextMenu.addItem(this.itemsMovedToParent[i]);
            }
        }
    };
    /**
     * Show the context menu.
     *
     * @param {MouseEvent} event Event.
     */
    CoreContextMenuComponent.prototype.showContextMenu = function (event) {
        var _this = this;
        if (!this.expanded) {
            var popover = this.popoverCtrl.create(__WEBPACK_IMPORTED_MODULE_5__context_menu_popover__["a" /* CoreContextMenuPopoverComponent */], { title: this.title, items: this.items, id: this.uniqueId });
            popover.onDidDismiss(function () {
                _this.expanded = false;
            });
            popover.present({
                ev: event
            });
            this.expanded = true;
        }
    };
    /**
     * Component destroyed.
     */
    CoreContextMenuComponent.prototype.ngOnDestroy = function () {
        this.domUtils.removeInstanceById(this.instanceId);
        this.removeMergedItems();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuComponent.prototype, "icon", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuComponent.prototype, "title", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('aria-label'),
        __metadata("design:type", String)
    ], CoreContextMenuComponent.prototype, "ariaLabel", void 0);
    CoreContextMenuComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-context-menu',
            templateUrl: 'core-context-menu.html'
        }),
        __param(4, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["w" /* PopoverController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__components_tabs_tab__["a" /* CoreTabComponent */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreContextMenuComponent);
    return CoreContextMenuComponent;
}());

//# sourceMappingURL=context-menu.js.map

/***/ }),
/* 74 */,
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContextMenuItemComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context_menu__ = __webpack_require__(73);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * This directive adds a item to the Context Menu popover.
 *
 * @description
 * This directive defines and item to be added to the popover generated in CoreContextMenu.
 *
 * It is required to place this tag inside a core-context-menu tag.
 *
 * <core-context-menu>
 *     <core-context-menu-item [hidden]="showGrid" [priority]="601" [content]="'core.layoutgrid' | translate"
 *         (action)="switchGrid()" [iconAction]="'apps'"></core-context-menu-item>
 * </core-context-menu>
 */
var CoreContextMenuItemComponent = /** @class */ (function () {
    function CoreContextMenuItemComponent(ctxtMenu) {
        this.ctxtMenu = ctxtMenu;
        this.closeOnClick = true; // Whether to close the popover when the item is clicked.
        this.hasAction = false;
        this.destroyed = false;
        this.action = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreContextMenuItemComponent.prototype.ngOnInit = function () {
        // Initialize values.
        this.priority = this.priority || 1;
        this.closeOnClick = this.getBooleanValue(this.closeOnClick, true);
        this.hasAction = this.action.observers.length > 0;
        this.ariaAction = this.ariaAction || this.content;
        if (this.hasAction) {
            this.href = '';
        }
        // Navigation help if href provided.
        this.captureLink = this.href && this.captureLink ? this.captureLink : false;
        this.autoLogin = this.autoLogin || 'check';
        if (!this.destroyed) {
            this.ctxtMenu.addItem(this);
        }
    };
    /**
     * Get a boolean value from item.
     *
     * @param {any} value Value to check.
     * @param {boolean} defaultValue Value to use if undefined.
     * @return {boolean} Boolean value.
     */
    CoreContextMenuItemComponent.prototype.getBooleanValue = function (value, defaultValue) {
        if (typeof value == 'undefined') {
            return defaultValue;
        }
        return value && value !== 'false';
    };
    /**
     * Component destroyed.
     */
    CoreContextMenuItemComponent.prototype.ngOnDestroy = function () {
        this.destroyed = true;
        this.ctxtMenu.removeItem(this);
    };
    /**
     * Detect changes on input properties.
     */
    CoreContextMenuItemComponent.prototype.ngOnChanges = function (changes) {
        if (changes.hidden && !changes.hidden.firstChange) {
            this.ctxtMenu.itemsChanged();
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "content", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "iconDescription", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "iconAction", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreContextMenuItemComponent.prototype, "iconSlash", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "ariaDescription", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "ariaAction", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "href", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreContextMenuItemComponent.prototype, "captureLink", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "autoLogin", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreContextMenuItemComponent.prototype, "closeOnClick", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreContextMenuItemComponent.prototype, "priority", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "badge", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreContextMenuItemComponent.prototype, "badgeClass", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreContextMenuItemComponent.prototype, "hidden", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreContextMenuItemComponent.prototype, "action", void 0);
    CoreContextMenuItemComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-context-menu-item',
            template: ''
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__context_menu__["a" /* CoreContextMenuComponent */]])
    ], CoreContextMenuItemComponent);
    return CoreContextMenuItemComponent;
}());

//# sourceMappingURL=context-menu-item.js.map

/***/ }),
/* 76 */,
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMarkRequiredComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Directive to add a red asterisk for required input fields.
 *
 * @description
 * For forms with required and not required fields, it is recommended to use this directive to mark the required ones.
 *
 * This directive should be applied in the label. Example:
 *
 * <ion-label core-mark-required="{{field.required}}">{{ 'core.login.username' | translate }}</ion-label>
 */
var CoreMarkRequiredComponent = /** @class */ (function () {
    function CoreMarkRequiredComponent(element, translate, textUtils, utils) {
        this.translate = translate;
        this.textUtils = textUtils;
        this.utils = utils;
        this.coreMarkRequired = true;
        this.element = element.nativeElement;
        this.requiredLabel = this.translate.instant('core.required');
    }
    /**
     * Component being initialized.
     */
    CoreMarkRequiredComponent.prototype.ngOnInit = function () {
        this.coreMarkRequired = this.utils.isTrueOrOne(this.coreMarkRequired);
    };
    /**
     * Called after the view is initialized.
     */
    CoreMarkRequiredComponent.prototype.ngAfterViewInit = function () {
        if (this.coreMarkRequired) {
            // Add the "required" to the aria-label.
            var ariaLabel = this.element.getAttribute('aria-label') || this.textUtils.cleanTags(this.element.innerHTML, true);
            if (ariaLabel) {
                this.element.setAttribute('aria-label', ariaLabel + ' ' + this.requiredLabel);
            }
        }
        else {
            // Remove the "required" from the aria-label.
            var ariaLabel = this.element.getAttribute('aria-label');
            if (ariaLabel) {
                this.element.setAttribute('aria-label', ariaLabel.replace(' ' + this.requiredLabel, ''));
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('core-mark-required'),
        __metadata("design:type", Object)
    ], CoreMarkRequiredComponent.prototype, "coreMarkRequired", void 0);
    CoreMarkRequiredComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: '[core-mark-required]',
            templateUrl: 'core-mark-required.html'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreMarkRequiredComponent);
    return CoreMarkRequiredComponent;
}());

//# sourceMappingURL=mark-required.js.map

/***/ }),
/* 78 */,
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__sites__ = __webpack_require__(1);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/*
 * Service that provides some features regarding synchronization.
*/
var CoreSyncProvider = /** @class */ (function () {
    function CoreSyncProvider(eventsProvider, sitesProvider) {
        var _this = this;
        this.sitesProvider = sitesProvider;
        // Variables for the database.
        this.SYNC_TABLE = 'sync';
        this.siteSchema = {
            name: 'CoreSyncProvider',
            version: 1,
            tables: [
                {
                    name: this.SYNC_TABLE,
                    columns: [
                        {
                            name: 'component',
                            type: 'TEXT',
                            notNull: true
                        },
                        {
                            name: 'id',
                            type: 'TEXT',
                            notNull: true
                        },
                        {
                            name: 'time',
                            type: 'INTEGER'
                        },
                        {
                            name: 'warnings',
                            type: 'TEXT'
                        }
                    ],
                    primaryKeys: ['component', 'id']
                }
            ]
        };
        // Store blocked sync objects.
        this.blockedItems = {};
        this.sitesProvider.registerSiteSchema(this.siteSchema);
        // Unblock all blocks on logout.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* CoreEventsProvider */].LOGOUT, function (data) {
            _this.clearAllBlocks(data.siteId);
        });
    }
    /**
     * Block a component and ID so it cannot be synchronized.
     *
     * @param {string} component Component name.
     * @param {string | number} id Unique ID per component.
     * @param {string} [operation] Operation name. If not defined, a default text is used.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreSyncProvider.prototype.blockOperation = function (component, id, operation, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (!this.blockedItems[siteId]) {
            this.blockedItems[siteId] = {};
        }
        if (!this.blockedItems[siteId][uniqueId]) {
            this.blockedItems[siteId][uniqueId] = {};
        }
        operation = operation || '-';
        this.blockedItems[siteId][uniqueId][operation] = true;
    };
    /**
     * Clear all blocks for a site or all sites.
     *
     * @param {string} [siteId] If set, clear the blocked objects only for this site. Otherwise clear them for all sites.
     */
    CoreSyncProvider.prototype.clearAllBlocks = function (siteId) {
        if (siteId) {
            delete this.blockedItems[siteId];
        }
        else {
            this.blockedItems = {};
        }
    };
    /**
     * Clear all blocks for a certain component.
     *
     * @param {string} component Component name.
     * @param {string | number} id Unique ID per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreSyncProvider.prototype.clearBlocks = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (this.blockedItems[siteId]) {
            delete this.blockedItems[siteId][uniqueId];
        }
    };
    /**
     * Returns a sync record.
     * @param  {string}           component Component name.
     * @param  {string | number}  id        Unique ID per component.
     * @param  {string}           [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>}     Record if found or reject.
     */
    CoreSyncProvider.prototype.getSyncRecord = function (component, id, siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecord(_this.SYNC_TABLE, { component: component, id: id });
        });
    };
    /**
     * Inserts or Updates info of a sync record.
     * @param  {string}           component Component name.
     * @param  {string | number}  id        Unique ID per component.
     * @param  {any}              data      Data that updates the record.
     * @param  {string}           [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>}     Promise resolved with done.
     */
    CoreSyncProvider.prototype.insertOrUpdateSyncRecord = function (component, id, data, siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            data.component = component;
            data.id = id;
            return db.insertRecord(_this.SYNC_TABLE, data);
        });
    };
    /**
     * Convenience function to create unique identifiers for a component and id.
     *
     * @param {string} component Component name.
     * @param {string | number} id Unique ID per component.
     * @return {string} Unique sync id.
     */
    CoreSyncProvider.prototype.getUniqueSyncBlockId = function (component, id) {
        return component + '#' + id;
    };
    /**
     * Check if a component is blocked.
     * One block can have different operations. Here we check how many operations are being blocking the object.
     *
     * @param {string} component Component name.
     * @param {string | number} id Unique ID per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {boolean} Whether it's blocked.
     */
    CoreSyncProvider.prototype.isBlocked = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!this.blockedItems[siteId]) {
            return false;
        }
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (!this.blockedItems[siteId][uniqueId]) {
            return false;
        }
        return Object.keys(this.blockedItems[siteId][uniqueId]).length > 0;
    };
    /**
     * Unblock an operation on a component and ID.
     *
     * @param {string} component Component name.
     * @param {string | number} id Unique ID per component.
     * @param {string} [operation] Operation name. If not defined, a default text is used.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreSyncProvider.prototype.unblockOperation = function (component, id, operation, siteId) {
        operation = operation || '-';
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (this.blockedItems[siteId] && this.blockedItems[siteId][uniqueId]) {
            delete this.blockedItems[siteId][uniqueId][operation];
        }
    };
    CoreSyncProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_2__sites__["a" /* CoreSitesProvider */]])
    ], CoreSyncProvider);
    return CoreSyncProvider;
}());

//# sourceMappingURL=sync.js.map

/***/ }),
/* 80 */,
/* 81 */,
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoginHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_init__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_ws__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_siteplugins_providers_siteplugins__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__configconstants__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_ts_md5_dist_md5__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




















/**
 * Helper provider that provides some common features regarding authentication.
 */
var CoreLoginHelperProvider = /** @class */ (function () {
    function CoreLoginHelperProvider(logger, sitesProvider, domUtils, wsProvider, translate, textUtils, eventsProvider, appProvider, utils, urlUtils, configProvider, platform, initDelegate, sitePluginsProvider, location, alertCtrl, courseProvider) {
        var _this = this;
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.wsProvider = wsProvider;
        this.translate = translate;
        this.textUtils = textUtils;
        this.eventsProvider = eventsProvider;
        this.appProvider = appProvider;
        this.utils = utils;
        this.urlUtils = urlUtils;
        this.configProvider = configProvider;
        this.platform = platform;
        this.initDelegate = initDelegate;
        this.sitePluginsProvider = sitePluginsProvider;
        this.location = location;
        this.alertCtrl = alertCtrl;
        this.courseProvider = courseProvider;
        this.isSSOConfirmShown = false;
        this.isOpenEditAlertShown = false;
        this.waitingForBrowser = false;
        this.logger = logger.getInstance('CoreLoginHelper');
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */].MAIN_MENU_OPEN, function () {
            /* If there is any page pending to be opened, do it now. Don't open pages stored more than 5 seconds ago, probably
               the function to open the page was called when it shouldn't. */
            if (_this.pageToLoad && Date.now() - _this.pageToLoad.time < 5000) {
                _this.loadPageInMainMenu(_this.pageToLoad.page, _this.pageToLoad.params);
                delete _this.pageToLoad;
            }
        });
    }
    CoreLoginHelperProvider_1 = CoreLoginHelperProvider;
    /**
     * Accept site policy.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if success, rejected if failure.
     */
    CoreLoginHelperProvider.prototype.acceptSitePolicy = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.write('core_user_agree_site_policy', {}).then(function (result) {
                if (!result.status) {
                    // Error.
                    if (result.warnings && result.warnings.length) {
                        // Check if there is a warning 'alreadyagreed'.
                        for (var i in result.warnings) {
                            var warning = result.warnings[i];
                            if (warning.warningcode == 'alreadyagreed') {
                                // Policy already agreed, treat it as a success.
                                return;
                            }
                        }
                        // Another warning, reject.
                        return Promise.reject(result.warnings[0]);
                    }
                    else {
                        return Promise.reject(null);
                    }
                }
            });
        });
    };
    /**
     * Function to handle URL received by Custom URL Scheme. If it's a SSO login, perform authentication.
     *
     * @param {string} url URL received.
     * @return {boolean} True if it's a SSO URL, false otherwise.
     * @deprecated Please use CoreCustomURLSchemesProvider.handleCustomURL instead.
     */
    CoreLoginHelperProvider.prototype.appLaunchedByURL = function (url) {
        var _this = this;
        var ssoScheme = __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].customurlscheme + '://token=';
        if (url.indexOf(ssoScheme) == -1) {
            return false;
        }
        if (this.appProvider.isSSOAuthenticationOngoing()) {
            // Authentication ongoing, probably duplicated request.
            return true;
        }
        if (this.appProvider.isDesktop()) {
            // In desktop, make sure InAppBrowser is closed.
            this.utils.closeInAppBrowser(true);
        }
        // App opened using custom URL scheme. Probably an SSO authentication.
        this.appProvider.startSSOAuthentication();
        this.logger.debug('App launched by URL with an SSO');
        // Delete the sso scheme from the URL.
        url = url.replace(ssoScheme, '');
        // Some platforms like Windows add a slash at the end. Remove it.
        // Some sites add a # at the end of the URL. If it's there, remove it.
        url = url.replace(/\/?#?\/?$/, '');
        // Decode from base64.
        try {
            url = atob(url);
        }
        catch (err) {
            // Error decoding the parameter.
            this.logger.error('Error decoding parameter received for login SSO');
            return false;
        }
        var siteData, modal;
        // Wait for app to be ready.
        this.initDelegate.ready().then(function () {
            modal = _this.domUtils.showModalLoading('core.login.authenticating', true);
            return _this.validateBrowserSSOLogin(url);
        }).then(function (data) {
            siteData = data;
            return _this.handleSSOLoginAuthentication(siteData.siteUrl, siteData.token, siteData.privateToken);
        }).then(function () {
            if (siteData.pageName) {
                // State defined, go to that state instead of site initial page.
                _this.appProvider.getRootNavController().push(siteData.pageName, siteData.pageParams);
            }
            else {
                _this.goToSiteInitialPage();
            }
        }).catch(function (error) {
            if (error) {
                // An error occurred, display the error and logout the user.
                _this.treatUserTokenError(siteData.siteUrl, error);
                _this.sitesProvider.logout();
            }
        }).finally(function () {
            modal.dismiss();
            _this.appProvider.finishSSOAuthentication();
        });
        return true;
    };
    /**
     * Check if a site allows requesting a password reset through the app.
     *
     * @param {string} siteUrl URL of the site.
     * @return {Promise<any>} Promise resolved with boolean: whether can be done through the app.
     */
    CoreLoginHelperProvider.prototype.canRequestPasswordReset = function (siteUrl) {
        return this.requestPasswordReset(siteUrl).then(function () {
            return true;
        }).catch(function (error) {
            return error.available == 1 || (typeof error.errorcode != 'undefined' && error.errorcode != 'invalidrecord' &&
                error.errorcode != '');
        });
    };
    /**
     * Function called when an SSO InAppBrowser is closed or the app is resumed. Check if user needs to be logged out.
     */
    CoreLoginHelperProvider.prototype.checkLogout = function () {
        var navCtrl = this.appProvider.getRootNavController();
        if (!this.appProvider.isSSOAuthenticationOngoing() && this.sitesProvider.isLoggedIn() &&
            this.sitesProvider.getCurrentSite().isLoggedOut() && navCtrl.getActive().name == 'CoreLoginReconnectPage') {
            // User must reauthenticate but he closed the InAppBrowser without doing so, logout him.
            this.sitesProvider.logout();
        }
    };
    /**
     * Show a confirm modal if needed and open a browser to perform SSO login.
     *
     * @param  {string} siteurl     URL of the site where the SSO login will be performed.
     * @param  {number} typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.
     * @param  {string} [service]   The service to use. If not defined, external service will be used.
     * @param  {string} [launchUrl] The URL to open for SSO. If not defined, local_mobile launch URL will be used.
     * @return {Void}
     */
    CoreLoginHelperProvider.prototype.confirmAndOpenBrowserForSSOLogin = function (siteUrl, typeOfLogin, service, launchUrl) {
        var _this = this;
        // Show confirm only if it's needed. Treat "false" (string) as false to prevent typing errors.
        var showConfirmation = this.shouldShowSSOConfirm(typeOfLogin);
        var promise;
        if (showConfirmation) {
            promise = this.domUtils.showConfirm(this.translate.instant('core.login.logininsiterequired'));
        }
        else {
            promise = Promise.resolve();
        }
        promise.then(function () {
            _this.openBrowserForSSOLogin(siteUrl, typeOfLogin, service, launchUrl);
        }).catch(function () {
            // User cancelled, ignore.
        });
    };
    /**
     * Format profile fields, filtering the ones that shouldn't be shown on signup and classifying them in categories.
     *
     * @param {any[]} profileFields Profile fields to format.
     * @return {any} Categories with the fields to show in each one.
     */
    CoreLoginHelperProvider.prototype.formatProfileFieldsForSignup = function (profileFields) {
        if (!profileFields) {
            return [];
        }
        var categories = {};
        profileFields.forEach(function (field) {
            if (!field.signup) {
                // Not a signup field, ignore it.
                return;
            }
            if (!categories[field.categoryid]) {
                categories[field.categoryid] = {
                    id: field.categoryid,
                    name: field.categoryname,
                    fields: []
                };
            }
            categories[field.categoryid].fields.push(field);
        });
        return Object.keys(categories).map(function (index) {
            return categories[index];
        });
    };
    /**
     * Builds an object with error messages for some common errors.
     * Please notice that this function doesn't support all possible error types.
     *
     * @param {string} [requiredMsg] Code of the string for required error.
     * @param {string} [emailMsg] Code of the string for invalid email error.
     * @param {string} [patternMsg] Code of the string for pattern not match error.
     * @param {string} [urlMsg] Code of the string for invalid url error.
     * @param {string} [minlengthMsg] Code of the string for "too short" error.
     * @param {string} [maxlengthMsg] Code of the string for "too long" error.
     * @param {string} [minMsg] Code of the string for min value error.
     * @param {string} [maxMsg] Code of the string for max value error.
     * @return {any} Object with the errors.
     */
    CoreLoginHelperProvider.prototype.getErrorMessages = function (requiredMsg, emailMsg, patternMsg, urlMsg, minlengthMsg, maxlengthMsg, minMsg, maxMsg) {
        var errors = {};
        if (requiredMsg) {
            errors.required = errors.requiredTrue = this.translate.instant(requiredMsg);
        }
        if (emailMsg) {
            errors.email = this.translate.instant(emailMsg);
        }
        if (patternMsg) {
            errors.pattern = this.translate.instant(patternMsg);
        }
        if (urlMsg) {
            errors.url = this.translate.instant(urlMsg);
        }
        if (minlengthMsg) {
            errors.minlength = this.translate.instant(minlengthMsg);
        }
        if (maxlengthMsg) {
            errors.maxlength = this.translate.instant(maxlengthMsg);
        }
        if (minMsg) {
            errors.min = this.translate.instant(minMsg);
        }
        if (maxMsg) {
            errors.max = this.translate.instant(maxMsg);
        }
        return errors;
    };
    /**
     * Get the site policy.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the site policy.
     */
    CoreLoginHelperProvider.prototype.getSitePolicy = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Try to get the latest config, maybe the site policy was just added or has changed.
            return site.getConfig('sitepolicy', true).then(function (sitePolicy) {
                return sitePolicy ? sitePolicy : Promise.reject(null);
            }, function () {
                // Cannot get config, try to get the site policy using auth_email_get_signup_settings.
                return _this.wsProvider.callAjax('auth_email_get_signup_settings', {}, { siteUrl: site.getURL() })
                    .then(function (settings) {
                    return settings.sitepolicy ? settings.sitepolicy : Promise.reject(null);
                });
            });
        });
    };
    /**
     * Get fixed site or sites.
     *
     * @return {string|any[]} Fixed site or list of fixed sites.
     */
    CoreLoginHelperProvider.prototype.getFixedSites = function () {
        return __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl;
    };
    /**
     * Get the valid identity providers from a site config.
     *
     * @param {any} siteConfig Site's public config.
     * @return {any[]} Valid identity providers.
     */
    CoreLoginHelperProvider.prototype.getValidIdentityProviders = function (siteConfig) {
        var validProviders = [], httpUrl = this.textUtils.concatenatePaths(siteConfig.wwwroot, 'auth/oauth2/'), httpsUrl = this.textUtils.concatenatePaths(siteConfig.httpswwwroot, 'auth/oauth2/');
        if (siteConfig.identityproviders && siteConfig.identityproviders.length) {
            siteConfig.identityproviders.forEach(function (provider) {
                if (provider.url && (provider.url.indexOf(httpsUrl) != -1 || provider.url.indexOf(httpUrl) != -1)) {
                    validProviders.push(provider);
                }
            });
        }
        return validProviders;
    };
    /**
     * Go to the page to add a new site.
     * If a fixed URL is configured, go to credentials instead.
     *
     * @param {boolean} [setRoot] True to set the new page as root, false to add it to the stack.
     * @param {boolean} [showKeyboard] Whether to show keyboard in the new page. Only if no fixed URL set.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.goToAddSite = function (setRoot, showKeyboard) {
        var pageName, params;
        if (this.isFixedUrlSet()) {
            // Fixed URL is set, go to credentials page.
            var url = typeof __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl == 'string' ?
                __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl : __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl[0].url;
            pageName = 'CoreLoginCredentialsPage';
            params = { siteUrl: url };
        }
        else {
            pageName = 'CoreLoginSitePage';
            params = {
                showKeyboard: showKeyboard
            };
        }
        if (setRoot) {
            return this.appProvider.getRootNavController().setRoot(pageName, params, { animate: false });
        }
        else {
            return this.appProvider.getRootNavController().push(pageName, params);
        }
    };
    /**
     * Open a page that doesn't belong to any site.
     *
     * @param {NavController} [navCtrl] Nav Controller.
     * @param {string} [page] Page to open.
     * @param {any} [params] Params of the page.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.goToNoSitePage = function (navCtrl, page, params) {
        navCtrl = navCtrl || this.appProvider.getRootNavController();
        if (page == 'CoreLoginSitesPage') {
            // Just open the page as root.
            return navCtrl.setRoot(page, params);
        }
        else {
            // Check if there is any site stored.
            return this.sitesProvider.hasSites().then(function (hasSites) {
                if (hasSites) {
                    // There are sites stored, open sites page first to be able to go back.
                    navCtrl.setRoot('CoreLoginSitesPage');
                    return navCtrl.push(page, params, { animate: false });
                }
                else {
                    if (page != 'CoreLoginSitePage') {
                        // Open the new site page to be able to go back.
                        navCtrl.setRoot('CoreLoginSitePage');
                        return navCtrl.push(page, params, { animate: false });
                    }
                    else {
                        // Just open the page as root.
                        return navCtrl.setRoot(page, params);
                    }
                }
            });
        }
    };
    /**
     * Go to the initial page of a site depending on 'userhomepage' setting.
     *
     * @param {NavController} [navCtrl] NavController to use. Defaults to app root NavController.
     * @param {string} [page] Name of the page to load after loading the main page.
     * @param {any} [params] Params to pass to the page.
     * @param {NavOptions} [options] Navigation options.
     * @param {string} [url] URL to open once the main menu is loaded.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.goToSiteInitialPage = function (navCtrl, page, params, options, url) {
        return this.openMainMenu(navCtrl, page, params, options, url);
    };
    /**
     * Convenient helper to handle authentication in the app using a token received by SSO login. If it's a new account,
     * the site is stored and the user is authenticated. If the account already exists, update its token.
     *
     * @param {string} siteUrl Site's URL.
     * @param {string} token User's token.
     * @param {string} [privateToken] User's private token.
     * @return {Promise<any>} Promise resolved when the user is authenticated with the token.
     */
    CoreLoginHelperProvider.prototype.handleSSOLoginAuthentication = function (siteUrl, token, privateToken) {
        // Always create a new site to prevent overriding data if another user credentials were introduced.
        return this.sitesProvider.newSite(siteUrl, token, privateToken);
    };
    /**
     * Check if the app is configured to use several fixed URLs.
     *
     * @return {boolean} Whether there are several fixed URLs.
     */
    CoreLoginHelperProvider.prototype.hasSeveralFixedSites = function () {
        return __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl && Array.isArray(__WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl) &&
            __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl.length > 1;
    };
    /**
     * Function called when a page starts loading in any InAppBrowser window.
     *
     * @param {string} url Loaded url.
     * @deprecated
     */
    CoreLoginHelperProvider.prototype.inAppBrowserLoadStart = function (url) {
        // This function is deprecated.
    };
    /**
     * Given a site public config, check if email signup is disabled.
     *
     * @param {any} config Site public config.
     * @return {boolean} Whether email signup is disabled.
     */
    CoreLoginHelperProvider.prototype.isEmailSignupDisabled = function (config) {
        var disabledFeatures = config && config.tool_mobile_disabledfeatures;
        if (!disabledFeatures) {
            return false;
        }
        disabledFeatures = this.textUtils.treatDisabledFeatures(disabledFeatures);
        var regEx = new RegExp('(,|^)CoreLoginEmailSignup(,|$)', 'g');
        return !!disabledFeatures.match(regEx);
    };
    /**
     * Check if the app is configured to use a fixed URL (only 1).
     *
     * @return {boolean} Whether there is 1 fixed URL.
     */
    CoreLoginHelperProvider.prototype.isFixedUrlSet = function () {
        if (Array.isArray(__WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl)) {
            return __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl.length == 1;
        }
        return !!__WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].siteurl;
    };
    /**
     * Check if current site is logged out, triggering mmCoreEventSessionExpired if it is.
     *
     * @param {string} [pageName] Name of the page to go once authenticated if logged out. If not defined, site initial page.
     * @param {any} [params] Params of the page to go once authenticated if logged out.
     * @return {boolean} True if user is logged out, false otherwise.
     */
    CoreLoginHelperProvider.prototype.isSiteLoggedOut = function (pageName, params) {
        var site = this.sitesProvider.getCurrentSite();
        if (!site) {
            return false;
        }
        if (site.isLoggedOut()) {
            this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {
                pageName: pageName,
                params: params
            }, site.getId());
            return true;
        }
        return false;
    };
    /**
     * Check if SSO login should use an embedded browser.
     *
     * @param {number} code Code to check.
     * @return {boolean} True if embedded browser, false othwerise.
     */
    CoreLoginHelperProvider.prototype.isSSOEmbeddedBrowser = function (code) {
        if (this.appProvider.isLinux()) {
            // In Linux desktop app, always use embedded browser.
            return true;
        }
        return code == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].LOGIN_SSO_INAPP_CODE;
    };
    /**
     * Check if SSO login is needed based on code returned by the WS.
     *
     * @param {number} code Code to check.
     * @return {boolean} True if SSO login is needed, false othwerise.
     */
    CoreLoginHelperProvider.prototype.isSSOLoginNeeded = function (code) {
        return code == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].LOGIN_SSO_CODE || code == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].LOGIN_SSO_INAPP_CODE;
    };
    /**
     * Load a site and load a certain page in that site.
     *
     * @param {string} page Name of the page to load.
     * @param {any} params Params to pass to the page.
     * @param {string} siteId Site to load.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.loadSiteAndPage = function (page, params, siteId) {
        var _this = this;
        var navCtrl = this.appProvider.getRootNavController();
        if (siteId == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NO_SITE_ID) {
            // Page doesn't belong to a site, just load the page.
            return navCtrl.setRoot(page, params);
        }
        else {
            var modal_1 = this.domUtils.showModalLoading();
            return this.sitesProvider.loadSite(siteId, page, params).then(function (loggedIn) {
                if (loggedIn) {
                    return _this.openMainMenu(navCtrl, page, params);
                }
            }).catch(function (error) {
                // Site doesn't exist.
                return navCtrl.setRoot('CoreLoginSitesPage');
            }).finally(function () {
                modal_1.dismiss();
            });
        }
    };
    /**
     * Load a certain page in the main menu page.
     *
     * @param {string} page Name of the page to load.
     * @param {any} params Params to pass to the page.
     */
    CoreLoginHelperProvider.prototype.loadPageInMainMenu = function (page, params) {
        if (!this.appProvider.isMainMenuOpen()) {
            // Main menu not open. Store the page to be loaded later.
            this.pageToLoad = {
                page: page,
                params: params,
                time: Date.now()
            };
            return;
        }
        if (page == CoreLoginHelperProvider_1.OPEN_COURSE) {
            // Use the openCourse function.
            this.courseProvider.openCourse(undefined, params.course, params);
        }
        else {
            this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */].LOAD_PAGE_MAIN_MENU, { redirectPage: page, redirectParams: params });
        }
    };
    /**
     * Open the main menu, loading a certain page.
     *
     * @param {NavController} navCtrl NavController.
     * @param {string} page Name of the page to load.
     * @param {any} params Params to pass to the page.
     * @param {NavOptions} [options] Navigation options.
     * @param {string} [url] URL to open once the main menu is loaded.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.openMainMenu = function (navCtrl, page, params, options, url) {
        var _this = this;
        navCtrl = navCtrl || this.appProvider.getRootNavController();
        // Due to DeepLinker, we need to remove the path from the URL before going to main menu.
        // IonTabs checks the URL to determine which path to load for deep linking, so we clear the URL.
        this.location.replaceState('');
        if (page == CoreLoginHelperProvider_1.OPEN_COURSE) {
            // Load the main menu first, and then open the course.
            return navCtrl.setRoot('CoreMainMenuPage').finally(function () {
                return _this.courseProvider.openCourse(undefined, params.course, params);
            });
        }
        else {
            // Open the main menu.
            return navCtrl.setRoot('CoreMainMenuPage', { redirectPage: page, redirectParams: params, urlToOpen: url }, options);
        }
    };
    /**
     * Open a browser to perform OAuth login (Google, Facebook, Microsoft).
     *
     * @param {string} siteUrl URL of the site where the login will be performed.
     * @param {any} provider The identity provider.
     * @param {string} [launchUrl] The URL to open for SSO. If not defined, tool/mobile launch URL will be used.
     * @param {string} [pageName] Name of the page to go once authenticated. If not defined, site initial page.
     * @param {any} [pageParams] Params of the state to go once authenticated.
     * @return {boolean} True if success, false if error.
     */
    CoreLoginHelperProvider.prototype.openBrowserForOAuthLogin = function (siteUrl, provider, launchUrl, pageName, pageParams) {
        launchUrl = launchUrl || siteUrl + '/admin/tool/mobile/launch.php';
        if (!provider || !provider.url) {
            return false;
        }
        var service = this.sitesProvider.determineService(siteUrl), params = this.urlUtils.extractUrlParams(provider.url);
        var loginUrl = this.prepareForSSOLogin(siteUrl, service, launchUrl, pageName, pageParams);
        if (!params.id) {
            return false;
        }
        loginUrl += '&oauthsso=' + params.id;
        if (this.appProvider.isLinux()) {
            // In Linux desktop app, always use embedded browser.
            this.utils.openInApp(loginUrl);
        }
        else {
            // Always open it in browser because the user might have the session stored in there.
            this.utils.openInBrowser(loginUrl);
            if (navigator.app) {
                navigator.app.exitApp();
            }
        }
        return true;
    };
    /**
     * Open a browser to perform SSO login.
     *
     * @param {string} siteurl URL of the site where the SSO login will be performed.
     * @param {number} typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.
     * @param {string} [service] The service to use. If not defined, external service will be used.
     * @param {string} [launchUrl] The URL to open for SSO. If not defined, local_mobile launch URL will be used.
     * @param {string} [pageName] Name of the page to go once authenticated. If not defined, site initial page.
     * @param {any} [pageParams] Params of the state to go once authenticated.
     */
    CoreLoginHelperProvider.prototype.openBrowserForSSOLogin = function (siteUrl, typeOfLogin, service, launchUrl, pageName, pageParams) {
        var loginUrl = this.prepareForSSOLogin(siteUrl, service, launchUrl, pageName, pageParams);
        if (this.isSSOEmbeddedBrowser(typeOfLogin)) {
            var options = {
                clearsessioncache: 'yes',
                closebuttoncaption: this.translate.instant('core.login.cancel'),
            };
            this.utils.openInApp(loginUrl, options);
        }
        else {
            this.utils.openInBrowser(loginUrl);
            if (navigator.app) {
                navigator.app.exitApp();
            }
        }
    };
    /**
     * Convenient helper to open change password page.
     *
     * @param {string} siteUrl Site URL to construct change password URL.
     * @param {string} error Error message.
     */
    CoreLoginHelperProvider.prototype.openChangePassword = function (siteUrl, error) {
        var _this = this;
        this.domUtils.showAlert(this.translate.instant('core.notice'), error, undefined, 3000).then(function (alert) {
            var subscription = alert.didDismiss.subscribe(function () {
                subscription && subscription.unsubscribe();
                _this.utils.openInApp(siteUrl + '/login/change_password.php');
            });
        });
    };
    /**
     * Open forgotten password in inappbrowser.
     *
     * @param {string} siteUrl URL of the site.
     */
    CoreLoginHelperProvider.prototype.openForgottenPassword = function (siteUrl) {
        this.utils.openInApp(siteUrl + '/login/forgot_password.php');
    };
    /*
     * Function to open in app browser to change password or complete user profile.
     *
     * @param {string} siteId The site ID.
     * @param {string} path The relative path of the URL to open.
     * @param {string} alertMessage The key of the message to display before opening the in app browser.
     * @param {boolean} [invalidateCache] Whether to invalidate site's cache (e.g. when the user is forced to change password).
     */
    CoreLoginHelperProvider.prototype.openInAppForEdit = function (siteId, path, alertMessage, invalidateCache) {
        var _this = this;
        if (!siteId || siteId !== this.sitesProvider.getCurrentSiteId()) {
            // Site that triggered the event is not current site, nothing to do.
            return;
        }
        var currentSite = this.sitesProvider.getCurrentSite(), siteUrl = currentSite && currentSite.getURL();
        if (!currentSite || !siteUrl) {
            return;
        }
        if (!this.isOpenEditAlertShown && !this.waitingForBrowser) {
            this.isOpenEditAlertShown = true;
            if (invalidateCache) {
                currentSite.invalidateWsCache();
            }
            // Open change password.
            alertMessage = this.translate.instant(alertMessage) + '<br>' + this.translate.instant('core.redirectingtosite');
            currentSite.openInAppWithAutoLogin(siteUrl + path, undefined, alertMessage).then(function () {
                _this.waitingForBrowser = true;
            }).finally(function () {
                _this.isOpenEditAlertShown = false;
            });
        }
    };
    /**
     * Prepare the app to perform SSO login.
     *
     * @param {string} siteUrl URL of the site where the SSO login will be performed.
     * @param {string} [service] The service to use. If not defined, external service will be used.
     * @param {string} [launchUrl] The URL to open for SSO. If not defined, local_mobile launch URL will be used.
     * @param {string} [pageName] Name of the page to go once authenticated. If not defined, site initial page.
     * @param {any} [pageParams] Params of the state to go once authenticated.
     */
    CoreLoginHelperProvider.prototype.prepareForSSOLogin = function (siteUrl, service, launchUrl, pageName, pageParams) {
        service = service || __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].wsextservice;
        launchUrl = launchUrl || siteUrl + '/local/mobile/launch.php';
        var passport = Math.random() * 1000;
        var loginUrl = launchUrl + '?service=' + service;
        loginUrl += '&passport=' + passport;
        loginUrl += '&urlscheme=' + __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].customurlscheme;
        // Store the siteurl and passport in CoreConfigProvider for persistence.
        // We are "configuring" the app to wait for an SSO. CoreConfigProvider shouldn't be used as a temporary storage.
        this.configProvider.set(__WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].LOGIN_LAUNCH_DATA, JSON.stringify({
            siteUrl: siteUrl,
            passport: passport,
            pageName: pageName || '',
            pageParams: pageParams || {}
        }));
        return loginUrl;
    };
    /**
     * Redirect to a new page, setting it as the root page and loading the right site if needed.
     *
     * @param {string} page Name of the page to load. Special cases: OPEN_COURSE (to open course page).
     * @param {any} params Params to pass to the page.
     * @param {string} [siteId] Site to load. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.redirect = function (page, params, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.sitesProvider.isLoggedIn()) {
            if (siteId && siteId != this.sitesProvider.getCurrentSiteId()) {
                // Target page belongs to a different site. Change site.
                if (this.sitePluginsProvider.hasSitePluginsLoaded) {
                    // The site has site plugins so the app will be restarted. Store the data and logout.
                    this.appProvider.storeRedirect(siteId, page, params);
                    return this.sitesProvider.logout();
                }
                else {
                    return this.sitesProvider.logout().then(function () {
                        return _this.loadSiteAndPage(page, params, siteId);
                    });
                }
            }
            else {
                this.loadPageInMainMenu(page, params);
            }
        }
        else {
            if (siteId) {
                return this.loadSiteAndPage(page, params, siteId);
            }
            else {
                return this.appProvider.getRootNavController().setRoot('CoreLoginSitesPage');
            }
        }
        return Promise.resolve();
    };
    /**
     * Request a password reset.
     *
     * @param {string} siteUrl URL of the site.
     * @param {string} [username] Username to search.
     * @param {string} [email] Email to search.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.requestPasswordReset = function (siteUrl, username, email) {
        var params = {};
        if (username) {
            params.username = username;
        }
        if (email) {
            params.email = email;
        }
        return this.wsProvider.callAjax('core_auth_request_password_reset', params, { siteUrl: siteUrl });
    };
    /**
     * Function that should be called when the session expires. Reserved for core use.
     *
     * @param {any} data Data received by the SESSION_EXPIRED event.
     */
    CoreLoginHelperProvider.prototype.sessionExpired = function (data) {
        var _this = this;
        var siteId = data && data.siteId, currentSite = this.sitesProvider.getCurrentSite(), siteUrl = currentSite && currentSite.getURL();
        var promise;
        if (!currentSite || !siteUrl) {
            return;
        }
        if (siteId && siteId !== currentSite.getId()) {
            return; // Site that triggered the event is not current site.
        }
        // Check authentication method.
        this.sitesProvider.checkSite(siteUrl).then(function (result) {
            if (result.warning) {
                _this.domUtils.showErrorModal(result.warning, true, 4000);
            }
            if (_this.isSSOLoginNeeded(result.code)) {
                // SSO. User needs to authenticate in a browser. Check if we need to display a message.
                if (!_this.appProvider.isSSOAuthenticationOngoing() && !_this.isSSOConfirmShown && !_this.waitingForBrowser) {
                    _this.isSSOConfirmShown = true;
                    if (_this.shouldShowSSOConfirm(result.code)) {
                        promise = _this.domUtils.showConfirm(_this.translate.instant('core.login.' +
                            (currentSite.isLoggedOut() ? 'loggedoutssodescription' : 'reconnectssodescription')));
                    }
                    else {
                        promise = Promise.resolve();
                    }
                    promise.then(function () {
                        _this.waitingForBrowser = true;
                        _this.sitesProvider.unsetCurrentSite(); // We need to unset current site to make authentication work fine.
                        _this.openBrowserForSSOLogin(result.siteUrl, result.code, result.service, result.config && result.config.launchurl, data.pageName, data.params);
                    }).catch(function () {
                        // User cancelled, logout him.
                        _this.sitesProvider.logout();
                    }).finally(function () {
                        _this.isSSOConfirmShown = false;
                    });
                }
            }
            else {
                var info = currentSite.getInfo();
                if (typeof info != 'undefined' && typeof info.username != 'undefined') {
                    var rootNavCtrl = _this.appProvider.getRootNavController(), activePage = rootNavCtrl.getActive();
                    // If current page is already reconnect, stop.
                    if (activePage && activePage.component && activePage.component.name == 'CoreLoginReconnectPage') {
                        return;
                    }
                    rootNavCtrl.setRoot('CoreLoginReconnectPage', {
                        infoSiteUrl: info.siteurl,
                        siteUrl: result.siteUrl,
                        siteId: siteId,
                        pageName: data.pageName,
                        pageParams: data.params,
                        siteConfig: result.config
                    });
                }
            }
        }).catch(function (error) {
            // Error checking site.
            if (currentSite.isLoggedOut()) {
                // Site is logged out, show error and logout the user.
                _this.domUtils.showErrorModalDefault(error, 'core.networkerrormsg', true);
                _this.sitesProvider.logout();
            }
        });
    };
    /**
     * Check if a confirm should be shown to open a SSO authentication.
     *
     * @param {number} typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.
     * @return {boolean} True if confirm modal should be shown, false otherwise.
     */
    CoreLoginHelperProvider.prototype.shouldShowSSOConfirm = function (typeOfLogin) {
        return !this.isSSOEmbeddedBrowser(typeOfLogin) &&
            (!__WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].skipssoconfirmation || String(__WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].skipssoconfirmation) === 'false');
    };
    /**
     * Show a modal warning the user that he should use the Classic app.
     *
     * @param {string} message The warning message.
     */
    CoreLoginHelperProvider.prototype.showLegacyNoticeModal = function (message) {
        var _this = this;
        var isAndroid = this.platform.is('android'), isIOS = this.platform.is('ios'), isWindows = this.appProvider.isWindows(), isLinux = this.appProvider.isLinux(), buttons = [
            {
                text: this.translate.instant('core.ok'),
                role: 'cancel'
            }
        ];
        if (isAndroid || isIOS || isWindows || isLinux) {
            buttons.push({
                text: this.translate.instant('core.download'),
                handler: function () {
                    var link;
                    if (isWindows) {
                        link = 'https://download.moodle.org/desktop/download.php?platform=windows&version=342';
                    }
                    else if (isLinux) {
                        link = 'https://download.moodle.org/desktop/download.php?platform=linux&version=342&arch=' +
                            (_this.appProvider.is64Bits() ? '64' : '32');
                    }
                    else if (isAndroid) {
                        link = 'market://details?id=com.moodle.classic';
                    }
                    else {
                        link = 'itms-apps://itunes.apple.com/app/id1403448117';
                    }
                    _this.utils.openInBrowser(link);
                }
            });
        }
        var alert = this.alertCtrl.create({
            message: message,
            buttons: buttons
        });
        alert.present().then(function () {
            if (!isAndroid && !isIOS) {
                // Treat all anchors so they don't override the app.
                var alertMessageEl = alert.pageRef().nativeElement.querySelector('.alert-message');
                _this.domUtils.treatAnchors(alertMessageEl);
            }
        });
    };
    /**
     * Show a modal to inform the user that a confirmation email was sent, and a button to resend the email on 3.6+ sites.
     *
     * @param {string} siteUrl Site URL.
     * @param {string} [email] Email of the user. If set displayed in the message.
     * @param {string} [username] Username. If not set the button to resend email will not be shown.
     * @param {string} [password] User password. If not set the button to resend email will not be shown.
     */
    CoreLoginHelperProvider.prototype.showNotConfirmedModal = function (siteUrl, email, username, password) {
        var _this = this;
        var title = this.translate.instant('core.login.mustconfirm');
        var message;
        if (email) {
            message = this.translate.instant('core.login.emailconfirmsent', { $a: email });
        }
        else {
            message = this.translate.instant('core.login.emailconfirmsentnoemail');
        }
        // Check whether we need to display the resend button or not.
        var promise;
        if (username && password) {
            var modal_2 = this.domUtils.showModalLoading();
            // We don't have site info before login, the only way to check if the WS is available is by calling it.
            var preSets = { siteUrl: siteUrl };
            promise = this.wsProvider.callAjax('core_auth_resend_confirmation_email', {}, preSets).catch(function (error) {
                // If the WS responds with an invalid parameter error it means the WS is avaiable.
                return Promise.resolve(error && error.errorcode === 'invalidparameter');
            }).finally(function () {
                modal_2.dismiss();
            });
        }
        else {
            promise = Promise.resolve(false);
        }
        promise.then(function (canResend) {
            if (canResend) {
                var okText = _this.translate.instant('core.login.resendemail');
                var cancelText = _this.translate.instant('core.close');
                _this.domUtils.showConfirm(message, title, okText, cancelText).then(function () {
                    // Call the WS to resend the confirmation email.
                    var modal = _this.domUtils.showModalLoading('core.sending', true);
                    var data = { username: username, password: password };
                    var preSets = { siteUrl: siteUrl };
                    _this.wsProvider.callAjax('core_auth_resend_confirmation_email', data, preSets).then(function (response) {
                        var message = _this.translate.instant('core.login.emailconfirmsentsuccess');
                        _this.domUtils.showAlert(_this.translate.instant('core.success'), message);
                    }).catch(function (error) {
                        _this.domUtils.showErrorModal(error);
                    }).finally(function () {
                        modal.dismiss();
                    });
                }).catch(function () {
                    // Dialog dismissed.
                });
            }
            else {
                _this.domUtils.showAlert(title, message);
            }
        });
    };
    /**
     * Function called when site policy is not agreed. Reserved for core use.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreLoginHelperProvider.prototype.sitePolicyNotAgreed = function (siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!siteId || siteId != this.sitesProvider.getCurrentSiteId()) {
            // Only current site allowed.
            return;
        }
        if (!this.sitesProvider.wsAvailableInCurrentSite('core_user_agree_site_policy')) {
            // WS not available, stop.
            return;
        }
        var rootNavCtrl = this.appProvider.getRootNavController(), activePage = rootNavCtrl.getActive();
        // If current page is already site policy, stop.
        if (activePage && activePage.component && activePage.component.name == 'CoreLoginSitePolicyPage') {
            return;
        }
        rootNavCtrl.setRoot('CoreLoginSitePolicyPage', { siteId: siteId });
    };
    /**
     * Convenient helper to handle get User Token error. It redirects to change password page if forcepassword is set.
     *
     * @param {string} siteUrl Site URL to construct change password URL.
     * @param {any} error Error object containing errorcode and error message.
     * @param {string} [username] Username.
     * @param {string} [password] User password.
     */
    CoreLoginHelperProvider.prototype.treatUserTokenError = function (siteUrl, error, username, password) {
        if (error.errorcode == 'forcepasswordchangenotice') {
            this.openChangePassword(siteUrl, this.textUtils.getErrorMessageFromError(error));
        }
        else if (error.errorcode == 'usernotconfirmed') {
            this.showNotConfirmedModal(siteUrl, undefined, username, password);
        }
        else if (error.errorcode == 'legacymoodleversion') {
            this.showLegacyNoticeModal(this.textUtils.getErrorMessageFromError(error));
        }
        else {
            this.domUtils.showErrorModal(error);
        }
    };
    /**
     * Convenient helper to validate a browser SSO login.
     *
     * @param {string} url URL received, to be validated.
     * @return {Promise<CoreLoginSSOData>} Promise resolved on success.
     */
    CoreLoginHelperProvider.prototype.validateBrowserSSOLogin = function (url) {
        var _this = this;
        // Split signature:::token
        var params = url.split(':::');
        return this.configProvider.get(__WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].LOGIN_LAUNCH_DATA).then(function (data) {
            data = _this.textUtils.parseJSON(data, null);
            if (data === null) {
                return Promise.reject(null);
            }
            var passport = data.passport;
            var launchSiteURL = data.siteUrl;
            // Reset temporary values.
            _this.configProvider.delete(__WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].LOGIN_LAUNCH_DATA);
            // Validate the signature.
            // We need to check both http and https.
            var signature = __WEBPACK_IMPORTED_MODULE_19_ts_md5_dist_md5__["Md5"].hashAsciiStr(launchSiteURL + passport);
            if (signature != params[0]) {
                if (launchSiteURL.indexOf('https://') != -1) {
                    launchSiteURL = launchSiteURL.replace('https://', 'http://');
                }
                else {
                    launchSiteURL = launchSiteURL.replace('http://', 'https://');
                }
                signature = __WEBPACK_IMPORTED_MODULE_19_ts_md5_dist_md5__["Md5"].hashAsciiStr(launchSiteURL + passport);
            }
            if (signature == params[0]) {
                _this.logger.debug('Signature validated');
                return {
                    siteUrl: launchSiteURL,
                    token: params[1],
                    privateToken: params[2],
                    pageName: data.pageName,
                    pageParams: data.pageParams
                };
            }
            else {
                _this.logger.debug('Invalid signature in the URL request yours: ' + params[0] + ' mine: '
                    + signature + ' for passport ' + passport);
                return Promise.reject(_this.translate.instant('core.unexpectederror'));
            }
        });
    };
    CoreLoginHelperProvider.OPEN_COURSE = 'open_course';
    CoreLoginHelperProvider = CoreLoginHelperProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_11__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_ws__["a" /* CoreWSProvider */], __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_12__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_14__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_13__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["v" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_7__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_15__core_siteplugins_providers_siteplugins__["a" /* CoreSitePluginsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__angular_common__["f" /* Location */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["b" /* AlertController */], __WEBPACK_IMPORTED_MODULE_16__core_course_providers_course__["a" /* CoreCourseProvider */]])
    ], CoreLoginHelperProvider);
    return CoreLoginHelperProvider;
    var CoreLoginHelperProvider_1;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreContextMenuComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreContextMenuComponent_0;
/* unused harmony export View_CoreContextMenuComponent_Host_0 */
/* unused harmony export CoreContextMenuComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_button_button_ngfactory__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular_components_button_button__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__icon_icon_ngfactory__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__icon_icon__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__context_menu__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ngx_translate_core_src_translate_service__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ionic_angular_components_popover_popover_controller__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__tabs_tab__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_utils__ = __webpack_require__(2);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 












var styles_CoreContextMenuComponent = [];
var RenderType_CoreContextMenuComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreContextMenuComponent, data: {} });

function View_CoreContextMenuComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 5, "button", [["aria-haspopup", "true"], ["class", "bar-button"], ["clear", ""], ["icon-only", ""], ["ion-button", ""]], [[8, "hidden", 0], [1, "aria-label", 0], [1, "aria-expanded", 0], [1, "aria-controls", 0]], [[null, "click"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("click" === en)) {
        var pd_0 = (_co.showContextMenu($event) !== false);
        ad = (pd_0 && ad);
    } return ad; }, __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_button_button_ngfactory__["b" /* View_Button_0 */], __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_button_button_ngfactory__["a" /* RenderType_Button */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 1097728, null, 0, __WEBPACK_IMPORTED_MODULE_2_ionic_angular_components_button_button__["a" /* Button */], [[8, ""], __WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */]], { clear: [0, "clear"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 0, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](3, 0, null, 0, 1, "core-icon", [], null, null, null, __WEBPACK_IMPORTED_MODULE_4__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_4__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](4, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_5__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 0, ["\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_43" /* ɵncd */](null, 0)], function (_ck, _v) { var _co = _v.component; var currVal_4 = ""; _ck(_v, 1, 0, currVal_4); var currVal_5 = _co.icon; _ck(_v, 4, 0, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.hideMenu; var currVal_1 = _co.ariaLabel; var currVal_2 = _co.expanded; var currVal_3 = _co.uniqueId; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }
function View_CoreContextMenuComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-context-menu", [], null, null, null, View_CoreContextMenuComponent_0, RenderType_CoreContextMenuComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 245760, null, 0, __WEBPACK_IMPORTED_MODULE_6__context_menu__["a" /* CoreContextMenuComponent */], [__WEBPACK_IMPORTED_MODULE_7__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_8_ionic_angular_components_popover_popover_controller__["a" /* PopoverController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_dom__["a" /* CoreDomUtilsProvider */], [2, __WEBPACK_IMPORTED_MODULE_10__tabs_tab__["a" /* CoreTabComponent */]], __WEBPACK_IMPORTED_MODULE_11__providers_utils_utils__["a" /* CoreUtilsProvider */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }
var CoreContextMenuComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-context-menu", __WEBPACK_IMPORTED_MODULE_6__context_menu__["a" /* CoreContextMenuComponent */], View_CoreContextMenuComponent_Host_0, { icon: "icon", title: "title", ariaLabel: "aria-label" }, {}, ["*"]);

//# sourceMappingURL=context-menu.ngfactory.js.map

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreContextMenuItemComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreContextMenuItemComponent_0;
/* unused harmony export View_CoreContextMenuItemComponent_Host_0 */
/* unused harmony export CoreContextMenuItemComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context_menu_item__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__context_menu__ = __webpack_require__(73);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 



var styles_CoreContextMenuItemComponent = [];
var RenderType_CoreContextMenuItemComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreContextMenuItemComponent, data: {} });

function View_CoreContextMenuItemComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [], null, null); }
function View_CoreContextMenuItemComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-context-menu-item", [], null, null, null, View_CoreContextMenuItemComponent_0, RenderType_CoreContextMenuItemComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 770048, null, 0, __WEBPACK_IMPORTED_MODULE_1__context_menu_item__["a" /* CoreContextMenuItemComponent */], [__WEBPACK_IMPORTED_MODULE_2__context_menu__["a" /* CoreContextMenuComponent */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }
var CoreContextMenuItemComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-context-menu-item", __WEBPACK_IMPORTED_MODULE_1__context_menu_item__["a" /* CoreContextMenuItemComponent */], View_CoreContextMenuItemComponent_Host_0, { content: "content", iconDescription: "iconDescription", iconAction: "iconAction", iconSlash: "iconSlash", ariaDescription: "ariaDescription", ariaAction: "ariaAction", href: "href", captureLink: "captureLink", autoLogin: "autoLogin", closeOnClick: "closeOnClick", priority: "priority", badge: "badge", badgeClass: "badgeClass", hidden: "hidden" }, { action: "action" }, []);

//# sourceMappingURL=context-menu-item.ngfactory.js.map

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreNavBarButtonsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Component to add buttons to the app's header without having to place them inside the header itself. This is meant for
 * pages that are loaded inside a sub ion-nav, so they don't have a header.
 *
 * If this component indicates a position (start/end), the buttons will only be added if the header has some buttons in that
 * position. If no start/end is specified, then the buttons will be added to the first <ion-buttons> found in the header.
 *
 * You can use the [hidden] input to hide all the inner buttons if a certain condition is met.
 *
 * IMPORTANT: Do not use *ngIf in the buttons inside this component, it can cause problems. Please use [hidden] instead.
 *
 * Example usage:
 *
 * <core-navbar-buttons end>
 *     <button ion-button icon-only [hidden]="!buttonShown" [attr.aria-label]="Do something" (click)="action()">
 *         <ion-icon name="funnel"></ion-icon>
 *     </button>
 * </core-navbar-buttons>
 */
var CoreNavBarButtonsComponent = /** @class */ (function () {
    function CoreNavBarButtonsComponent(element, logger, domUtils) {
        this.domUtils = domUtils;
        this.BUTTON_HIDDEN_CLASS = 'core-navbar-button-hidden';
        this.forceHidden = false;
        this.element = element.nativeElement;
        this.logger = logger.getInstance('CoreNavBarButtonsComponent');
        this.instanceId = this.domUtils.storeInstanceByElement(this.element, this);
    }
    Object.defineProperty(CoreNavBarButtonsComponent.prototype, "hidden", {
        // If the hidden input is true, hide all buttons.
        set: function (value) {
            this._hidden = value;
            this.showHideAllElements();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CoreNavBarButtonsComponent.prototype, "buttons", {
        // Get all the ion-buttons inside this directive and apply the role bar-button.
        set: function (buttons) {
            buttons.forEach(function (button) {
                button.setRole('bar-button');
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Component being initialized.
     */
    CoreNavBarButtonsComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.searchHeader().then(function (header) {
            if (header) {
                // Search the right buttons container (start, end or any).
                var selector = 'ion-buttons', buttonsContainer = void 0;
                if (_this.element.hasAttribute('start')) {
                    selector += '[start]';
                }
                else if (_this.element.hasAttribute('end')) {
                    selector += '[end]';
                }
                buttonsContainer = header.querySelector(selector);
                if (buttonsContainer) {
                    _this.mergeContextMenus(buttonsContainer);
                    _this.movedChildren = _this.domUtils.moveChildren(_this.element, buttonsContainer);
                    _this.showHideAllElements();
                }
                else {
                    _this.logger.warn('The header was found, but it didn\'t have the right ion-buttons.', selector);
                }
            }
        }).catch(function () {
            // Header not found.
            _this.logger.warn('Header not found.');
        });
    };
    /**
     * Force or unforce hiding all buttons. If this is true, it will override the "hidden" input.
     *
     * @param {boolean} value The value to set.
     */
    CoreNavBarButtonsComponent.prototype.forceHide = function (value) {
        this.forceHidden = value;
        this.showHideAllElements();
    };
    /**
     * If both button containers have a context menu, merge them into a single one.
     *
     * @param {HTMLElement} buttonsContainer The container where the buttons will be moved.
     */
    CoreNavBarButtonsComponent.prototype.mergeContextMenus = function (buttonsContainer) {
        // Check if both button containers have a context menu.
        var mainContextMenu = buttonsContainer.querySelector('core-context-menu');
        if (!mainContextMenu) {
            return;
        }
        var secondaryContextMenu = this.element.querySelector('core-context-menu');
        if (!secondaryContextMenu) {
            return;
        }
        // Both containers have a context menu. Merge them to prevent having 2 menus at the same time.
        var mainContextMenuInstance = this.domUtils.getInstanceByElement(mainContextMenu), secondaryContextMenuInstance = this.domUtils.getInstanceByElement(secondaryContextMenu);
        // Check that both context menus belong to the same core-tab. We shouldn't merge menus from different tabs.
        if (mainContextMenuInstance && secondaryContextMenuInstance &&
            mainContextMenuInstance.coreTab === secondaryContextMenuInstance.coreTab) {
            this.mergedContextMenu = secondaryContextMenuInstance;
            this.mergedContextMenu.mergeContextMenus(mainContextMenuInstance);
            // Remove the empty context menu from the DOM.
            secondaryContextMenu.parentElement.removeChild(secondaryContextMenu);
        }
    };
    /**
     * Search the ion-header where the buttons should be added.
     *
     * @param {number} [retries] Number of retries so far.
     * @return {Promise<HTMLElement>} Promise resolved with the header element.
     */
    CoreNavBarButtonsComponent.prototype.searchHeader = function (retries) {
        var _this = this;
        if (retries === void 0) { retries = 0; }
        var parentPage = this.element;
        while (parentPage) {
            if (!parentPage.parentElement) {
                // No parent, stop.
                break;
            }
            // Get the next parent page.
            parentPage = this.domUtils.closest(parentPage.parentElement, '.ion-page');
            if (parentPage) {
                // Check if the page has a header. If it doesn't, search the next parent page.
                var header = this.searchHeaderInPage(parentPage);
                if (header && getComputedStyle(header, null).display != 'none') {
                    return Promise.resolve(header);
                }
            }
        }
        // Header not found.
        if (retries < 5) {
            // If the component or any of its parent is inside a ng-content or similar it can be detached when it's initialized.
            // Try again after a while.
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    _this.searchHeader(retries + 1).then(resolve, reject);
                }, 200);
            });
        }
        // We've waited enough time, reject.
        return Promise.reject(null);
    };
    /**
     * Search ion-header inside a page. The header should be a direct child.
     *
     * @param  {HTMLElement} page Page to search in.
     * @return {HTMLElement} Header element. Undefined if not found.
     */
    CoreNavBarButtonsComponent.prototype.searchHeaderInPage = function (page) {
        for (var i = 0; i < page.children.length; i++) {
            var child = page.children[i];
            if (child.tagName == 'ION-HEADER') {
                return child;
            }
        }
    };
    /**
     * Show or hide all the elements.
     */
    CoreNavBarButtonsComponent.prototype.showHideAllElements = function () {
        var _this = this;
        // Show or hide all moved children.
        if (this.movedChildren) {
            this.movedChildren.forEach(function (child) {
                _this.showHideElement(child);
            });
        }
        // Show or hide all the context menu items that were merged to another context menu.
        if (this.mergedContextMenu) {
            if (this.forceHidden || this._hidden) {
                this.mergedContextMenu.removeMergedItems();
            }
            else {
                this.mergedContextMenu.restoreMergedItems();
            }
        }
    };
    /**
     * Show or hide an element.
     *
     * @param {Node} element Element to show or hide.
     */
    CoreNavBarButtonsComponent.prototype.showHideElement = function (element) {
        // Check if it's an HTML Element
        if (element instanceof Element) {
            if (this.forceHidden || this._hidden) {
                element.classList.add(this.BUTTON_HIDDEN_CLASS);
            }
            else {
                element.classList.remove(this.BUTTON_HIDDEN_CLASS);
            }
        }
    };
    /**
     * Component destroyed.
     */
    CoreNavBarButtonsComponent.prototype.ngOnDestroy = function () {
        this.domUtils.removeInstanceById(this.instanceId);
        // This component was destroyed, remove all the buttons that were moved.
        // The buttons can be moved outside of the current page, that's why we need to manually destroy them.
        // There's no need to destroy context menu items that were merged because they weren't moved from their DOM position.
        if (this.movedChildren) {
            this.movedChildren.forEach(function (child) {
                if (child.parentElement) {
                    child.parentElement.removeChild(child);
                }
            });
        }
        if (this.mergedContextMenu) {
            this.mergedContextMenu.removeMergedItems();
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('hidden'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], CoreNavBarButtonsComponent.prototype, "hidden", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["r" /* ContentChildren */])(__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["d" /* Button */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["T" /* QueryList */]),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["T" /* QueryList */]])
    ], CoreNavBarButtonsComponent.prototype, "buttons", null);
    CoreNavBarButtonsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-navbar-buttons',
            template: '<ng-content></ng-content>'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreNavBarButtonsComponent);
    return CoreNavBarButtonsComponent;
}());

//# sourceMappingURL=navbar-buttons.js.map

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreMarkRequiredComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreMarkRequiredComponent_0;
/* unused harmony export View_CoreMarkRequiredComponent_Host_0 */
/* unused harmony export CoreMarkRequiredComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular_components_icon_icon__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular_config_config__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mark_required__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core_src_translate_service__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(2);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 








var styles_CoreMarkRequiredComponent = [];
var RenderType_CoreMarkRequiredComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreMarkRequiredComponent, data: {} });

function View_CoreMarkRequiredComponent_1(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "ion-icon", [["class", "core-input-required-asterisk"], ["md", "ios-medical"], ["name", "medical"], ["role", "img"]], [[8, "title", 0], [2, "hide", null]], null, null, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 147456, null, 0, __WEBPACK_IMPORTED_MODULE_1_ionic_angular_components_icon_icon__["a" /* Icon */], [__WEBPACK_IMPORTED_MODULE_2_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */]], { name: [0, "name"], md: [1, "md"] }, null)], function (_ck, _v) { var currVal_2 = "medical"; var currVal_3 = "ios-medical"; _ck(_v, 1, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.requiredLabel; var currVal_1 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 1)._hidden; _ck(_v, 0, 0, currVal_0, currVal_1); }); }
function View_CoreMarkRequiredComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_43" /* ɵncd */](null, 0), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreMarkRequiredComponent_1)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](3, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_3__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, [" "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.coreMarkRequired; _ck(_v, 3, 0, currVal_0); }, null); }
function View_CoreMarkRequiredComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "div", [["core-mark-required", ""]], null, null, null, View_CoreMarkRequiredComponent_0, RenderType_CoreMarkRequiredComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 4308992, null, 0, __WEBPACK_IMPORTED_MODULE_4__mark_required__["a" /* CoreMarkRequiredComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */]], { coreMarkRequired: [0, "coreMarkRequired"] }, null)], function (_ck, _v) { var currVal_0 = ""; _ck(_v, 1, 0, currVal_0); }, null); }
var CoreMarkRequiredComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("[core-mark-required]", __WEBPACK_IMPORTED_MODULE_4__mark_required__["a" /* CoreMarkRequiredComponent */], View_CoreMarkRequiredComponent_Host_0, { coreMarkRequired: "core-mark-required" }, {}, ["*"]);

//# sourceMappingURL=mark-required.ngfactory.js.map

/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInputErrorsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to show errors if an input isn't valid.
 *
 * @description
 * The purpose of this component is to make easier and consistent the validation of forms.
 *
 * It should be applied next to the input element (ion-input, ion-select, ...). In case of ion-checkbox, it should be in another
 * item, placing it in the same item as the checkbox will cause problems.
 *
 * Please notice that the inputs need to have a FormControl to make it work. That FormControl needs to be passed to this component.
 *
 * If this component is placed in the same ion-item as a ion-label or ion-input, then it should have the attribute "item-content",
 * otherwise Ionic will remove it.
 *
 * Example usage:
 *
 * <ion-item text-wrap>
 *     <ion-label stacked core-mark-required="true">{{ 'core.login.username' | translate }}</ion-label>
 *     <ion-input type="text" name="username" formControlName="username"></ion-input>
 *     <core-input-errors item-content [control]="myForm.controls.username" [errorMessages]="usernameErrors"></core-input-errors>
 * </ion-item>
 */
var CoreInputErrorsComponent = /** @class */ (function () {
    function CoreInputErrorsComponent(translate) {
        this.translate = translate;
    }
    /**
     * Component is being initialized.
     */
    CoreInputErrorsComponent.prototype.ngOnInit = function () {
        if (this.formControl) {
            this.initErrorMessages();
            this.errorKeys = Object.keys(this.errorMessages);
        }
    };
    /**
     * Initialize some common errors if they aren't set.
     */
    CoreInputErrorsComponent.prototype.initErrorMessages = function () {
        this.errorMessages = this.errorMessages || {};
        this.errorMessages.required = this.errorMessages.required || this.translate.instant('core.required');
        this.errorMessages.email = this.errorMessages.email || this.translate.instant('core.login.invalidemail');
        this.errorMessages.date = this.errorMessages.date || this.translate.instant('core.login.invaliddate');
        this.errorMessages.datetime = this.errorMessages.datetime || this.translate.instant('core.login.invaliddate');
        this.errorMessages.datetimelocal = this.errorMessages.datetimelocal || this.translate.instant('core.login.invaliddate');
        this.errorMessages.time = this.errorMessages.time || this.translate.instant('core.login.invalidtime');
        this.errorMessages.url = this.errorMessages.url || this.translate.instant('core.login.invalidurl');
        // Set empty values by default, the default error messages will be built in the template when needed.
        this.errorMessages.max = this.errorMessages.max || '';
        this.errorMessages.min = this.errorMessages.min || '';
    };
    /**
     * Component being changed.
     */
    CoreInputErrorsComponent.prototype.ngOnChanges = function (changes) {
        if (changes.errorText) {
            this.errorText = changes.errorText.currentValue;
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('control'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["e" /* FormControl */])
    ], CoreInputErrorsComponent.prototype, "formControl", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreInputErrorsComponent.prototype, "errorMessages", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreInputErrorsComponent.prototype, "errorText", void 0);
    CoreInputErrorsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-input-errors',
            templateUrl: 'core-input-errors.html'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreInputErrorsComponent);
    return CoreInputErrorsComponent;
}());

//# sourceMappingURL=input-errors.js.map

/***/ }),
/* 88 */,
/* 89 */,
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksModuleIndexHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_handler__ = __webpack_require__(53);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Handler to handle URLs pointing to the index of a module.
 */
var CoreContentLinksModuleIndexHandler = /** @class */ (function (_super) {
    __extends(CoreContentLinksModuleIndexHandler, _super);
    /**
     * Construct the handler.
     *
     * @param {CoreCourseHelperProvider} courseHelper The CoreCourseHelperProvider instance.
     * @param {string} addon Name of the addon as it's registered in course delegate. It'll be used to check if it's disabled.
     * @param {string} modName Name of the module (assign, book, ...).
     */
    function CoreContentLinksModuleIndexHandler(courseHelper, addon, modName) {
        var _this = _super.call(this) || this;
        _this.courseHelper = courseHelper;
        _this.addon = addon;
        _this.modName = modName;
        /**
         * If this boolean is set to true, the app will retrieve all modules with this modName with a single WS call.
         * This reduces the number of WS calls, but it isn't recommended for modules that can return a lot of contents.
         * @type {boolean}
         */
        _this.useModNameToGetModule = false;
        // Match the view.php URL with an id param.
        _this.pattern = new RegExp('\/mod\/' + modName + '\/view\.php.*([\&\?]id=\\d+)');
        _this.featureName = 'CoreCourseModuleDelegate_' + addon;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreContentLinksModuleIndexHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        courseId = courseId || params.courseid || params.cid;
        return [{
                action: function (siteId, navCtrl) {
                    _this.courseHelper.navigateToModule(parseInt(params.id, 10), siteId, courseId, undefined, _this.useModNameToGetModule ? _this.modName : undefined);
                }
            }];
    };
    return CoreContentLinksModuleIndexHandler;
}(__WEBPACK_IMPORTED_MODULE_0__base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=module-index-handler.js.map

/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreNavBarButtonsComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreNavBarButtonsComponent_0;
/* unused harmony export View_CoreNavBarButtonsComponent_Host_0 */
/* unused harmony export CoreNavBarButtonsComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__navbar_buttons__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 




var styles_CoreNavBarButtonsComponent = [];
var RenderType_CoreNavBarButtonsComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreNavBarButtonsComponent, data: {} });

function View_CoreNavBarButtonsComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_43" /* ɵncd */](null, 0)], null, null); }
function View_CoreNavBarButtonsComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 2, "core-navbar-buttons", [], null, null, null, View_CoreNavBarButtonsComponent_0, RenderType_CoreNavBarButtonsComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 245760, null, 1, __WEBPACK_IMPORTED_MODULE_1__navbar_buttons__["a" /* CoreNavBarButtonsComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]], null, null), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](603979776, 1, { buttons: 1 })], function (_ck, _v) { _ck(_v, 1, 0); }, null); }
var CoreNavBarButtonsComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-navbar-buttons", __WEBPACK_IMPORTED_MODULE_1__navbar_buttons__["a" /* CoreNavBarButtonsComponent */], View_CoreNavBarButtonsComponent_Host_0, { hidden: "hidden" }, {}, ["*"]);

//# sourceMappingURL=navbar-buttons.ngfactory.js.map

/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseOptionsDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__course__ = __webpack_require__(15);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service to interact with plugins to be shown in each course (participants, learning plans, ...).
 */
var CoreCourseOptionsDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseOptionsDelegate, _super);
    function CoreCourseOptionsDelegate(loggerProvider, sitesProvider, utils, eventsProvider, coursesProvider) {
        var _this = _super.call(this, 'CoreCourseOptionsDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.utils = utils;
        _this.eventsProvider = eventsProvider;
        _this.coursesProvider = coursesProvider;
        _this.loaded = {};
        _this.lastUpdateHandlersForCoursesStart = {};
        _this.coursesHandlers = {};
        _this.featurePrefix = 'CoreCourseOptionsDelegate_';
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function () {
            _this.clearCoursesHandlers();
        });
        return _this;
    }
    /**
     * Check if handlers are loaded for a certain course.
     *
     * @param {number} courseId The course ID to check.
     * @return {boolean} True if handlers are loaded, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.areHandlersLoaded = function (courseId) {
        return !!this.loaded[courseId];
    };
    /**
     * Clear all course options handlers.
     *
     * @param {number} [courseId] The course ID. If not defined, all handlers will be cleared.
     */
    CoreCourseOptionsDelegate.prototype.clearCoursesHandlers = function (courseId) {
        if (courseId) {
            this.loaded[courseId] = false;
            delete this.coursesHandlers[courseId];
        }
        else {
            this.loaded = {};
            this.coursesHandlers = {};
        }
    };
    /**
     * Clear all courses handlers and invalidate its options.
     *
     * @param {number} [courseId] The course ID. If not defined, all handlers will be cleared.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseOptionsDelegate.prototype.clearAndInvalidateCoursesOptions = function (courseId) {
        var promises = [];
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__["a" /* CoreCoursesProvider */].EVENT_MY_COURSES_REFRESHED);
        // Invalidate course enabled data for the handlers that are enabled at site level.
        if (courseId) {
            // Invalidate only options for this course.
            promises.push(this.coursesProvider.invalidateCoursesAdminAndNavOptions([courseId]));
            promises.push(this.invalidateCourseHandlers(courseId));
        }
        else {
            // Invalidate all options.
            promises.push(this.coursesProvider.invalidateUserNavigationOptions());
            promises.push(this.coursesProvider.invalidateUserAdministrationOptions());
            for (var cId in this.coursesHandlers) {
                promises.push(this.invalidateCourseHandlers(parseInt(cId, 10)));
            }
        }
        this.clearCoursesHandlers(courseId);
        return Promise.all(promises);
    };
    /**
     * Get the handlers for a course using a certain access type.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} refresh True if it should refresh the list.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<CoreCourseOptionsHandler[]>} Promise resolved with array of handlers.
     */
    CoreCourseOptionsDelegate.prototype.getHandlersForAccess = function (courseId, refresh, accessData, navOptions, admOptions) {
        var _this = this;
        // If the handlers aren't loaded, do not refresh.
        if (!this.loaded[courseId]) {
            refresh = false;
        }
        if (refresh || !this.coursesHandlers[courseId] || this.coursesHandlers[courseId].access.type != accessData.type) {
            if (!this.coursesHandlers[courseId]) {
                this.coursesHandlers[courseId] = {};
            }
            this.coursesHandlers[courseId].access = accessData;
            this.coursesHandlers[courseId].navOptions = navOptions;
            this.coursesHandlers[courseId].admOptions = admOptions;
            this.coursesHandlers[courseId].deferred = this.utils.promiseDefer();
            this.updateHandlersForCourse(courseId, accessData, navOptions, admOptions);
        }
        return this.coursesHandlers[courseId].deferred.promise.then(function () {
            return _this.coursesHandlers[courseId].enabledHandlers;
        });
    };
    /**
     * Get the list of handlers that should be displayed for a course.
     * This function should be called only when the handlers need to be displayed, since it can call several WebServices.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {boolean} [isGuest] Whether it's guest.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<CoreCourseOptionsHandlerToDisplay[]>} Promise resolved with array of handlers.
     */
    CoreCourseOptionsDelegate.prototype.getHandlersToDisplay = function (injector, course, refresh, isGuest, navOptions, admOptions) {
        return this.getHandlersToDisplayInternal(false, injector, course, refresh, isGuest, navOptions, admOptions);
    };
    /**
     * Get the list of menu handlers that should be displayed for a course.
     * This function should be called only when the handlers need to be displayed, since it can call several WebServices.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {boolean} [isGuest] Whether it's guest.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<CoreCourseOptionsMenuHandlerToDisplay[]>} Promise resolved with array of handlers.
     */
    CoreCourseOptionsDelegate.prototype.getMenuHandlersToDisplay = function (injector, course, refresh, isGuest, navOptions, admOptions) {
        return this.getHandlersToDisplayInternal(true, injector, course, refresh, isGuest, navOptions, admOptions);
    };
    /**
     * Get the list of menu handlers that should be displayed for a course.
     * This function should be called only when the handlers need to be displayed, since it can call several WebServices.
     *
     * @param {boolean} menu If true, gets menu handlers; false, gets tab handlers
     * @param {Injector} injector Injector.
     * @param {any} course The course object.
     * @param {boolean} refresh True if it should refresh the list.
     * @param {boolean} isGuest Whether it's guest.
     * @param {any} navOptions Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} admOptions Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<any[]>} Promise resolved with array of handlers.
     */
    CoreCourseOptionsDelegate.prototype.getHandlersToDisplayInternal = function (menu, injector, course, refresh, isGuest, navOptions, admOptions) {
        var _this = this;
        course.id = parseInt(course.id, 10);
        var accessData = {
            type: isGuest ? __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_GUEST : __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_DEFAULT
        }, handlersToDisplay = [];
        if (navOptions) {
            course.navOptions = navOptions;
        }
        if (admOptions) {
            course.admOptions = admOptions;
        }
        return this.loadCourseOptions(course, refresh).then(function () {
            // Call getHandlersForAccess to make sure the handlers have been loaded.
            return _this.getHandlersForAccess(course.id, refresh, accessData, course.navOptions, course.admOptions);
        }).then(function () {
            var promises = [];
            var handlerList;
            if (menu) {
                handlerList = _this.coursesHandlers[course.id].enabledMenuHandlers;
            }
            else {
                handlerList = _this.coursesHandlers[course.id].enabledHandlers;
            }
            handlerList.forEach(function (handler) {
                var getFunction = menu ? handler.getMenuDisplayData : handler.getDisplayData;
                promises.push(Promise.resolve(getFunction.call(handler, injector, course)).then(function (data) {
                    handlersToDisplay.push({
                        data: data,
                        priority: handler.priority,
                        prefetch: handler.prefetch && handler.prefetch.bind(handler),
                        name: handler.name
                    });
                }).catch(function (err) {
                    _this.logger.error('Error getting data for handler', handler.name, err);
                }));
            });
            return Promise.all(promises);
        }).then(function () {
            // Sort them by priority.
            handlersToDisplay.sort(function (a, b) {
                return b.priority - a.priority;
            });
            return handlersToDisplay;
        });
    };
    /**
     * Check if a course has any handler enabled for default access, using course object.
     *
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @return {Promise<boolean>} Promise resolved with boolean: true if it has handlers, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.hasHandlersForCourse = function (course, refresh) {
        var _this = this;
        // Load course options if missing.
        return this.loadCourseOptions(course, refresh).then(function () {
            return _this.hasHandlersForDefault(course.id, refresh, course.navOptions, course.admOptions);
        });
    };
    /**
     * Check if a course has any handler enabled for default access.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<boolean>} Promise resolved with boolean: true if it has handlers, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.hasHandlersForDefault = function (courseId, refresh, navOptions, admOptions) {
        // Default access.
        var accessData = {
            type: __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_DEFAULT
        };
        return this.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions).then(function (handlers) {
            return !!(handlers && handlers.length);
        });
    };
    /**
     * Check if a course has any handler enabled for guest access.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<boolean>} Promise resolved with boolean: true if it has handlers, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.hasHandlersForGuest = function (courseId, refresh, navOptions, admOptions) {
        // Guest access.
        var accessData = {
            type: __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_GUEST
        };
        return this.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions).then(function (handlers) {
            return !!(handlers && handlers.length);
        });
    };
    /**
     * Invalidate the data to be able to determine if handlers are enabled for a certain course.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseOptionsDelegate.prototype.invalidateCourseHandlers = function (courseId) {
        var promises = [], courseData = this.coursesHandlers[courseId];
        if (!courseData) {
            return Promise.resolve();
        }
        courseData.enabledHandlers.forEach(function (handler) {
            if (handler && handler.invalidateEnabledForCourse) {
                promises.push(Promise.resolve(handler.invalidateEnabledForCourse(courseId, courseData.navOptions, courseData.admOptions)));
            }
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Check if a time belongs to the last update handlers for course call.
     * This is to handle the cases where updateHandlersForCourse don't finish in the same order as they're called.
     *
     * @param {number} courseId Course ID.
     * @param {number} time Time to check.
     * @return {boolean} Whether it's the last call.
     */
    CoreCourseOptionsDelegate.prototype.isLastUpdateCourseCall = function (courseId, time) {
        if (!this.lastUpdateHandlersForCoursesStart[courseId]) {
            return true;
        }
        return time == this.lastUpdateHandlersForCoursesStart[courseId];
    };
    /**
     * Load course options if missing.
     *
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @return {Promise<void>} Promise resolved when done.
     */
    CoreCourseOptionsDelegate.prototype.loadCourseOptions = function (course, refresh) {
        if (this.coursesProvider.canGetAdminAndNavOptions() &&
            (typeof course.navOptions == 'undefined' || typeof course.admOptions == 'undefined' || refresh)) {
            return this.coursesProvider.getCoursesAdminAndNavOptions([course.id]).then(function (options) {
                course.navOptions = options.navOptions[course.id];
                course.admOptions = options.admOptions[course.id];
            });
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Update handlers for each course.
     *
     * @param {string} [siteId] Site ID.
     */
    CoreCourseOptionsDelegate.prototype.updateData = function (siteId) {
        if (this.sitesProvider.getCurrentSiteId() === siteId) {
            // Update handlers for all courses.
            for (var courseId in this.coursesHandlers) {
                var handler = this.coursesHandlers[courseId];
                this.updateHandlersForCourse(parseInt(courseId, 10), handler.access, handler.navOptions, handler.admOptions);
            }
        }
    };
    /**
     * Update the handlers for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<any>} Resolved when updated.
     */
    CoreCourseOptionsDelegate.prototype.updateHandlersForCourse = function (courseId, accessData, navOptions, admOptions) {
        var _this = this;
        var promises = [], enabledForCourse = [], enabledForCourseMenu = [], siteId = this.sitesProvider.getCurrentSiteId(), now = Date.now();
        this.lastUpdateHandlersForCoursesStart[courseId] = now;
        var _loop_1 = function (name_1) {
            var handler = this_1.enabledHandlers[name_1];
            // Checks if the handler is enabled for the user.
            promises.push(Promise.resolve(handler.isEnabledForCourse(courseId, accessData, navOptions, admOptions))
                .then(function (enabled) {
                if (enabled) {
                    if (handler.isMenuHandler) {
                        enabledForCourseMenu.push(handler);
                    }
                    else {
                        enabledForCourse.push(handler);
                    }
                }
                else {
                    return Promise.reject(null);
                }
            }).catch(function () {
                // Nothing to do here, it is not enabled for this user.
            }));
        };
        var this_1 = this;
        for (var name_1 in this.enabledHandlers) {
            _loop_1(name_1);
        }
        return Promise.all(promises).then(function () {
            return true;
        }).catch(function () {
            // Never fails.
            return true;
        }).finally(function () {
            // Verify that this call is the last one that was started.
            // Check that site hasn't changed since the check started.
            if (_this.isLastUpdateCourseCall(courseId, now) && _this.sitesProvider.getCurrentSiteId() === siteId) {
                // Update the coursesHandlers array with the new enabled addons.
                _this.coursesHandlers[courseId].enabledHandlers = enabledForCourse;
                _this.coursesHandlers[courseId].enabledMenuHandlers = enabledForCourseMenu;
                _this.loaded[courseId] = true;
                // Resolve the promise.
                _this.coursesHandlers[courseId].deferred.resolve();
            }
        });
    };
    CoreCourseOptionsDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreCourseOptionsDelegate);
    return CoreCourseOptionsDelegate;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=options-delegate.js.map

/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreInputErrorsComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreInputErrorsComponent_0;
/* unused harmony export View_CoreInputErrorsComponent_Host_0 */
/* unused harmony export CoreInputErrorsComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core_src_translate_pipe__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core_src_translate_service__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__input_errors__ = __webpack_require__(87);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 





var styles_CoreInputErrorsComponent = [];
var RenderType_CoreInputErrorsComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreInputErrorsComponent, data: {} });

function View_CoreInputErrorsComponent_5(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "span", [], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](1, null, ["", ""]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.errorMessages[_v.parent.parent.context.$implicit]; _ck(_v, 1, 0, currVal_0); }); }
function View_CoreInputErrorsComponent_6(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 3, "span", [], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](1, null, ["\n                    ", "\n                "])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_48" /* ɵpod */](2, { $a: 0 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_47" /* ɵpid */](131072, __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core_src_translate_pipe__["a" /* TranslatePipe */], [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */]])], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_56" /* ɵunv */](_v, 1, 0, __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 3).transform("core.login.invalidvaluemax", _ck(_v, 2, 0, _co.formControl.errors.max.max))); _ck(_v, 1, 0, currVal_0); }); }
function View_CoreInputErrorsComponent_7(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 3, "span", [], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](1, null, ["\n                    ", "\n                "])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_48" /* ɵpod */](2, { $a: 0 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_47" /* ɵpid */](131072, __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core_src_translate_pipe__["a" /* TranslatePipe */], [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */]])], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_56" /* ɵunv */](_v, 1, 0, __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 3).transform("core.login.invalidvaluemin", _ck(_v, 2, 0, _co.formControl.errors.min.min))); _ck(_v, 1, 0, currVal_0); }); }
function View_CoreInputErrorsComponent_4(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 10, "div", [["class", "core-input-error"]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n                "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreInputErrorsComponent_5)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](3, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_3__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n                "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreInputErrorsComponent_6)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](6, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_3__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n                "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreInputErrorsComponent_7)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](9, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_3__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.errorMessages[_v.parent.context.$implicit]; _ck(_v, 3, 0, currVal_0); var currVal_1 = ((!_co.errorMessages[_v.parent.context.$implicit] && (_v.parent.context.$implicit == "max")) && _co.formControl.errors.max); _ck(_v, 6, 0, currVal_1); var currVal_2 = ((!_co.errorMessages[_v.parent.context.$implicit] && (_v.parent.context.$implicit == "min")) && _co.formControl.errors.min); _ck(_v, 9, 0, currVal_2); }, null); }
function View_CoreInputErrorsComponent_3(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 4, null, null, null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreInputErrorsComponent_4)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](3, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_3__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.formControl.hasError(_v.context.$implicit); _ck(_v, 3, 0, currVal_0); }, null); }
function View_CoreInputErrorsComponent_2(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 4, null, null, null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreInputErrorsComponent_3)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](3, 802816, null, 0, __WEBPACK_IMPORTED_MODULE_3__angular_common__["j" /* NgForOf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["E" /* IterableDiffers */]], { ngForOf: [0, "ngForOf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.errorKeys; _ck(_v, 3, 0, currVal_0); }, null); }
function View_CoreInputErrorsComponent_8(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "div", [["aria-live", "assertive"], ["class", "core-input-error"]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](1, null, ["", ""]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.errorText; _ck(_v, 1, 0, currVal_0); }); }
function View_CoreInputErrorsComponent_1(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 7, "div", [["class", "core-input-error-container"], ["role", "alert"]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreInputErrorsComponent_2)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](3, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_3__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreInputErrorsComponent_8)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](6, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_3__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = ((_co.formControl && _co.formControl.dirty) && !_co.formControl.valid); _ck(_v, 3, 0, currVal_0); var currVal_1 = _co.errorText; _ck(_v, 6, 0, currVal_1); }, null); }
function View_CoreInputErrorsComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreInputErrorsComponent_1)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_3__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = (((_co.formControl && _co.formControl.dirty) && !_co.formControl.valid) || _co.errorText); _ck(_v, 1, 0, currVal_0); }, null); }
function View_CoreInputErrorsComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-input-errors", [], null, null, null, View_CoreInputErrorsComponent_0, RenderType_CoreInputErrorsComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 638976, null, 0, __WEBPACK_IMPORTED_MODULE_4__input_errors__["a" /* CoreInputErrorsComponent */], [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core_src_translate_service__["a" /* TranslateService */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }
var CoreInputErrorsComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-input-errors", __WEBPACK_IMPORTED_MODULE_4__input_errors__["a" /* CoreInputErrorsComponent */], View_CoreInputErrorsComponent_Host_0, { formControl: "control", errorMessages: "errorMessages", errorText: "errorText" }, {}, []);

//# sourceMappingURL=input-errors.ngfactory.js.map

/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service to interact with plugins to be shown in user profile. Provides functions to register a plugin
 * and notify an update in the data.
 */
var CoreUserDelegate = /** @class */ (function (_super) {
    __extends(CoreUserDelegate, _super);
    function CoreUserDelegate(loggerProvider, sitesProvider, coursesProvider, eventsProvider, utils) {
        var _this = _super.call(this, 'CoreUserDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.coursesProvider = coursesProvider;
        _this.eventsProvider = eventsProvider;
        _this.utils = utils;
        _this.featurePrefix = 'CoreUserDelegate_';
        // Hold the handlers and the observable to notify them for each user.
        _this.userHandlers = {};
        eventsProvider.on(CoreUserDelegate_1.UPDATE_HANDLER_EVENT, function (data) {
            if (data && data.handler && _this.userHandlers[data.userId]) {
                var userData = _this.userHandlers[data.userId], handler = userData.handlers.find(function (userHandler) {
                    return userHandler.name == data.handler;
                });
                if (handler) {
                    for (var x in data.data) {
                        handler.data[x] = data.data[x];
                    }
                    userData.observable.next(userData.handlers);
                }
            }
        });
        return _this;
    }
    CoreUserDelegate_1 = CoreUserDelegate;
    /**
     * Check if handlers are loaded.
     *
     * @return {boolean} True if handlers are loaded, false otherwise.
     */
    CoreUserDelegate.prototype.areHandlersLoaded = function (userId) {
        return this.userHandlers[userId] && this.userHandlers[userId].loaded;
    };
    /**
     * Clear current user handlers.
     *
     * @param {number} userId The user to clear.
     */
    CoreUserDelegate.prototype.clearUserHandlers = function (userId) {
        var userData = this.userHandlers[userId];
        if (userData) {
            userData.handlers = [];
            userData.observable.next([]);
            userData.loaded = false;
        }
    };
    /**
     * Get the profile handlers for a user.
     *
     * @param {any} user The user object.
     * @param {number} courseId The course ID.
     * @return {Subject<CoreUserProfileHandlerToDisplay[]>} Resolved with the handlers.
     */
    CoreUserDelegate.prototype.getProfileHandlersFor = function (user, courseId) {
        var _this = this;
        var promise, navOptions, admOptions;
        if (this.coursesProvider.canGetAdminAndNavOptions()) {
            // Get course options.
            promise = this.coursesProvider.getUserCourses(true).then(function (courses) {
                var courseIds = courses.map(function (course) {
                    return course.id;
                });
                return _this.coursesProvider.getCoursesAdminAndNavOptions(courseIds).then(function (options) {
                    // For backwards compatibility we don't modify the courseId.
                    var courseIdForOptions = courseId || _this.sitesProvider.getCurrentSiteHomeId();
                    navOptions = options.navOptions[courseIdForOptions];
                    admOptions = options.admOptions[courseIdForOptions];
                });
            });
        }
        else {
            promise = Promise.resolve();
        }
        // Initialize the user handlers if it isn't initialized already.
        if (!this.userHandlers[user.id]) {
            this.userHandlers[user.id] = {
                loaded: false,
                handlers: [],
                observable: new __WEBPACK_IMPORTED_MODULE_7_rxjs__["BehaviorSubject"]([])
            };
        }
        var userData = this.userHandlers[user.id];
        userData.handlers = [];
        promise.then(function () {
            var promises = [];
            var _loop_1 = function (name_1) {
                // Checks if the handler is enabled for the user.
                var handler = _this.handlers[name_1], isEnabledForUser = handler.isEnabledForUser(user, courseId, navOptions, admOptions);
                promises.push(Promise.resolve(isEnabledForUser).then(function (enabled) {
                    if (enabled) {
                        userData.handlers.push({
                            name: name_1,
                            data: handler.getDisplayData(user, courseId),
                            priority: handler.priority,
                            type: handler.type || CoreUserDelegate_1.TYPE_NEW_PAGE
                        });
                    }
                }).catch(function () {
                    // Nothing to do here, it is not enabled for this user.
                }));
            };
            for (var name_1 in _this.enabledHandlers) {
                _loop_1(name_1);
            }
            return _this.utils.allPromises(promises).then(function () {
                // Sort them by priority.
                userData.handlers.sort(function (a, b) {
                    return b.priority - a.priority;
                });
                userData.loaded = true;
                userData.observable.next(userData.handlers);
            });
        }).catch(function () {
            // Never fails.
            userData.loaded = true;
            userData.observable.next(userData.handlers);
        });
        return userData.observable;
    };
    /**
     * User profile handler type for communication.
     * @type {string}
     */
    CoreUserDelegate.TYPE_COMMUNICATION = 'communication';
    /**
     * User profile handler type for new page.
     * @type {string}
     */
    CoreUserDelegate.TYPE_NEW_PAGE = 'newpage';
    /**
     * User profile handler type for actions.
     * @type {string}
     */
    CoreUserDelegate.TYPE_ACTION = 'action';
    /**
     * Update handler information event.
     * @type {string}
     */
    CoreUserDelegate.UPDATE_HANDLER_EVENT = 'CoreUserDelegate_update_handler_event';
    CoreUserDelegate = CoreUserDelegate_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreUserDelegate);
    return CoreUserDelegate;
    var CoreUserDelegate_1;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=user-delegate.js.map

/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleDescriptionComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Component to display the description of a module.
 *
 * This directive is meant to display a module description in a similar way throughout all the app.
 *
 * You can add a note at the right side of the description by using the 'note' attribute.
 *
 * You can also pass a component and componentId to be used in format-text.
 *
 * Module descriptions are shortened by default, allowing the user to see the full description by clicking in it.
 * If you want the whole description to be shown you can use the 'showFull' attribute.
 *
 * Example usage:
 *
 * <core-course-module-description [description]="myDescription"></core-course-module-description
 */
var CoreCourseModuleDescriptionComponent = /** @class */ (function () {
    function CoreCourseModuleDescriptionComponent() {
        // Nothing to do.
    }
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCourseModuleDescriptionComponent.prototype, "description", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCourseModuleDescriptionComponent.prototype, "note", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCourseModuleDescriptionComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseModuleDescriptionComponent.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseModuleDescriptionComponent.prototype, "showFull", void 0);
    CoreCourseModuleDescriptionComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-module-description',
            templateUrl: 'core-course-module-description.html'
        }),
        __metadata("design:paramtypes", [])
    ], CoreCourseModuleDescriptionComponent);
    return CoreCourseModuleDescriptionComponent;
}());

//# sourceMappingURL=module-description.js.map

/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCronDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_constants__ = __webpack_require__(39);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/*
 * Service to handle cron processes. The registered processes will be executed every certain time.
*/
var CoreCronDelegate = /** @class */ (function () {
    function CoreCronDelegate(logger, appProvider, configProvider, utils, network, zone) {
        var _this = this;
        this.appProvider = appProvider;
        this.configProvider = configProvider;
        this.utils = utils;
        // Variables for database.
        this.CRON_TABLE = 'cron';
        this.tableSchema = {
            name: this.CRON_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'TEXT',
                    primaryKey: true
                },
                {
                    name: 'value',
                    type: 'INTEGER'
                }
            ]
        };
        this.handlers = {};
        this.queuePromise = Promise.resolve();
        this.logger = logger.getInstance('CoreCronDelegate');
        this.appDB = this.appProvider.getDB();
        this.appDB.createTableFromSchema(this.tableSchema);
        // When the app is re-connected, start network handlers that were stopped.
        network.onConnect().subscribe(function () {
            // Execute the callback in the Angular zone, so change detection doesn't stop working.
            zone.run(function () {
                _this.startNetworkHandlers();
            });
        });
    }
    CoreCronDelegate_1 = CoreCronDelegate;
    /**
     * Try to execute a handler. It will schedule the next execution once done.
     * If the handler cannot be executed or it fails, it will be re-executed after mmCoreCronMinInterval.
     *
     * @param {string} name Name of the handler.
     * @param {boolean} [force] Wether the execution is forced (manual sync).
     * @param {string}  [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved if handler is executed successfully, rejected otherwise.
     */
    CoreCronDelegate.prototype.checkAndExecuteHandler = function (name, force, siteId) {
        var _this = this;
        if (!this.handlers[name] || !this.handlers[name].execute) {
            // Invalid handler.
            this.logger.debug('Cannot execute handler because is invalid: ' + name);
            return Promise.reject(null);
        }
        var usesNetwork = this.handlerUsesNetwork(name), isSync = !force && this.isHandlerSync(name);
        var promise;
        if (usesNetwork && !this.appProvider.isOnline()) {
            // Offline, stop executing.
            this.logger.debug('Cannot execute handler because device is offline: ' + name);
            this.stopHandler(name);
            return Promise.reject(null);
        }
        if (isSync) {
            // Check network connection.
            promise = this.configProvider.get(__WEBPACK_IMPORTED_MODULE_6__core_constants__["a" /* CoreConstants */].SETTINGS_SYNC_ONLY_ON_WIFI, false).then(function (syncOnlyOnWifi) {
                return !syncOnlyOnWifi || _this.appProvider.isWifi();
            });
        }
        else {
            promise = Promise.resolve(true);
        }
        return promise.then(function (execute) {
            if (!execute) {
                // Cannot execute in this network connection, retry soon.
                _this.logger.debug('Cannot execute handler because device is using limited connection: ' + name);
                _this.scheduleNextExecution(name, CoreCronDelegate_1.MIN_INTERVAL);
                return Promise.reject(null);
            }
            // Add the execution to the queue.
            _this.queuePromise = _this.queuePromise.catch(function () {
                // Ignore errors in previous handlers.
            }).then(function () {
                return _this.executeHandler(name, force, siteId).then(function () {
                    _this.logger.debug("Execution of handler '" + name + "' was a success.");
                    return _this.setHandlerLastExecutionTime(name, Date.now()).then(function () {
                        _this.scheduleNextExecution(name);
                    });
                }, function (error) {
                    // Handler call failed. Retry soon.
                    _this.logger.error("Execution of handler '" + name + "' failed.", error);
                    _this.scheduleNextExecution(name, CoreCronDelegate_1.MIN_INTERVAL);
                    return Promise.reject(null);
                });
            });
            return _this.queuePromise;
        });
    };
    /**
     * Run a handler, cancelling the execution if it takes more than MAX_TIME_PROCESS.
     *
     * @param {string} name Name of the handler.
     * @param {boolean} [force] Wether the execution is forced (manual sync).
     * @param {string} [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved when the handler finishes or reaches max time, rejected if it fails.
     */
    CoreCronDelegate.prototype.executeHandler = function (name, force, siteId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cancelTimeout;
            _this.logger.debug('Executing handler: ' + name);
            // Wrap the call in Promise.resolve to make sure it's a promise.
            Promise.resolve(_this.handlers[name].execute(siteId, force)).then(resolve).catch(reject).finally(function () {
                clearTimeout(cancelTimeout);
            });
            cancelTimeout = setTimeout(function () {
                // The handler took too long. Resolve because we don't want to retry soon.
                _this.logger.debug("Resolving execution of handler '" + name + "' because it took too long.");
                resolve();
            }, CoreCronDelegate_1.MAX_TIME_PROCESS);
        });
    };
    /**
     * Force execution of synchronization cron tasks without waiting for the scheduled time.
     * Please notice that some tasks may not be executed depending on the network connection and sync settings.
     *
     * @param {string} [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved if all handlers are executed successfully, rejected otherwise.
     */
    CoreCronDelegate.prototype.forceSyncExecution = function (siteId) {
        var promises = [];
        for (var name_1 in this.handlers) {
            if (this.isHandlerManualSync(name_1)) {
                // Now force the execution of the handler.
                promises.push(this.forceCronHandlerExecution(name_1, siteId));
            }
        }
        return this.utils.allPromises(promises);
    };
    /**
     * Force execution of a cron tasks without waiting for the scheduled time.
     * Please notice that some tasks may not be executed depending on the network connection and sync settings.
     *
     * @param {string} [name]  If provided, the name of the handler.
     * @param {string} [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved if handler has been executed successfully, rejected otherwise.
     */
    CoreCronDelegate.prototype.forceCronHandlerExecution = function (name, siteId) {
        var handler = this.handlers[name];
        // Mark the handler as running (it might be running already).
        handler.running = true;
        // Cancel pending timeout.
        clearTimeout(handler.timeout);
        delete handler.timeout;
        // Now force the execution of the handler.
        return this.checkAndExecuteHandler(name, true, siteId);
    };
    /**
     * Get a handler's interval.
     *
     * @param {string} name Handler's name.
     * @return {number} Handler's interval.
     */
    CoreCronDelegate.prototype.getHandlerInterval = function (name) {
        if (!this.handlers[name] || !this.handlers[name].getInterval) {
            // Invalid, return default.
            return CoreCronDelegate_1.DEFAULT_INTERVAL;
        }
        // Don't allow intervals lower than the minimum.
        var minInterval = this.appProvider.isDesktop() ? CoreCronDelegate_1.DESKTOP_MIN_INTERVAL : CoreCronDelegate_1.MIN_INTERVAL, handlerInterval = this.handlers[name].getInterval();
        if (!handlerInterval) {
            return CoreCronDelegate_1.DEFAULT_INTERVAL;
        }
        else {
            return Math.max(minInterval, handlerInterval);
        }
    };
    /**
     * Get a handler's last execution ID.
     *
     * @param {string} name Handler's name.
     * @return {string} Handler's last execution ID.
     */
    CoreCronDelegate.prototype.getHandlerLastExecutionId = function (name) {
        return 'last_execution_' + name;
    };
    /**
     * Get a handler's last execution time. If not defined, return 0.
     *
     * @param {string} name Handler's name.
     * @return {Promise<number>} Promise resolved with the handler's last execution time.
     */
    CoreCronDelegate.prototype.getHandlerLastExecutionTime = function (name) {
        var id = this.getHandlerLastExecutionId(name);
        return this.appDB.getRecord(this.CRON_TABLE, { id: id }).then(function (entry) {
            var time = parseInt(entry.value, 10);
            return isNaN(time) ? 0 : time;
        }).catch(function () {
            return 0; // Not set, return 0.
        });
    };
    /**
     * Check if a handler uses network. Defaults to true.
     *
     * @param {string} name Handler's name.
     * @return {boolean} True if handler uses network or not defined, false otherwise.
     */
    CoreCronDelegate.prototype.handlerUsesNetwork = function (name) {
        if (!this.handlers[name] || !this.handlers[name].usesNetwork) {
            // Invalid, return default.
            return true;
        }
        return this.handlers[name].usesNetwork();
    };
    /**
     * Check if there is any manual sync handler registered.
     *
     * @return {boolean} Whether it has at least 1 manual sync handler.
     */
    CoreCronDelegate.prototype.hasManualSyncHandlers = function () {
        for (var name_2 in this.handlers) {
            if (this.isHandlerManualSync(name_2)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Check if there is any sync handler registered.
     *
     * @return {boolean} Whether it has at least 1 sync handler.
     */
    CoreCronDelegate.prototype.hasSyncHandlers = function () {
        for (var name_3 in this.handlers) {
            if (this.isHandlerSync(name_3)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Check if a handler can be manually synced. Defaults will use isSync instead.
     *
     * @param {string} name Handler's name.
     * @return {boolean} True if handler is a sync process and can be manually executed or not defined, false otherwise.
     */
    CoreCronDelegate.prototype.isHandlerManualSync = function (name) {
        if (!this.handlers[name] || !this.handlers[name].canManualSync) {
            // Invalid, return default.
            return this.isHandlerSync(name);
        }
        return this.handlers[name].canManualSync();
    };
    /**
     * Check if a handler is a sync process. Defaults to true.
     *
     * @param {string} name Handler's name.
     * @return {boolean} True if handler is a sync process or not defined, false otherwise.
     */
    CoreCronDelegate.prototype.isHandlerSync = function (name) {
        if (!this.handlers[name] || !this.handlers[name].isSync) {
            // Invalid, return default.
            return true;
        }
        return this.handlers[name].isSync();
    };
    /**
     * Register a handler to be executed every certain time.
     *
     * @param {CoreCronHandler} handler The handler to register.
     */
    CoreCronDelegate.prototype.register = function (handler) {
        if (!handler || !handler.name) {
            // Invalid handler.
            return;
        }
        if (typeof this.handlers[handler.name] != 'undefined') {
            this.logger.debug("The cron handler '" + handler.name + "' is already registered.");
            return;
        }
        this.logger.debug("Register handler '" + handler.name + "' in cron.");
        handler.running = false;
        this.handlers[handler.name] = handler;
        // Start the handler.
        this.startHandler(handler.name);
    };
    /**
     * Schedule a next execution for a handler.
     *
     * @param {string} name Name of the handler.
     * @param {number} [time] Time to the next execution. If not supplied it will be calculated using the last execution and
     *                        the handler's interval. This param should be used only if it's really necessary.
     */
    CoreCronDelegate.prototype.scheduleNextExecution = function (name, time) {
        var _this = this;
        if (!this.handlers[name]) {
            // Invalid handler.
            return;
        }
        if (this.handlers[name].timeout) {
            // There's already a pending timeout.
            return;
        }
        var promise;
        if (time) {
            promise = Promise.resolve(time);
        }
        else {
            // Get last execution time to check when do we need to execute it.
            promise = this.getHandlerLastExecutionTime(name).then(function (lastExecution) {
                var interval = _this.getHandlerInterval(name), nextExecution = lastExecution + interval;
                return nextExecution - Date.now();
            });
        }
        promise.then(function (nextExecution) {
            _this.logger.debug("Scheduling next execution of handler '" + name + "' in '" + nextExecution + "' ms");
            if (nextExecution < 0) {
                nextExecution = 0; // Big negative numbers aren't executed immediately.
            }
            _this.handlers[name].timeout = setTimeout(function () {
                delete _this.handlers[name].timeout;
                _this.checkAndExecuteHandler(name).catch(function () {
                    // Ignore errors.
                });
            }, nextExecution);
        });
    };
    /**
     * Set a handler's last execution time.
     *
     * @param {string} name Handler's name.
     * @param {number} time Time to set.
     * @return {Promise}    Promise resolved when the execution time is saved.
     */
    CoreCronDelegate.prototype.setHandlerLastExecutionTime = function (name, time) {
        var id = this.getHandlerLastExecutionId(name), entry = {
            id: id,
            value: time
        };
        return this.appDB.insertRecord(this.CRON_TABLE, entry);
    };
    /**
     * Start running a handler periodically.
     *
     * @param {string} name Name of the handler.
     */
    CoreCronDelegate.prototype.startHandler = function (name) {
        if (!this.handlers[name]) {
            // Invalid handler.
            this.logger.debug("Cannot start handler '" + name + "', is invalid.");
            return;
        }
        if (this.handlers[name].running) {
            this.logger.debug("Handler '" + name + "', is already running.");
            return;
        }
        this.handlers[name].running = true;
        this.scheduleNextExecution(name);
    };
    /**
     * Start running periodically the handlers that use network.
     */
    CoreCronDelegate.prototype.startNetworkHandlers = function () {
        for (var name_4 in this.handlers) {
            if (this.handlerUsesNetwork(name_4)) {
                this.startHandler(name_4);
            }
        }
    };
    /**
     * Stop running a handler periodically.
     *
     * @param {string} name Name of the handler.
     */
    CoreCronDelegate.prototype.stopHandler = function (name) {
        if (!this.handlers[name]) {
            // Invalid handler.
            this.logger.debug("Cannot stop handler '" + name + "', is invalid.");
            return;
        }
        if (!this.handlers[name].running) {
            this.logger.debug("Cannot stop handler '" + name + "', it's not running.");
            return;
        }
        this.handlers[name].running = false;
        clearTimeout(this.handlers[name].timeout);
        delete this.handlers[name].timeout;
    };
    // Constants.
    CoreCronDelegate.DEFAULT_INTERVAL = 3600000; // Default interval is 1 hour.
    CoreCronDelegate.MIN_INTERVAL = 300000; // Minimum interval is 5 minutes.
    CoreCronDelegate.DESKTOP_MIN_INTERVAL = 60000; // Minimum interval in desktop is 1 minute.
    CoreCronDelegate.MAX_TIME_PROCESS = 120000; // Max time a process can block the queue. Defaults to 2 minutes.
    CoreCronDelegate = CoreCronDelegate_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__config__["a" /* CoreConfigProvider */],
            __WEBPACK_IMPORTED_MODULE_5__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__["a" /* Network */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["M" /* NgZone */]])
    ], CoreCronDelegate);
    return CoreCronDelegate;
    var CoreCronDelegate_1;
}());

//# sourceMappingURL=cron.js.map

/***/ }),
/* 97 */,
/* 98 */,
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreIconComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Core Icon is a component that enabled a posibility to add fontawesome icon to the html. It's recommended if both fontawesome
 * or ionicons can be used in the name attribute. To use fontawesome just place the full icon name with the fa- prefix and
 * the component will detect it.
 * Check available icons https://fontawesome.com/v4.7.0/icons/.
 */
var CoreIconComponent = /** @class */ (function () {
    function CoreIconComponent(el, config) {
        this.config = config;
        this.element = el.nativeElement;
    }
    /**
     * Detect changes on input properties.
     */
    CoreIconComponent.prototype.ngOnChanges = function (changes) {
        if (!changes.name || !this.name) {
            return;
        }
        var oldElement = this.newElement ? this.newElement : this.element;
        // Use a new created element to avoid ion-icon working.
        // This is necessary to make the FontAwesome stuff work.
        // It is also required to stop Ionic overriding the aria-label attribute.
        this.newElement = document.createElement('ion-icon');
        if (this.name.startsWith('fa-')) {
            this.newElement.classList.add('icon');
            this.newElement.classList.add('fa');
            this.newElement.classList.add(this.name);
            if (this.isTrueProperty(this.fixedWidth)) {
                this.newElement.classList.add('fa-fw');
            }
            if (this.color) {
                this.newElement.classList.add('fa-' + this.color);
            }
        }
        else {
            var mode = this.config.get('iconMode');
            this.newElement.classList.add('icon');
            this.newElement.classList.add('icon-' + mode);
            this.newElement.classList.add('ion-' + mode + '-' + this.name);
        }
        !this.ariaLabel && this.newElement.setAttribute('aria-hidden', 'true');
        !this.ariaLabel && this.newElement.setAttribute('role', 'presentation');
        this.ariaLabel && this.newElement.setAttribute('aria-label', this.ariaLabel);
        var attrs = this.element.attributes;
        for (var i = attrs.length - 1; i >= 0; i--) {
            if (attrs[i].name == 'class') {
                // We don't want to override the classes we already added. Add them one by one.
                if (attrs[i].value) {
                    var classes = attrs[i].value.split(' ');
                    for (var j = 0; j < classes.length; j++) {
                        if (classes[j]) {
                            this.newElement.classList.add(classes[j]);
                        }
                    }
                }
            }
            else {
                this.newElement.setAttribute(attrs[i].name, attrs[i].value);
            }
        }
        if (this.slash) {
            this.newElement.classList.add('icon-slash');
        }
        oldElement.parentElement.replaceChild(this.newElement, oldElement);
    };
    /**
     * Check if the value is true or on.
     *
     * @param  {any}     val value to be checked.
     * @return {boolean}     If has a value equivalent to true.
     */
    CoreIconComponent.prototype.isTrueProperty = function (val) {
        if (typeof val === 'string') {
            val = val.toLowerCase().trim();
            return (val === 'true' || val === 'on' || val === '');
        }
        return !!val;
    };
    /**
     * Component destroyed.
     */
    CoreIconComponent.prototype.ngOnDestroy = function () {
        if (this.newElement) {
            this.newElement.remove();
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIconComponent.prototype, "name", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('color'),
        __metadata("design:type", String)
    ], CoreIconComponent.prototype, "color", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('slash'),
        __metadata("design:type", Boolean)
    ], CoreIconComponent.prototype, "slash", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('isActive'),
        __metadata("design:type", Boolean)
    ], CoreIconComponent.prototype, "isActive", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('md'),
        __metadata("design:type", String)
    ], CoreIconComponent.prototype, "md", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('ios'),
        __metadata("design:type", String)
    ], CoreIconComponent.prototype, "ios", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('fixed-width'),
        __metadata("design:type", String)
    ], CoreIconComponent.prototype, "fixedWidth", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('label'),
        __metadata("design:type", String)
    ], CoreIconComponent.prototype, "ariaLabel", void 0);
    CoreIconComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-icon',
            templateUrl: 'core-icon.html',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Config */]])
    ], CoreIconComponent);
    return CoreIconComponent;
}());

//# sourceMappingURL=icon.js.map

/***/ }),
/* 100 */,
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModDataProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__offline__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__fields_delegate__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Service that provides some features for databases.
 */
var AddonModDataProvider = /** @class */ (function () {
    function AddonModDataProvider(logger, sitesProvider, utils, filepoolProvider, dataOffline, appProvider, fieldsDelegate, logHelper) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.filepoolProvider = filepoolProvider;
        this.dataOffline = dataOffline;
        this.appProvider = appProvider;
        this.fieldsDelegate = fieldsDelegate;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = AddonModDataProvider_1.COMPONENT + ':';
        this.logger = logger.getInstance('AddonModDataProvider');
    }
    AddonModDataProvider_1 = AddonModDataProvider;
    /**
     * Adds a new entry to a database.
     *
     * @param   {number}  dataId          Data instance ID.
     * @param   {number}  entryId         EntryId or provisional entry ID when offline.
     * @param   {number}  courseId        Course ID.
     * @param   {any}     contents        The fields data to be created.
     * @param   {number}  [groupId]       Group id, 0 means that the function will determine the user group.
     * @param   {any[]}   fields          The fields that define the contents.
     * @param   {string}  [siteId]        Site ID. If not defined, current site.
     * @param   {boolean} [forceOffline]  Force editing entry in offline.
     * @return  {Promise<any>}            Promise resolved when the action is done.
     */
    AddonModDataProvider.prototype.addEntry = function (dataId, entryId, courseId, contents, groupId, fields, siteId, forceOffline) {
        var _this = this;
        if (groupId === void 0) { groupId = 0; }
        if (forceOffline === void 0) { forceOffline = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a data to be synchronized later.
        var storeOffline = function () {
            return _this.dataOffline.saveEntry(dataId, entryId, 'add', courseId, groupId, contents, undefined, siteId)
                .then(function (entry) {
                return {
                    // Return provissional entry Id.
                    newentryid: entry
                };
            });
        };
        if (!this.appProvider.isOnline() || forceOffline) {
            var notifications = this.checkFields(fields, contents);
            if (notifications) {
                return Promise.resolve({
                    fieldnotifications: notifications
                });
            }
            return storeOffline();
        }
        return this.addEntryOnline(dataId, contents, groupId, siteId).catch(function (error) {
            if (_this.utils.isWebServiceError(error)) {
                // The WebService has thrown an error, this means that responses cannot be submitted.
                return Promise.reject(error);
            }
            // Couldn't connect to server, store in offline.
            return storeOffline();
        });
    };
    /**
     * Adds a new entry to a database. It does not cache calls. It will fail if offline or cannot connect.
     *
     * @param   {number} dataId     Database ID.
     * @param   {any[]}  data       The fields data to be created.
     * @param   {number} [groupId]  Group id, 0 means that the function will determine the user group.
     * @param   {string} [siteId]   Site ID. If not defined, current site.
     * @return  {Promise<any>}      Promise resolved when the action is done.
     */
    AddonModDataProvider.prototype.addEntryOnline = function (dataId, data, groupId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                databaseid: dataId,
                data: data
            };
            if (typeof groupId !== 'undefined') {
                params['groupid'] = groupId;
            }
            return site.write('mod_data_add_entry', params);
        });
    };
    /**
     * Approves or unapproves an entry.
     *
     * @param   {number}    dataId      Database ID.
     * @param   {number}    entryId     Entry ID.
     * @param   {boolean}   approve     Whether to approve (true) or unapprove the entry.
     * @param   {number}    courseId    Course ID.
     * @param   {string}    [siteId]    Site ID. If not defined, current site.
     * @return  {Promise<any>}          Promise resolved when the action is done.
     */
    AddonModDataProvider.prototype.approveEntry = function (dataId, entryId, approve, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a data to be synchronized later.
        var storeOffline = function () {
            var action = approve ? 'approve' : 'disapprove';
            return _this.dataOffline.saveEntry(dataId, entryId, action, courseId, undefined, undefined, undefined, siteId);
        };
        // Get if the opposite action is not synced.
        var oppositeAction = approve ? 'disapprove' : 'approve';
        return this.dataOffline.getEntry(dataId, entryId, oppositeAction, siteId).then(function () {
            // Found. Just delete the action.
            return _this.dataOffline.deleteEntry(dataId, entryId, oppositeAction, siteId);
        }).catch(function () {
            if (!_this.appProvider.isOnline()) {
                // App is offline, store the action.
                return storeOffline();
            }
            return _this.approveEntryOnline(entryId, approve, siteId).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means that responses cannot be submitted.
                    return Promise.reject(error);
                }
                // Couldn't connect to server, store in offline.
                return storeOffline();
            });
        });
    };
    /**
     * Approves or unapproves an entry. It does not cache calls. It will fail if offline or cannot connect.
     *
     * @param   {number}    entryId  Entry ID.
     * @param   {boolean}   approve  Whether to approve (true) or unapprove the entry.
     * @param   {string}    [siteId] Site ID. If not defined, current site.
     * @return  {Promise<any>}       Promise resolved when the action is done.
     */
    AddonModDataProvider.prototype.approveEntryOnline = function (entryId, approve, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                entryid: entryId,
                approve: approve ? 1 : 0
            };
            return site.write('mod_data_approve_entry', params);
        });
    };
    /**
     * Convenience function to check fields requeriments here named "notifications".
     *
     * @param   {any}    fields    The fields that define the contents.
     * @param   {any}    contents  The contents data of the fields.
     * @return  {any}            Array of notifications if any or false.
     */
    AddonModDataProvider.prototype.checkFields = function (fields, contents) {
        var _this = this;
        var notifications = [], contentsIndexed = {};
        contents.forEach(function (content) {
            if (typeof contentsIndexed[content.fieldid] == 'undefined') {
                contentsIndexed[content.fieldid] = [];
            }
            contentsIndexed[content.fieldid].push(content);
        });
        // App is offline, check required fields.
        Object.keys(fields).forEach(function (key) {
            var field = fields[key], notification = _this.fieldsDelegate.getFieldsNotifications(field, contentsIndexed[field.id]);
            if (notification) {
                notifications.push({
                    fieldname: field.name,
                    notification: notification
                });
            }
        });
        return notifications.length ? notifications : false;
    };
    /**
     * Deletes an entry.
     *
     * @param   {number}    dataId     Database ID.
     * @param   {number}    entryId    Entry ID.
     * @param   {number}    courseId   Course ID.
     * @param   {string}    [siteId]   Site ID. If not defined, current site.
     * @return  {Promise<any>}         Promise resolved when the action is done.
     */
    AddonModDataProvider.prototype.deleteEntry = function (dataId, entryId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a data to be synchronized later.
        var storeOffline = function () {
            return _this.dataOffline.saveEntry(dataId, entryId, 'delete', courseId, undefined, undefined, undefined, siteId);
        };
        var justAdded = false;
        // Check if the opposite action is not synced and just delete it.
        return this.dataOffline.getEntryActions(dataId, entryId, siteId).then(function (entries) {
            if (entries && entries.length) {
                // Found. Delete other actions first.
                var proms = entries.map(function (entry) {
                    if (entry.action == 'add') {
                        justAdded = true;
                    }
                    return _this.dataOffline.deleteEntry(dataId, entryId, entry.action, siteId);
                });
                return Promise.all(proms);
            }
        }).then(function () {
            if (justAdded) {
                // The field was added offline, delete and stop.
                return;
            }
            if (!_this.appProvider.isOnline()) {
                // App is offline, store the action.
                return storeOffline();
            }
            return _this.deleteEntryOnline(entryId, siteId).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means that responses cannot be submitted.
                    return Promise.reject(error);
                }
                // Couldn't connect to server, store in offline.
                return storeOffline();
            });
        });
    };
    /**
     * Deletes an entry. It does not cache calls. It will fail if offline or cannot connect.
     *
     * @param   {number}  entryId  Entry ID.
     * @param   {string}  [siteId] Site ID. If not defined, current site.
     * @return  {Promise<any>}     Promise resolved when the action is done.
     */
    AddonModDataProvider.prototype.deleteEntryOnline = function (entryId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                entryid: entryId
            };
            return site.write('mod_data_delete_entry', params);
        });
    };
    /**
     * Updates an existing entry.
     *
     * @param   {number}  dataId          Database ID.
     * @param   {number}  entryId         Entry ID.
     * @param   {number}  courseId        Course ID.
     * @param   {any[]}   contents        The contents data to be updated.
     * @param   {any}     fields          The fields that define the contents.
     * @param   {string}  [siteId]        Site ID. If not defined, current site.
     * @param   {boolean} forceOffline    Force editing entry in offline.
     * @return  {Promise<any>}            Promise resolved when the action is done.
     */
    AddonModDataProvider.prototype.editEntry = function (dataId, entryId, courseId, contents, fields, siteId, forceOffline) {
        var _this = this;
        if (forceOffline === void 0) { forceOffline = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a data to be synchronized later.
        var storeOffline = function () {
            return _this.dataOffline.saveEntry(dataId, entryId, 'edit', courseId, undefined, contents, undefined, siteId)
                .then(function () {
                return {
                    updated: true
                };
            });
        };
        var justAdded = false, groupId;
        if (!this.appProvider.isOnline() || forceOffline) {
            var notifications = this.checkFields(fields, contents);
            if (notifications) {
                return Promise.resolve({
                    fieldnotifications: notifications
                });
            }
        }
        // Get other not not synced actions.
        return this.dataOffline.getEntryActions(dataId, entryId, siteId).then(function (entries) {
            if (entries && entries.length) {
                // Found. Delete add and edit actions first.
                var proms_1 = [];
                entries.forEach(function (entry) {
                    if (entry.action == 'add') {
                        justAdded = true;
                        groupId = entry.groupid;
                        proms_1.push(_this.dataOffline.deleteEntry(dataId, entryId, entry.action, siteId));
                    }
                    else if (entry.action == 'edit') {
                        proms_1.push(_this.dataOffline.deleteEntry(dataId, entryId, entry.action, siteId));
                    }
                });
                return Promise.all(proms_1);
            }
        }).then(function () {
            if (justAdded) {
                // The field was added offline, add again and stop.
                return _this.addEntry(dataId, entryId, courseId, contents, groupId, fields, siteId, forceOffline)
                    .then(function (result) {
                    result.updated = true;
                    return result;
                });
            }
            if (!_this.appProvider.isOnline() || forceOffline) {
                // App is offline, store the action.
                return storeOffline();
            }
            return _this.editEntryOnline(entryId, contents, siteId).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means that responses cannot be submitted.
                    return Promise.reject(error);
                }
                // Couldn't connect to server, store in offline.
                return storeOffline();
            });
        });
    };
    /**
     * Updates an existing entry. It does not cache calls. It will fail if offline or cannot connect.
     *
     * @param   {number}  entryId  Entry ID.
     * @param   {any[]}   data     The fields data to be updated.
     * @param   {string}  [siteId] Site ID. If not defined, current site.
     * @return  {Promise<any>}     Promise resolved when the action is done.
     */
    AddonModDataProvider.prototype.editEntryOnline = function (entryId, data, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                entryid: entryId,
                data: data
            };
            return site.write('mod_data_update_entry', params);
        });
    };
    /**
     * Performs the whole fetch of the entries in the database.
     *
     * @param  {number}    dataId          Data ID.
     * @param  {number}    [groupId]       Group ID.
     * @param  {string}    [sort]          Sort the records by this field id. See AddonModDataProvider#getEntries for more info.
     * @param  {string}    [order]         The direction of the sorting.  See AddonModDataProvider#getEntries for more info.
     * @param  {number}    [perPage]       Records per page to fetch. It has to match with the prefetch.
     *                                     Default on AddonModDataProvider.PER_PAGE.
     * @param  {boolean}   [forceCache]    True to always get the value from cache, false otherwise. Default false.
     * @param  {boolean}   [ignoreCache]   True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}    [siteId]        Site ID. If not defined, current site.
     * @return {Promise<AddonModDataEntry[]>} Promise resolved when done.
     */
    AddonModDataProvider.prototype.fetchAllEntries = function (dataId, groupId, sort, order, perPage, forceCache, ignoreCache, siteId) {
        if (groupId === void 0) { groupId = 0; }
        if (sort === void 0) { sort = '0'; }
        if (order === void 0) { order = 'DESC'; }
        if (perPage === void 0) { perPage = AddonModDataProvider_1.PER_PAGE; }
        if (forceCache === void 0) { forceCache = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.fetchEntriesRecursive(dataId, groupId, sort, order, perPage, forceCache, ignoreCache, [], 0, siteId);
    };
    /**
     * Recursive call on fetch all entries.
     *
     * @param  {number}    dataId          Data ID.
     * @param  {number}    groupId         Group ID.
     * @param  {string}    sort            Sort the records by this field id. See AddonModDataProvider#getEntries for more info.
     * @param  {string}    order           The direction of the sorting.  See AddonModDataProvider#getEntries for more info.
     * @param  {number}    perPage         Records per page to fetch. It has to match with the prefetch.
     * @param  {boolean}   forceCache      True to always get the value from cache, false otherwise. Default false.
     * @param  {boolean}   ignoreCache     True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {any}       entries         Entries already fetch (just to concatenate them).
     * @param  {number}    page            Page of records to return.
     * @param  {string}    siteId          Site ID.
     * @return {Promise<AddonModDataEntry[]>} Promise resolved when done.
     */
    AddonModDataProvider.prototype.fetchEntriesRecursive = function (dataId, groupId, sort, order, perPage, forceCache, ignoreCache, entries, page, siteId) {
        var _this = this;
        return this.getEntries(dataId, groupId, sort, order, page, perPage, forceCache, ignoreCache, siteId)
            .then(function (result) {
            entries = entries.concat(result.entries);
            var canLoadMore = perPage > 0 && ((page + 1) * perPage) < result.totalcount;
            if (canLoadMore) {
                return _this.fetchEntriesRecursive(dataId, groupId, sort, order, perPage, forceCache, ignoreCache, entries, page + 1, siteId);
            }
            return entries;
        });
    };
    /**
     * Get cache key for data data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModDataProvider.prototype.getDatabaseDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'data:' + courseId;
    };
    /**
     * Get prefix cache key for all database activity data WS calls.
     *
     * @param {number} dataId   Data ID.
     * @return {string}         Cache key.
     */
    AddonModDataProvider.prototype.getDatabaseDataPrefixCacheKey = function (dataId) {
        return this.ROOT_CACHE_KEY + dataId;
    };
    /**
     * Get a database data. If more than one is found, only the first will be returned.
     *
     * @param {number}   courseId           Course ID.
     * @param {string}   key                Name of the property to check.
     * @param {any}      value              Value to search.
     * @param {string}   [siteId]           Site ID. If not defined, current site.
     * @param {boolean}  [forceCache=false] True to always get the value from cache, false otherwise. Default false.
     * @return {Promise<any>}  Promise resolved when the data is retrieved.
     */
    AddonModDataProvider.prototype.getDatabaseByKey = function (courseId, key, value, siteId, forceCache) {
        var _this = this;
        if (forceCache === void 0) { forceCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getDatabaseDataCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (forceCache) {
                preSets['omitExpires'] = true;
            }
            return site.read('mod_data_get_databases_by_courses', params, preSets).then(function (response) {
                if (response && response.databases) {
                    var currentData = response.databases.find(function (data) { return data[key] == value; });
                    if (currentData) {
                        return currentData;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a data by course module ID.
     *
     * @param {number}   courseId           Course ID.
     * @param {number}   cmId               Course module ID.
     * @param {string}   [siteId]           Site ID. If not defined, current site.
     * @param {boolean}  [forceCache=false] True to always get the value from cache, false otherwise. Default false.
     * @return {Promise<any>} Promise resolved when the data is retrieved.
     */
    AddonModDataProvider.prototype.getDatabase = function (courseId, cmId, siteId, forceCache) {
        if (forceCache === void 0) { forceCache = false; }
        return this.getDatabaseByKey(courseId, 'coursemodule', cmId, siteId, forceCache);
    };
    /**
     * Get a data by ID.
     *
     * @param {number}   courseId           Course ID.
     * @param {number}   id                 Data ID.
     * @param {string}   [siteId]           Site ID. If not defined, current site.
     * @param {boolean}  [forceCache=false] True to always get the value from cache, false otherwise. Default false.
     * @return {Promise<any>}         Promise resolved when the data is retrieved.
     */
    AddonModDataProvider.prototype.getDatabaseById = function (courseId, id, siteId, forceCache) {
        if (forceCache === void 0) { forceCache = false; }
        return this.getDatabaseByKey(courseId, 'id', id, siteId, forceCache);
    };
    /**
     * Get prefix cache key for all database access information data WS calls.
     *
     * @param {number} dataId   Data ID.
     * @return {string}         Cache key.
     */
    AddonModDataProvider.prototype.getDatabaseAccessInformationDataPrefixCacheKey = function (dataId) {
        return this.getDatabaseDataPrefixCacheKey(dataId) + ':access:';
    };
    /**
     * Get cache key for database access information data WS calls.
     *
     * @param {number} dataId       Data ID.
     * @param {number} [groupId=0]  Group ID.
     * @return {string}             Cache key.
     */
    AddonModDataProvider.prototype.getDatabaseAccessInformationDataCacheKey = function (dataId, groupId) {
        if (groupId === void 0) { groupId = 0; }
        return this.getDatabaseAccessInformationDataPrefixCacheKey(dataId) + groupId;
    };
    /**
     * Get  access information for a given database.
     *
     * @param   {number}    dataId              Data ID.
     * @param   {number}    [groupId]           Group ID.
     * @param   {boolean}   [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param   {boolean}   [ignoreCache=false] True if it should ignore cached data (it'll always fail in offline or server down).
     * @param   {string}    [siteId]            Site ID. If not defined, current site.
     * @return  {Promise<any>}                  Promise resolved when the database is retrieved.
     */
    AddonModDataProvider.prototype.getDatabaseAccessInformation = function (dataId, groupId, offline, ignoreCache, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                databaseid: dataId
            }, preSets = {
                cacheKey: _this.getDatabaseAccessInformationDataCacheKey(dataId, groupId)
            };
            if (typeof groupId !== 'undefined') {
                params['groupid'] = groupId;
            }
            if (offline) {
                preSets['omitExpires'] = true;
            }
            else if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return site.read('mod_data_get_data_access_information', params, preSets);
        });
    };
    /**
     * Get entries for a specific database and group.
     *
     * @param   {number}    dataId             Data ID.
     * @param   {number}    [groupId=0]        Group ID.
     * @param   {string}    [sort=0]           Sort the records by this field id, reserved ids are:
     *                                            0: timeadded
     *                                           -1: firstname
     *                                           -2: lastname
     *                                           -3: approved
     *                                           -4: timemodified.
     *                                          Empty for using the default database setting.
     * @param   {string}    [order=DESC]        The direction of the sorting: 'ASC' or 'DESC'.
     *                                          Empty for using the default database setting.
     * @param   {number}    [page=0]            Page of records to return.
     * @param   {number}    [perPage=PER_PAGE]  Records per page to return. Default on PER_PAGE.
     * @param   {boolean}   [forceCache=false]  True to always get the value from cache, false otherwise. Default false.
     * @param   {boolean}   [ignoreCache=false] True if it should ignore cached data (it'll always fail in offline or server down).
     * @param   {string}    [siteId]            Site ID. If not defined, current site.
     * @return  {Promise<AddonModDataEntries>} Promise resolved when the database is retrieved.
     */
    AddonModDataProvider.prototype.getEntries = function (dataId, groupId, sort, order, page, perPage, forceCache, ignoreCache, siteId) {
        var _this = this;
        if (groupId === void 0) { groupId = 0; }
        if (sort === void 0) { sort = '0'; }
        if (order === void 0) { order = 'DESC'; }
        if (page === void 0) { page = 0; }
        if (perPage === void 0) { perPage = AddonModDataProvider_1.PER_PAGE; }
        if (forceCache === void 0) { forceCache = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Always use sort and order params to improve cache usage (entries are identified by params).
            var params = {
                databaseid: dataId,
                returncontents: 1,
                page: page,
                perpage: perPage,
                groupid: groupId,
                sort: sort,
                order: order
            }, preSets = {
                cacheKey: _this.getEntriesCacheKey(dataId, groupId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (forceCache) {
                preSets['omitExpires'] = true;
            }
            else if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return site.read('mod_data_get_entries', params, preSets).then(function (response) {
                response.entries.forEach(function (entry) {
                    entry.contents = _this.utils.arrayToObject(entry.contents, 'fieldid');
                });
                return response;
            });
        });
    };
    /**
     * Get cache key for database entries data WS calls.
     *
     * @param {number} dataId       Data ID.
     * @param {number} [groupId=0]  Group ID.
     * @return {string}             Cache key.
     */
    AddonModDataProvider.prototype.getEntriesCacheKey = function (dataId, groupId) {
        if (groupId === void 0) { groupId = 0; }
        return this.getEntriesPrefixCacheKey(dataId) + groupId;
    };
    /**
     * Get prefix cache key for database all entries data WS calls.
     *
     * @param {number} dataId     Data ID.
     * @return {string}           Cache key.
     */
    AddonModDataProvider.prototype.getEntriesPrefixCacheKey = function (dataId) {
        return this.getDatabaseDataPrefixCacheKey(dataId) + ':entries:';
    };
    /**
     * Get an entry of the database activity.
     *
     * @param   {number}    dataId    Data ID for caching purposes.
     * @param   {number}    entryId   Entry ID.
     * @param   {boolean}   [ignoreCache=false] True if it should ignore cached data (it'll always fail in offline or server down).
     * @param   {string}    [siteId]  Site ID. If not defined, current site.
     * @return {Promise<{entry: AddonModDataEntry, ratinginfo: CoreRatingInfo}>} Promise resolved when the entry is retrieved.
     */
    AddonModDataProvider.prototype.getEntry = function (dataId, entryId, ignoreCache, siteId) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                entryid: entryId,
                returncontents: 1
            }, preSets = {
                cacheKey: _this.getEntryCacheKey(dataId, entryId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return site.read('mod_data_get_entry', params, preSets).then(function (response) {
                response.entry.contents = _this.utils.arrayToObject(response.entry.contents, 'fieldid');
                return response;
            });
        });
    };
    /**
     * Get cache key for database entry data WS calls.
     *
     * @param {number} dataId     Data ID for caching purposes.
     * @param {number} entryId    Entry ID.
     * @return {string}           Cache key.
     */
    AddonModDataProvider.prototype.getEntryCacheKey = function (dataId, entryId) {
        return this.getDatabaseDataPrefixCacheKey(dataId) + ':entry:' + entryId;
    };
    /**
     * Get the list of configured fields for the given database.
     *
     * @param  {number} dataId               Data ID.
     * @param  {boolean} [forceCache=false]  True to always get the value from cache, false otherwise. Default false.
     * @param  {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string} [siteId]             Site ID. If not defined, current site.
     * @return {Promise<any>}                Promise resolved when the fields are retrieved.
     */
    AddonModDataProvider.prototype.getFields = function (dataId, forceCache, ignoreCache, siteId) {
        var _this = this;
        if (forceCache === void 0) { forceCache = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                databaseid: dataId
            }, preSets = {
                cacheKey: _this.getFieldsCacheKey(dataId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (forceCache) {
                preSets['omitExpires'] = true;
            }
            else if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return site.read('mod_data_get_fields', params, preSets).then(function (response) {
                if (response && response.fields) {
                    return response.fields;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for database fields data WS calls.
     *
     * @param {number} dataId     Data ID.
     * @return {string}           Cache key.
     */
    AddonModDataProvider.prototype.getFieldsCacheKey = function (dataId) {
        return this.getDatabaseDataPrefixCacheKey(dataId) + ':fields';
    };
    /**
     * Invalidate the prefetched content.
     * To invalidate files, use AddonModDataProvider#invalidateFiles.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModDataProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.getDatabase(courseId, moduleId).then(function (data) {
            var ps = [];
            // Do not invalidate module data before getting module info, we need it!
            ps.push(_this.invalidateDatabaseData(courseId, siteId));
            ps.push(_this.invalidateDatabaseWSData(data.id, siteId));
            return Promise.all(ps);
        }));
        promises.push(this.invalidateFiles(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates database access information data.
     *
     * @param {number} dataId     Data ID.
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>}     Promise resolved when the data is invalidated.
     */
    AddonModDataProvider.prototype.invalidateDatabaseAccessInformationData = function (dataId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getDatabaseAccessInformationDataPrefixCacheKey(dataId));
        });
    };
    /**
     * Invalidates database entries data.
     *
     * @param {number} dataId       Data ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModDataProvider.prototype.invalidateEntriesData = function (dataId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getEntriesPrefixCacheKey(dataId));
        });
    };
    /**
     * Invalidate the prefetched files.
     *
     * @param {number} moduleId  The module ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when the files are invalidated.
     */
    AddonModDataProvider.prototype.invalidateFiles = function (moduleId, siteId) {
        return this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModDataProvider_1.COMPONENT, moduleId);
    };
    /**
     * Invalidates database data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModDataProvider.prototype.invalidateDatabaseData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getDatabaseDataCacheKey(courseId));
        });
    };
    /**
     * Invalidates database data except files and module info.
     *
     * @param  {number} databaseId   Data ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModDataProvider.prototype.invalidateDatabaseWSData = function (databaseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getDatabaseDataPrefixCacheKey(databaseId));
        });
    };
    /**
     * Invalidates database entry data.
     *
     * @param  {number}  dataId     Data ID for caching purposes.
     * @param  {number}  entryId    Entry ID.
     * @param  {string}  [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise resolved when the data is invalidated.
     */
    AddonModDataProvider.prototype.invalidateEntryData = function (dataId, entryId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getEntryCacheKey(dataId, entryId));
        });
    };
    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the database WS are available.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>}  Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     * @since 3.3
     */
    AddonModDataProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('mod_data_get_data_access_information');
        });
    };
    /**
     * Report the database as being viewed.
     *
     * @param {number} id      Module ID.
     * @param {string} [name] Name of the data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModDataProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            databaseid: id
        };
        return this.logHelper.logSingle('mod_data_view_database', params, AddonModDataProvider_1.COMPONENT, id, name, 'data', {}, siteId);
    };
    /**
     * Performs search over a database.
     *
     * @param {number} dataId             The data instance id.
     * @param {number} [groupId=0]        Group id, 0 means that the function will determine the user group.
     * @param {string} [search]           Search text. It will be used if advSearch is not defined.
     * @param {any[]}  [advSearch]        Advanced search data.
     * @param {string} [sort]             Sort by this field.
     * @param {string} [order]            The direction of the sorting.
     * @param {number} [page=0]           Page of records to return.
     * @param {number} [perPage=PER_PAGE] Records per page to return. Default on AddonModDataProvider.PER_PAGE.
     * @param {string} [siteId]           Site ID. If not defined, current site.
     * @return {Promise<AddonModDataEntries>} Promise resolved when the action is done.
     */
    AddonModDataProvider.prototype.searchEntries = function (dataId, groupId, search, advSearch, sort, order, page, perPage, siteId) {
        var _this = this;
        if (groupId === void 0) { groupId = 0; }
        if (page === void 0) { page = 0; }
        if (perPage === void 0) { perPage = AddonModDataProvider_1.PER_PAGE; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                databaseid: dataId,
                groupid: groupId,
                returncontents: 1,
                page: page,
                perpage: perPage
            }, preSets = {
                getFromCache: false,
                saveToCache: true,
                emergencyCache: true
            };
            if (typeof sort != 'undefined') {
                params['sort'] = sort;
            }
            if (typeof order !== 'undefined') {
                params['order'] = order;
            }
            if (typeof search !== 'undefined') {
                params['search'] = search;
            }
            if (typeof advSearch !== 'undefined') {
                params['advsearch'] = advSearch;
            }
            return site.read('mod_data_search_entries', params, preSets).then(function (response) {
                response.entries.forEach(function (entry) {
                    entry.contents = _this.utils.arrayToObject(entry.contents, 'fieldid');
                });
                return response;
            });
        });
    };
    AddonModDataProvider.COMPONENT = 'mmaModData';
    AddonModDataProvider.PER_PAGE = 25;
    AddonModDataProvider.ENTRY_CHANGED = 'addon_mod_data_entry_changed';
    AddonModDataProvider = AddonModDataProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_7__offline__["a" /* AddonModDataOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_8__fields_delegate__["a" /* AddonModDataFieldsDelegate */],
            __WEBPACK_IMPORTED_MODULE_6__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModDataProvider);
    return AddonModDataProvider;
    var AddonModDataProvider_1;
}());

//# sourceMappingURL=data.js.map

/***/ }),
/* 102 */,
/* 103 */,
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksModuleListHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_handler__ = __webpack_require__(53);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Handler to handle URLs pointing to a list of a certain type of modules.
 */
var CoreContentLinksModuleListHandler = /** @class */ (function (_super) {
    __extends(CoreContentLinksModuleListHandler, _super);
    /**
     * Construct the handler.
     *
     * @param {CoreContentLinksHelperProvider} linkHelper The CoreContentLinksHelperProvider instance.
     * @param {TranslateService} translate The TranslateService instance.
     * @param {string} addon Name of the addon as it's registered in course delegate. It'll be used to check if it's disabled.
     * @param {string} modName Name of the module (assign, book, ...).
     */
    function CoreContentLinksModuleListHandler(linkHelper, translate, addon, modName) {
        var _this = _super.call(this) || this;
        _this.linkHelper = linkHelper;
        _this.translate = translate;
        _this.addon = addon;
        _this.modName = modName;
        // Match the view.php URL with an id param.
        _this.pattern = new RegExp('\/mod\/' + modName + '\/index\.php.*([\&\?]id=\\d+)');
        _this.featureName = 'CoreCourseModuleDelegate_' + addon;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreContentLinksModuleListHandler.prototype.getActions = function (siteIds, url, params) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    var stateParams = {
                        courseId: params.id,
                        modName: _this.modName,
                        title: _this.title || _this.translate.instant('addon.mod_' + _this.modName + '.modulenameplural')
                    };
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.linkHelper.goInSite(navCtrl, 'CoreCourseListModTypePage', stateParams, siteId);
                }
            }];
    };
    return CoreContentLinksModuleListHandler;
}(__WEBPACK_IMPORTED_MODULE_0__base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=module-list-handler.js.map

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./src/pipes/bytes-to-size.ts
var bytes_to_size = __webpack_require__(1443);

// EXTERNAL MODULE: ./src/pipes/create-links.ts
var create_links = __webpack_require__(1480);

// EXTERNAL MODULE: ./src/pipes/date-day-or-time.ts
var date_day_or_time = __webpack_require__(298);

// EXTERNAL MODULE: ./src/pipes/duration.ts
var duration = __webpack_require__(1444);

// EXTERNAL MODULE: ./src/pipes/format-date.ts
var format_date = __webpack_require__(235);

// CONCATENATED MODULE: ./src/pipes/no-tags.ts
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Pipe to remove HTML tags.
 */
var no_tags_CoreNoTagsPipe = /** @class */ (function () {
    function CoreNoTagsPipe() {
    }
    /**
     * Takes a text and removes HTML tags.
     *
     * @param {string} text The text to treat.
     * @return {string} Treated text.
     */
    CoreNoTagsPipe.prototype.transform = function (text) {
        return text.replace(/(<([^>]+)>)/ig, '');
    };
    CoreNoTagsPipe = __decorate([
        Object(core["S" /* Pipe */])({
            name: 'coreNoTags',
        })
    ], CoreNoTagsPipe);
    return CoreNoTagsPipe;
}());

//# sourceMappingURL=no-tags.js.map
// EXTERNAL MODULE: ./src/pipes/seconds-to-hms.ts
var seconds_to_hms = __webpack_require__(1438);

// EXTERNAL MODULE: ./src/pipes/time-ago.ts
var time_ago = __webpack_require__(422);

// EXTERNAL MODULE: ./src/providers/logger.ts
var logger = __webpack_require__(5);

// EXTERNAL MODULE: ./src/providers/utils/time.ts
var time = __webpack_require__(24);

// CONCATENATED MODULE: ./src/pipes/to-locale-string.ts
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var to_locale_string___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Filter to format a timestamp to a locale string. Timestamp can be in seconds or milliseconds.
 * @deprecated since 3.6. Use coreFormatDate instead.
 */
var to_locale_string_CoreToLocaleStringPipe = /** @class */ (function () {
    function CoreToLocaleStringPipe(logger, timeUtils) {
        this.timeUtils = timeUtils;
        this.logger = logger.getInstance('CoreToLocaleStringPipe');
    }
    /**
     * Format a timestamp to a locale string.
     *
     * @param {number|string} timestamp The timestamp (can be in seconds or milliseconds).
     * @return {string} Formatted time.
     */
    CoreToLocaleStringPipe.prototype.transform = function (timestamp) {
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        if (timestamp < 0) {
            // Date not valid.
            return '';
        }
        if (timestamp < 100000000000) {
            // Timestamp is in seconds, convert it to milliseconds.
            timestamp = timestamp * 1000;
        }
        return this.timeUtils.userDate(timestamp, 'core.strftimedatetimeshort');
    };
    CoreToLocaleStringPipe = to_locale_string___decorate([
        Object(core["S" /* Pipe */])({
            name: 'coreToLocaleString',
        }),
        __metadata("design:paramtypes", [logger["a" /* CoreLoggerProvider */], time["a" /* CoreTimeUtilsProvider */]])
    ], CoreToLocaleStringPipe);
    return CoreToLocaleStringPipe;
}());

//# sourceMappingURL=to-locale-string.js.map
// CONCATENATED MODULE: ./src/pipes/pipes.module.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return pipes_module_CorePipesModule; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var pipes_module___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










var pipes_module_CorePipesModule = /** @class */ (function () {
    function CorePipesModule() {
    }
    CorePipesModule = pipes_module___decorate([
        Object(core["I" /* NgModule */])({
            declarations: [
                bytes_to_size["a" /* CoreBytesToSizePipe */],
                create_links["a" /* CoreCreateLinksPipe */],
                date_day_or_time["a" /* CoreDateDayOrTimePipe */],
                duration["a" /* CoreDurationPipe */],
                format_date["a" /* CoreFormatDatePipe */],
                no_tags_CoreNoTagsPipe,
                seconds_to_hms["a" /* CoreSecondsToHMSPipe */],
                time_ago["a" /* CoreTimeAgoPipe */],
                to_locale_string_CoreToLocaleStringPipe
            ],
            imports: [],
            exports: [
                bytes_to_size["a" /* CoreBytesToSizePipe */],
                create_links["a" /* CoreCreateLinksPipe */],
                date_day_or_time["a" /* CoreDateDayOrTimePipe */],
                duration["a" /* CoreDurationPipe */],
                format_date["a" /* CoreFormatDatePipe */],
                no_tags_CoreNoTagsPipe,
                seconds_to_hms["a" /* CoreSecondsToHMSPipe */],
                time_ago["a" /* CoreTimeAgoPipe */],
                to_locale_string_CoreToLocaleStringPipe
            ]
        })
    ], CorePipesModule);
    return CorePipesModule;
}());

//# sourceMappingURL=pipes.module.js.map

/***/ }),
/* 106 */,
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmptyBoxComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Component to show an empty box message. It will show an optional icon or image and a text centered on page.
 *
 * Use class="core-empty-box-clickable" if you want to add some clickable elements to the box.
 *
 * Usage:
 * <core-empty-box *ngIf="empty" icon="bell" [message]="'core.emptymessage' | translate"></core-empty-box>
 */
var CoreEmptyBoxComponent = /** @class */ (function () {
    // If image or icon is not supplied, it's true by default.
    function CoreEmptyBoxComponent() {
        // Nothing to do.
    }
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreEmptyBoxComponent.prototype, "message", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreEmptyBoxComponent.prototype, "icon", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreEmptyBoxComponent.prototype, "image", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreEmptyBoxComponent.prototype, "inline", void 0);
    CoreEmptyBoxComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-empty-box',
            templateUrl: 'core-empty-box.html'
        }),
        __metadata("design:paramtypes", [])
    ], CoreEmptyBoxComponent);
    return CoreEmptyBoxComponent;
}());

//# sourceMappingURL=empty-box.js.map

/***/ }),
/* 108 */,
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreQuestionBehaviourDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__delegate__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__default_behaviour_handler__ = __webpack_require__(578);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Delegate to register question behaviour handlers.
 */
var CoreQuestionBehaviourDelegate = /** @class */ (function (_super) {
    __extends(CoreQuestionBehaviourDelegate, _super);
    function CoreQuestionBehaviourDelegate(logger, sitesProvider, eventsProvider, questionDelegate, defaultHandler) {
        var _this = _super.call(this, 'CoreQuestionBehaviourDelegate', logger, sitesProvider, eventsProvider) || this;
        _this.questionDelegate = questionDelegate;
        _this.defaultHandler = defaultHandler;
        _this.handlerNameProperty = 'type';
        return _this;
    }
    /**
     * Determine a question new state based on its answer(s).
     *
     * @param {string} component Component the question belongs to.
     * @param {number} attemptId Attempt ID the question belongs to.
     * @param {any} question The question.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreQuestionState>} Promise resolved with state.
     */
    CoreQuestionBehaviourDelegate.prototype.determineNewState = function (behaviour, component, attemptId, question, siteId) {
        behaviour = this.questionDelegate.getBehaviourForQuestion(question, behaviour);
        return Promise.resolve(this.executeFunctionOnEnabled(behaviour, 'determineNewState', [component, attemptId, question, siteId]));
    };
    /**
     * Handle a question behaviour.
     * If the behaviour requires a submit button, it should add it to question.behaviourButtons.
     * If the behaviour requires to show some extra data, it should return a directive to render it.
     *
     * @param {Injector} injector Injector.
     * @param {string} behaviour Default behaviour.
     * @param {any} question The question.
     * @return {Promise<any[]>} Promise resolved with components to render some extra data in the question.
     */
    CoreQuestionBehaviourDelegate.prototype.handleQuestion = function (injector, behaviour, question) {
        behaviour = this.questionDelegate.getBehaviourForQuestion(question, behaviour);
        return Promise.resolve(this.executeFunctionOnEnabled(behaviour, 'handleQuestion', [injector, question]));
    };
    /**
     * Check if a question behaviour is supported.
     *
     * @param {string} behaviour Name of the behaviour.
     * @return {boolean} Whether it's supported.
     */
    CoreQuestionBehaviourDelegate.prototype.isBehaviourSupported = function (behaviour) {
        return this.hasHandler(behaviour, true);
    };
    CoreQuestionBehaviourDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__delegate__["a" /* CoreQuestionDelegate */], __WEBPACK_IMPORTED_MODULE_6__default_behaviour_handler__["a" /* CoreQuestionBehaviourDefaultHandler */]])
    ], CoreQuestionBehaviourDelegate);
    return CoreQuestionBehaviourDelegate;
}(__WEBPACK_IMPORTED_MODULE_4__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=behaviour-delegate.js.map

/***/ }),
/* 110 */,
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__providers_events__ = __webpack_require__(11);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Superclass to help creating delegates
 */
var CoreDelegate = /** @class */ (function () {
    /**
     * Constructor of the Delegate.
     *
     * @param {string} delegateName Delegate name used for logging purposes.
     * @param {CoreLoggerProvider}   loggerProvider CoreLoggerProvider instance, cannot be directly injected.
     * @param {CoreSitesProvider}    sitesProvider  CoreSitesProvider instance, cannot be directly injected.
     * @param {CoreEventsProvider}   [eventsProvider]  CoreEventsProvider instance, cannot be directly injected.
     *                                                  If not set, no events will be fired.
     */
    function CoreDelegate(delegateName, loggerProvider, sitesProvider, eventsProvider) {
        this.loggerProvider = loggerProvider;
        this.sitesProvider = sitesProvider;
        this.eventsProvider = eventsProvider;
        /**
         * List of registered handlers.
         * @type {any}
         */
        this.handlers = {};
        /**
         * List of registered handlers enabled for the current site.
         * @type {any}
         */
        this.enabledHandlers = {};
        /**
         * Name of the property to be used to index the handlers. By default, the handler's name will be used.
         * If your delegate uses a Moodle component name to identify the handlers, please override this property.
         * E.g. CoreCourseModuleDelegate uses 'modName' to index the handlers.
         * @type {string}
         */
        this.handlerNameProperty = 'name';
        /**
         * Set of promises to update a handler, to prevent doing the same operation twice.
         * @type {{[siteId: string]: {[name: string]: Promise<any>}}}
         */
        this.updatePromises = {};
        this.logger = this.loggerProvider.getInstance(delegateName);
        if (eventsProvider) {
            // Update handlers on this cases.
            eventsProvider.on(__WEBPACK_IMPORTED_MODULE_0__providers_events__["a" /* CoreEventsProvider */].LOGIN, this.updateHandlers.bind(this));
            eventsProvider.on(__WEBPACK_IMPORTED_MODULE_0__providers_events__["a" /* CoreEventsProvider */].SITE_UPDATED, this.updateHandlers.bind(this));
            eventsProvider.on(__WEBPACK_IMPORTED_MODULE_0__providers_events__["a" /* CoreEventsProvider */].SITE_PLUGINS_LOADED, this.updateHandlers.bind(this));
        }
    }
    /**
     * Execute a certain function in a enabled handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {string} handlerName The handler name.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.executeFunctionOnEnabled = function (handlerName, fnName, params) {
        return this.execute(this.enabledHandlers[handlerName], fnName, params);
    };
    /**
     * Execute a certain function in a handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {string} handlerName The handler name.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.executeFunction = function (handlerName, fnName, params) {
        return this.execute(this.handlers[handlerName], fnName, params);
    };
    /**
     * Execute a certain function in a handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {any} handler The handler.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.execute = function (handler, fnName, params) {
        if (handler && handler[fnName]) {
            return handler[fnName].apply(handler, params);
        }
        else if (this.defaultHandler && this.defaultHandler[fnName]) {
            return this.defaultHandler[fnName].apply(this.defaultHandler, params);
        }
    };
    /**
     * Get a handler.
     *
     * @param  {string} handlerName The handler name.
     * @param  {boolean} [enabled]  Only enabled, or any.
     * @return {CoreDelegateHandler} Handler.
     */
    CoreDelegate.prototype.getHandler = function (handlerName, enabled) {
        if (enabled === void 0) { enabled = false; }
        return enabled ? this.enabledHandlers[handlerName] : this.handlers[handlerName];
    };
    /**
     * Gets the handler full name for a given name. This is useful when the handlerNameProperty is different than "name".
     * E.g. blocks are indexed by blockName. If you call this function passing the blockName it will return the name.
     *
     * @param {string} name Name used to indentify the handler.
     * @return {string} Full name of corresponding handler.
     */
    CoreDelegate.prototype.getHandlerName = function (name) {
        var handler = this.getHandler(name, true);
        if (!handler) {
            return '';
        }
        return handler.name;
    };
    /**
     * Check if function exists on a handler.
     *
     * @param {string} handlerName         The handler name.
     * @param {string} fnName              Name of the function to execute.
     * @param {booealn} [onlyEnabled=true] If check only enabled handlers or all.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.hasFunction = function (handlerName, fnName, onlyEnabled) {
        if (onlyEnabled === void 0) { onlyEnabled = true; }
        var handler = onlyEnabled ? this.enabledHandlers[handlerName] : this.handlers[handlerName];
        return handler && handler[fnName];
    };
    /**
     * Check if a handler name has a registered handler (not necessarily enabled).
     *
     * @param {string} name The handler name.
     * @param  {boolean} [enabled]  Only enabled, or any.
     * @return {boolean} If the handler is registered or not.
     */
    CoreDelegate.prototype.hasHandler = function (name, enabled) {
        if (enabled === void 0) { enabled = false; }
        return enabled ? typeof this.enabledHandlers[name] !== 'undefined' : typeof this.handlers[name] !== 'undefined';
    };
    /**
     * Check if a time belongs to the last update handlers call.
     * This is to handle the cases where updateHandlers don't finish in the same order as they're called.
     *
     * @param {number} time Time to check.
     * @return {boolean} Whether it's the last call.
     */
    CoreDelegate.prototype.isLastUpdateCall = function (time) {
        if (!this.lastUpdateHandlersStart) {
            return true;
        }
        return time == this.lastUpdateHandlersStart;
    };
    /**
     * Register a handler.
     *
     * @param {CoreDelegateHandler} handler The handler delegate object to register.
     * @return {boolean} True when registered, false if already registered.
     */
    CoreDelegate.prototype.registerHandler = function (handler) {
        if (typeof this.handlers[handler[this.handlerNameProperty]] !== 'undefined') {
            this.logger.log("Handler '" + handler[this.handlerNameProperty] + "' already registered");
            return false;
        }
        this.logger.log("Registered handler '" + handler[this.handlerNameProperty] + "'");
        this.handlers[handler[this.handlerNameProperty]] = handler;
        return true;
    };
    /**
     * Update the handler for the current site.
     *
     * @param {CoreDelegateHandler} handler The handler to check.
     * @param {number} time Time this update process started.
     * @return {Promise<void>} Resolved when done.
     */
    CoreDelegate.prototype.updateHandler = function (handler, time) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId(), currentSite = this.sitesProvider.getCurrentSite();
        var promise;
        if (this.updatePromises[siteId] && this.updatePromises[siteId][handler.name]) {
            // There's already an update ongoing for this handler, return the promise.
            return this.updatePromises[siteId][handler.name];
        }
        else if (!this.updatePromises[siteId]) {
            this.updatePromises[siteId] = {};
        }
        if (!this.sitesProvider.isLoggedIn()) {
            promise = Promise.reject(null);
        }
        else if (this.isFeatureDisabled(handler, currentSite)) {
            promise = Promise.resolve(false);
        }
        else {
            promise = Promise.resolve(handler.isEnabled());
        }
        // Checks if the handler is enabled.
        this.updatePromises[siteId][handler.name] = promise.catch(function () {
            return false;
        }).then(function (enabled) {
            // Check that site hasn't changed since the check started.
            if (_this.sitesProvider.getCurrentSiteId() === siteId) {
                if (enabled) {
                    _this.enabledHandlers[handler[_this.handlerNameProperty]] = handler;
                }
                else {
                    delete _this.enabledHandlers[handler[_this.handlerNameProperty]];
                }
            }
        }).finally(function () {
            // Update finished, delete the promise.
            delete _this.updatePromises[siteId][handler.name];
        });
        return this.updatePromises[siteId][handler.name];
    };
    /**
     * Check if feature is enabled or disabled in the site, depending on the feature prefix and the handler name.
     *
     * @param  {CoreDelegateHandler} handler Handler to check.
     * @param  {CoreSite} site Site to check.
     * @return {boolean} Whether is enabled or disabled in site.
     */
    CoreDelegate.prototype.isFeatureDisabled = function (handler, site) {
        return typeof this.featurePrefix != 'undefined' && site.isFeatureDisabled(this.featurePrefix + handler.name);
    };
    /**
     * Update the handlers for the current site.
     *
     * @return {Promise<void>} Resolved when done.
     */
    CoreDelegate.prototype.updateHandlers = function () {
        var _this = this;
        var promises = [], now = Date.now();
        this.logger.debug('Updating handlers for current site.');
        this.lastUpdateHandlersStart = now;
        // Loop over all the handlers.
        for (var name_1 in this.handlers) {
            promises.push(this.updateHandler(this.handlers[name_1], now));
        }
        return Promise.all(promises).then(function () {
            return true;
        }, function () {
            // Never reject.
            return true;
        }).then(function () {
            // Verify that this call is the last one that was started.
            if (_this.isLastUpdateCall(now)) {
                _this.updateData();
            }
        });
    };
    /**
     * Update handlers Data.
     * Override this function to update handlers data.
     */
    CoreDelegate.prototype.updateData = function () {
        // To be overridden.
    };
    return CoreDelegate;
}());

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreCourseModuleDescriptionComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreCourseModuleDescriptionComponent_0;
/* unused harmony export View_CoreCourseModuleDescriptionComponent_Host_0 */
/* unused harmony export CoreCourseModuleDescriptionComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_item_item_ngfactory__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular_components_item_item__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular_util_form__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_ionic_angular_components_item_item_reorder__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_ionic_angular_components_item_item_content__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_ionic_angular_components_note_note__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ionic_angular_components_card_card__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__directives_format_text__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ngx_translate_core_src_translate_service__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_ionic_angular_platform_platform__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__contentlinks_providers_helper__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_ionic_angular_navigation_nav_controller__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_ionic_angular_components_content_content__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__components_split_view_split_view__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_utils_iframe__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__module_description__ = __webpack_require__(95);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 




























var styles_CoreCourseModuleDescriptionComponent = [];
var RenderType_CoreCourseModuleDescriptionComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreCourseModuleDescriptionComponent, data: {} });

function View_CoreCourseModuleDescriptionComponent_2(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 10, "ion-item", [["class", "item item-block"], ["text-wrap", ""]], null, null, null, __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_item_item_ngfactory__["b" /* View_Item_0 */], __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_item_item_ngfactory__["a" /* RenderType_Item */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 1097728, null, 3, __WEBPACK_IMPORTED_MODULE_2_ionic_angular_components_item_item__["a" /* Item */], [__WEBPACK_IMPORTED_MODULE_3_ionic_angular_util_form__["a" /* Form */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */], [2, __WEBPACK_IMPORTED_MODULE_5_ionic_angular_components_item_item_reorder__["a" /* ItemReorder */]]], null, null), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](335544320, 4, { contentLabel: 0 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](603979776, 5, { _buttons: 1 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](603979776, 6, { _icons: 1 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](5, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_6_ionic_angular_components_item_item_content__["a" /* ItemContent */], [], null, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](7, 0, null, 4, 2, "ion-note", [["item-end", ""]], null, null, null, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](8, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_7_ionic_angular_components_note_note__["a" /* Note */], [__WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */]], null, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](9, null, ["", ""])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n    "]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.note; _ck(_v, 9, 0, currVal_0); }); }
function View_CoreCourseModuleDescriptionComponent_1(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 16, "ion-card", [], null, null, null, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_8_ionic_angular_components_card_card__["a" /* Card */], [__WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */]], null, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](3, 0, null, null, 9, "ion-item", [["class", "item item-block"], ["text-wrap", ""]], null, null, null, __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_item_item_ngfactory__["b" /* View_Item_0 */], __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_item_item_ngfactory__["a" /* RenderType_Item */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](4, 1097728, null, 3, __WEBPACK_IMPORTED_MODULE_2_ionic_angular_components_item_item__["a" /* Item */], [__WEBPACK_IMPORTED_MODULE_3_ionic_angular_util_form__["a" /* Form */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */], [2, __WEBPACK_IMPORTED_MODULE_5_ionic_angular_components_item_item_reorder__["a" /* ItemReorder */]]], null, null), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](335544320, 1, { contentLabel: 0 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](603979776, 2, { _buttons: 1 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](603979776, 3, { _icons: 1 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](8, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_6_ionic_angular_components_item_item_content__["a" /* ItemContent */], [], null, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](10, 0, null, 2, 1, "core-format-text", [["fullOnClick", "true"]], null, null, null, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](11, 540672, null, 0, __WEBPACK_IMPORTED_MODULE_9__directives_format_text__["a" /* CoreFormatTextDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_10__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_11__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_12__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_13__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_14_ionic_angular_platform_platform__["a" /* Platform */], __WEBPACK_IMPORTED_MODULE_15__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_16__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_17__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_18__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_19__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_20__contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], [2, __WEBPACK_IMPORTED_MODULE_21_ionic_angular_navigation_nav_controller__["a" /* NavController */]], [2, __WEBPACK_IMPORTED_MODULE_22_ionic_angular_components_content_content__["a" /* Content */]], [2, __WEBPACK_IMPORTED_MODULE_23__components_split_view_split_view__["a" /* CoreSplitViewComponent */]], __WEBPACK_IMPORTED_MODULE_24__providers_utils_iframe__["a" /* CoreIframeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_25__providers_events__["a" /* CoreEventsProvider */]], { text: [0, "text"], component: [1, "component"], componentId: [2, "componentId"], maxHeight: [3, "maxHeight"], fullOnClick: [4, "fullOnClick"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreCourseModuleDescriptionComponent_2)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](15, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_26__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.description; var currVal_1 = _co.component; var currVal_2 = _co.componentId; var currVal_3 = ((_co.showFull && (_co.showFull !== "false")) ? 0 : 120); var currVal_4 = "true"; _ck(_v, 11, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_5 = _co.note; _ck(_v, 15, 0, currVal_5); }, null); }
function View_CoreCourseModuleDescriptionComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreCourseModuleDescriptionComponent_1)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_26__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.description; _ck(_v, 1, 0, currVal_0); }, null); }
function View_CoreCourseModuleDescriptionComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-course-module-description", [], null, null, null, View_CoreCourseModuleDescriptionComponent_0, RenderType_CoreCourseModuleDescriptionComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 49152, null, 0, __WEBPACK_IMPORTED_MODULE_27__module_description__["a" /* CoreCourseModuleDescriptionComponent */], [], null, null)], null, null); }
var CoreCourseModuleDescriptionComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-course-module-description", __WEBPACK_IMPORTED_MODULE_27__module_description__["a" /* CoreCourseModuleDescriptionComponent */], View_CoreCourseModuleDescriptionComponent_Host_0, { description: "description", note: "note", component: "component", componentId: "componentId", showFull: "showFull" }, {}, []);

//# sourceMappingURL=module-description.ngfactory.js.map

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUpdateManagerProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__config__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__init__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__local_notifications__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__configconstants__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__addon_calendar_providers_calendar__ = __webpack_require__(358);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












/**
 * Factory to handle app updates. This factory shouldn't be used outside of core.
 *
 * This service handles processes that need to be run when updating the app, like migrate Ionic 1 database data to Ionic 3.
 */
var CoreUpdateManagerProvider = /** @class */ (function () {
    function CoreUpdateManagerProvider(logger, configProvider, sitesProvider, filepoolProvider, notifProvider, utils, appProvider, timeUtils, calendarProvider) {
        this.configProvider = configProvider;
        this.sitesProvider = sitesProvider;
        this.filepoolProvider = filepoolProvider;
        this.notifProvider = notifProvider;
        this.utils = utils;
        this.appProvider = appProvider;
        this.timeUtils = timeUtils;
        this.calendarProvider = calendarProvider;
        // Data for init delegate.
        this.name = 'CoreUpdateManager';
        this.priority = __WEBPACK_IMPORTED_MODULE_4__init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 300;
        this.blocking = true;
        this.VERSION_APPLIED = 'version_applied';
        this.localNotificationsComponentsMigrate = {};
        /**
         * Tables to migrate from app DB ('MoodleMobile'). Include all the core ones to decrease the dependencies.
         *
         * @type {CoreUpdateManagerMigrateTable[]}
         */
        this.appDBTables = [
            {
                name: 'config',
                newName: 'core_config',
                fields: [
                    {
                        name: 'value',
                        type: 'any'
                    }
                ]
            },
            {
                name: 'cron'
            },
            {
                name: 'current_site',
                fields: [
                    {
                        name: 'siteid',
                        newName: 'siteId'
                    }
                ]
            },
            {
                name: 'desktop_local_notifications',
                fields: [
                    {
                        name: 'data',
                        type: 'object'
                    },
                    {
                        name: 'triggered',
                        type: 'boolean'
                    }
                ],
                filterFields: ['id', 'title', 'text', 'at', 'data', 'triggered']
            },
            {
                name: 'files_queue',
                newName: 'filepool_files_queue',
                fields: [
                    {
                        name: 'isexternalfile',
                        type: 'boolean'
                    },
                    {
                        name: 'links',
                        type: 'object'
                    },
                    {
                        name: 'sortorder',
                        delete: true
                    }
                ]
            },
            {
                name: 'notification_components'
            },
            {
                name: 'notification_sites'
            },
            {
                name: 'notifications_triggered'
            },
            {
                name: 'shared_files'
            },
            {
                name: 'sites',
                fields: [
                    {
                        name: 'siteurl',
                        newName: 'siteUrl'
                    },
                    {
                        name: 'infos',
                        newName: 'info',
                        type: 'object'
                    },
                    {
                        name: 'privatetoken',
                        newName: 'privateToken'
                    },
                    {
                        name: 'config',
                        type: 'object'
                    },
                    {
                        name: 'loggedout',
                        newName: 'loggedOut'
                    }
                ]
            },
        ];
        /**
         * Tables to migrate from each site DB. Include all the core ones to decrease the dependencies.
         *
         * @type {CoreUpdateManagerMigrateTable[]}
         */
        this.siteDBTables = [
            {
                name: 'check_updates_times',
                fields: [
                    {
                        name: 'courseid',
                        newName: 'courseId'
                    }
                ]
            },
            {
                name: 'course_status',
                fields: [
                    {
                        name: 'previous',
                        newName: 'previousStatus'
                    },
                    {
                        name: 'downloadtime',
                        newName: 'downloadTime'
                    },
                    {
                        name: 'previousdownloadtime',
                        newName: 'previousDownloadTime'
                    }
                ]
            },
            {
                name: 'filepool',
                newName: 'filepool_files',
                fields: [
                    {
                        name: 'stale',
                        type: 'boolean'
                    },
                    {
                        name: 'downloaded',
                        newName: 'downloadTime'
                    },
                    {
                        name: 'isexternalfile',
                        type: 'boolean'
                    }
                ]
            },
            {
                name: 'files_links',
                newName: 'filepool_files_links',
                fields: [
                    {
                        name: 'componentAndId',
                        delete: true
                    }
                ]
            },
            {
                name: 'filepool_packages',
                fields: [
                    {
                        name: 'downloadtime',
                        newName: 'downloadTime'
                    },
                    {
                        name: 'previousdownloadtime',
                        newName: 'previousDownloadTime'
                    },
                    {
                        name: 'revision',
                        newName: 'extra'
                    },
                    {
                        name: 'timemodified',
                        delete: true
                    }
                ]
            },
            {
                name: 'mm_emulator_last_received_notification',
                newName: 'core_emulator_last_received_notification',
                filterFields: ['component', 'id', 'timecreated']
            },
            {
                name: 'questions',
                fields: [
                    {
                        name: 'componentId',
                        newName: 'componentid'
                    },
                    {
                        name: 'componentAndAttempt',
                        delete: true
                    },
                    {
                        name: 'componentAndComponentId',
                        delete: true
                    }
                ]
            },
            {
                name: 'question_answers',
                fields: [
                    {
                        name: 'componentId',
                        newName: 'componentid'
                    },
                    {
                        name: 'componentAndAttempt',
                        delete: true
                    },
                    {
                        name: 'componentAndComponentId',
                        delete: true
                    },
                    {
                        name: 'componentAndAttemptAndQuestion',
                        delete: true
                    }
                ]
            },
            {
                name: 'sync'
            },
            {
                name: 'users'
            },
            {
                name: 'wscache',
                fields: [
                    {
                        name: 'data',
                        type: 'object'
                    },
                    {
                        name: 'expirationtime',
                        newName: 'expirationTime'
                    }
                ]
            }
        ];
        this.logger = logger.getInstance('CoreUpdateManagerProvider');
    }
    /**
     * Check if the app has been updated and performs the needed processes.
     * This function shouldn't be used outside of core.
     *
     * @return {Promise<any>} Promise resolved when the update process finishes.
     */
    CoreUpdateManagerProvider.prototype.load = function () {
        var _this = this;
        var promises = [], versionCode = __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].versioncode;
        return this.configProvider.get(this.VERSION_APPLIED, 0).then(function (versionApplied) {
            if (!versionApplied) {
                // No version applied, either the app was just installed or it's being updated from Ionic 1.
                return _this.migrateAllDBs().then(function () {
                    // Now that the DBs have been migrated, migrate the local notification components names.
                    return _this.migrateLocalNotificationsComponents();
                }).then(function () {
                    // DBs migrated, get the version applied again.
                    return _this.configProvider.get(_this.VERSION_APPLIED, 0);
                });
            }
            else {
                return versionApplied;
            }
        }).then(function (versionApplied) {
            if (versionCode >= 2013 && versionApplied < 2013 && versionApplied > 0) {
                promises.push(_this.migrateFileExtensions());
            }
            if (versionCode >= 2017 && versionApplied < 2017 && versionApplied > 0) {
                promises.push(_this.setCalendarDefaultNotifTime());
                promises.push(_this.setSitesConfig());
            }
            // In version 2018 we adapted the forum offline stores to match a new schema.
            // However, due to the migration of data to SQLite we can no longer do that.
            if (versionCode >= 3500 && versionApplied < 3500 && versionApplied > 0) {
                promises.push(_this.logoutLegacySites());
            }
            return Promise.all(promises).then(function () {
                return _this.configProvider.set(_this.VERSION_APPLIED, versionCode);
            }).catch(function (error) {
                _this.logger.error("Error applying update from " + versionApplied + " to " + versionCode, error);
            });
        });
    };
    /**
     * Register several app tables to be migrated to the new schema.
     *
     * @param {CoreUpdateManagerMigrateTable[]} tables The tables to migrate.
     */
    CoreUpdateManagerProvider.prototype.registerAppTablesMigration = function (tables) {
        var _this = this;
        tables.forEach(function (table) {
            _this.registerAppTableMigration(table);
        });
    };
    /**
     * Register an app table to be migrated to the new schema.
     *
     * @param {CoreUpdateManagerMigrateTable} table The table to migrate.
     */
    CoreUpdateManagerProvider.prototype.registerAppTableMigration = function (table) {
        this.appDBTables.push(table);
    };
    /**
     * Register several site tables to be migrated to the new schema.
     *
     * @param {CoreUpdateManagerMigrateTable[]} tables The tables to migrate.
     */
    CoreUpdateManagerProvider.prototype.registerSiteTablesMigration = function (tables) {
        var _this = this;
        tables.forEach(function (table) {
            _this.registerSiteTableMigration(table);
        });
    };
    /**
     * Register a site table to be migrated to the new schema.
     *
     * @param {CoreUpdateManagerMigrateTable} table The table to migrate.
     */
    CoreUpdateManagerProvider.prototype.registerSiteTableMigration = function (table) {
        this.siteDBTables.push(table);
    };
    /**
     * Register a migration of component name for local notifications.
     *
     * @param {string} oldName The old name.
     * @param {string} newName The new name.
     */
    CoreUpdateManagerProvider.prototype.registerLocalNotifComponentMigration = function (oldName, newName) {
        this.localNotificationsComponentsMigrate[oldName] = newName;
    };
    /**
     * Migrate all DBs and tables from the old format to SQLite.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUpdateManagerProvider.prototype.migrateAllDBs = function () {
        var _this = this;
        if (!window.ydn) {
            // The ydn-db library is not loaded, stop.
            return Promise.resolve();
        }
        // First migrate the app DB.
        return this.migrateAppDB().then(function () {
            // Now migrate all site DBs.
            return _this.sitesProvider.getSitesIds();
        }).then(function (ids) {
            var promises = [];
            ids.forEach(function (id) {
                promises.push(_this.migrateSiteDB(id));
            });
            return _this.utils.allPromises(promises);
        });
    };
    /**
     * Migrate the app DB.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUpdateManagerProvider.prototype.migrateAppDB = function () {
        var oldDb = new window.ydn.db.Storage('MoodleMobile'), newDb = this.appProvider.getDB();
        return this.migrateDB(oldDb, newDb, this.appDBTables);
    };
    /**
     * Migrate the DB of a certain site.
     *
     * @param {string} siteId The site ID.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUpdateManagerProvider.prototype.migrateSiteDB = function (siteId) {
        var _this = this;
        // Get the site DB.
        return this.sitesProvider.getSiteDb(siteId).then(function (newDb) {
            var oldDb = new window.ydn.db.Storage('Site-' + siteId);
            return _this.migrateDB(oldDb, newDb, _this.siteDBTables);
        });
    };
    /**
     * Migrate all the tables of a certain DB to the SQLite DB.
     *
     * @param {any} oldDb The old DB (created using ydn-db).
     * @param {SQLiteDB} newDb The new DB.
     * @param {CoreUpdateManagerMigrateTable[]} tables The tables to migrate.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUpdateManagerProvider.prototype.migrateDB = function (oldDb, newDb, tables) {
        var _this = this;
        if (!oldDb || !newDb) {
            // Some of the DBs doesn't exist, stop.
            return Promise.resolve();
        }
        var promises = [];
        tables.forEach(function (table) {
            // Get current values.
            promises.push(Promise.resolve(oldDb.values(table.name, undefined, 99999999)).then(function (entries) {
                var fields = table.fields || [], filterFields = table.filterFields || [];
                var _loop_1 = function (i) {
                    var entry = entries[i];
                    // Convert and rename the fields to match the new schema.
                    fields.forEach(function (field) {
                        var value = entry[field.name];
                        // Convert the field to the right format.
                        if (field.type == 'object' || (field.type == 'any' && typeof value == 'object')) {
                            entry[field.name] = JSON.stringify(value);
                        }
                        else if (field.type == 'date' && value) {
                            entry[field.name] = value.getTime();
                        }
                        else if (field.type == 'boolean' || (field.type == 'any' && typeof value == 'boolean')) {
                            entry[field.name] = value ? 1 : 0;
                        }
                        if (field.newName) {
                            // Rename the field.
                            entry[field.newName] = entry[field.name];
                            delete entry[field.name];
                        }
                        if (field.delete) {
                            // Delete the field.
                            delete entry[field.name];
                        }
                    });
                    // Remove invalid and unneeded properties.
                    for (var name_1 in entry) {
                        if (name_1.indexOf('$') === 0) {
                            // Property not valid, remove.
                            delete entry[name_1];
                        }
                        else if (filterFields.length && filterFields.indexOf(name_1) == -1) {
                            // The property isn't present in filterFields, remove it.
                            delete entry[name_1];
                        }
                    }
                };
                // Treat the entries.
                for (var i = 0; i < entries.length; i++) {
                    _loop_1(i);
                }
                // Now store the entries in the new DB.
                return newDb.insertRecords(table.newName || table.name, entries);
            }).catch(function (error) {
                _this.logger.error('Error migrating table ' + table.name + ' to ' + (table.newName || table.name) + ': ', error);
            }));
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Migrates files filling extensions.
     *
     * @return {Promise<any>} Promise resolved when the site migration is finished.
     */
    CoreUpdateManagerProvider.prototype.migrateFileExtensions = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (sites) {
            var promises = [];
            sites.forEach(function (siteId) {
                promises.push(_this.filepoolProvider.fillMissingExtensionInFiles(siteId));
            });
            promises.push(_this.filepoolProvider.treatExtensionInQueue());
            return Promise.all(promises);
        });
    };
    /**
     * Migrate local notifications components from the old nomenclature to the new one.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUpdateManagerProvider.prototype.migrateLocalNotificationsComponents = function () {
        var _this = this;
        if (!this.notifProvider.isAvailable()) {
            // Local notifications not available, nothing to do.
            return Promise.resolve();
        }
        var promises = [];
        var _loop_2 = function (oldName) {
            var newName = this_1.localNotificationsComponentsMigrate[oldName];
            promises.push(this_1.notifProvider.updateComponentName(oldName, newName).catch(function (error) {
                _this.logger.error('Error migrating local notif component from ' + oldName + ' to ' + newName + ': ', error);
            }));
        };
        var this_1 = this;
        for (var oldName in this.localNotificationsComponentsMigrate) {
            _loop_2(oldName);
        }
        return Promise.all(promises);
    };
    /**
     * Calendar default notification time is configurable from version 3.2.1, and a new option "Default" is added.
     * All events that were configured to use the fixed default time should now be configured to use "Default" option.
     *
     * @return {Promise<any>} Promise resolved when the events are configured.
     */
    CoreUpdateManagerProvider.prototype.setCalendarDefaultNotifTime = function () {
        var _this = this;
        if (!this.notifProvider.isAvailable()) {
            // Local notifications not available, nothing to do.
            return Promise.resolve();
        }
        var now = this.timeUtils.timestamp();
        return this.sitesProvider.getSitesIds().then(function (siteIds) {
            var promises = [];
            siteIds.forEach(function (siteId) {
                // Get stored events.
                promises.push(_this.calendarProvider.getAllEventsFromLocalDb(siteId).then(function (events) {
                    var eventPromises = [];
                    events.forEach(function (event) {
                        if (event.notificationtime && event.notificationtime == __WEBPACK_IMPORTED_MODULE_11__addon_calendar_providers_calendar__["a" /* AddonCalendarProvider */].DEFAULT_NOTIFICATION_TIME) {
                            eventPromises.push(_this.calendarProvider.addEventReminder(event, -1, siteId));
                        }
                        else if (event.notificationtime && event.notificationtime > 0) {
                            var time = event.timestart - event.notificationtime * 60;
                            if (time < now) {
                                // Old reminder, just not add this.
                                return;
                            }
                            eventPromises.push(_this.calendarProvider.addEventReminder(event, time, siteId));
                        }
                    });
                    return Promise.all(eventPromises);
                }));
            });
            return Promise.all(promises);
        });
    };
    /**
     * In version 3.2.1 we want the site config to be stored in each site if available.
     * Since it can be slow, we'll only block retrieving the config of current site, the rest will be in background.
     *
     * @return {Promise<any>} Promise resolved when the config is loaded for the current site (if any).
     */
    CoreUpdateManagerProvider.prototype.setSitesConfig = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (siteIds) {
            return _this.sitesProvider.getStoredCurrentSiteId().catch(function () {
                // Error getting current site.
            }).then(function (currentSiteId) {
                var promise;
                // Load the config of current site first.
                if (currentSiteId) {
                    promise = _this.setSiteConfig(currentSiteId);
                }
                else {
                    promise = Promise.resolve();
                }
                // Load the config of rest of sites in background.
                siteIds.forEach(function (siteId) {
                    if (siteId != currentSiteId) {
                        _this.setSiteConfig(siteId);
                    }
                });
                return promise;
            });
        });
    };
    /**
     * Store the config of a site.
     *
     * @param {String} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the config is loaded for the site.
     */
    CoreUpdateManagerProvider.prototype.setSiteConfig = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (site.getStoredConfig() || !site.wsAvailable('tool_mobile_get_config')) {
                // Site already has the config or it cannot be retrieved. Stop.
                return;
            }
            // Get the site config.
            return site.getConfig().then(function (config) {
                return _this.sitesProvider.addSite(site.getId(), site.getURL(), site.getToken(), site.getInfo(), site.getPrivateToken(), config);
            }).catch(function () {
                // Ignore errors.
            });
        });
    };
    /**
     * Logout from legacy sites.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUpdateManagerProvider.prototype.logoutLegacySites = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (siteIds) {
            var promises = [];
            siteIds.forEach(function (siteId) {
                promises.push(_this.sitesProvider.getSite(siteId).then(function (site) {
                    // If the site is a legacy site, mark it as logged out so the user has to authenticate again.
                    if (_this.sitesProvider.isLegacyMoodleByInfo(site.getInfo())) {
                        return _this.sitesProvider.setSiteLoggedOut(site.getId(), true);
                    }
                }));
            });
            return _this.utils.allPromises(promises);
        });
    };
    CoreUpdateManagerProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_7__sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_5__local_notifications__["a" /* CoreLocalNotificationsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_9__utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__addon_calendar_providers_calendar__["a" /* AddonCalendarProvider */]])
    ], CoreUpdateManagerProvider);
    return CoreUpdateManagerProvider;
}());

//# sourceMappingURL=update-manager.js.map

/***/ }),
/* 114 */,
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreIconComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreIconComponent_0;
/* unused harmony export View_CoreIconComponent_Host_0 */
/* unused harmony export CoreIconComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__icon__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular_config_config__ = __webpack_require__(6);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 



var styles_CoreIconComponent = [];
var RenderType_CoreIconComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreIconComponent, data: {} });

function View_CoreIconComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 0, "div", [], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"]))], null, null); }
function View_CoreIconComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-icon", [], null, null, null, View_CoreIconComponent_0, RenderType_CoreIconComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_1__icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular_config_config__["a" /* Config */]], null, null)], null, null); }
var CoreIconComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-icon", __WEBPACK_IMPORTED_MODULE_1__icon__["a" /* CoreIconComponent */], View_CoreIconComponent_Host_0, { name: "name", color: "color", slash: "slash", isActive: "isActive", md: "md", ios: "ios", fixedWidth: "fixed-width", ariaLabel: "label" }, {}, []);

//# sourceMappingURL=icon.ngfactory.js.map

/***/ }),
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreEmptyBoxComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreEmptyBoxComponent_0;
/* unused harmony export View_CoreEmptyBoxComponent_Host_0 */
/* unused harmony export CoreEmptyBoxComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__icon_icon_ngfactory__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__icon_icon__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__empty_box__ = __webpack_require__(107);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 






var styles_CoreEmptyBoxComponent = [];
var RenderType_CoreEmptyBoxComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreEmptyBoxComponent, data: {} });

function View_CoreEmptyBoxComponent_1(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 0, "img", [["role", "presentation"]], [[8, "src", 4]], null, null, null, null))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.image; _ck(_v, 0, 0, currVal_0); }); }
function View_CoreEmptyBoxComponent_2(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-icon", [], null, null, null, __WEBPACK_IMPORTED_MODULE_1__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_1__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_2__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.icon; _ck(_v, 1, 0, currVal_0); }, null); }
function View_CoreEmptyBoxComponent_3(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "p", [], [[2, "padding-top", null]], null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](1, null, ["", ""]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = (_co.image || _co.icon); _ck(_v, 0, 0, currVal_0); var currVal_1 = _co.message; _ck(_v, 1, 0, currVal_1); }); }
function View_CoreEmptyBoxComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 15, "div", [["class", "core-empty-box"]], [[2, "core-empty-box-inline", null]], null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](2, 0, null, null, 12, "div", [["class", "core-empty-box-content"], ["padding", ""]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreEmptyBoxComponent_1)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](5, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_4__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreEmptyBoxComponent_2)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](8, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_4__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreEmptyBoxComponent_3)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](11, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_4__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_43" /* ɵncd */](null, 0), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"]))], function (_ck, _v) { var _co = _v.component; var currVal_1 = (_co.image && !_co.icon); _ck(_v, 5, 0, currVal_1); var currVal_2 = _co.icon; _ck(_v, 8, 0, currVal_2); var currVal_3 = _co.message; _ck(_v, 11, 0, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = ((!_co.image && !_co.icon) || _co.inline); _ck(_v, 0, 0, currVal_0); }); }
function View_CoreEmptyBoxComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-empty-box", [], null, null, null, View_CoreEmptyBoxComponent_0, RenderType_CoreEmptyBoxComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 49152, null, 0, __WEBPACK_IMPORTED_MODULE_5__empty_box__["a" /* CoreEmptyBoxComponent */], [], null, null)], null, null); }
var CoreEmptyBoxComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-empty-box", __WEBPACK_IMPORTED_MODULE_5__empty_box__["a" /* CoreEmptyBoxComponent */], View_CoreEmptyBoxComponent_Host_0, { message: "message", icon: "icon", image: "image", inline: "inline" }, {}, ["*"]);

//# sourceMappingURL=empty-box.ngfactory.js.map

/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModDataFieldsDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__default_field_handler__ = __webpack_require__(563);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Delegate to register database fields handlers.
 */
var AddonModDataFieldsDelegate = /** @class */ (function (_super) {
    __extends(AddonModDataFieldsDelegate, _super);
    function AddonModDataFieldsDelegate(logger, sitesProvider, eventsProvider, utils, defaultHandler) {
        var _this = _super.call(this, 'AddonModDataFieldsDelegate', logger, sitesProvider, eventsProvider) || this;
        _this.utils = utils;
        _this.defaultHandler = defaultHandler;
        _this.handlerNameProperty = 'type';
        return _this;
    }
    /**
     * Get the component to use for a certain field field.
     *
     * @param {Injector} injector Injector.
     * @param {any} field         The field object.
     * @return {Promise<any>}     Promise resolved with the component to use, undefined if not found.
     */
    AddonModDataFieldsDelegate.prototype.getComponentForField = function (injector, field) {
        return Promise.resolve(this.executeFunctionOnEnabled(field.type, 'getComponent', [injector, field]));
    };
    /**
     * Get database data in the input data to search.
     *
     * @param  {any} field      Defines the field to be rendered.
     * @param  {any} inputData  Data entered in the search form.
     * @return {any}             Name and data field.
     */
    AddonModDataFieldsDelegate.prototype.getFieldSearchData = function (field, inputData) {
        return this.executeFunctionOnEnabled(field.type, 'getFieldSearchData', [field, inputData]);
    };
    /**
     * Get database data in the input data to add or update entry.
     *
     * @param  {any} field               Defines the field to be rendered.
     * @param  {any} inputData           Data entered in the search form.
     * @param  {any} originalFieldData   Original field entered data.
     * @return {any}                     Name and data field.
     */
    AddonModDataFieldsDelegate.prototype.getFieldEditData = function (field, inputData, originalFieldData) {
        return this.executeFunctionOnEnabled(field.type, 'getFieldEditData', [field, inputData, originalFieldData]);
    };
    /**
     * Get database data in the input files to add or update entry.
     *
     * @param  {any} field               Defines the field to be rendered.
     * @param  {any} inputData           Data entered in the search form.
     * @param  {any} originalFieldData   Original field entered data.
     * @return {any}                     Name and data field.
     */
    AddonModDataFieldsDelegate.prototype.getFieldEditFiles = function (field, inputData, originalFieldData) {
        return this.executeFunctionOnEnabled(field.type, 'getFieldEditFiles', [field, inputData, originalFieldData]);
    };
    /**
     * Check and get field requeriments.
     *
     * @param  {any} field      Defines the field to be rendered.
     * @param  {any} inputData  Data entered in the edit form.
     * @return {string}         String with the notification or false.
     */
    AddonModDataFieldsDelegate.prototype.getFieldsNotifications = function (field, inputData) {
        return this.executeFunctionOnEnabled(field.type, 'getFieldsNotifications', [field, inputData]);
    };
    /**
     * Check if field type manage files or not.
     *
     * @param  {any} field  Defines the field to be checked.
     * @return {boolean}    If the field type manages files.
     */
    AddonModDataFieldsDelegate.prototype.hasFiles = function (field) {
        return this.hasFunction(field.type, 'getFieldEditFiles');
    };
    /**
     * Check if the data has changed for a certain field.
     *
     * @param  {any} field               Defines the field to be rendered.
     * @param  {any} inputData           Data entered in the search form.
     * @param  {any} originalFieldData   Original field entered data.
     * @return {Promise<void>}           Promise rejected if has changed, resolved if no changes.
     */
    AddonModDataFieldsDelegate.prototype.hasFieldDataChanged = function (field, inputData, originalFieldData) {
        return Promise.resolve(this.executeFunctionOnEnabled(field.type, 'hasFieldDataChanged', [field, inputData, originalFieldData])).then(function (result) {
            return result ? Promise.reject(null) : Promise.resolve();
        });
    };
    /**
     * Check if a field plugin is supported.
     *
     * @param  {string} pluginType Type of the plugin.
     * @return {boolean}           True if supported, false otherwise.
     */
    AddonModDataFieldsDelegate.prototype.isPluginSupported = function (pluginType) {
        return this.hasHandler(pluginType, true);
    };
    /**
     * Override field content data with offline submission.
     *
     * @param  {any} field               Defines the field to be rendered.
     * @param  {any} originalContent     Original data to be overriden.
     * @param  {any}  offlineContent     Array with all the offline data to override.
     * @param  {any}  [offlineFiles]     Array with all the offline files in the field.
     * @return {any}                     Data overriden
     */
    AddonModDataFieldsDelegate.prototype.overrideData = function (field, originalContent, offlineContent, offlineFiles) {
        originalContent = originalContent || {};
        if (!offlineContent) {
            return originalContent;
        }
        return this.executeFunctionOnEnabled(field.type, 'overrideData', [originalContent, offlineContent, offlineFiles]);
    };
    AddonModDataFieldsDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__default_field_handler__["a" /* AddonModDataDefaultFieldHandler */]])
    ], AddonModDataFieldsDelegate);
    return AddonModDataFieldsDelegate;
}(__WEBPACK_IMPORTED_MODULE_5__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=fields-delegate.js.map

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreConfigConstants; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// tslint:disable: variable-name
var CoreConfigConstants = /** @class */ (function () {
    function CoreConfigConstants() {
    }
    CoreConfigConstants.app_id = 'com.moodle.moodlemobile';
    CoreConfigConstants.appname = 'Moodle Mobile';
    CoreConfigConstants.desktopappname = 'Moodle Desktop';
    CoreConfigConstants.versioncode = 3700;
    CoreConfigConstants.versionname = '3.7.0';
    CoreConfigConstants.cache_update_frequency_usually = 420000;
    CoreConfigConstants.cache_update_frequency_often = 1200000;
    CoreConfigConstants.cache_update_frequency_sometimes = 3600000;
    CoreConfigConstants.cache_update_frequency_rarely = 43200000;
    CoreConfigConstants.default_lang = 'en';
    CoreConfigConstants.languages = {
        'ar': 'عربي',
        'bg': 'Български',
        'ca': 'Català',
        'cs': 'Čeština',
        'da': 'Dansk',
        'de': 'Deutsch',
        'de-du': 'Deutsch - Du',
        'el': 'Ελληνικά',
        'en': 'English',
        'en-us': 'English - United States',
        'es': 'Español',
        'es-mx': 'Español - México',
        'eu': 'Euskara',
        'fa': 'فارسی',
        'fi': 'Suomi',
        'fr': 'Français',
        'he': 'עברית',
        'hi': 'हिंदी',
        'hr': 'Hrvatski',
        'hu': 'magyar',
        'id': 'Indonesian',
        'it': 'Italiano',
        'ja': '日本語',
        'km': 'ខ្មែរ',
        'kn': 'ಕನ್ನಡ',
        'ko': '한국어',
        'lt': 'Lietuvių',
        'mr': 'मराठी',
        'nl': 'Nederlands',
        'no': 'Norsk - bokmål',
        'pl': 'Polski',
        'pt': 'Português - Portugal',
        'pt-br': 'Português - Brasil',
        'ro': 'Română',
        'ru': 'Русский',
        'sr-cr': 'Српски',
        'sr-lt': 'Srpski',
        'sv': 'Svenska',
        'tg': 'Тоҷикӣ',
        'tr': 'Türkçe',
        'uk': 'Українська',
        'zh-cn': '简体中文',
        'zh-tw': '正體中文'
    };
    CoreConfigConstants.wsservice = 'moodle_mobile_app';
    CoreConfigConstants.wsextservice = 'local_mobile';
    CoreConfigConstants.customurlscheme = 'moodlemobile';
    CoreConfigConstants.siteurl = 'http://ti.utxicotepec.edu.mx';
    CoreConfigConstants.sitename = 'Virtual TI';
    CoreConfigConstants.multisitesdisplay = '';
    CoreConfigConstants.skipssoconfirmation = false;
    CoreConfigConstants.forcedefaultlanguage = false;
    CoreConfigConstants.privacypolicy = 'https://moodle.org/mod/page/view.php?id=8148';
    CoreConfigConstants.notificoncolor = '#f98012';
    CoreConfigConstants.statusbarbg = false;
    CoreConfigConstants.statusbarlighttext = false;
    CoreConfigConstants.statusbarbgios = '#f98012';
    CoreConfigConstants.statusbarlighttextios = true;
    CoreConfigConstants.statusbarbgandroid = '#df7310';
    CoreConfigConstants.statusbarlighttextandroid = true;
    CoreConfigConstants.statusbarbgremotetheme = '#000000';
    CoreConfigConstants.statusbarlighttextremotetheme = true;
    CoreConfigConstants.enableanalytics = false;
    CoreConfigConstants.compilationtime = 1559903179777;
    CoreConfigConstants.lastcommit = '6557e34f9718bab8bde741eefc09df9865e42a00';
    return CoreConfigConstants;
}());

//# sourceMappingURL=configconstants.js.map

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreQuestionProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to handle questions.
 */
var CoreQuestionProvider = /** @class */ (function () {
    function CoreQuestionProvider(logger, sitesProvider, timeUtils, utils) {
        this.sitesProvider = sitesProvider;
        this.timeUtils = timeUtils;
        this.utils = utils;
        // Variables for database.
        this.QUESTION_TABLE = 'questions';
        this.QUESTION_ANSWERS_TABLE = 'question_answers';
        this.siteSchema = {
            name: 'CoreQuestionProvider',
            version: 1,
            tables: [
                {
                    name: this.QUESTION_TABLE,
                    columns: [
                        {
                            name: 'component',
                            type: 'TEXT',
                            notNull: true
                        },
                        {
                            name: 'attemptid',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'slot',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'componentid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'number',
                            type: 'INTEGER'
                        },
                        {
                            name: 'state',
                            type: 'TEXT'
                        }
                    ],
                    primaryKeys: ['component', 'attemptid', 'slot']
                },
                {
                    name: this.QUESTION_ANSWERS_TABLE,
                    columns: [
                        {
                            name: 'component',
                            type: 'TEXT',
                            notNull: true
                        },
                        {
                            name: 'attemptid',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'name',
                            type: 'TEXT',
                            notNull: true
                        },
                        {
                            name: 'componentid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'questionslot',
                            type: 'INTEGER'
                        },
                        {
                            name: 'value',
                            type: 'TEXT'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['component', 'attemptid', 'name']
                }
            ]
        };
        this.QUESTION_PREFIX_REGEX = /q\d+:(\d+)_/;
        this.STATES = {
            todo: {
                name: 'todo',
                class: 'core-question-notyetanswered',
                status: 'notyetanswered',
                active: true,
                finished: false
            },
            invalid: {
                name: 'invalid',
                class: 'core-question-invalidanswer',
                status: 'invalidanswer',
                active: true,
                finished: false
            },
            complete: {
                name: 'complete',
                class: 'core-question-answersaved',
                status: 'answersaved',
                active: true,
                finished: false
            },
            needsgrading: {
                name: 'needsgrading',
                class: 'core-question-requiresgrading',
                status: 'requiresgrading',
                active: false,
                finished: true
            },
            finished: {
                name: 'finished',
                class: 'core-question-complete',
                status: 'complete',
                active: false,
                finished: true
            },
            gaveup: {
                name: 'gaveup',
                class: 'core-question-notanswered',
                status: 'notanswered',
                active: false,
                finished: true
            },
            gradedwrong: {
                name: 'gradedwrong',
                class: 'core-question-incorrect',
                status: 'incorrect',
                active: false,
                finished: true
            },
            gradedpartial: {
                name: 'gradedpartial',
                class: 'core-question-partiallycorrect',
                status: 'partiallycorrect',
                active: false,
                finished: true
            },
            gradedright: {
                name: 'gradedright',
                class: 'core-question-correct',
                status: 'correct',
                active: false,
                finished: true
            },
            mangrwrong: {
                name: 'mangrwrong',
                class: 'core-question-incorrect',
                status: 'incorrect',
                active: false,
                finished: true
            },
            mangrpartial: {
                name: 'mangrpartial',
                class: 'core-question-partiallycorrect',
                status: 'partiallycorrect',
                active: false,
                finished: true
            },
            mangrright: {
                name: 'mangrright',
                class: 'core-question-correct',
                status: 'correct',
                active: false,
                finished: true
            },
            cannotdeterminestatus: {
                name: 'cannotdeterminestatus',
                class: 'core-question-unknown',
                status: 'cannotdeterminestatus',
                active: true,
                finished: false
            }
        };
        this.logger = logger.getInstance('CoreQuestionProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    /**
     * Compare that all the answers in two objects are equal, except some extra data like sequencecheck or certainty.
     *
     * @param {any} prevAnswers Object with previous answers.
     * @param {any} newAnswers Object with new answers.
     * @return {boolean} Whether all answers are equal.
     */
    CoreQuestionProvider.prototype.compareAllAnswers = function (prevAnswers, newAnswers) {
        // Get all the keys.
        var keys = this.utils.mergeArraysWithoutDuplicates(Object.keys(prevAnswers), Object.keys(newAnswers));
        // Check that all the keys have the same value on both objects.
        for (var i in keys) {
            var key = keys[i];
            // Ignore extra answers like sequencecheck or certainty.
            if (!this.isExtraAnswer(key[0])) {
                if (!this.utils.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, key)) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * Convert a list of answers retrieved from local DB to an object with name - value.
     *
     * @param {any[]} answers List of answers.
     * @param {boolean} [removePrefix] Whether to remove the prefix in the answer's name.
     * @return {any} Object with name -> value.
     */
    CoreQuestionProvider.prototype.convertAnswersArrayToObject = function (answers, removePrefix) {
        var _this = this;
        var result = {};
        answers.forEach(function (answer) {
            if (removePrefix) {
                var nameWithoutPrefix = _this.removeQuestionPrefix(answer.name);
                result[nameWithoutPrefix] = answer.value;
            }
            else {
                result[answer.name] = answer.value;
            }
        });
        return result;
    };
    /**
     * Retrieve an answer from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} name Answer's name.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the answer.
     */
    CoreQuestionProvider.prototype.getAnswer = function (component, attemptId, name, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.QUESTION_ANSWERS_TABLE, { component: component, attemptid: attemptId, name: name });
        });
    };
    /**
     * Retrieve an attempt answers from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the answers.
     */
    CoreQuestionProvider.prototype.getAttemptAnswers = function (component, attemptId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(_this.QUESTION_ANSWERS_TABLE, { component: component, attemptid: attemptId });
        });
    };
    /**
     * Retrieve an attempt questions from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the questions.
     */
    CoreQuestionProvider.prototype.getAttemptQuestions = function (component, attemptId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(_this.QUESTION_TABLE, { component: component, attemptid: attemptId });
        });
    };
    /**
     * Get all the answers that aren't "extra" (sequencecheck, certainty, ...).
     *
     * @param {any} answers Object with all the answers.
     * @return {any} Object with the basic answers.
     */
    CoreQuestionProvider.prototype.getBasicAnswers = function (answers) {
        var result = {};
        for (var name_1 in answers) {
            if (!this.isExtraAnswer(name_1)) {
                result[name_1] = answers[name_1];
            }
        }
        return result;
    };
    /**
     * Get all the answers that aren't "extra" (sequencecheck, certainty, ...).
     *
     * @param {any[]} answers List of answers.
     * @return {any[]} List with the basic answers.
     */
    CoreQuestionProvider.prototype.getBasicAnswersFromArray = function (answers) {
        var _this = this;
        var result = [];
        answers.forEach(function (answer) {
            if (_this.isExtraAnswer(answer.name)) {
                result.push(answer);
            }
        });
        return result;
    };
    /**
     * Retrieve a question from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} slot Question slot.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the question.
     */
    CoreQuestionProvider.prototype.getQuestion = function (component, attemptId, slot, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.QUESTION_TABLE, { component: component, attemptid: attemptId, slot: slot });
        });
    };
    /**
     * Retrieve a question answers from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} slot Question slot.
     * @param {boolean} [filter] Whether it should ignore "extra" answers like sequencecheck or certainty.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the answers.
     */
    CoreQuestionProvider.prototype.getQuestionAnswers = function (component, attemptId, slot, filter, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(_this.QUESTION_ANSWERS_TABLE, { component: component, attemptid: attemptId,
                questionslot: slot }).then(function (answers) {
                if (filter) {
                    // Get only answers that isn't "extra" data like sequencecheck or certainty.
                    return _this.getBasicAnswersFromArray(answers);
                }
                else {
                    return answers;
                }
            });
        });
    };
    /**
     * Extract the question slot from a question name.
     *
     * @param {string} name Question name.
     * @return {number} Question slot.
     */
    CoreQuestionProvider.prototype.getQuestionSlotFromName = function (name) {
        if (name) {
            var match = name.match(this.QUESTION_PREFIX_REGEX);
            if (match && match[1]) {
                return parseInt(match[1], 10);
            }
        }
        return -1;
    };
    /**
     * Get question state based on state name.
     *
     * @param {string} name State name.
     * @return {CoreQuestionState} State.
     */
    CoreQuestionProvider.prototype.getState = function (name) {
        return this.STATES[name || 'cannotdeterminestatus'];
    };
    /**
     * Check if an answer is extra data like sequencecheck or certainty.
     *
     * @param {string} name Answer name.
     * @return {boolean} Whether it's extra data.
     */
    CoreQuestionProvider.prototype.isExtraAnswer = function (name) {
        // Maybe the name still has the prefix.
        name = this.removeQuestionPrefix(name);
        return name[0] == '-' || name[0] == ':';
    };
    /**
     * Remove an attempt answers from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreQuestionProvider.prototype.removeAttemptAnswers = function (component, attemptId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(_this.QUESTION_ANSWERS_TABLE, { component: component, attemptid: attemptId });
        });
    };
    /**
     * Remove an attempt questions from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreQuestionProvider.prototype.removeAttemptQuestions = function (component, attemptId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(_this.QUESTION_TABLE, { component: component, attemptid: attemptId });
        });
    };
    /**
     * Remove an answer from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} name Answer's name.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreQuestionProvider.prototype.removeAnswer = function (component, attemptId, name, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(_this.QUESTION_ANSWERS_TABLE, { component: component, attemptid: attemptId,
                name: name });
        });
    };
    /**
     * Remove a question from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} slot Question slot.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreQuestionProvider.prototype.removeQuestion = function (component, attemptId, slot, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(_this.QUESTION_TABLE, { component: component, attemptid: attemptId, slot: slot });
        });
    };
    /**
     * Remove a question answers from site DB.
     *
     * @param {string} component Component the attempt belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {string} slot Question slot.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreQuestionProvider.prototype.removeQuestionAnswers = function (component, attemptId, slot, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(_this.QUESTION_ANSWERS_TABLE, { component: component, attemptid: attemptId,
                questionslot: slot });
        });
    };
    /**
     * Remove the prefix from a question answer name.
     *
     * @param {string} name Question name.
     * @return {string} Name without prefix.
     */
    CoreQuestionProvider.prototype.removeQuestionPrefix = function (name) {
        if (name) {
            return name.replace(this.QUESTION_PREFIX_REGEX, '');
        }
        return '';
    };
    /**
     * Save answers in local DB.
     *
     * @param {string} component Component the answers belong to. E.g. 'mmaModQuiz'.
     * @param {number} componentId ID of the component the answers belong to.
     * @param {number} attemptId Attempt ID.
     * @param {number} userId User ID.
     * @param {any} answers Object with the answers to save.
     * @param {number} [timemodified] Time modified to set in the answers. If not defined, current time.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreQuestionProvider.prototype.saveAnswers = function (component, componentId, attemptId, userId, answers, timemodified, siteId) {
        var _this = this;
        timemodified = timemodified || this.timeUtils.timestamp();
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var db = site.getDb(), promises = [];
            for (var name_2 in answers) {
                var value = answers[name_2], entry = {
                    component: component,
                    componentid: componentId,
                    attemptid: attemptId,
                    userid: userId,
                    questionslot: _this.getQuestionSlotFromName(name_2),
                    name: name_2,
                    value: value,
                    timemodified: timemodified
                };
                promises.push(db.insertRecord(_this.QUESTION_ANSWERS_TABLE, entry));
            }
            return Promise.all(promises);
        });
    };
    /**
     * Save a question in local DB.
     *
     * @param {string} component Component the question belongs to. E.g. 'mmaModQuiz'.
     * @param {number} componentId ID of the component the question belongs to.
     * @param {number} attemptId Attempt ID.
     * @param {number} userId User ID.
     * @param {any} question The question to save.
     * @param {string} state Question's state.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreQuestionProvider.prototype.saveQuestion = function (component, componentId, attemptId, userId, question, state, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var entry = {
                component: component,
                componentid: componentId,
                attemptid: attemptId,
                userid: userId,
                number: question.number,
                slot: question.slot,
                state: state
            };
            return site.getDb().insertRecord(_this.QUESTION_TABLE, entry);
        });
    };
    CoreQuestionProvider.COMPONENT = 'mmQuestion';
    CoreQuestionProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreQuestionProvider);
    return CoreQuestionProvider;
}());

//# sourceMappingURL=question.js.map

/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModQuizAccessRuleDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_delegate__ = __webpack_require__(111);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Delegate to register access rules for quiz module.
 */
var AddonModQuizAccessRuleDelegate = /** @class */ (function (_super) {
    __extends(AddonModQuizAccessRuleDelegate, _super);
    function AddonModQuizAccessRuleDelegate(logger, sitesProvider, eventsProvider, utils) {
        var _this = _super.call(this, 'AddonModQuizAccessRulesDelegate', logger, sitesProvider, eventsProvider) || this;
        _this.utils = utils;
        _this.handlerNameProperty = 'ruleName';
        return _this;
    }
    /**
     * Get the handler for a certain rule.
     *
     * @param {string} ruleName Name of the access rule.
     * @return {AddonModQuizAccessRuleHandler} Handler. Undefined if no handler found for the rule.
     */
    AddonModQuizAccessRuleDelegate.prototype.getAccessRuleHandler = function (ruleName) {
        return this.getHandler(ruleName, true);
    };
    /**
     * Given a list of rules, get some fixed preflight data (data that doesn't require user interaction).
     *
     * @param {string[]} rules List of active rules names.
     * @param {any} quiz Quiz.
     * @param {any} preflightData Object where to store the preflight data.
     * @param {any} [attempt] The attempt started/continued. If not supplied, user is starting a new attempt.
     * @param {boolean} [prefetch] Whether the user is prefetching the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when all the data has been gathered.
     */
    AddonModQuizAccessRuleDelegate.prototype.getFixedPreflightData = function (rules, quiz, preflightData, attempt, prefetch, siteId) {
        var _this = this;
        rules = rules || [];
        var promises = [];
        rules.forEach(function (rule) {
            promises.push(Promise.resolve(_this.executeFunctionOnEnabled(rule, 'getFixedPreflightData', [quiz, preflightData, attempt, prefetch, siteId])));
        });
        return this.utils.allPromises(promises).catch(function () {
            // Never reject.
        });
    };
    /**
     * Get the Component to use to display the access rule preflight.
     *
     * @param {Injector} injector Injector.
     * @return {Promise<any>} Promise resolved with the component to use, undefined if not found.
     */
    AddonModQuizAccessRuleDelegate.prototype.getPreflightComponent = function (rule, injector) {
        return Promise.resolve(this.executeFunctionOnEnabled(rule, 'getPreflightComponent', [injector]));
    };
    /**
     * Check if an access rule is supported.
     *
     * @param {string} ruleName Name of the rule.
     * @return {boolean} Whether it's supported.
     */
    AddonModQuizAccessRuleDelegate.prototype.isAccessRuleSupported = function (ruleName) {
        return this.hasHandler(ruleName, true);
    };
    /**
     * Given a list of rules, check if preflight check is required.
     *
     * @param {string[]} rules List of active rules names.
     * @param {any} quiz Quiz.
     * @param {any} [attempt] The attempt started/continued. If not supplied, user is starting a new attempt.
     * @param {boolean} [prefetch] Whether the user is prefetching the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether it's required.
     */
    AddonModQuizAccessRuleDelegate.prototype.isPreflightCheckRequired = function (rules, quiz, attempt, prefetch, siteId) {
        var _this = this;
        rules = rules || [];
        var promises = [];
        var isRequired = false;
        rules.forEach(function (rule) {
            promises.push(_this.isPreflightCheckRequiredForRule(rule, quiz, attempt, prefetch, siteId).then(function (required) {
                if (required) {
                    isRequired = true;
                }
            }));
        });
        return this.utils.allPromises(promises).then(function () {
            return isRequired;
        }).catch(function () {
            // Never reject.
            return isRequired;
        });
    };
    /**
     * Check if preflight check is required for a certain rule.
     *
     * @param {string} rule Rule name.
     * @param {any} quiz Quiz.
     * @param {any} [attempt] The attempt started/continued. If not supplied, user is starting a new attempt.
     * @param {boolean} [prefetch] Whether the user is prefetching the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether it's required.
     */
    AddonModQuizAccessRuleDelegate.prototype.isPreflightCheckRequiredForRule = function (rule, quiz, attempt, prefetch, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(rule, 'isPreflightCheckRequired', [quiz, attempt, prefetch, siteId]));
    };
    /**
     * Notify all rules that the preflight check has passed.
     *
     * @param {string[]} rules List of active rules names.
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @param {any} preflightData Preflight data gathered.
     * @param {boolean} [prefetch] Whether the user is prefetching the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModQuizAccessRuleDelegate.prototype.notifyPreflightCheckPassed = function (rules, quiz, attempt, preflightData, prefetch, siteId) {
        var _this = this;
        rules = rules || [];
        var promises = [];
        rules.forEach(function (rule) {
            promises.push(Promise.resolve(_this.executeFunctionOnEnabled(rule, 'notifyPreflightCheckPassed', [quiz, attempt, preflightData, prefetch, siteId])));
        });
        return this.utils.allPromises(promises).catch(function () {
            // Never reject.
        });
    };
    /**
     * Notify all rules that the preflight check has failed.
     *
     * @param {string[]} rules List of active rules names.
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @param {any} preflightData Preflight data gathered.
     * @param {boolean} [prefetch] Whether the user is prefetching the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModQuizAccessRuleDelegate.prototype.notifyPreflightCheckFailed = function (rules, quiz, attempt, preflightData, prefetch, siteId) {
        var _this = this;
        rules = rules || [];
        var promises = [];
        rules.forEach(function (rule) {
            promises.push(Promise.resolve(_this.executeFunctionOnEnabled(rule, 'notifyPreflightCheckFailed', [quiz, attempt, preflightData, prefetch, siteId])));
        });
        return this.utils.allPromises(promises).catch(function () {
            // Never reject.
        });
    };
    /**
     * Whether or not the time left of an attempt should be displayed.
     *
     * @param {string[]} rules List of active rules names.
     * @param {any} attempt The attempt.
     * @param {number} endTime The attempt end time (in seconds).
     * @param {number} timeNow The current time in seconds.
     * @return {boolean} Whether it should be displayed.
     */
    AddonModQuizAccessRuleDelegate.prototype.shouldShowTimeLeft = function (rules, attempt, endTime, timeNow) {
        rules = rules || [];
        for (var i in rules) {
            var rule = rules[i];
            if (this.executeFunctionOnEnabled(rule, 'shouldShowTimeLeft', [attempt, endTime, timeNow])) {
                return true;
            }
        }
        return false;
    };
    AddonModQuizAccessRuleDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonModQuizAccessRuleDelegate);
    return AddonModQuizAccessRuleDelegate;
}(__WEBPACK_IMPORTED_MODULE_5__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=access-rules-delegate.js.map

/***/ }),
/* 124 */,
/* 125 */
/***/ (function(module, exports) {

module.exports = require('electron');

/***/ }),
/* 126 */,
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModAssignOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__ = __webpack_require__(24);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to handle offline assign.
 */
var AddonModAssignOfflineProvider = /** @class */ (function () {
    function AddonModAssignOfflineProvider(logger, sitesProvider, textUtils, fileProvider, timeUtils) {
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.timeUtils = timeUtils;
        this.siteSchema = {
            name: 'AddonModAssignOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModAssignOfflineProvider_1.SUBMISSIONS_TABLE,
                    columns: [
                        {
                            name: 'assignid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'plugindata',
                            type: 'TEXT'
                        },
                        {
                            name: 'onlinetimemodified',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        },
                        {
                            name: 'submitted',
                            type: 'INTEGER'
                        },
                        {
                            name: 'submissionstatement',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['assignid', 'userid']
                },
                {
                    name: AddonModAssignOfflineProvider_1.SUBMISSIONS_GRADES_TABLE,
                    columns: [
                        {
                            name: 'assignid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'grade',
                            type: 'REAL'
                        },
                        {
                            name: 'attemptnumber',
                            type: 'INTEGER'
                        },
                        {
                            name: 'addattempt',
                            type: 'INTEGER'
                        },
                        {
                            name: 'workflowstate',
                            type: 'TEXT'
                        },
                        {
                            name: 'applytoall',
                            type: 'INTEGER'
                        },
                        {
                            name: 'outcomes',
                            type: 'TEXT'
                        },
                        {
                            name: 'plugindata',
                            type: 'TEXT'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['assignid', 'userid']
                }
            ]
        };
        this.logger = logger.getInstance('AddonModAssignOfflineProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModAssignOfflineProvider_1 = AddonModAssignOfflineProvider;
    /**
     * Delete a submission.
     *
     * @param {number} assignId Assignment ID.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if deleted, rejected if failure.
     */
    AddonModAssignOfflineProvider.prototype.deleteSubmission = function (assignId, userId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().deleteRecords(AddonModAssignOfflineProvider_1.SUBMISSIONS_TABLE, { assignid: assignId, userid: userId });
        });
    };
    /**
     * Delete a submission grade.
     *
     * @param {number} assignId Assignment ID.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if deleted, rejected if failure.
     */
    AddonModAssignOfflineProvider.prototype.deleteSubmissionGrade = function (assignId, userId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().deleteRecords(AddonModAssignOfflineProvider_1.SUBMISSIONS_GRADES_TABLE, { assignid: assignId, userid: userId });
        });
    };
    /**
     * Get all the assignments ids that have something to be synced.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number[]>} Promise resolved with assignments id that have something to be synced.
     */
    AddonModAssignOfflineProvider.prototype.getAllAssigns = function (siteId) {
        var promises = [];
        promises.push(this.getAllSubmissions(siteId));
        promises.push(this.getAllSubmissionsGrade(siteId));
        return Promise.all(promises).then(function (results) {
            // Flatten array.
            results = [].concat.apply([], results);
            // Get assign id.
            results = results.map(function (object) {
                return object.assignid;
            });
            // Get unique values.
            results = results.filter(function (id, pos) {
                return results.indexOf(id) == pos;
            });
            return results;
        });
    };
    /**
     * Get all the stored submissions from all the assignments.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]} Promise resolved with submissions.
     */
    AddonModAssignOfflineProvider.prototype.getAllSubmissions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getAllRecords(AddonModAssignOfflineProvider_1.SUBMISSIONS_TABLE);
        }).then(function (submissions) {
            // Parse the plugin data.
            submissions.forEach(function (submission) {
                submission.plugindata = _this.textUtils.parseJSON(submission.plugindata, {});
            });
            return submissions;
        });
    };
    /**
     * Get all the stored submissions grades from all the assignments.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with submissions grades.
     */
    AddonModAssignOfflineProvider.prototype.getAllSubmissionsGrade = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getAllRecords(AddonModAssignOfflineProvider_1.SUBMISSIONS_GRADES_TABLE);
        }).then(function (submissions) {
            // Parse the plugin data and outcomes.
            submissions.forEach(function (submission) {
                submission.outcomes = _this.textUtils.parseJSON(submission.outcomes, {});
                submission.plugindata = _this.textUtils.parseJSON(submission.plugindata, {});
            });
            return submissions;
        });
    };
    /**
     * Get all the stored submissions for a certain assignment.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with submissions.
     */
    AddonModAssignOfflineProvider.prototype.getAssignSubmissions = function (assignId, siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecords(AddonModAssignOfflineProvider_1.SUBMISSIONS_TABLE, { assignid: assignId });
        }).then(function (submissions) {
            // Parse the plugin data.
            submissions.forEach(function (submission) {
                submission.plugindata = _this.textUtils.parseJSON(submission.plugindata, {});
            });
            return submissions;
        });
    };
    /**
     * Get all the stored submissions grades for a certain assignment.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with submissions grades.
     */
    AddonModAssignOfflineProvider.prototype.getAssignSubmissionsGrade = function (assignId, siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecords(AddonModAssignOfflineProvider_1.SUBMISSIONS_GRADES_TABLE, { assignid: assignId });
        }).then(function (submissions) {
            // Parse the plugin data and outcomes.
            submissions.forEach(function (submission) {
                submission.outcomes = _this.textUtils.parseJSON(submission.outcomes, {});
                submission.plugindata = _this.textUtils.parseJSON(submission.plugindata, {});
            });
            return submissions;
        });
    };
    /**
     * Get a stored submission.
     *
     * @param {number} assignId Assignment ID.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with submission.
     */
    AddonModAssignOfflineProvider.prototype.getSubmission = function (assignId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().getRecord(AddonModAssignOfflineProvider_1.SUBMISSIONS_TABLE, { assignid: assignId, userid: userId });
        }).then(function (submission) {
            // Parse the plugin data.
            submission.plugindata = _this.textUtils.parseJSON(submission.plugindata, {});
            return submission;
        });
    };
    /**
     * Get the path to the folder where to store files for an offline submission.
     *
     * @param {number} assignId Assignment ID.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the path.
     */
    AddonModAssignOfflineProvider.prototype.getSubmissionFolder = function (assignId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var siteFolderPath = _this.fileProvider.getSiteFolder(site.getId()), submissionFolderPath = 'offlineassign/' + assignId + '/' + userId;
            return _this.textUtils.concatenatePaths(siteFolderPath, submissionFolderPath);
        });
    };
    /**
     * Get a stored submission grade.
     * Submission grades are not identified using attempt number so it can retrieve the feedback for a previous attempt.
     *
     * @param {number} assignId Assignment ID.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with submission grade.
     */
    AddonModAssignOfflineProvider.prototype.getSubmissionGrade = function (assignId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().getRecord(AddonModAssignOfflineProvider_1.SUBMISSIONS_GRADES_TABLE, { assignid: assignId, userid: userId });
        }).then(function (submission) {
            // Parse the plugin data and outcomes.
            submission.outcomes = _this.textUtils.parseJSON(submission.outcomes, {});
            submission.plugindata = _this.textUtils.parseJSON(submission.plugindata, {});
            return submission;
        });
    };
    /**
     * Get the path to the folder where to store files for a certain plugin in an offline submission.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} pluginName Name of the plugin. Must be unique (both in submission and feedback plugins).
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the path.
     */
    AddonModAssignOfflineProvider.prototype.getSubmissionPluginFolder = function (assignId, pluginName, userId, siteId) {
        var _this = this;
        return this.getSubmissionFolder(assignId, userId, siteId).then(function (folderPath) {
            return _this.textUtils.concatenatePaths(folderPath, pluginName);
        });
    };
    /**
     * Check if the assignment has something to be synced.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the assignment has something to be synced.
     */
    AddonModAssignOfflineProvider.prototype.hasAssignOfflineData = function (assignId, siteId) {
        var promises = [];
        promises.push(this.getAssignSubmissions(assignId, siteId));
        promises.push(this.getAssignSubmissionsGrade(assignId, siteId));
        return Promise.all(promises).then(function (results) {
            for (var i = 0; i < results.length; i++) {
                var result = results[i];
                if (result && result.length) {
                    return true;
                }
            }
            return false;
        }).catch(function () {
            // No offline data found.
            return false;
        });
    };
    /**
     * Mark/Unmark a submission as being submitted.
     *
     * @param {number} assignId Assignment ID.
     * @param {number} courseId Course ID the assign belongs to.
     * @param {boolean} submitted True to mark as submitted, false to mark as not submitted.
     * @param {boolean} acceptStatement True to accept the submission statement, false otherwise.
     * @param {number} timemodified The time the submission was last modified in online.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if marked, rejected if failure.
     */
    AddonModAssignOfflineProvider.prototype.markSubmitted = function (assignId, courseId, submitted, acceptStatement, timemodified, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            // Check if there's a submission stored.
            return _this.getSubmission(assignId, userId, site.getId()).catch(function () {
                // No submission, create an empty one.
                var now = _this.timeUtils.timestamp();
                return {
                    assignid: assignId,
                    courseid: courseId,
                    userid: userId,
                    onlinetimemodified: timemodified,
                    timecreated: now,
                    timemodified: now
                };
            }).then(function (submission) {
                // Mark the submission.
                submission.submitted = submitted ? 1 : 0;
                submission.submissionstatement = acceptStatement ? 1 : 0;
                submission.plugindata = submission.plugindata ? JSON.stringify(submission.plugindata) : '{}';
                return site.getDb().insertRecord(AddonModAssignOfflineProvider_1.SUBMISSIONS_TABLE, submission);
            });
        });
    };
    /**
     * Save a submission to be sent later.
     *
     * @param {number} assignId Assignment ID.
     * @param {number} courseId Course ID the assign belongs to.
     * @param {any} pluginData Data to save.
     * @param {number} timemodified The time the submission was last modified in online.
     * @param {boolean} submitted True if submission has been submitted, false otherwise.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if stored, rejected if failure.
     */
    AddonModAssignOfflineProvider.prototype.saveSubmission = function (assignId, courseId, pluginData, timemodified, submitted, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var now = _this.timeUtils.timestamp(), entry = {
                assignid: assignId,
                courseid: courseId,
                plugindata: pluginData ? JSON.stringify(pluginData) : '{}',
                userid: userId,
                submitted: submitted ? 1 : 0,
                timecreated: now,
                timemodified: now,
                onlinetimemodified: timemodified
            };
            return site.getDb().insertRecord(AddonModAssignOfflineProvider_1.SUBMISSIONS_TABLE, entry);
        });
    };
    /**
     * Save a grading to be sent later.
     *
     * @param {number} assignId Assign ID.
     * @param {number} userId User ID.
     * @param {number} courseId Course ID the assign belongs to.
     * @param {number} grade Grade to submit.
     * @param {number} attemptNumber Number of the attempt being graded.
     * @param {boolean} addAttempt Admit the user to attempt again.
     * @param {string} workflowState Next workflow State.
     * @param {boolean} applyToAll If it's a team submission, whether the grade applies to all group members.
     * @param {any} outcomes Object including all outcomes values. If empty, any of them will be sent.
     * @param {any} pluginData Plugin data to save.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if stored, rejected if failure.
     */
    AddonModAssignOfflineProvider.prototype.submitGradingForm = function (assignId, userId, courseId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes, pluginData, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var now = _this.timeUtils.timestamp(), entry = {
                assignid: assignId,
                userid: userId,
                courseid: courseId,
                grade: grade,
                attemptnumber: attemptNumber,
                addattempt: addAttempt ? 1 : 0,
                workflowstate: workflowState,
                applytoall: applyToAll ? 1 : 0,
                outcomes: outcomes ? JSON.stringify(outcomes) : '{}',
                plugindata: pluginData ? JSON.stringify(pluginData) : '{}',
                timemodified: now
            };
            return site.getDb().insertRecord(AddonModAssignOfflineProvider_1.SUBMISSIONS_GRADES_TABLE, entry);
        });
    };
    // Variables for database.
    AddonModAssignOfflineProvider.SUBMISSIONS_TABLE = 'addon_mod_assign_submissions';
    AddonModAssignOfflineProvider.SUBMISSIONS_GRADES_TABLE = 'addon_mod_assign_submissions_grading';
    AddonModAssignOfflineProvider = AddonModAssignOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__["a" /* CoreTimeUtilsProvider */]])
    ], AddonModAssignOfflineProvider);
    return AddonModAssignOfflineProvider;
    var AddonModAssignOfflineProvider_1;
}());

//# sourceMappingURL=assign-offline.js.map

/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreQuestionHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__question__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__delegate__ = __webpack_require__(68);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Service with some common functions to handle questions.
 */
var CoreQuestionHelperProvider = /** @class */ (function () {
    function CoreQuestionHelperProvider(domUtils, textUtils, questionProvider, sitesProvider, translate, urlUtils, utils, filepoolProvider, questionDelegate) {
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        this.questionProvider = questionProvider;
        this.sitesProvider = sitesProvider;
        this.translate = translate;
        this.urlUtils = urlUtils;
        this.utils = utils;
        this.filepoolProvider = filepoolProvider;
        this.questionDelegate = questionDelegate;
        this.lastErrorShown = 0;
    }
    /**
     * Add a behaviour button to the question's "behaviourButtons" property.
     *
     * @param {any} question Question.
     * @param {HTMLInputElement} button Behaviour button (DOM element).
     */
    CoreQuestionHelperProvider.prototype.addBehaviourButton = function (question, button) {
        if (!button || !question) {
            return;
        }
        if (!question.behaviourButtons) {
            question.behaviourButtons = [];
        }
        // Extract the data we want.
        question.behaviourButtons.push({
            id: button.id,
            name: button.name,
            value: button.value,
            disabled: button.disabled
        });
    };
    /**
     * Extract question behaviour submit buttons from the question's HTML and add them to "behaviourButtons" property.
     * The buttons aren't deleted from the content because all the im-controls block will be removed afterwards.
     *
     * @param {any} question Question to treat.
     * @param {string} [selector] Selector to search the buttons. By default, '.im-controls input[type="submit"]'.
     */
    CoreQuestionHelperProvider.prototype.extractQbehaviourButtons = function (question, selector) {
        var _this = this;
        selector = selector || '.im-controls input[type="submit"]';
        var element = this.domUtils.convertToElement(question.html);
        // Search the buttons.
        var buttons = Array.from(element.querySelectorAll(selector));
        buttons.forEach(function (button) {
            _this.addBehaviourButton(question, button);
        });
        question.html = element.innerHTML;
    };
    /**
     * Check if the question has CBM and, if so, extract the certainty options and add them to a new
     * "behaviourCertaintyOptions" property.
     * The value of the selected option is stored in question.behaviourCertaintySelected.
     * We don't remove them from HTML because the whole im-controls block will be removed afterwards.
     *
     * @param {any} question Question to treat.
     * @return {boolean} Wether the certainty is found.
     */
    CoreQuestionHelperProvider.prototype.extractQbehaviourCBM = function (question) {
        var _this = this;
        var element = this.domUtils.convertToElement(question.html);
        var labels = Array.from(element.querySelectorAll('.im-controls .certaintychoices label[for*="certainty"]'));
        question.behaviourCertaintyOptions = [];
        labels.forEach(function (label) {
            // Search the radio button inside this certainty and add its data to the options array.
            var input = label.querySelector('input[type="radio"]');
            if (input) {
                question.behaviourCertaintyOptions.push({
                    id: input.id,
                    name: input.name,
                    value: input.value,
                    text: _this.textUtils.cleanTags(label.innerHTML),
                    disabled: input.disabled
                });
                if (input.checked) {
                    question.behaviourCertaintySelected = input.value;
                }
            }
        });
        // If we have a certainty value stored in local we'll use that one.
        if (question.localAnswers && typeof question.localAnswers['-certainty'] != 'undefined') {
            question.behaviourCertaintySelected = question.localAnswers['-certainty'];
        }
        return labels.length > 0;
    };
    /**
     * Check if the question has a redo button and, if so, add it to "behaviourButtons" property
     * and remove it from the HTML.
     *
     * @param {any} question Question to treat.
     */
    CoreQuestionHelperProvider.prototype.extractQbehaviourRedoButton = function (question) {
        // Create a fake div element so we can search using querySelector.
        var redoSelector = 'input[type="submit"][name*=redoslot], input[type="submit"][name*=tryagain]';
        // Search redo button in feedback.
        if (!this.searchBehaviourButton(question, 'html', '.outcome ' + redoSelector)) {
            // Not found in question HTML.
            if (question.feedbackHtml) {
                // We extracted the feedback already, search it in there.
                if (this.searchBehaviourButton(question, 'feedbackHtml', redoSelector)) {
                    // Button found, stop.
                    return;
                }
            }
            // Button still not found. Now search in the info box if it exists.
            if (question.infoHtml) {
                this.searchBehaviourButton(question, 'infoHtml', redoSelector);
            }
        }
    };
    /**
     * Check if the question contains a "seen" input.
     * If so, add the name and value to a "behaviourSeenInput" property and remove the input.
     *
     * @param {any} question Question to treat.
     * @return {boolean} Whether the seen input is found.
     */
    CoreQuestionHelperProvider.prototype.extractQbehaviourSeenInput = function (question) {
        var element = this.domUtils.convertToElement(question.html);
        // Search the "seen" input.
        var seenInput = element.querySelector('input[type="hidden"][name*=seen]');
        if (seenInput) {
            // Get the data and remove the input.
            question.behaviourSeenInput = {
                name: seenInput.name,
                value: seenInput.value
            };
            seenInput.parentElement.removeChild(seenInput);
            question.html = element.innerHTML;
            return true;
        }
        return false;
    };
    /**
     * Removes the comment from the question HTML code and adds it in a new "commentHtml" property.
     *
     * @param {any} question Question.
     */
    CoreQuestionHelperProvider.prototype.extractQuestionComment = function (question) {
        this.extractQuestionLastElementNotInContent(question, '.comment', 'commentHtml');
    };
    /**
     * Removes the feedback from the question HTML code and adds it in a new "feedbackHtml" property.
     *
     * @param {any} question Question.
     */
    CoreQuestionHelperProvider.prototype.extractQuestionFeedback = function (question) {
        this.extractQuestionLastElementNotInContent(question, '.outcome', 'feedbackHtml');
    };
    /**
     * Extracts the info box from a question and add it to an "infoHtml" property.
     *
     * @param {any} question Question.
     * @param {string} selector Selector to search the element.
     */
    CoreQuestionHelperProvider.prototype.extractQuestionInfoBox = function (question, selector) {
        this.extractQuestionLastElementNotInContent(question, selector, 'infoHtml');
    };
    /**
     * Searches the last occurrence of a certain element and check it's not in the question contents.
     * If found, removes it from the question HTML and adds it to a new property inside question.
     *
     * @param {any} question Question.
     * @param {string} selector Selector to search the element.
     * @param {string} attrName Name of the attribute to store the HTML in.
     */
    CoreQuestionHelperProvider.prototype.extractQuestionLastElementNotInContent = function (question, selector, attrName) {
        var element = this.domUtils.convertToElement(question.html);
        var matches = Array.from(element.querySelectorAll(selector));
        // Get the last element and check it's not in the question contents.
        var last = matches.pop();
        while (last) {
            if (!this.domUtils.closest(last, '.formulation')) {
                // Not in question contents. Add it to a separate attribute and remove it from the HTML.
                question[attrName] = last.innerHTML;
                last.parentElement.removeChild(last);
                question.html = element.innerHTML;
                return;
            }
            // It's inside the question content, treat next element.
            last = matches.pop();
        }
    };
    /**
     * Removes the scripts from a question's HTML and adds it in a new 'scriptsCode' property.
     * It will also search for init_question functions of the question type and add the object to an 'initObjects' property.
     *
     * @param {any} question Question.
     * @param {number} usageId Usage ID.
     */
    CoreQuestionHelperProvider.prototype.extractQuestionScripts = function (question, usageId) {
        var _this = this;
        question.scriptsCode = '';
        question.initObjects = null;
        question.amdArgs = null;
        if (question.html) {
            // Search the scripts.
            var matches = question.html.match(/<script[^>]*>[\s\S]*?<\/script>/mg);
            if (!matches) {
                // No scripts, stop.
                return;
            }
            matches.forEach(function (match) {
                // Add the script to scriptsCode and remove it from html.
                question.scriptsCode += match;
                question.html = question.html.replace(match, '');
                // Search init_question functions for this type.
                var initMatches = match.match(new RegExp('M\.qtype_' + question.type + '\.init_question\\(.*?}\\);', 'mg'));
                if (initMatches) {
                    var initMatch = initMatches.pop();
                    // Remove start and end of the match, we only want the object.
                    initMatch = initMatch.replace('M.qtype_' + question.type + '.init_question(', '');
                    initMatch = initMatch.substr(0, initMatch.length - 2);
                    // Try to convert it to an object and add it to the question.
                    question.initObjects = _this.textUtils.parseJSON(initMatch, null);
                }
                var amdRegExp = new RegExp('require\\(\\["qtype_' + question.type + '/question"\\], ' +
                    'function\\(amd\\) \\{ amd\.init\\(("(q|question-' + usageId + '-)' + question.slot +
                    '".*?)\\); \\}\\);;', 'm');
                var amdMatch = match.match(amdRegExp);
                if (amdMatch) {
                    // Try to convert the arguments to an array and add them to the question.
                    question.amdArgs = _this.textUtils.parseJSON('[' + amdMatch[1] + ']', null);
                }
            });
        }
    };
    /**
     * Get the names of all the inputs inside an HTML code.
     * This function will return an object where the keys are the input names. The values will always be true.
     * This is in order to make this function compatible with other functions like CoreQuestionProvider.getBasicAnswers.
     *
     * @param {string} html HTML code.
     * @return {any} Object where the keys are the names.
     */
    CoreQuestionHelperProvider.prototype.getAllInputNamesFromHtml = function (html) {
        var _this = this;
        var element = this.domUtils.convertToElement('<form>' + html + '</form>'), form = element.children[0], answers = {};
        // Search all input elements.
        Array.from(form.elements).forEach(function (element) {
            var name = element.name || '';
            // Ignore flag and submit inputs.
            if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {
                return;
            }
            answers[_this.questionProvider.removeQuestionPrefix(name)] = true;
        });
        return answers;
    };
    /**
     * Retrieve the answers entered in a form.
     * We don't use ngModel because it doesn't detect changes done by JavaScript and some questions might do that.
     *
     * @param {HTMLFormElement} form Form.
     * @return {any} Object with the answers.
     */
    CoreQuestionHelperProvider.prototype.getAnswersFromForm = function (form) {
        if (!form || !form.elements) {
            return {};
        }
        var answers = {}, elements = Array.from(form.elements);
        elements.forEach(function (element) {
            var name = element.name || element.getAttribute('ng-reflect-name') || '';
            // Ignore flag and submit inputs.
            if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {
                return;
            }
            // Get the value.
            if (element.type == 'checkbox') {
                answers[name] = !!element.checked;
            }
            else if (element.type == 'radio') {
                if (element.checked) {
                    answers[name] = element.value;
                }
            }
            else {
                answers[name] = element.value;
            }
        });
        return answers;
    };
    /**
     * Given an HTML code with list of attachments, returns the list of attached files (filename and fileurl).
     * Please take into account that this function will treat all the anchors in the HTML, you should provide
     * an HTML containing only the attachments anchors.
     *
     * @param  {String} html HTML code to search in.
     * @return {Object[]}    Attachments.
     */
    CoreQuestionHelperProvider.prototype.getQuestionAttachmentsFromHtml = function (html) {
        var _this = this;
        var element = this.domUtils.convertToElement(html);
        // Remove the filemanager (area to attach files to a question).
        this.domUtils.removeElement(element, 'div[id*=filemanager]');
        // Search the anchors.
        var anchors = Array.from(element.querySelectorAll('a')), attachments = [];
        anchors.forEach(function (anchor) {
            var content = anchor.innerHTML;
            // Check anchor is valid.
            if (anchor.href && content) {
                content = _this.textUtils.cleanTags(content, true).trim();
                attachments.push({
                    filename: content,
                    fileurl: anchor.href
                });
            }
        });
        return attachments;
    };
    /**
     * Get the sequence check from a question HTML.
     *
     * @param {string} html Question's HTML.
     * @return {{name: string, value: string}} Object with the sequencecheck name and value.
     */
    CoreQuestionHelperProvider.prototype.getQuestionSequenceCheckFromHtml = function (html) {
        if (html) {
            var element = this.domUtils.convertToElement(html);
            // Search the input holding the sequencecheck.
            var input = element.querySelector('input[name*=sequencecheck]');
            if (input && typeof input.name != 'undefined' && typeof input.value != 'undefined') {
                return {
                    name: input.name,
                    value: input.value
                };
            }
        }
    };
    /**
     * Get the CSS class for a question based on its state.
     *
     * @param {string} name Question's state name.
     * @return {string} State class.
     */
    CoreQuestionHelperProvider.prototype.getQuestionStateClass = function (name) {
        var state = this.questionProvider.getState(name);
        return state ? state.class : '';
    };
    /**
     * Get the validation error message from a question HTML if it's there.
     *
     * @param {string} html Question's HTML.
     * @return {string} Validation error message if present.
     */
    CoreQuestionHelperProvider.prototype.getValidationErrorFromHtml = function (html) {
        var element = this.domUtils.convertToElement(html);
        return this.domUtils.getContentsOfElement(element, '.validationerror');
    };
    /**
     * Check if some HTML contains draft file URLs for the current site.
     *
     * @param {string} html Question's HTML.
     * @return {boolean} Whether it contains draft files URLs.
     */
    CoreQuestionHelperProvider.prototype.hasDraftFileUrls = function (html) {
        var url = this.sitesProvider.getCurrentSite().getURL();
        if (url.slice(-1) != '/') {
            url = url += '/';
        }
        url += 'draftfile.php';
        return html.indexOf(url) != -1;
    };
    /**
     * For each input element found in the HTML, search if there's a local answer stored and
     * override the HTML's value with the local one.
     *
     * @param {any} question Question.
     */
    CoreQuestionHelperProvider.prototype.loadLocalAnswersInHtml = function (question) {
        var _this = this;
        var element = this.domUtils.convertToElement('<form>' + question.html + '</form>'), form = element.children[0];
        // Search all input elements.
        Array.from(form.elements).forEach(function (element) {
            var name = element.name || '';
            // Ignore flag and submit inputs.
            if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {
                return;
            }
            // Search if there's a local answer.
            name = _this.questionProvider.removeQuestionPrefix(name);
            if (question.localAnswers && typeof question.localAnswers[name] != 'undefined') {
                if (element.tagName == 'TEXTAREA') {
                    // Just put the answer inside the textarea.
                    element.innerHTML = question.localAnswers[name];
                }
                else if (element.tagName == 'SELECT') {
                    // Search the selected option and select it.
                    var selected = element.querySelector('option[value="' + question.localAnswers[name] + '"]');
                    if (selected) {
                        selected.setAttribute('selected', 'selected');
                    }
                }
                else if (element.type == 'radio') {
                    // Check if this radio is selected.
                    if (element.value == question.localAnswers[name]) {
                        element.setAttribute('checked', 'checked');
                    }
                    else {
                        element.removeAttribute('checked');
                    }
                }
                else if (element.type == 'checkbox') {
                    // Check if this checkbox is checked.
                    if (_this.utils.isTrueOrOne(question.localAnswers[name])) {
                        element.setAttribute('checked', 'checked');
                    }
                    else {
                        element.removeAttribute('checked');
                    }
                }
                else {
                    // Put the answer in the value.
                    element.setAttribute('value', question.localAnswers[name]);
                }
            }
        });
        // Update the question HTML.
        question.html = form.innerHTML;
    };
    /**
     * Prefetch the files in a question HTML.
     *
     * @param {any} question Question.
     * @param {string} [component] The component to link the files to. If not defined, question component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component. If not defined, question ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [usageId] Usage ID. Required in Moodle 3.7+.
     * @return {Promise<any>} Promise resolved when all the files have been downloaded.
     */
    CoreQuestionHelperProvider.prototype.prefetchQuestionFiles = function (question, component, componentId, siteId, usageId) {
        var _this = this;
        var urls = this.domUtils.extractDownloadableFilesFromHtml(question.html);
        if (!component) {
            component = __WEBPACK_IMPORTED_MODULE_8__question__["a" /* CoreQuestionProvider */].COMPONENT;
            componentId = question.id;
        }
        urls.push.apply(urls, this.questionDelegate.getAdditionalDownloadableFiles(question, usageId));
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [];
            urls.forEach(function (url) {
                if (!site.canDownloadFiles() && _this.urlUtils.isPluginFileUrl(url)) {
                    return;
                }
                if (url.indexOf('theme/image.php') > -1 && url.indexOf('flagged') > -1) {
                    // Ignore flag images.
                    return;
                }
                promises.push(_this.filepoolProvider.addToQueueByUrl(siteId, url, component, componentId));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Prepare and return the answers.
     *
     * @param {any[]} questions The list of questions.
     * @param {any} answers The input data.
     * @param {boolean} offline True if data should be saved in offline.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with answers to send to server.
     */
    CoreQuestionHelperProvider.prototype.prepareAnswers = function (questions, answers, offline, siteId) {
        var _this = this;
        var promises = [];
        questions = questions || [];
        questions.forEach(function (question) {
            promises.push(_this.questionDelegate.prepareAnswersForQuestion(question, answers, offline, siteId));
        });
        return this.utils.allPromises(promises).then(function () {
            return answers;
        });
    };
    /**
     * Replace Moodle's correct/incorrect classes with the Mobile ones.
     *
     * @param {HTMLElement} element DOM element.
     */
    CoreQuestionHelperProvider.prototype.replaceCorrectnessClasses = function (element) {
        this.domUtils.replaceClassesInElement(element, {
            correct: 'core-question-answer-correct',
            incorrect: 'core-question-answer-incorrect'
        });
    };
    /**
     * Replace Moodle's feedback classes with the Mobile ones.
     *
     * @param {HTMLElement} element DOM element.
     */
    CoreQuestionHelperProvider.prototype.replaceFeedbackClasses = function (element) {
        this.domUtils.replaceClassesInElement(element, {
            outcome: 'core-question-feedback-container core-question-feedback-padding',
            specificfeedback: 'core-question-feedback-container core-question-feedback-inline'
        });
    };
    /**
     * Search a behaviour button in a certain question property containing HTML.
     *
     * @param {any} question Question.
     * @param {string} htmlProperty The name of the property containing the HTML to search.
     * @param {string} selector The selector to find the button.
     * @return {boolean} Whether the button is found.
     */
    CoreQuestionHelperProvider.prototype.searchBehaviourButton = function (question, htmlProperty, selector) {
        var element = this.domUtils.convertToElement(question[htmlProperty]);
        var button = element.querySelector(selector);
        if (button) {
            // Add a behaviour button to the question's "behaviourButtons" property.
            this.addBehaviourButton(question, button);
            // Remove the button from the HTML.
            button.parentElement.removeChild(button);
            // Update the question's html.
            question[htmlProperty] = element.innerHTML;
            return true;
        }
        return false;
    };
    /**
     * Convenience function to show a parsing error and abort.
     *
     * @param {EventEmitter<void>} [onAbort] If supplied, will emit an event.
     * @param {string} [error] Error to show.
     */
    CoreQuestionHelperProvider.prototype.showComponentError = function (onAbort, error) {
        // Prevent consecutive errors.
        var now = Date.now();
        if (now - this.lastErrorShown > 500) {
            this.lastErrorShown = now;
            this.domUtils.showErrorModalDefault(error, 'addon.mod_quiz.errorparsequestions', true);
        }
        onAbort && onAbort.emit();
    };
    /**
     * Treat correctness icons, replacing them with local icons and setting click events to show the feedback if needed.
     *
     * @param {HTMLElement} element DOM element.
     */
    CoreQuestionHelperProvider.prototype.treatCorrectnessIcons = function (element) {
        var icons = Array.from(element.querySelectorAll('img.icon, img.questioncorrectnessicon'));
        icons.forEach(function (icon) {
            // Replace the icon with the font version.
            if (icon.src) {
                var newIcon = document.createElement('i');
                if (icon.src.indexOf('incorrect') > -1) {
                    newIcon.className = 'icon fa fa-remove text-danger fa-fw questioncorrectnessicon';
                }
                else if (icon.src.indexOf('correct') > -1) {
                    newIcon.className = 'icon fa fa-check text-success fa-fw questioncorrectnessicon';
                }
                else {
                    return;
                }
                newIcon.title = icon.title;
                newIcon.ariaLabel = icon.title;
                icon.parentNode.replaceChild(newIcon, icon);
            }
        });
        var spans = Array.from(element.querySelectorAll('.feedbackspan.accesshide'));
        spans.forEach(function (span) {
            // Search if there's a hidden feedback for this element.
            var icon = span.previousSibling;
            if (!icon) {
                return;
            }
            if (!icon.classList.contains('icon') && !icon.classList.contains('questioncorrectnessicon')) {
                return;
            }
            icon.classList.add('questioncorrectnessicon');
            if (span.innerHTML) {
                // There's a hidden feedback. Mark the icon as tappable.
                // The click listener is only added if treatCorrectnessIconsClicks is called.
                icon.setAttribute('tappable', '');
            }
        });
    };
    /**
     * Add click listeners to all tappable correctness icons.
     *
     * @param {HTMLElement} element DOM element.
     * @param {string} [component] The component to use when viewing the feedback.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     */
    CoreQuestionHelperProvider.prototype.treatCorrectnessIconsClicks = function (element, component, componentId) {
        var _this = this;
        var icons = Array.from(element.querySelectorAll('i.icon.questioncorrectnessicon[tappable]')), title = this.translate.instant('core.question.feedback');
        icons.forEach(function (icon) {
            // Search the feedback for the icon.
            var span = icon.parentElement.querySelector('.feedbackspan.accesshide');
            if (span) {
                // There's a hidden feedback, show it when the icon is clicked.
                icon.addEventListener('click', function (event) {
                    _this.textUtils.expandText(title, span.innerHTML, component, componentId);
                });
            }
        });
    };
    CoreQuestionHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__question__["a" /* CoreQuestionProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_9__delegate__["a" /* CoreQuestionDelegate */]])
    ], CoreQuestionHelperProvider);
    return CoreQuestionHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_constants__ = __webpack_require__(39);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Provider to provide some helper functions regarding files and packages.
 */
var CoreFileHelperProvider = /** @class */ (function () {
    function CoreFileHelperProvider(fileProvider, filepoolProvider, sitesProvider, appProvider, translate, utils) {
        this.fileProvider = fileProvider;
        this.filepoolProvider = filepoolProvider;
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        this.translate = translate;
        this.utils = utils;
    }
    /**
     * Convenience function to open a file, downloading it if needed.
     *
     * @param {any} file The file to download.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [state] The file's state. If not provided, it will be calculated.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFileHelperProvider.prototype.downloadAndOpenFile = function (file, component, componentId, state, onProgress, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var fileUrl = this.getFileUrl(file), timemodified = this.getFileTimemodified(file);
        return this.downloadFileIfNeeded(file, fileUrl, component, componentId, timemodified, state, onProgress, siteId)
            .then(function (url) {
            if (!url) {
                return;
            }
            if (url.indexOf('http') === 0) {
                /* In iOS, if we use the same URL in embedded browser and background download then the download only
                   downloads a few bytes (cached ones). Add a hash to the URL so both URLs are different. */
                url = url + '#moodlemobile-embedded';
                return _this.utils.openOnlineFile(url).catch(function (error) {
                    // Error opening the file, some apps don't allow opening online files.
                    if (!_this.fileProvider.isAvailable()) {
                        return Promise.reject(error);
                    }
                    var promise;
                    // Get the state.
                    if (state) {
                        promise = Promise.resolve(state);
                    }
                    else {
                        promise = _this.filepoolProvider.getFileStateByUrl(siteId, fileUrl, timemodified);
                    }
                    return promise.then(function (state) {
                        if (state == __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                            return Promise.reject(_this.translate.instant('core.erroropenfiledownloading'));
                        }
                        var promise;
                        if (state === __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
                            // File is not downloaded, download and then return the local URL.
                            promise = _this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);
                        }
                        else {
                            // File is outdated and can't be opened in online, return the local URL.
                            promise = _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                        }
                        return promise.then(function (url) {
                            return _this.utils.openFile(url);
                        });
                    });
                });
            }
            else {
                return _this.utils.openFile(url);
            }
        });
    };
    /**
     * Download a file if it needs to be downloaded.
     *
     * @param {any} file The file to download.
     * @param {string} fileUrl The file URL.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified] The time this file was modified.
     * @param {string} [state] The file's state. If not provided, it will be calculated.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<string>} Resolved with the URL to use on success.
     */
    CoreFileHelperProvider.prototype.downloadFileIfNeeded = function (file, fileUrl, component, componentId, timemodified, state, onProgress, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var fixedUrl = site.fixPluginfileURL(fileUrl);
            if (_this.fileProvider.isAvailable()) {
                var promise = void 0;
                if (state) {
                    promise = Promise.resolve(state);
                }
                else {
                    // Calculate the state.
                    promise = _this.filepoolProvider.getFileStateByUrl(siteId, fileUrl, timemodified);
                }
                return promise.then(function (state) {
                    // The file system is available.
                    var isWifi = _this.appProvider.isWifi(), isOnline = _this.appProvider.isOnline();
                    if (state == __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOADED) {
                        // File is downloaded, get the local file URL.
                        return _this.filepoolProvider.getUrlByUrl(siteId, fileUrl, component, componentId, timemodified, false, false, file);
                    }
                    else {
                        if (!isOnline && !_this.isStateDownloaded(state)) {
                            // Not downloaded and user is offline, reject.
                            return Promise.reject(_this.translate.instant('core.networkerrormsg'));
                        }
                        if (onProgress) {
                            // This call can take a while. Send a fake event to notify that we're doing some calculations.
                            onProgress({ calculating: true });
                        }
                        return _this.filepoolProvider.shouldDownloadBeforeOpen(fixedUrl, file.filesize).then(function () {
                            if (state == __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                                // It's already downloading, stop.
                                return;
                            }
                            // Download and then return the local URL.
                            return _this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);
                        }, function () {
                            // Start the download if in wifi, but return the URL right away so the file is opened.
                            if (isWifi) {
                                _this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);
                            }
                            if (!_this.isStateDownloaded(state) || isOnline) {
                                // Not downloaded or online, return the online URL.
                                return fixedUrl;
                            }
                            else {
                                // Outdated but offline, so we return the local URL.
                                return _this.filepoolProvider.getUrlByUrl(siteId, fileUrl, component, componentId, timemodified, false, false, file);
                            }
                        });
                    }
                });
            }
            else {
                // Use the online URL.
                return fixedUrl;
            }
        });
    };
    /**
     * Download the file.
     *
     * @param {string} fileUrl The file URL.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified] The time this file was modified.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {any} [file] The file to download.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<string>} Resolved with internal URL on success, rejected otherwise.
     */
    CoreFileHelperProvider.prototype.downloadFile = function (fileUrl, component, componentId, timemodified, onProgress, file, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get the site and check if it can download files.
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canDownloadFiles()) {
                return Promise.reject(_this.translate.instant('core.cannotdownloadfiles'));
            }
            return _this.filepoolProvider.downloadUrl(siteId, fileUrl, false, component, componentId, timemodified, onProgress, undefined, file).catch(function (error) {
                // Download failed, check the state again to see if the file was downloaded before.
                return _this.filepoolProvider.getFileStateByUrl(siteId, fileUrl, timemodified).then(function (state) {
                    if (_this.isStateDownloaded(state)) {
                        return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                    }
                    else {
                        return Promise.reject(error);
                    }
                });
            });
        });
    };
    /**
     * Get the file's URL.
     *
     * @param {any} file The file.
     */
    CoreFileHelperProvider.prototype.getFileUrl = function (file) {
        return file.fileurl || file.url;
    };
    /**
     * Get the file's timemodified.
     *
     * @param {any} file The file.
     */
    CoreFileHelperProvider.prototype.getFileTimemodified = function (file) {
        return file.timemodified || 0;
    };
    /**
     * Check if a state is downloaded or outdated.
     *
     * @param {string} state The state to check.
     */
    CoreFileHelperProvider.prototype.isStateDownloaded = function (state) {
        return state === __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOADED || state === __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].OUTDATED;
    };
    /**
     * Whether the file has to be opened in browser (external repository).
     * The file must have a mimetype attribute.
     *
     * @param {any} file The file to check.
     * @return {boolean} Whether the file should be opened in browser.
     */
    CoreFileHelperProvider.prototype.shouldOpenInBrowser = function (file) {
        if (!file || !file.isexternalfile || !file.mimetype) {
            return false;
        }
        var mimetype = file.mimetype;
        if (mimetype.indexOf('application/vnd.google-apps.') != -1) {
            // Google Docs file, always open in browser.
            return true;
        }
        if (file.repositorytype == 'onedrive') {
            // In OneDrive, open in browser the office docs
            return mimetype.indexOf('application/vnd.openxmlformats-officedocument') != -1 ||
                mimetype == 'text/plain' || mimetype == 'document/unknown';
        }
        return false;
    };
    CoreFileHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_4__filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_5__sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_6__utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreFileHelperProvider);
    return CoreFileHelperProvider;
}());

//# sourceMappingURL=file-helper.js.map

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CorePushNotificationsDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to handle push notifications actions to perform when clicked and received.
 */
var CorePushNotificationsDelegate = /** @class */ (function () {
    function CorePushNotificationsDelegate(loggerProvider, sitesProvider, utils) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.observables = {};
        this.clickHandlers = {};
        this.counterHandlers = {};
        this.logger = loggerProvider.getInstance('CorePushNotificationsDelegate');
        this.observables['receive'] = new __WEBPACK_IMPORTED_MODULE_4_rxjs__["Subject"]();
    }
    /**
     * Function called when a push notification is clicked. Sends notification to handlers.
     *
     * @param {any} notification Notification clicked.
     * @return {Promise<any>} Promise resolved when done.
     */
    CorePushNotificationsDelegate.prototype.clicked = function (notification) {
        if (!notification) {
            return;
        }
        var promises = [];
        var handlers = [];
        var _loop_1 = function (name_1) {
            var handler = this_1.clickHandlers[name_1];
            // Check if the handler is disabled for the site.
            promises.push(this_1.isFeatureDisabled(handler, notification.site).then(function (disabled) {
                if (!disabled) {
                    // Check if the handler handles the notification.
                    return Promise.resolve(handler.handles(notification)).then(function (handles) {
                        if (handles) {
                            handlers.push(handler);
                        }
                    });
                }
            }));
        };
        var this_1 = this;
        for (var name_1 in this.clickHandlers) {
            _loop_1(name_1);
        }
        return this.utils.allPromises(promises).catch(function () {
            // Ignore errors.
        }).then(function () {
            // Sort by priority.
            handlers = handlers.sort(function (a, b) {
                return a.priority <= b.priority ? 1 : -1;
            });
            if (handlers[0]) {
                // Execute the first one.
                handlers[0].handleClick(notification);
            }
        });
    };
    /**
     * Check if a handler's feature is disabled for a certain site.
     *
     * @param {CorePushNotificationsClickHandler} handler Handler to check.
     * @param {string} siteId The site ID to check.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the handler feature is disabled.
     */
    CorePushNotificationsDelegate.prototype.isFeatureDisabled = function (handler, siteId) {
        if (handler.featureName) {
            // Check if the feature is disabled.
            return this.sitesProvider.isFeatureDisabled(handler.featureName, siteId);
        }
        else {
            return Promise.resolve(false);
        }
    };
    /**
     * Function called when a push notification is received in foreground (cannot tell when it's received in background).
     * Sends notification to all handlers.
     *
     * @param {any} notification Notification received.
     */
    CorePushNotificationsDelegate.prototype.received = function (notification) {
        this.observables['receive'].next(notification);
    };
    /**
     * Register a push notifications observable for a certain event. Right now, only receive is supported.
     * let observer = pushNotificationsDelegate.on('receive').subscribe((notification) => {
     * ...
     * observer.unsuscribe();
     *
     * @param {string}  eventName Only receive is permitted.
     * @return {Subject<any>} Observer to subscribe.
     */
    CorePushNotificationsDelegate.prototype.on = function (eventName) {
        if (typeof this.observables[eventName] == 'undefined') {
            var eventNames = Object.keys(this.observables).join(', ');
            this.logger.warn("'" + eventName + "' event name is not allowed. Use one of the following: '" + eventNames + "'.");
            return new __WEBPACK_IMPORTED_MODULE_4_rxjs__["Subject"]();
        }
        return this.observables[eventName];
    };
    /**
     * Register a click handler.
     *
     * @param {CorePushNotificationsClickHandler} handler The handler to register.
     * @return {boolean} True if registered successfully, false otherwise.
     */
    CorePushNotificationsDelegate.prototype.registerClickHandler = function (handler) {
        if (typeof this.clickHandlers[handler.name] !== 'undefined') {
            this.logger.log("Addon '" + handler.name + "' already registered");
            return false;
        }
        this.logger.log("Registered addon '" + handler.name + "'");
        this.clickHandlers[handler.name] = handler;
        return true;
    };
    /**
     * Register a push notifications handler for update badge counter.
     *
     * @param {string} name  Handler's name.
     */
    CorePushNotificationsDelegate.prototype.registerCounterHandler = function (name) {
        if (typeof this.counterHandlers[name] == 'undefined') {
            this.logger.debug("Registered handler '" + name + "' as badge counter handler.");
            this.counterHandlers[name] = name;
        }
        else {
            this.logger.log("Handler '" + name + "' as badge counter handler already registered.");
        }
    };
    /**
     * Check if a counter handler is present.
     *
     * @param {string} name       Handler's name.
     * @return {boolean}  If handler name is present.
     */
    CorePushNotificationsDelegate.prototype.isCounterHandlerRegistered = function (name) {
        return typeof this.counterHandlers[name] != 'undefined';
    };
    /**
     * Get all counter badge handlers.
     *
     * @return {any}  with all the handler names.
     */
    CorePushNotificationsDelegate.prototype.getCounterHandlers = function () {
        return this.counterHandlers;
    };
    CorePushNotificationsDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CorePushNotificationsDelegate);
    return CorePushNotificationsDelegate;
}());

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFeedbackProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__offline__ = __webpack_require__(282);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service that provides some features for feedbacks.
 */
var AddonModFeedbackProvider = /** @class */ (function () {
    function AddonModFeedbackProvider(logger, sitesProvider, utils, filepoolProvider, feedbackOffline, appProvider, logHelper) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.filepoolProvider = filepoolProvider;
        this.feedbackOffline = feedbackOffline;
        this.appProvider = appProvider;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = this.ROOT_CACHE_KEY + '';
        this.logger = logger.getInstance('AddonModFeedbackProvider');
    }
    AddonModFeedbackProvider_1 = AddonModFeedbackProvider;
    /**
     * Check dependency of a question item.
     *
     * @param   {any[]}  items      All question items to check dependency.
     * @param   {any}    item       Item to check.
     * @return  {boolean}           Return true if dependency is acomplished and it can be shown. False, otherwise.
     */
    AddonModFeedbackProvider.prototype.checkDependencyItem = function (items, item) {
        var depend = items.find(function (itemFind) {
            return itemFind.id == item.dependitem;
        });
        // Item not found, looks like dependent item has been removed or is in the same or following pages.
        if (!depend) {
            return true;
        }
        switch (depend.typ) {
            case 'label':
                return false;
            case 'multichoice':
            case 'multichoicerated':
                return this.compareDependItemMultichoice(depend, item.dependvalue);
            default:
                break;
        }
        return item.dependvalue == depend.rawValue;
    };
    /**
     * Check dependency item of type Multichoice.
     *
     * @param  {any}     item        Item to check.
     * @param  {string}  dependValue Value to compare.
     * @return {boolean}             Return true if dependency is acomplished and it can be shown. False, otherwise.
     */
    AddonModFeedbackProvider.prototype.compareDependItemMultichoice = function (item, dependValue) {
        var values, choices;
        var parts = item.presentation.split(AddonModFeedbackProvider_1.MULTICHOICE_TYPE_SEP) || [], subtype = parts.length > 0 && parts[0] ? parts[0] : 'r';
        choices = parts[1] || '';
        choices = choices.split(AddonModFeedbackProvider_1.MULTICHOICE_ADJUST_SEP)[0] || '';
        choices = choices.split(AddonModFeedbackProvider_1.LINE_SEP) || [];
        if (subtype === 'c') {
            if (typeof item.rawValue == 'undefined') {
                values = [''];
            }
            else {
                item.rawValue = '' + item.rawValue;
                values = item.rawValue.split(AddonModFeedbackProvider_1.LINE_SEP);
            }
        }
        else {
            values = [item.rawValue];
        }
        for (var index = 0; index < choices.length; index++) {
            for (var x in values) {
                if (values[x] == index + 1) {
                    var value = choices[index];
                    if (item.typ == 'multichoicerated') {
                        value = value.split(AddonModFeedbackProvider_1.MULTICHOICERATED_VALUE_SEP)[1] || '';
                    }
                    if (value.trim() == dependValue) {
                        return true;
                    }
                    // We can finish checking if only searching on one value and we found it.
                    if (values.length == 1) {
                        return false;
                    }
                }
            }
        }
        return false;
    };
    /**
     * Fill values of item questions.
     *
     * @param   {number}   feedbackId   Feedback ID.
     * @param   {any[]}    items        Item to fill the value.
     * @param   {boolean}  offline      True if it should return cached data. Has priority over ignoreCache.
     * @param   {boolean}  ignoreCache  True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}   siteId       Site ID.
     * @return  {Promise<any>}          Resolved with values when done.
     */
    AddonModFeedbackProvider.prototype.fillValues = function (feedbackId, items, offline, ignoreCache, siteId) {
        var _this = this;
        return this.getCurrentValues(feedbackId, offline, ignoreCache, siteId).then(function (valuesArray) {
            var values = {};
            valuesArray.forEach(function (value) {
                values[value.item] = value.value;
            });
            items.forEach(function (itemData) {
                if (itemData.hasvalue && typeof values[itemData.id] != 'undefined') {
                    itemData.rawValue = values[itemData.id];
                }
            });
        }).catch(function () {
            // Ignore errors.
        }).then(function () {
            // Merge with offline data.
            return _this.feedbackOffline.getFeedbackResponses(feedbackId, siteId).then(function (offlineValuesArray) {
                var offlineValues = {};
                // Merge all values into one array.
                offlineValuesArray = offlineValuesArray.reduce(function (a, b) {
                    var responses = _this.utils.objectToArrayOfObjects(b.responses, 'id', 'value');
                    return a.concat(responses);
                }, []).map(function (a) {
                    var parts = a.id.split('_');
                    a.typ = parts[0];
                    a.item = parseInt(parts[1], 0);
                    return a;
                });
                offlineValuesArray.forEach(function (value) {
                    if (typeof offlineValues[value.item] == 'undefined') {
                        offlineValues[value.item] = [];
                    }
                    offlineValues[value.item].push(value.value);
                });
                items.forEach(function (itemData) {
                    if (itemData.hasvalue && typeof offlineValues[itemData.id] != 'undefined') {
                        // Treat multichoice checkboxes.
                        if (itemData.typ == 'multichoice' &&
                            itemData.presentation.split(AddonModFeedbackProvider_1.MULTICHOICE_TYPE_SEP)[0] == 'c') {
                            offlineValues[itemData.id] = offlineValues[itemData.id].filter(function (value) {
                                return value > 0;
                            });
                            itemData.rawValue = offlineValues[itemData.id].join(AddonModFeedbackProvider_1.LINE_SEP);
                        }
                        else {
                            itemData.rawValue = offlineValues[itemData.id][0];
                        }
                    }
                });
                return items;
            });
        }).catch(function () {
            // Ignore errors.
            return items;
        });
    };
    /**
     * Returns all the feedback non respondents users.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    groupId         Group id, 0 means that the function will determine the user group.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @param   {any}       [previous]      Only for recurrent use. Object with the previous fetched info.
     * @return  {Promise<any>}              Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getAllNonRespondents = function (feedbackId, groupId, ignoreCache, siteId, previous) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (typeof previous == 'undefined') {
            previous = {
                page: 0,
                users: []
            };
        }
        return this.getNonRespondents(feedbackId, groupId, previous.page, ignoreCache, siteId).then(function (response) {
            if (previous.users.length < response.total) {
                previous.users = previous.users.concat(response.users);
            }
            if (previous.users.length < response.total) {
                // Can load more.
                previous.page++;
                return _this.getAllNonRespondents(feedbackId, groupId, ignoreCache, siteId, previous);
            }
            previous.total = response.total;
            return previous;
        });
    };
    /**
     * Returns all the feedback user responses.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    groupId         Group id, 0 means that the function will determine the user group.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @param   {any}       [previous]      Only for recurrent use. Object with the previous fetched info.
     * @return  {Promise<any>}              Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getAllResponsesAnalysis = function (feedbackId, groupId, ignoreCache, siteId, previous) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (typeof previous == 'undefined') {
            previous = {
                page: 0,
                attempts: [],
                anonattempts: []
            };
        }
        return this.getResponsesAnalysis(feedbackId, groupId, previous.page, ignoreCache, siteId).then(function (responses) {
            if (previous.anonattempts.length < responses.totalanonattempts) {
                previous.anonattempts = previous.anonattempts.concat(responses.anonattempts);
            }
            if (previous.attempts.length < responses.totalattempts) {
                previous.attempts = previous.attempts.concat(responses.attempts);
            }
            if (previous.anonattempts.length < responses.totalanonattempts || previous.attempts.length < responses.totalattempts) {
                // Can load more.
                previous.page++;
                return _this.getAllResponsesAnalysis(feedbackId, groupId, ignoreCache, siteId, previous);
            }
            previous.totalattempts = responses.totalattempts;
            previous.totalanonattempts = responses.totalanonattempts;
            return previous;
        });
    };
    /**
     * Get analysis information for a given feedback.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    [groupId]       Group ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @return  {Promise<any>}                   Promise resolved when the feedback is retrieved.
     */
    AddonModFeedbackProvider.prototype.getAnalysis = function (feedbackId, groupId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId
            }, preSets = {
                cacheKey: _this.getAnalysisDataCacheKey(feedbackId, groupId)
            };
            if (groupId) {
                params['groupid'] = groupId;
            }
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_feedback_get_analysis', params, preSets);
        });
    };
    /**
     * Get cache key for feedback analysis data WS calls.
     *
     * @param {number} feedbackId Feedback ID.
     * @param {number} [groupId=0]  Group ID.
     * @return {string}         Cache key.
     */
    AddonModFeedbackProvider.prototype.getAnalysisDataCacheKey = function (feedbackId, groupId) {
        if (groupId === void 0) { groupId = 0; }
        return this.getAnalysisDataPrefixCacheKey(feedbackId) + groupId;
    };
    /**
     * Get prefix cache key for feedback analysis data WS calls.
     *
     * @param {number} feedbackId Feedback ID.
     * @return {string}         Cache key.
     */
    AddonModFeedbackProvider.prototype.getAnalysisDataPrefixCacheKey = function (feedbackId) {
        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':analysis:';
    };
    /**
     * Find an attempt in all responses analysis.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    attemptId       Attempt id to find.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @param   {any}       [previous]      Only for recurrent use. Object with the previous fetched info.
     * @return  {Promise<any>}              Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getAttempt = function (feedbackId, attemptId, ignoreCache, siteId, previous) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (typeof previous == 'undefined') {
            previous = {
                page: 0,
                attemptsLoaded: 0,
                anonAttemptsLoaded: 0
            };
        }
        return this.getResponsesAnalysis(feedbackId, 0, previous.page, ignoreCache, siteId).then(function (responses) {
            var attempt;
            attempt = responses.attempts.find(function (attempt) {
                return attemptId == attempt.id;
            });
            if (attempt) {
                return attempt;
            }
            attempt = responses.anonattempts.find(function (attempt) {
                return attemptId == attempt.id;
            });
            if (attempt) {
                return attempt;
            }
            if (previous.anonAttemptsLoaded < responses.totalanonattempts) {
                previous.anonAttemptsLoaded += responses.anonattempts.length;
            }
            if (previous.attemptsLoaded < responses.totalattempts) {
                previous.attemptsLoaded += responses.attempts.length;
            }
            if (previous.anonAttemptsLoaded < responses.totalanonattempts || previous.attemptsLoaded < responses.totalattempts) {
                // Can load more. Check there.
                previous.page++;
                return _this.getAttempt(feedbackId, attemptId, ignoreCache, siteId, previous);
            }
            // Not found and all loaded. Reject.
            return Promise.reject(null);
        });
    };
    /**
     * Get prefix cache key for feedback completion data WS calls.
     *
     * @param {number} feedbackId Feedback ID.
     * @return {string}         Cache key.
     */
    AddonModFeedbackProvider.prototype.getCompletedDataCacheKey = function (feedbackId) {
        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':completed:';
    };
    /**
     * Returns the temporary completion timemodified for the current user.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @return  {Promise<any>}                   Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getCurrentCompletedTimeModified = function (feedbackId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId
            }, preSets = {
                cacheKey: _this.getCurrentCompletedTimeModifiedDataCacheKey(feedbackId)
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_feedback_get_current_completed_tmp', params, preSets).then(function (response) {
                if (response && typeof response.feedback != 'undefined' && typeof response.feedback.timemodified != 'undefined') {
                    return response.feedback.timemodified;
                }
                return 0;
            }).catch(function () {
                // Ignore errors.
                return 0;
            });
        });
    };
    /**
     * Get prefix cache key for feedback current completed temp data WS calls.
     *
     * @param {number} feedbackId Feedback ID.
     * @return {string}         Cache key.
     */
    AddonModFeedbackProvider.prototype.getCurrentCompletedTimeModifiedDataCacheKey = function (feedbackId) {
        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':completedtime:';
    };
    /**
     * Returns the temporary responses or responses of the last submission for the current user.
     *
     * @param   {number}    feedbackId          Feedback ID.
     * @param   {boolean}   [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param   {boolean}   [ignoreCache=false] True if it should ignore cached data (it always fail in offline or server down).
     * @param   {string}    [siteId]            Site ID. If not defined, current site.
     * @return  {Promise<any>}                  Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getCurrentValues = function (feedbackId, offline, ignoreCache, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId
            }, preSets = {
                cacheKey: _this.getCurrentValuesDataCacheKey(feedbackId)
            };
            if (offline) {
                preSets['omitExpires'] = true;
            }
            else if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return site.read('mod_feedback_get_unfinished_responses', params, preSets).then(function (response) {
                if (!response || typeof response.responses == 'undefined') {
                    return Promise.reject(null);
                }
                if (response.responses.length == 0) {
                    // No unfinished responses, fetch responses of the last submission.
                    return site.read('mod_feedback_get_finished_responses', params, preSets).then(function (response) {
                        if (!response || typeof response.responses == 'undefined') {
                            return Promise.reject(null);
                        }
                        return response.responses;
                    });
                }
                return response.responses;
            });
        });
    };
    /**
     * Get cache key for get current values feedback data WS calls.
     *
     * @param  {number} feedbackId  Feedback ID.
     * @return {string}             Cache key.
     */
    AddonModFeedbackProvider.prototype.getCurrentValuesDataCacheKey = function (feedbackId) {
        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':currentvalues';
    };
    /**
     * Get  access information for a given feedback.
     *
     * @param   {number}    feedbackId          Feedback ID.
     * @param   {boolean}   [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param   {boolean}   [ignoreCache=false] True if it should ignore cached data (it always fail in offline or server down).
     * @param   {string}    [siteId]            Site ID. If not defined, current site.
     * @return  {Promise<any>}                  Promise resolved when the feedback is retrieved.
     */
    AddonModFeedbackProvider.prototype.getFeedbackAccessInformation = function (feedbackId, offline, ignoreCache, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId
            }, preSets = {
                cacheKey: _this.getFeedbackAccessInformationDataCacheKey(feedbackId)
            };
            if (offline) {
                preSets['omitExpires'] = true;
            }
            else if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return site.read('mod_feedback_get_feedback_access_information', params, preSets);
        });
    };
    /**
     * Get cache key for feedback access information data WS calls.
     *
     * @param {number} feedbackId Feedback ID.
     * @return {string}         Cache key.
     */
    AddonModFeedbackProvider.prototype.getFeedbackAccessInformationDataCacheKey = function (feedbackId) {
        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':access';
    };
    /**
     * Get cache key for feedback data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModFeedbackProvider.prototype.getFeedbackCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'feedback:' + courseId;
    };
    /**
     * Get prefix cache key for all feedback activity data WS calls.
     *
     * @param {number} feedbackId Feedback ID.
     * @return {string}         Cache key.
     */
    AddonModFeedbackProvider.prototype.getFeedbackDataPrefixCacheKey = function (feedbackId) {
        return this.ROOT_CACHE_KEY + feedbackId;
    };
    /**
     * Get a feedback with key=value. If more than one is found, only the first will be returned.
     *
     * @param {number}   courseId            Course ID.
     * @param {string}   key                 Name of the property to check.
     * @param {any}      value               Value to search.
     * @param {string}   [siteId]            Site ID. If not defined, current site.
     * @param {boolean} [forceCache]  True to always get the value from cache, false otherwise. Default false.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}  Promise resolved when the feedback is retrieved.
     */
    AddonModFeedbackProvider.prototype.getFeedbackDataByKey = function (courseId, key, value, siteId, forceCache, ignoreCache) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getFeedbackCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_8__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_feedback_get_feedbacks_by_courses', params, preSets).then(function (response) {
                if (response && response.feedbacks) {
                    var currentFeedback = response.feedbacks.find(function (feedback) {
                        return feedback[key] == value;
                    });
                    if (currentFeedback) {
                        return currentFeedback;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a feedback by course module ID.
     *
     * @param {number}   courseId       Course ID.
     * @param {number}   cmId           Course module ID.
     * @param {string}   [siteId]       Site ID. If not defined, current site.
     * @param {boolean} [forceCache]   True to always get the value from cache, false otherwise. Default false.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}   Promise resolved when the feedback is retrieved.
     */
    AddonModFeedbackProvider.prototype.getFeedback = function (courseId, cmId, siteId, forceCache, ignoreCache) {
        return this.getFeedbackDataByKey(courseId, 'coursemodule', cmId, siteId, forceCache, ignoreCache);
    };
    /**
     * Get a feedback by ID.
     *
     * @param {number}  courseId      Course ID.
     * @param {number}  id            Feedback ID.
     * @param {string}  [siteId]      Site ID. If not defined, current site.
     * @param {boolean} [forceCache]  True to always get the value from cache, false otherwise. Default false.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}         Promise resolved when the feedback is retrieved.
     */
    AddonModFeedbackProvider.prototype.getFeedbackById = function (courseId, id, siteId, forceCache, ignoreCache) {
        return this.getFeedbackDataByKey(courseId, 'id', id, siteId, forceCache, ignoreCache);
    };
    /**
     * Returns the items (questions) in the given feedback.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @return  {Promise<any>}                   Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getItems = function (feedbackId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId
            }, preSets = {
                cacheKey: _this.getItemsDataCacheKey(feedbackId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_8__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_feedback_get_items', params, preSets);
        });
    };
    /**
     * Get cache key for get items feedback data WS calls.
     *
     * @param  {number} feedbackId  Feedback ID.
     * @return {string}             Cache key.
     */
    AddonModFeedbackProvider.prototype.getItemsDataCacheKey = function (feedbackId) {
        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':items';
    };
    /**
     * Retrieves a list of students who didn't submit the feedback.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    [groupId=0]     Group id, 0 means that the function will determine the user group.
     * @param   {number}    [page=0]        The page of records to return.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @return  {Promise<any>}              Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getNonRespondents = function (feedbackId, groupId, page, ignoreCache, siteId) {
        var _this = this;
        if (groupId === void 0) { groupId = 0; }
        if (page === void 0) { page = 0; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId,
                groupid: groupId,
                page: page
            }, preSets = {
                cacheKey: _this.getNonRespondentsDataCacheKey(feedbackId, groupId)
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_feedback_get_non_respondents', params, preSets);
        });
    };
    /**
     * Get cache key for non respondents feedback data WS calls.
     *
     * @param  {number} feedbackId  Feedback ID.
     * @param  {number} [groupId=0] Group id, 0 means that the function will determine the user group.
     * @return {string}             Cache key.
     */
    AddonModFeedbackProvider.prototype.getNonRespondentsDataCacheKey = function (feedbackId, groupId) {
        if (groupId === void 0) { groupId = 0; }
        return this.getNonRespondentsDataPrefixCacheKey(feedbackId) + groupId;
    };
    /**
     * Get prefix cache key for feedback non respondents data WS calls.
     *
     * @param {number} feedbackId Feedback ID.
     * @return {string}           Cache key.
     */
    AddonModFeedbackProvider.prototype.getNonRespondentsDataPrefixCacheKey = function (feedbackId) {
        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':nonrespondents:';
    };
    /**
     * Get a single feedback page items. This function is not cached, use AddonModFeedbackHelperProvider#getPageItems instead.
     *
     * @param   {number}    feedbackId  Feedback ID.
     * @param   {number}    page        The page to get.
     * @param   {string}    [siteId]    Site ID. If not defined, current site.
     * @return  {Promise<any>}          Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getPageItems = function (feedbackId, page, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId,
                page: page
            };
            return site.write('mod_feedback_get_page_items', params);
        });
    };
    /**
     * Get a single feedback page items. If offline or server down it will use getItems to calculate dependencies.
     *
     * @param   {number}  feedbackId          Feedback ID.
     * @param   {number}  page                The page to get.
     * @param   {boolean} [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param   {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}  [siteId]            Site ID. If not defined, current site.
     * @return  {Promise<any>}                Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getPageItemsWithValues = function (feedbackId, page, offline, ignoreCache, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getPageItems(feedbackId, page, siteId).then(function (response) {
            return _this.fillValues(feedbackId, response.items, offline, ignoreCache, siteId).then(function (items) {
                response.items = items;
                return response;
            });
        }).catch(function () {
            // If getPageItems fail we should calculate it using getItems.
            return _this.getItems(feedbackId, false, siteId).then(function (response) {
                return _this.fillValues(feedbackId, response.items, offline, ignoreCache, siteId).then(function (items) {
                    // Separate items by pages.
                    var currentPage = 0;
                    var previousPageItems = [];
                    var pageItems = items.filter(function (item) {
                        // Greater page, discard all entries.
                        if (currentPage > page) {
                            return false;
                        }
                        if (item.typ == 'pagebreak') {
                            currentPage++;
                            return false;
                        }
                        // Save items on previous page to check dependencies and discard entry.
                        if (currentPage < page) {
                            previousPageItems.push(item);
                            return false;
                        }
                        // Filter depending items.
                        if (item && item.dependitem > 0 && previousPageItems.length > 0) {
                            return _this.checkDependencyItem(previousPageItems, item);
                        }
                        // Filter items with errors.
                        return item;
                    });
                    // Check if there are more pages.
                    response.hasprevpage = page > 0;
                    response.hasnextpage = currentPage > page;
                    response.items = pageItems;
                    return response;
                });
            });
        });
    };
    /**
     * Convenience function to get the page we can jump.
     *
     * @param  {number}  feedbackId Feedback ID.
     * @param  {number}  page       Page where we want to jump.
     * @param  {number}  changePage If page change is forward (1) or backward (-1).
     * @param  {string}  siteId     Site ID.
     * @return {Promise<number | false>}  Page number where to jump. Or false if completed or first page.
     */
    AddonModFeedbackProvider.prototype.getPageJumpTo = function (feedbackId, page, changePage, siteId) {
        var _this = this;
        return this.getPageItemsWithValues(feedbackId, page, true, false, siteId).then(function (resp) {
            // The page we are going has items.
            if (resp.items.length > 0) {
                return page;
            }
            // Check we can jump futher.
            if ((changePage == 1 && resp.hasnextpage) || (changePage == -1 && resp.hasprevpage)) {
                return _this.getPageJumpTo(feedbackId, page + changePage, changePage, siteId);
            }
            // Completed or first page.
            return false;
        });
    };
    /**
     * Returns the feedback user responses.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    groupId         Group id, 0 means that the function will determine the user group.
     * @param   {number}    page            The page of records to return.
     * @param   {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @return  {Promise<any>}              Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getResponsesAnalysis = function (feedbackId, groupId, page, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId,
                groupid: groupId || 0,
                page: page || 0
            }, preSets = {
                cacheKey: _this.getResponsesAnalysisDataCacheKey(feedbackId, groupId)
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_feedback_get_responses_analysis', params, preSets);
        });
    };
    /**
     * Get cache key for responses analysis feedback data WS calls.
     *
     * @param  {number} feedbackId  Feedback ID.
     * @param  {number} [groupId=0] Group id, 0 means that the function will determine the user group.
     * @return {string}             Cache key.
     */
    AddonModFeedbackProvider.prototype.getResponsesAnalysisDataCacheKey = function (feedbackId, groupId) {
        if (groupId === void 0) { groupId = 0; }
        return this.getResponsesAnalysisDataPrefixCacheKey(feedbackId) + groupId;
    };
    /**
     * Get prefix cache key for feedback responses analysis data WS calls.
     *
     * @param {number} feedbackId Feedback ID.
     * @return {string}         Cache key.
     */
    AddonModFeedbackProvider.prototype.getResponsesAnalysisDataPrefixCacheKey = function (feedbackId) {
        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':responsesanalysis:';
    };
    /**
     * Gets the resume page information.
     *
     * @param   {number}    feedbackId          Feedback ID.
     * @param   {boolean}   [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param   {boolean}   [ignoreCache=false] True if it should ignore cached data (it always fail in offline or server down).
     * @param   {string}    [siteId]            Site ID. If not defined, current site.
     * @return  {Promise<any>}                  Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.getResumePage = function (feedbackId, offline, ignoreCache, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId
            }, preSets = {
                cacheKey: _this.getResumePageDataCacheKey(feedbackId)
            };
            if (offline) {
                preSets['omitExpires'] = true;
            }
            else if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return site.read('mod_feedback_launch_feedback', params, preSets).then(function (response) {
                if (response && typeof response.gopage != 'undefined') {
                    // WS will return -1 for last page but the user need to start again.
                    return response.gopage > 0 ? response.gopage : 0;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get prefix cache key for resume feedback page data WS calls.
     *
     * @param {number} feedbackId   Feedback ID.
     * @return {string}             Cache key.
     */
    AddonModFeedbackProvider.prototype.getResumePageDataCacheKey = function (feedbackId) {
        return this.getFeedbackDataPrefixCacheKey(feedbackId) + ':launch';
    };
    /**
     * Invalidates feedback data except files and module info.
     *
     * @param  {number} feedbackId   Feedback ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateAllFeedbackData = function (feedbackId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getFeedbackDataPrefixCacheKey(feedbackId));
        });
    };
    /**
     * Invalidates feedback analysis data.
     *
     * @param {number} feedbackId   Feedback ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateAnalysisData = function (feedbackId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getAnalysisDataPrefixCacheKey(feedbackId));
        });
    };
    /**
     * Invalidate the prefetched content.
     * To invalidate files, use AddonFeedbackProvider#invalidateFiles.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.getFeedback(courseId, moduleId, siteId).then(function (feedback) {
            var ps = [];
            // Do not invalidate module data before getting module info, we need it!
            ps.push(_this.invalidateFeedbackData(courseId, siteId));
            ps.push(_this.invalidateAllFeedbackData(feedback.id, siteId));
            return Promise.all(ps);
        }));
        promises.push(this.invalidateFiles(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates temporary completion record data.
     *
     * @param  {number} feedbackId   Feedback ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateCurrentValuesData = function (feedbackId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCurrentValuesDataCacheKey(feedbackId));
        });
    };
    /**
     * Invalidates feedback access information data.
     *
     * @param {number} feedbackId   Feedback ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateFeedbackAccessInformationData = function (feedbackId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getFeedbackAccessInformationDataCacheKey(feedbackId));
        });
    };
    /**
     * Invalidates feedback data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateFeedbackData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getFeedbackCacheKey(courseId));
        });
    };
    /**
     * Invalidate the prefetched files.
     *
     * @param {number} moduleId  The module ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when the files are invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateFiles = function (moduleId, siteId) {
        return this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModFeedbackProvider_1.COMPONENT, moduleId);
    };
    /**
     * Invalidates feedback non respondents record data.
     *
     * @param  {number} feedbackId   Feedback ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateNonRespondentsData = function (feedbackId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getNonRespondentsDataPrefixCacheKey(feedbackId));
        });
    };
    /**
     * Invalidates feedback user responses record data.
     *
     * @param  {number} feedbackId   Feedback ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateResponsesAnalysisData = function (feedbackId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getResponsesAnalysisDataPrefixCacheKey(feedbackId));
        });
    };
    /**
     * Invalidates launch feedback data.
     *
     * @param {number} feedbackId   Feedback ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModFeedbackProvider.prototype.invalidateResumePageData = function (feedbackId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getResumePageDataCacheKey(feedbackId));
        });
    };
    /**
     * Returns if feedback has been completed
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @return  {Promise<boolean>}              Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.isCompleted = function (feedbackId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId
            }, preSets = {
                cacheKey: _this.getCompletedDataCacheKey(feedbackId)
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return _this.utils.promiseWorks(site.read('mod_feedback_get_last_completed', params, preSets));
        });
    };
    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the feedback WS are available.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     * @since 3.3
     */
    AddonModFeedbackProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('mod_feedback_get_feedbacks_by_courses') &&
                site.wsAvailable('mod_feedback_get_feedback_access_information');
        });
    };
    /**
     * Report the feedback as being viewed.
     *
     * @param {number} id                   Module ID.
     * @param {string} [name] Name of the feedback.
     * @param  {boolean} [formViewed=false] True if form was viewed.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}               Promise resolved when the WS call is successful.
     */
    AddonModFeedbackProvider.prototype.logView = function (id, name, formViewed, siteId) {
        if (formViewed === void 0) { formViewed = false; }
        var params = {
            feedbackid: id,
            moduleviewed: formViewed ? 1 : 0
        };
        return this.logHelper.logSingle('mod_feedback_view_feedback', params, AddonModFeedbackProvider_1.COMPONENT, id, name, 'feedback', { moduleviewed: params.moduleviewed }, siteId);
    };
    /**
     * Process a jump between pages.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    page            The page being processed.
     * @param   {any}       responses       The data to be processed the key is the field name (usually type[index]_id).
     * @param   {boolean}   goPrevious      Whether we want to jump to previous page.
     * @param   {boolean}   formHasErrors   Whether the form we sent has required but empty fields (only used in offline).
     * @param   {number}    courseId        Course ID the feedback belongs to.
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @return  {Promise<any>}              Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.processPage = function (feedbackId, page, responses, goPrevious, formHasErrors, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.feedbackOffline.saveResponses(feedbackId, page, responses, courseId, siteId).then(function () {
                // Simulate process_page response.
                var response = {
                    jumpto: page,
                    completed: false,
                    offline: true
                };
                var changePage = 0;
                if (goPrevious) {
                    if (page > 0) {
                        changePage = -1;
                    }
                }
                else if (!formHasErrors) {
                    // We can only go next if it has no errors.
                    changePage = 1;
                }
                if (changePage === 0) {
                    return response;
                }
                return _this.getPageItemsWithValues(feedbackId, page, true, false, siteId).then(function (resp) {
                    // Check completion.
                    if (changePage == 1 && !resp.hasnextpage) {
                        response.completed = true;
                        return response;
                    }
                    return _this.getPageJumpTo(feedbackId, page + changePage, changePage, siteId).then(function (loadPage) {
                        if (loadPage === false) {
                            // Completed or first page.
                            if (changePage == -1) {
                                // First page.
                                response.jumpto = 0;
                            }
                            else {
                                // Completed.
                                response.completed = true;
                            }
                        }
                        else {
                            response.jumpto = loadPage;
                        }
                        return response;
                    });
                });
            });
        };
        if (!this.appProvider.isOnline()) {
            // App is offline, store the action.
            return storeOffline();
        }
        // If there's already a response to be sent to the server, discard it first.
        return this.feedbackOffline.deleteFeedbackPageResponses(feedbackId, page, siteId).then(function () {
            return _this.processPageOnline(feedbackId, page, responses, goPrevious, siteId).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means that responses cannot be submitted.
                    return Promise.reject(error);
                }
                // Couldn't connect to server, store in offline.
                return storeOffline();
            });
        });
    };
    /**
     * Process a jump between pages.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    page            The page being processed.
     * @param   {any}       responses       The data to be processed the key is the field name (usually type[index]_id).
     * @param   {boolean}   goPrevious      Whether we want to jump to previous page.
     * @param   {string}    [siteId]        Site ID. If not defined, current site.
     * @return  {Promise<any>}                   Promise resolved when the info is retrieved.
     */
    AddonModFeedbackProvider.prototype.processPageOnline = function (feedbackId, page, responses, goPrevious, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                feedbackid: feedbackId,
                page: page,
                responses: _this.utils.objectToArrayOfObjects(responses, 'name', 'value'),
                goprevious: goPrevious ? 1 : 0
            };
            return site.write('mod_feedback_process_page', params).catch(function (error) {
                return Promise.reject(_this.utils.createFakeWSError(error));
            }).then(function (response) {
                // Invalidate and update current values because they will change.
                return _this.invalidateCurrentValuesData(feedbackId, site.getId()).then(function () {
                    return _this.getCurrentValues(feedbackId, false, false, site.getId());
                }).catch(function () {
                    // Ignore errors.
                }).then(function () {
                    return response;
                });
            });
        });
    };
    AddonModFeedbackProvider.COMPONENT = 'mmaModFeedback';
    AddonModFeedbackProvider.FORM_SUBMITTED = 'addon_mod_feedback_form_submitted';
    AddonModFeedbackProvider.LINE_SEP = '|';
    AddonModFeedbackProvider.MULTICHOICE_TYPE_SEP = '>>>>>';
    AddonModFeedbackProvider.MULTICHOICE_ADJUST_SEP = '<<<<<';
    AddonModFeedbackProvider.MULTICHOICE_HIDENOSELECT = 'h';
    AddonModFeedbackProvider.MULTICHOICERATED_VALUE_SEP = '####';
    AddonModFeedbackProvider = AddonModFeedbackProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_7__offline__["a" /* AddonModFeedbackOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_6__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModFeedbackProvider);
    return AddonModFeedbackProvider;
    var AddonModFeedbackProvider_1;
}());

//# sourceMappingURL=feedback.js.map

/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreBlockDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__default_block_handler__ = __webpack_require__(566);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_siteplugins_providers_siteplugins__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Delegate to register block handlers.
 */
var CoreBlockDelegate = /** @class */ (function (_super) {
    __extends(CoreBlockDelegate, _super);
    function CoreBlockDelegate(logger, sitesProvider, eventsProvider, defaultHandler, sitePluginsProvider) {
        var _this = _super.call(this, 'CoreBlockDelegate', logger, sitesProvider, eventsProvider) || this;
        _this.defaultHandler = defaultHandler;
        _this.sitePluginsProvider = sitePluginsProvider;
        _this.handlerNameProperty = 'blockName';
        _this.featurePrefix = 'CoreBlockDelegate_';
        _this.blocksUpdateObservable = new __WEBPACK_IMPORTED_MODULE_7_rxjs__["Subject"]();
        return _this;
    }
    /**
     * Check if blocks are disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreBlockDelegate.prototype.areBlocksDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('NoDelegate_SiteBlocks');
    };
    /**
     * Check if blocks are disabled in a certain site.
     *
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>}     Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreBlockDelegate.prototype.areBlocksDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.areBlocksDisabledInSite(site);
        });
    };
    /**
     * Get the display data for a certain block.
     *
     * @param {Injector} injector Injector.
     * @param {any} block The block to render.
     * @param {string} contextLevel The context where the block will be used.
     * @param {number} instanceId The instance ID associated with the context level.
     * @return {Promise<CoreBlockHandlerData>} Promise resolved with the display data.
     */
    CoreBlockDelegate.prototype.getBlockDisplayData = function (injector, block, contextLevel, instanceId) {
        return Promise.resolve(this.executeFunctionOnEnabled(block.name, 'getDisplayData', [injector, block]));
    };
    /**
     * Check if any of the blocks in a list is supported.
     *
     * @param {any[]} blocks The list of blocks.
     * @return {boolean} Whether any of the blocks is supported.
     */
    CoreBlockDelegate.prototype.hasSupportedBlock = function (blocks) {
        var _this = this;
        blocks = blocks || [];
        return !!blocks.find(function (block) { return _this.isBlockSupported(block.name); });
    };
    /**
     * Check if a block is supported.
     *
     * @param {string} name Block "name". E.g. 'activity_modules'.
     * @return {boolean} Whether it's supported.
     */
    CoreBlockDelegate.prototype.isBlockSupported = function (name) {
        return this.hasHandler(name, true);
    };
    /**
     * Check if feature is enabled or disabled in the site, depending on the feature prefix and the handler name.
     *
     * @param  {CoreDelegateHandler} handler Handler to check.
     * @param  {CoreSite} site Site to check.
     * @return {boolean} Whether is enabled or disabled in site.
     */
    CoreBlockDelegate.prototype.isFeatureDisabled = function (handler, site) {
        return this.areBlocksDisabledInSite(site) || _super.prototype.isFeatureDisabled.call(this, handler, site);
    };
    /**
     * Called when there are new block handlers available. Informs anyone who subscribed to the
     * observable.
     */
    CoreBlockDelegate.prototype.updateData = function () {
        this.blocksUpdateObservable.next();
    };
    CoreBlockDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__default_block_handler__["a" /* CoreBlockDefaultHandler */], __WEBPACK_IMPORTED_MODULE_6__core_siteplugins_providers_siteplugins__["a" /* CoreSitePluginsProvider */]])
    ], CoreBlockDelegate);
    return CoreBlockDelegate;
}(__WEBPACK_IMPORTED_MODULE_4__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 136 */,
/* 137 */,
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseActivityPrefetchHandlerBase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__module_prefetch_handler__ = __webpack_require__(1018);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Base prefetch handler to be registered in CoreCourseModulePrefetchDelegate. It is useful to minimize the amount of
 * functions that handlers need to implement. It also provides some helper features like preventing a module to be
 * downloaded twice at the same time.
 *
 * If your handler inherits from this service, you just need to override the functions that you want to change.
 *
 * This class should be used for ACTIVITIES. You must override the prefetch function, and it's recommended to call
 * prefetchPackage in there since it handles the package status.
 */
var CoreCourseActivityPrefetchHandlerBase = /** @class */ (function (_super) {
    __extends(CoreCourseActivityPrefetchHandlerBase, _super);
    function CoreCourseActivityPrefetchHandlerBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Download the module.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {string} [dirPath] Path of the directory where to store all the content files.
     * @return {Promise<any>} Promise resolved when all content is downloaded.
     */
    CoreCourseActivityPrefetchHandlerBase.prototype.download = function (module, courseId, dirPath) {
        // Same implementation for download and prefetch.
        return this.prefetch(module, courseId, false, dirPath);
    };
    /**
     * Prefetch a module.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @param {string} [dirPath] Path of the directory where to store all the content files.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseActivityPrefetchHandlerBase.prototype.prefetch = function (module, courseId, single, dirPath) {
        // To be overridden. It should call prefetchPackage
        return Promise.resolve();
    };
    /**
     * Prefetch the module, setting package status at start and finish.
     *
     * Example usage from a child instance:
     *     return this.prefetchPackage(module, courseId, single, this.prefetchModule.bind(this), siteId, someParam, anotherParam);
     *
     * Then the function "prefetchModule" will receive params:
     *     prefetchModule(module, courseId, single, siteId, someParam, anotherParam)
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @param {prefetchFunction} downloadFn Function to perform the prefetch. Please check the documentation of prefetchFunction.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the module has been downloaded. Data returned is not reliable.
     */
    CoreCourseActivityPrefetchHandlerBase.prototype.prefetchPackage = function (module, courseId, single, downloadFn, siteId) {
        var _this = this;
        var args = [];
        for (var _i = 5; _i < arguments.length; _i++) {
            args[_i - 5] = arguments[_i];
        }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!this.appProvider.isOnline()) {
            // Cannot prefetch in offline.
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        if (this.isDownloading(module.id, siteId)) {
            // There's already a download ongoing for this module, return the promise.
            return this.getOngoingDownload(module.id, siteId);
        }
        var prefetchPromise = this.setDownloading(module.id, siteId).then(function () {
            // Package marked as downloading, get module info to be able to handle links.
            return Promise.all([
                _this.courseProvider.getModuleBasicInfo(module.id, siteId),
                _this.courseProvider.getModule(module.id, courseId, undefined, false, true, siteId),
            ]);
        }).then(function () {
            // Call the download function, send all the params except downloadFn. This includes all params passed after siteId.
            return downloadFn.apply(downloadFn, [module, courseId, single, siteId].concat(args));
        }).then(function (extra) {
            // Only accept string types.
            if (typeof extra != 'string') {
                extra = '';
            }
            // Prefetch finished, mark as downloaded.
            return _this.setDownloaded(module.id, siteId, extra);
        }).catch(function (error) {
            // Error prefetching, go back to previous status and reject the promise.
            return _this.setPreviousStatusAndReject(module.id, error, siteId);
        });
        return this.addOngoingDownload(module.id, prefetchPromise, siteId);
    };
    /**
     * Mark the module as downloaded.
     *
     * @param {number} id Unique identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {string} [extra] Extra data to store.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseActivityPrefetchHandlerBase.prototype.setDownloaded = function (id, siteId, extra) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* CoreConstants */].DOWNLOADED, this.component, id, extra);
    };
    /**
     * Mark the module as downloading.
     *
     * @param {number} id Unique identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseActivityPrefetchHandlerBase.prototype.setDownloading = function (id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* CoreConstants */].DOWNLOADING, this.component, id);
    };
    /**
     * Set previous status and return a rejected promise.
     *
     * @param {number} id Unique identifier per component.
     * @param {any} [error] Error to return.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<never>} Rejected promise.
     */
    CoreCourseActivityPrefetchHandlerBase.prototype.setPreviousStatusAndReject = function (id, error, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.setPackagePreviousStatus(siteId, this.component, id).then(function () {
            return Promise.reject(error);
        });
    };
    return CoreCourseActivityPrefetchHandlerBase;
}(__WEBPACK_IMPORTED_MODULE_1__module_prefetch_handler__["a" /* CoreCourseModulePrefetchHandlerBase */]));

//# sourceMappingURL=activity-prefetch-handler.js.map

/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_camera__ = __webpack_require__(338);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__fileuploader__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__delegate__ = __webpack_require__(425);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












/**
 * Helper service to upload files.
 */
var CoreFileUploaderHelperProvider = /** @class */ (function () {
    function CoreFileUploaderHelperProvider(logger, appProvider, translate, fileUploaderProvider, domUtils, textUtils, fileProvider, utils, actionSheetCtrl, uploaderDelegate, camera, platform) {
        this.appProvider = appProvider;
        this.translate = translate;
        this.fileUploaderProvider = fileUploaderProvider;
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.utils = utils;
        this.actionSheetCtrl = actionSheetCtrl;
        this.uploaderDelegate = uploaderDelegate;
        this.camera = camera;
        this.platform = platform;
        this.logger = logger.getInstance('CoreFileUploaderProvider');
    }
    /**
     * Show a confirmation modal to the user if the size of the file is bigger than the allowed threshold.
     *
     * @param {number} size File size.
     * @param {boolean} [alwaysConfirm] True to show a confirm even if the size isn't high.
     * @param {boolean} [allowOffline] True to allow uploading in offline.
     * @param {number} [wifiThreshold] Threshold for WiFi connection. Default: CoreFileUploaderProvider.WIFI_SIZE_WARNING.
     * @param {number} [limitedThreshold] Threshold for limited connection. Default: CoreFileUploaderProvider.LIMITED_SIZE_WARNING.
     * @return {Promise<void>} Promise resolved when the user confirms or if there's no need to show a modal.
     */
    CoreFileUploaderHelperProvider.prototype.confirmUploadFile = function (size, alwaysConfirm, allowOffline, wifiThreshold, limitedThreshold) {
        if (size == 0) {
            return Promise.resolve();
        }
        if (!allowOffline && !this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.fileuploader.errormustbeonlinetoupload'));
        }
        wifiThreshold = typeof wifiThreshold == 'undefined' ? __WEBPACK_IMPORTED_MODULE_10__fileuploader__["a" /* CoreFileUploaderProvider */].WIFI_SIZE_WARNING : wifiThreshold;
        limitedThreshold = typeof limitedThreshold == 'undefined' ?
            __WEBPACK_IMPORTED_MODULE_10__fileuploader__["a" /* CoreFileUploaderProvider */].LIMITED_SIZE_WARNING : limitedThreshold;
        if (size < 0) {
            return this.domUtils.showConfirm(this.translate.instant('core.fileuploader.confirmuploadunknownsize'));
        }
        else if (size >= wifiThreshold || (this.appProvider.isNetworkAccessLimited() && size >= limitedThreshold)) {
            var readableSize = this.textUtils.bytesToSize(size, 2);
            return this.domUtils.showConfirm(this.translate.instant('core.fileuploader.confirmuploadfile', { size: readableSize }));
        }
        else if (alwaysConfirm) {
            return this.domUtils.showConfirm(this.translate.instant('core.areyousure'));
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Create a temporary copy of a file and upload it.
     *
     * @param {any} file File to copy and upload.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the copy of the file.
     * @param {string} [name] Name to use when uploading the file. If not defined, use the file's name.
     * @return {Promise<any>} Promise resolved when the file is uploaded.
     */
    CoreFileUploaderHelperProvider.prototype.copyAndUploadFile = function (file, upload, name) {
        var _this = this;
        name = name || file.name;
        var modal = this.domUtils.showModalLoading('core.fileuploader.readingfile', true);
        // Get unique name for the copy.
        return this.fileProvider.getUniqueNameInFolder(__WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, name).then(function (newName) {
            var filePath = _this.textUtils.concatenatePaths(__WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, newName);
            // Write the data into the file.
            return _this.fileProvider.writeFileDataInFile(file, filePath, function (progress) {
                _this.showProgressModal(modal, 'core.fileuploader.readingfileperc', progress);
            });
        }).catch(function (error) {
            _this.logger.error('Error reading file to upload.', error);
            modal.dismiss();
            return Promise.reject(_this.translate.instant('core.fileuploader.errorreadingfile'));
        }).then(function (fileEntry) {
            modal.dismiss();
            if (upload) {
                // Pass true to delete the copy after the upload.
                return _this.uploadGenericFile(fileEntry.toURL(), name, file.type, true);
            }
            else {
                return fileEntry;
            }
        });
    };
    /**
     * Copy or move a file to the app temporary folder.
     *
     * @param {string} path  Path of the file.
     * @param {boolean} shouldDelete True if original file should be deleted (move), false otherwise (copy).
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {string} [defaultExt] Defaut extension to use if the file doesn't have any.
     * @return {Promise<any>} Promise resolved with the copied file.
     */
    CoreFileUploaderHelperProvider.prototype.copyToTmpFolder = function (path, shouldDelete, maxSize, defaultExt) {
        var _this = this;
        var fileName = this.fileProvider.getFileAndDirectoryFromPath(path).name, promise, fileTooLarge;
        // Check that size isn't too large.
        if (typeof maxSize != 'undefined' && maxSize != -1) {
            promise = this.fileProvider.getExternalFile(path).then(function (fileEntry) {
                return _this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (file) {
                    if (file.size > maxSize) {
                        fileTooLarge = file;
                    }
                });
            }).catch(function () {
                // Ignore failures.
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            if (fileTooLarge) {
                return _this.errorMaxBytes(maxSize, fileTooLarge.name);
            }
            // File isn't too large.
            // Picking an image from album in Android adds a timestamp at the end of the file. Delete it.
            fileName = fileName.replace(/(\.[^\.]*)\?[^\.]*$/, '$1');
            // Get a unique name in the folder to prevent overriding another file.
            return _this.fileProvider.getUniqueNameInFolder(__WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, fileName, defaultExt);
        }).then(function (newName) {
            // Now move or copy the file.
            var destPath = _this.textUtils.concatenatePaths(__WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, newName);
            if (shouldDelete) {
                return _this.fileProvider.moveExternalFile(path, destPath);
            }
            else {
                return _this.fileProvider.copyExternalFile(path, destPath);
            }
        });
    };
    /**
     * Function called when trying to upload a file bigger than max size. Shows an error.
     *
     * @param {number} maxSize Max size (bytes).
     * @param {string} fileName Name of the file.
     * @return {Promise<any>} Rejected promise.
     */
    CoreFileUploaderHelperProvider.prototype.errorMaxBytes = function (maxSize, fileName) {
        var errorMessage = this.translate.instant('core.fileuploader.maxbytesfile', {
            $a: {
                file: fileName,
                size: this.textUtils.bytesToSize(maxSize, 2)
            }
        });
        this.domUtils.showErrorModal(errorMessage);
        return Promise.reject(null);
    };
    /**
     * Function called when the file picker is closed.
     */
    CoreFileUploaderHelperProvider.prototype.filePickerClosed = function () {
        if (this.filePickerDeferred) {
            this.filePickerDeferred.reject(this.domUtils.createCanceledError());
            this.filePickerDeferred = undefined;
        }
    };
    /**
     * Function to call once a file is uploaded using the file picker.
     *
     * @param {any} result Result of the upload process.
     */
    CoreFileUploaderHelperProvider.prototype.fileUploaded = function (result) {
        if (this.filePickerDeferred) {
            this.filePickerDeferred.resolve(result);
            this.filePickerDeferred = undefined;
        }
        // Close the action sheet if it's opened.
        if (this.actionSheet) {
            this.actionSheet.dismiss();
        }
    };
    /**
     * Open the "file picker" to select and upload a file.
     *
     * @param {number} [maxSize] Max size of the file to upload. If not defined or -1, no max size.
     * @param {string} [title] File picker title.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when a file is uploaded, rejected if file picker is closed without a file uploaded.
     *                        The resolve value is the response of the upload request.
     */
    CoreFileUploaderHelperProvider.prototype.selectAndUploadFile = function (maxSize, title, mimetypes) {
        return this.selectFileWithPicker(maxSize, false, title, mimetypes, true);
    };
    /**
     * Open the "file picker" to select a file without uploading it.
     *
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [title] File picker title.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when a file is selected, rejected if file picker is closed without selecting a file.
     *                        The resolve value is the FileEntry of a copy of the picked file, so it can be deleted afterwards.
     */
    CoreFileUploaderHelperProvider.prototype.selectFile = function (maxSize, allowOffline, title, mimetypes) {
        return this.selectFileWithPicker(maxSize, allowOffline, title, mimetypes, false);
    };
    /**
     * Open the "file picker" to select a file and maybe uploading it.
     *
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [title] File picker title.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @param {boolean} [upload] Whether the file should be uploaded.
     * @return {Promise<any>} Promise resolved when a file is selected/uploaded, rejected if file picker is closed.
     */
    CoreFileUploaderHelperProvider.prototype.selectFileWithPicker = function (maxSize, allowOffline, title, mimetypes, upload) {
        var _this = this;
        // Create the cancel button and get the handlers to upload the file.
        var buttons = [{
                text: this.translate.instant('core.cancel'),
                role: 'cancel',
                handler: function () {
                    // User cancelled the action sheet.
                    _this.filePickerClosed();
                }
            }], handlers = this.uploaderDelegate.getHandlers(mimetypes);
        this.filePickerDeferred = this.utils.promiseDefer();
        // Sort the handlers by priority.
        handlers.sort(function (a, b) {
            return a.priority <= b.priority ? 1 : -1;
        });
        // Create a button for each handler.
        handlers.forEach(function (handler) {
            buttons.push({
                text: _this.translate.instant(handler.title),
                icon: handler.icon,
                cssClass: handler.class,
                handler: function () {
                    if (!handler.action) {
                        // Nothing to do.
                        return false;
                    }
                    if (!allowOffline && !_this.appProvider.isOnline()) {
                        // Not allowed, show error.
                        _this.domUtils.showErrorModal('core.fileuploader.errormustbeonlinetoupload', true);
                        return false;
                    }
                    handler.action(maxSize, upload, allowOffline, handler.mimetypes).then(function (data) {
                        if (data.treated) {
                            // The handler already treated the file. Return the result.
                            return data.result;
                        }
                        else {
                            // The handler didn't treat the file, we need to do it.
                            if (data.fileEntry) {
                                // The handler provided us a fileEntry, use it.
                                return _this.uploadFileEntry(data.fileEntry, data.delete, maxSize, upload, allowOffline);
                            }
                            else if (data.path) {
                                // The handler provided a path. First treat it like it's a relative path.
                                return _this.fileProvider.getFile(data.path).catch(function () {
                                    // File not found, it's probably an absolute path.
                                    return _this.fileProvider.getExternalFile(data.path);
                                }).then(function (fileEntry) {
                                    // File found, treat it.
                                    return _this.uploadFileEntry(fileEntry, data.delete, maxSize, upload, allowOffline);
                                });
                            }
                            // Nothing received, fail.
                            return Promise.reject('No file received');
                        }
                    }).then(function (result) {
                        // Success uploading or picking, return the result.
                        _this.fileUploaded(result);
                    }).catch(function (error) {
                        if (error) {
                            _this.domUtils.showErrorModal(error);
                        }
                    });
                    // Do not close the action sheet, it will be closed if success.
                    return false;
                }
            });
        });
        this.actionSheet = this.actionSheetCtrl.create({
            title: title ? title : this.translate.instant('core.fileuploader.' + (upload ? 'uploadafile' : 'selectafile')),
            buttons: buttons
        });
        this.actionSheet.present();
        // Call afterRender for each button.
        setTimeout(function () {
            handlers.forEach(function (handler) {
                if (handler.afterRender) {
                    handler.afterRender(maxSize, upload, allowOffline, handler.mimetypes);
                }
            });
        }, 500);
        return this.filePickerDeferred.promise;
    };
    /**
     * Convenience function to upload a file on a certain site, showing a confirm if needed.
     *
     * @param {any} fileEntry FileEntry of the file to upload.
     * @param {boolean} [deleteAfterUpload] Whether the file should be deleted after upload.
     * @param {string} [siteId] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the file is uploaded.
     */
    CoreFileUploaderHelperProvider.prototype.showConfirmAndUploadInSite = function (fileEntry, deleteAfterUpload, siteId) {
        var _this = this;
        return this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (file) {
            return _this.confirmUploadFile(file.size).then(function () {
                return _this.uploadGenericFile(fileEntry.toURL(), file.name, file.type, deleteAfterUpload, siteId).then(function () {
                    _this.domUtils.showToast('core.fileuploader.fileuploaded', true, undefined, 'core-toast-success');
                });
            }).catch(function (err) {
                if (err) {
                    _this.domUtils.showErrorModal(err);
                }
                return Promise.reject(null);
            });
        }, function () {
            _this.domUtils.showErrorModal('core.fileuploader.errorreadingfile', true);
            return Promise.reject(null);
        });
    };
    /**
     * Treat a capture audio/video error.
     *
     * @param {any} error Error returned by the Cordova plugin. Can be a string or an object.
     * @param {string} defaultMessage Key of the default message to show.
     * @return {Promise<any>} Rejected promise. If it doesn't have an error message it means it was cancelled.
     */
    CoreFileUploaderHelperProvider.prototype.treatCaptureError = function (error, defaultMessage) {
        // Cancelled or error. If cancelled, error is an object with code = 3.
        if (error) {
            if (typeof error === 'string') {
                this.logger.error('Error while recording audio/video: ' + error);
                if (error.indexOf('No Activity found') > -1) {
                    // User doesn't have an app to do this.
                    return Promise.reject(this.translate.instant('core.fileuploader.errornoapp'));
                }
                else {
                    return Promise.reject(this.translate.instant(defaultMessage));
                }
            }
            else {
                if (error.code != 3) {
                    // Error, not cancelled.
                    this.logger.error('Error while recording audio/video', error);
                    return Promise.reject(this.translate.instant(defaultMessage));
                }
                else {
                    this.logger.debug('Cancelled');
                }
            }
        }
        return Promise.reject(null);
    };
    /**
     * Treat a capture image or browse album error.
     *
     * @param {string} error Error returned by the Cordova plugin.
     * @param {string} defaultMessage Key of the default message to show.
     * @return {Promise<any>} Rejected promise. If it doesn't have an error message it means it was cancelled.
     */
    CoreFileUploaderHelperProvider.prototype.treatImageError = function (error, defaultMessage) {
        // Cancelled or error.
        if (error) {
            if (typeof error == 'string') {
                if (error.toLowerCase().indexOf('error') > -1 || error.toLowerCase().indexOf('unable') > -1) {
                    this.logger.error('Error getting image: ' + error);
                    return Promise.reject(error);
                }
                else {
                    // User cancelled.
                    this.logger.debug('Cancelled');
                }
            }
            else {
                return Promise.reject(this.translate.instant(defaultMessage));
            }
        }
        return Promise.reject(null);
    };
    /**
     * Convenient helper for the user to record and upload a video.
     *
     * @param {boolean} isAudio True if uploading an audio, false if it's a video.
     * @param {number} maxSize Max size of the upload. -1 for no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadAudioOrVideo = function (isAudio, maxSize, upload, mimetypes) {
        var _this = this;
        this.logger.debug('Trying to record a ' + (isAudio ? 'audio' : 'video') + ' file');
        var options = { limit: 1, mimetypes: mimetypes }, promise = isAudio ? this.fileUploaderProvider.captureAudio(options) : this.fileUploaderProvider.captureVideo(options);
        // The mimetypes param is only for desktop apps, the Cordova plugin doesn't support it.
        return promise.then(function (medias) {
            // We used limit 1, we only want 1 media.
            var media = medias[0];
            var path = media.fullPath;
            var error = _this.fileUploaderProvider.isInvalidMimetype(mimetypes, path); // Verify that the mimetype is supported.
            if (error) {
                return Promise.reject(error);
            }
            // Make sure the path has the protocol. In iOS it doesn't.
            if (_this.appProvider.isMobile() && path.indexOf('file://') == -1) {
                path = 'file://' + path;
            }
            if (upload) {
                return _this.uploadFile(path, maxSize, true, _this.fileUploaderProvider.getMediaUploadOptions(media));
            }
            else {
                // Copy or move the file to our temporary folder.
                return _this.copyToTmpFolder(path, true, maxSize);
            }
        }, function (error) {
            var defaultError = isAudio ? 'core.fileuploader.errorcapturingaudio' : 'core.fileuploader.errorcapturingvideo';
            return _this.treatCaptureError(error, defaultError);
        });
    };
    /**
     * Uploads a file of any type.
     * This function will not check the size of the file, please check it before calling this function.
     *
     * @param {string} uri File URI.
     * @param {string} name File name.
     * @param {string} type File type.
     * @param {boolean} [deleteAfterUpload] Whether the file should be deleted after upload.
     * @param {string} [siteId] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the file is uploaded.
     */
    CoreFileUploaderHelperProvider.prototype.uploadGenericFile = function (uri, name, type, deleteAfterUpload, siteId) {
        var options = this.fileUploaderProvider.getFileUploadOptions(uri, name, type, deleteAfterUpload);
        return this.uploadFile(uri, -1, false, options, siteId);
    };
    /**
     * Convenient helper for the user to upload an image, either from the album or taking it with the camera.
     *
     * @param {boolean} fromAlbum True if the image should be selected from album, false if it should be taken with camera.
     * @param {number} maxSize Max size of the upload. -1 for no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadImage = function (fromAlbum, maxSize, upload, mimetypes) {
        var _this = this;
        this.logger.debug('Trying to capture an image with camera');
        var options = {
            quality: 50,
            destinationType: this.camera.DestinationType.FILE_URI,
            correctOrientation: true
        };
        if (fromAlbum) {
            var imageSupported = !mimetypes || this.utils.indexOfRegexp(mimetypes, /^image\//) > -1, videoSupported = !mimetypes || this.utils.indexOfRegexp(mimetypes, /^video\//) > -1;
            options.sourceType = this.camera.PictureSourceType.PHOTOLIBRARY;
            options.popoverOptions = {
                x: 10,
                y: 10,
                width: this.platform.width() - 200,
                height: this.platform.height() - 200,
                arrowDir: this.camera.PopoverArrowDirection.ARROW_ANY
            };
            // Determine the mediaType based on the mimetypes.
            if (imageSupported && !videoSupported) {
                options.mediaType = this.camera.MediaType.PICTURE;
            }
            else if (!imageSupported && videoSupported) {
                options.mediaType = this.camera.MediaType.VIDEO;
            }
            else if (this.platform.is('ios')) {
                // Only get all media in iOS because in Android using this option allows uploading any kind of file.
                options.mediaType = this.camera.MediaType.ALLMEDIA;
            }
        }
        else if (mimetypes) {
            if (mimetypes.indexOf('image/jpeg') > -1) {
                options.encodingType = this.camera.EncodingType.JPEG;
            }
            else if (mimetypes.indexOf('image/png') > -1) {
                options.encodingType = this.camera.EncodingType.PNG;
            }
        }
        return this.fileUploaderProvider.getPicture(options).then(function (path) {
            var error = _this.fileUploaderProvider.isInvalidMimetype(mimetypes, path); // Verify that the mimetype is supported.
            if (error) {
                return Promise.reject(error);
            }
            if (upload) {
                return _this.uploadFile(path, maxSize, true, _this.fileUploaderProvider.getCameraUploadOptions(path, fromAlbum));
            }
            else {
                // Copy or move the file to our temporary folder.
                return _this.copyToTmpFolder(path, !fromAlbum, maxSize, 'jpg');
            }
        }, function (error) {
            var defaultError = fromAlbum ? 'core.fileuploader.errorgettingimagealbum' : 'core.fileuploader.errorcapturingimage';
            return _this.treatImageError(error, defaultError);
        });
    };
    /**
     * Upload a file given the file entry.
     *
     * @param {any} fileEntry The file entry.
     * @param {boolean} deleteAfter True if the file should be deleted once treated.
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [name] Name to use when uploading the file. If not defined, use the file's name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadFileEntry = function (fileEntry, deleteAfter, maxSize, upload, allowOffline, name) {
        var _this = this;
        return this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (file) {
            return _this.uploadFileObject(file, maxSize, upload, allowOffline, name).then(function (result) {
                if (deleteAfter) {
                    // We have uploaded and deleted a copy of the file. Now delete the original one.
                    _this.fileProvider.removeFileByFileEntry(fileEntry);
                }
                return result;
            });
        });
    };
    /**
     * Upload a file given the file object.
     *
     * @param {any} file The file object.
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [name] Name to use when uploading the file. If not defined, use the file's name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadFileObject = function (file, maxSize, upload, allowOffline, name) {
        var _this = this;
        if (maxSize != -1 && file.size > maxSize) {
            return this.errorMaxBytes(maxSize, file.name);
        }
        return this.confirmUploadFile(file.size, false, allowOffline).then(function () {
            // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
            return _this.copyAndUploadFile(file, upload, name);
        });
    };
    /**
     * Convenience function to upload a file, allowing to retry if it fails.
     *
     * @param {string} path Absolute path of the file to upload.
     * @param {number} maxSize Max size of the upload. -1 for no max size.
     * @param {boolean} checkSize True to check size.
     * @param {CoreFileUploaderOptions} Options.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if the file is uploaded, rejected otherwise.
     */
    CoreFileUploaderHelperProvider.prototype.uploadFile = function (path, maxSize, checkSize, options, siteId) {
        var _this = this;
        var errorStr = this.translate.instant('core.error'), retryStr = this.translate.instant('core.retry'), uploadingStr = this.translate.instant('core.fileuploader.uploading'), errorUploading = function (error) {
            // Allow the user to retry.
            return _this.domUtils.showConfirm(error, errorStr, retryStr).then(function () {
                // Try again.
                return _this.uploadFile(path, maxSize, checkSize, options, siteId);
            }, function () {
                // User cancelled. Delete the file if needed.
                if (options.deleteAfterUpload) {
                    _this.fileProvider.removeExternalFile(path);
                }
                return Promise.reject(null);
            });
        };
        var promise, file;
        if (!this.appProvider.isOnline()) {
            return errorUploading(this.translate.instant('core.fileuploader.errormustbeonlinetoupload'));
        }
        if (checkSize) {
            // Check that file size is the right one.
            promise = this.fileProvider.getExternalFile(path).then(function (fileEntry) {
                return _this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (f) {
                    file = f;
                    return file.size;
                });
            }).catch(function () {
                // Ignore failures.
            });
        }
        else {
            promise = Promise.resolve(0);
        }
        return promise.then(function (size) {
            if (maxSize != -1 && size > maxSize) {
                return _this.errorMaxBytes(maxSize, file.name);
            }
            if (size > 0) {
                return _this.confirmUploadFile(size);
            }
        }).then(function () {
            // File isn't too large and user confirmed, let's upload.
            var modal = _this.domUtils.showModalLoading(uploadingStr);
            return _this.fileUploaderProvider.uploadFile(path, options, function (progress) {
                // Progress uploading.
                _this.showProgressModal(modal, 'core.fileuploader.uploadingperc', progress);
            }, siteId).catch(function (error) {
                _this.logger.error('Error uploading file.', error);
                modal.dismiss();
                if (typeof error != 'string') {
                    error = _this.translate.instant('core.fileuploader.errorwhileuploading');
                }
                return errorUploading(error);
            }).finally(function () {
                modal.dismiss();
            });
        });
    };
    /**
     * Show a progress modal.
     *
     * @param {Loading} modal The modal where to show the progress.
     * @param {string} stringKey The key of the string to display.
     * @param {ProgressEvent|CoreFileProgressEvent} progress The progress event.
     */
    CoreFileUploaderHelperProvider.prototype.showProgressModal = function (modal, stringKey, progress) {
        if (progress && progress.lengthComputable) {
            // Calculate the progress percentage.
            var perc = Math.min((progress.loaded / progress.total) * 100, 100);
            if (perc >= 0) {
                modal.setContent(this.translate.instant(stringKey, { $a: perc.toFixed(1) }));
                if (modal._cmp && modal._cmp.changeDetectorRef) {
                    // Force a change detection, otherwise the content is not updated.
                    modal._cmp.changeDetectorRef.detectChanges();
                }
            }
        }
    };
    CoreFileUploaderHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_10__fileuploader__["a" /* CoreFileUploaderProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["a" /* ActionSheetController */], __WEBPACK_IMPORTED_MODULE_11__delegate__["a" /* CoreFileUploaderDelegate */],
            __WEBPACK_IMPORTED_MODULE_2__ionic_native_camera__["a" /* Camera */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */]])
    ], CoreFileUploaderHelperProvider);
    return CoreFileUploaderHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CorePushNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_badge__ = __webpack_require__(541);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_push__ = __webpack_require__(336);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__ = __webpack_require__(469);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_init__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_sites_factory__ = __webpack_require__(420);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__delegate__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_local_notifications__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_config__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__configconstants__ = __webpack_require__(121);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


















/**
 * Service to handle push notifications.
 */
var CorePushNotificationsProvider = /** @class */ (function () {
    function CorePushNotificationsProvider(logger, appProvider, initDelegate, pushNotificationsDelegate, sitesProvider, badge, localNotificationsProvider, utils, textUtils, push, configProvider, device, zone, translate, platform, sitesFactory) {
        var _this = this;
        this.appProvider = appProvider;
        this.initDelegate = initDelegate;
        this.pushNotificationsDelegate = pushNotificationsDelegate;
        this.sitesProvider = sitesProvider;
        this.badge = badge;
        this.localNotificationsProvider = localNotificationsProvider;
        this.utils = utils;
        this.textUtils = textUtils;
        this.push = push;
        this.configProvider = configProvider;
        this.device = device;
        this.zone = zone;
        this.translate = translate;
        this.platform = platform;
        this.sitesFactory = sitesFactory;
        this.appTablesSchema = [
            {
                name: CorePushNotificationsProvider_1.BADGE_TABLE,
                columns: [
                    {
                        name: 'siteid',
                        type: 'TEXT'
                    },
                    {
                        name: 'addon',
                        type: 'TEXT'
                    },
                    {
                        name: 'number',
                        type: 'INTEGER'
                    }
                ],
                primaryKeys: ['siteid', 'addon']
            },
            {
                name: CorePushNotificationsProvider_1.PENDING_UNREGISTER_TABLE,
                columns: [
                    {
                        name: 'siteid',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'siteurl',
                        type: 'TEXT'
                    },
                    {
                        name: 'token',
                        type: 'TEXT'
                    },
                    {
                        name: 'info',
                        type: 'TEXT'
                    }
                ]
            }
        ];
        this.siteSchema = {
            name: 'AddonPushNotificationsProvider',
            version: 1,
            tables: [
                {
                    name: CorePushNotificationsProvider_1.REGISTERED_DEVICES_TABLE,
                    columns: [
                        {
                            name: 'appid',
                            type: 'TEXT',
                        },
                        {
                            name: 'uuid',
                            type: 'TEXT'
                        },
                        {
                            name: 'name',
                            type: 'TEXT'
                        },
                        {
                            name: 'model',
                            type: 'TEXT'
                        },
                        {
                            name: 'platform',
                            type: 'TEXT'
                        },
                        {
                            name: 'version',
                            type: 'TEXT'
                        },
                        {
                            name: 'pushid',
                            type: 'TEXT'
                        },
                    ],
                    primaryKeys: ['appid', 'uuid']
                }
            ],
        };
        this.logger = logger.getInstance('CorePushNotificationsProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTablesFromSchema(this.appTablesSchema);
        this.sitesProvider.registerSiteSchema(this.siteSchema);
        platform.ready().then(function () {
            // Create the default channel.
            _this.createDefaultChannel();
            translate.onLangChange.subscribe(function (event) {
                // Update the channel name.
                _this.createDefaultChannel();
            });
        });
    }
    CorePushNotificationsProvider_1 = CorePushNotificationsProvider;
    /**
     * Check whether the device can be registered in Moodle to receive push notifications.
     *
     * @return {boolean} Whether the device can be registered in Moodle.
     */
    CorePushNotificationsProvider.prototype.canRegisterOnMoodle = function () {
        return this.pushID && this.appProvider.isMobile();
    };
    /**
     * Delete all badge records for a given site.
     *
     * @param  {string} siteId Site ID.
     * @return {Promise<any>}  Resolved when done.
     */
    CorePushNotificationsProvider.prototype.cleanSiteCounters = function (siteId) {
        var _this = this;
        return this.appDB.deleteRecords(CorePushNotificationsProvider_1.BADGE_TABLE, { siteid: siteId }).finally(function () {
            _this.updateAppCounter();
        });
    };
    /**
     * Create the default push channel. It is used to change the name.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CorePushNotificationsProvider.prototype.createDefaultChannel = function () {
        var _this = this;
        if (!this.platform.is('android')) {
            return Promise.resolve();
        }
        return this.push.createChannel({
            id: 'PushPluginChannel',
            description: this.translate.instant('core.misc'),
            importance: 4
        }).catch(function (error) {
            _this.logger.error('Error changing push channel name', error);
        });
    };
    /**
     * Returns options for push notifications based on device.
     *
     * @return {Promise<PushOptions>} Promise with the push options resolved when done.
     */
    CorePushNotificationsProvider.prototype.getOptions = function () {
        var promise;
        if (this.localNotificationsProvider.canDisableSound()) {
            promise = this.configProvider.get(__WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].SETTINGS_NOTIFICATION_SOUND, true);
        }
        else {
            promise = Promise.resolve(true);
        }
        return promise.then(function (soundEnabled) {
            return {
                android: {
                    sound: !!soundEnabled,
                    icon: 'smallicon',
                    iconColor: __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].notificoncolor
                },
                ios: {
                    alert: 'true',
                    badge: true,
                    sound: !!soundEnabled
                },
                windows: {
                    sound: !!soundEnabled
                }
            };
        });
    };
    /**
     * Get the pushID for this device.
     *
     * @return {string} Push ID.
     */
    CorePushNotificationsProvider.prototype.getPushId = function () {
        return this.pushID;
    };
    /**
     * Get data to register the device in Moodle.
     *
     * @return {CorePushNotificationsRegisterData} Data.
     */
    CorePushNotificationsProvider.prototype.getRegisterData = function () {
        return {
            appid: __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].app_id,
            name: this.device.manufacturer || '',
            model: this.device.model,
            platform: this.device.platform + '-fcm',
            version: this.device.version,
            pushid: this.pushID,
            uuid: this.device.uuid
        };
    };
    /**
     * Get Sitebadge  counter from the database.
     *
     * @param  {string} siteId Site ID.
     * @return {Promise<any>}       Promise resolved with the stored badge counter for the site.
     */
    CorePushNotificationsProvider.prototype.getSiteCounter = function (siteId) {
        return this.getAddonBadge(siteId);
    };
    /**
     * Log a firebase event.
     *
     * @param {string} name Name of the event.
     * @param {any} data Data of the event.
     * @param {boolean} [filter] Whether to filter the data. This is useful when logging a full notification.
     * @return {Promise<any>} Promise resolved when done. This promise is never rejected.
     */
    CorePushNotificationsProvider.prototype.logEvent = function (name, data, filter) {
        var _this = this;
        var win = window; // This feature is only present in our fork of the plugin.
        if (__WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].enableanalytics && win.PushNotification && win.PushNotification.logEvent) {
            return new Promise(function (resolve, reject) {
                win.PushNotification.logEvent(resolve, function (error) {
                    _this.logger.error('Error logging firebase event', name, error);
                    resolve();
                }, name, data, !!filter);
            });
        }
        return Promise.resolve();
    };
    /**
     * Log a firebase view_item event.
     *
     * @param {number|string} itemId The item ID.
     * @param {string} itemName The item name.
     * @param {string} itemCategory The item category.
     * @param {string} wsName Name of the WS.
     * @param {any} [data] Other data to pass to the event.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done. This promise is never rejected.
     */
    CorePushNotificationsProvider.prototype.logViewEvent = function (itemId, itemName, itemCategory, wsName, data, siteId) {
        data = data || {};
        // Add "moodle" to the name of all extra params.
        data = this.utils.prefixKeys(data, 'moodle');
        data['moodleaction'] = wsName;
        data['moodlesiteid'] = siteId || this.sitesProvider.getCurrentSiteId();
        if (itemId) {
            data['item_id'] = itemId;
        }
        if (itemName) {
            data['item_name'] = itemName;
        }
        if (itemCategory) {
            data['item_category'] = itemCategory;
        }
        return this.logEvent('view_item', data, false);
    };
    /**
     * Log a firebase view_item_list event.
     *
     * @param {string} itemCategory The item category.
     * @param {string} wsName Name of the WS.
     * @param {any} [data] Other data to pass to the event.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done. This promise is never rejected.
     */
    CorePushNotificationsProvider.prototype.logViewListEvent = function (itemCategory, wsName, data, siteId) {
        data = data || {};
        // Add "moodle" to the name of all extra params.
        data = this.utils.prefixKeys(data, 'moodle');
        data['moodleaction'] = wsName;
        data['moodlesiteid'] = siteId || this.sitesProvider.getCurrentSiteId();
        if (itemCategory) {
            data['item_category'] = itemCategory;
        }
        return this.logEvent('view_item_list', data, false);
    };
    /**
     * Function called when a push notification is clicked. Redirect the user to the right state.
     *
     * @param {any} notification Notification.
     */
    CorePushNotificationsProvider.prototype.notificationClicked = function (notification) {
        var _this = this;
        this.initDelegate.ready().then(function () {
            _this.pushNotificationsDelegate.clicked(notification);
        });
    };
    /**
     * This function is called when we receive a Notification from APNS or a message notification from GCM.
     * The app can be in foreground or background,
     * if we are in background this code is executed when we open the app clicking in the notification bar.
     *
     * @param {any} notification Notification received.
     */
    CorePushNotificationsProvider.prototype.onMessageReceived = function (notification) {
        var _this = this;
        var data = notification ? notification.additionalData : {};
        this.sitesProvider.getSite(data.site).then(function () {
            if (typeof data.customdata == 'string') {
                data.customdata = _this.textUtils.parseJSON(data.customdata, {});
            }
            if (_this.utils.isTrueOrOne(data.foreground)) {
                // If the app is in foreground when the notification is received, it's not shown. Let's show it ourselves.
                if (_this.localNotificationsProvider.isAvailable()) {
                    var localNotif_1 = {
                        id: data.notId || 1,
                        data: data,
                        title: '',
                        text: '',
                        channel: 'PushPluginChannel'
                    }, promises = [], isAndroid_1 = _this.platform.is('android'), extraFeatures_1 = _this.utils.isTrueOrOne(data.extrafeatures);
                    // Apply formatText to title and message.
                    promises.push(_this.textUtils.formatText(notification.title, true, true).then(function (formattedTitle) {
                        localNotif_1.title = formattedTitle;
                    }).catch(function () {
                        localNotif_1.title = notification.title;
                    }));
                    promises.push(_this.textUtils.formatText(notification.message, true, true).catch(function () {
                        // Error formatting, use the original message.
                        return notification.message;
                    }).then(function (formattedMessage) {
                        if (extraFeatures_1 && isAndroid_1 && _this.utils.isFalseOrZero(data.notif)) {
                            // It's a message, use messaging style. Ionic Native doesn't specify this option.
                            localNotif_1.text = [
                                {
                                    message: formattedMessage,
                                    person: data.conversationtype == 2 ? data.userfromfullname : ''
                                }
                            ];
                        }
                        else {
                            localNotif_1.text = formattedMessage;
                        }
                    }));
                    if (extraFeatures_1 && isAndroid_1) {
                        // Use a different icon if needed.
                        localNotif_1.icon = notification.image;
                        // This feature isn't supported by the official plugin, we use a fork.
                        localNotif_1.iconType = data['image-type'];
                    }
                    Promise.all(promises).then(function () {
                        _this.localNotificationsProvider.schedule(localNotif_1, CorePushNotificationsProvider_1.COMPONENT, data.site, true);
                    });
                }
                // Trigger a notification received event.
                _this.initDelegate.ready().then(function () {
                    data.title = notification.title;
                    data.message = notification.message;
                    _this.pushNotificationsDelegate.received(data);
                });
            }
            else {
                // The notification was clicked.
                _this.notificationClicked(data);
            }
        });
    };
    /**
     * Unregisters a device from a certain Moodle site.
     *
     * @param {CoreSite} site Site to unregister from.
     * @return {Promise<any>} Promise resolved when device is unregistered.
     */
    CorePushNotificationsProvider.prototype.unregisterDeviceOnMoodle = function (site) {
        var _this = this;
        if (!site || !this.appProvider.isMobile()) {
            return Promise.reject(null);
        }
        this.logger.debug("Unregister device on Moodle: '" + site.id + "'");
        var data = {
            appid: __WEBPACK_IMPORTED_MODULE_17__configconstants__["a" /* CoreConfigConstants */].app_id,
            uuid: this.device.uuid
        };
        return site.write('core_user_remove_user_device', data).then(function (response) {
            if (!response || !response.removed) {
                return Promise.reject(null);
            }
            var promises = [];
            // Remove the device from the local DB.
            promises.push(site.getDb().deleteRecords(CorePushNotificationsProvider_1.REGISTERED_DEVICES_TABLE, _this.getRegisterData()));
            // Remove pending unregisters for this site.
            promises.push(_this.appDB.deleteRecords(CorePushNotificationsProvider_1.PENDING_UNREGISTER_TABLE, { siteid: site.id }));
            return Promise.all(promises).catch(function () {
                // Ignore errors.
            });
        }).catch(function (error) {
            if (_this.utils.isWebServiceError(error)) {
                // It's a WebService error, can't unregister.
                return Promise.reject(error);
            }
            // Store the pending unregister so it's retried again later.
            return _this.appDB.insertRecord(CorePushNotificationsProvider_1.PENDING_UNREGISTER_TABLE, {
                siteid: site.id,
                siteurl: site.getURL(),
                token: site.getToken(),
                info: JSON.stringify(site.getInfo())
            }).then(function () {
                return Promise.reject(error);
            });
        });
    };
    /**
     * Update Counter for an addon. It will update the refered siteId counter and the total badge.
     * It will return the updated addon counter.
     *
     * @param  {string} addon    Registered addon name to set the badge number.
     * @param  {number} value    The number to be stored.
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>}    Promise resolved with the stored badge counter for the addon on the site.
     */
    CorePushNotificationsProvider.prototype.updateAddonCounter = function (addon, value, siteId) {
        var _this = this;
        if (this.pushNotificationsDelegate.isCounterHandlerRegistered(addon)) {
            siteId = siteId || this.sitesProvider.getCurrentSiteId();
            return this.saveAddonBadge(value, siteId, addon).then(function () {
                return _this.updateSiteCounter(siteId).then(function () {
                    return value;
                });
            });
        }
        return Promise.resolve(0);
    };
    /**
     * Update total badge counter of the app.
     *
     * @return {Promise<any>}        Promise resolved with the stored badge counter for the site.
     */
    CorePushNotificationsProvider.prototype.updateAppCounter = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (sites) {
            var promises = [];
            sites.forEach(function (siteId) {
                promises.push(_this.getAddonBadge(siteId));
            });
            return Promise.all(promises).then(function (counters) {
                var total = counters.reduce(function (previous, counter) {
                    // The app badge counter does not support strings, so parse to int before.
                    return previous + parseInt(counter, 10);
                }, 0);
                if (!_this.appProvider.isDesktop() && !_this.appProvider.isMobile()) {
                    // Browser doesn't have an app badge, stop.
                    return total;
                }
                // Set the app badge.
                return _this.badge.set(total).then(function () {
                    return total;
                });
            });
        });
    };
    /**
     * Update counter for a site using the stored addon data. It will update the total badge application number.
     * It will return the updated site counter.
     *
     * @param  {string} siteId Site ID.
     * @return {Promise<any>}       Promise resolved with the stored badge counter for the site.
     */
    CorePushNotificationsProvider.prototype.updateSiteCounter = function (siteId) {
        var _this = this;
        var addons = this.pushNotificationsDelegate.getCounterHandlers(), promises = [];
        for (var x in addons) {
            promises.push(this.getAddonBadge(siteId, addons[x]));
        }
        return Promise.all(promises).then(function (counters) {
            var plus = false, total = counters.reduce(function (previous, counter) {
                // Check if there is a plus sign at the end of the counter.
                if (counter != parseInt(counter, 10)) {
                    plus = true;
                    counter = parseInt(counter, 10);
                }
                return previous + counter;
            }, 0);
            total = plus && total > 0 ? total + '+' : total;
            // Save the counter on site.
            return _this.saveAddonBadge(total, siteId);
        }).then(function (siteTotal) {
            return _this.updateAppCounter().then(function () {
                return siteTotal;
            });
        });
    };
    /**
     * Register a device in Apple APNS or Google GCM.
     *
     * @return {Promise<any>} Promise resolved when the device is registered.
     */
    CorePushNotificationsProvider.prototype.registerDevice = function () {
        var _this = this;
        try {
            // Check if sound is enabled for notifications.
            return this.getOptions().then(function (options) {
                var pushObject = _this.push.init(options);
                pushObject.on('notification').subscribe(function (notification) {
                    // Execute the callback in the Angular zone, so change detection doesn't stop working.
                    _this.zone.run(function () {
                        _this.logger.log('Received a notification', notification);
                        _this.onMessageReceived(notification);
                    });
                });
                pushObject.on('registration').subscribe(function (data) {
                    // Execute the callback in the Angular zone, so change detection doesn't stop working.
                    _this.zone.run(function () {
                        _this.pushID = data.registrationId;
                        if (_this.sitesProvider.isLoggedIn()) {
                            _this.registerDeviceOnMoodle().catch(function (error) {
                                _this.logger.warn('Can\'t register device', error);
                            });
                        }
                    });
                });
                pushObject.on('error').subscribe(function (error) {
                    // Execute the callback in the Angular zone, so change detection doesn't stop working.
                    _this.zone.run(function () {
                        _this.logger.warn('Error with Push plugin', error);
                    });
                });
            });
        }
        catch (ex) {
            // Ignore errors.
            this.logger.warn(ex);
        }
        return Promise.reject(null);
    };
    /**
     * Registers a device on a Moodle site if needed.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [forceUnregister] Whether to force unregister and register.
     * @return {Promise<any>} Promise resolved when device is registered.
     */
    CorePushNotificationsProvider.prototype.registerDeviceOnMoodle = function (siteId, forceUnregister) {
        var _this = this;
        this.logger.debug('Register device on Moodle.');
        if (!this.canRegisterOnMoodle()) {
            return Promise.reject(null);
        }
        var data = this.getRegisterData();
        var result, site;
        return this.sitesProvider.getSite(siteId).then(function (s) {
            site = s;
            if (forceUnregister) {
                return { unregister: true, register: true };
            }
            else {
                // Check if the device is already registered.
                return _this.shouldRegister(data, site);
            }
        }).then(function (res) {
            result = res;
            if (result.unregister) {
                // Unregister the device first.
                return _this.unregisterDeviceOnMoodle(site).catch(function () {
                    // Ignore errors.
                });
            }
        }).then(function () {
            if (result.register) {
                // Now register the device.
                return site.write('core_user_add_user_device', _this.utils.clone(data)).then(function (response) {
                    // Insert the device in the local DB.
                    return site.getDb().insertRecord(CorePushNotificationsProvider_1.REGISTERED_DEVICES_TABLE, data)
                        .catch(function (error) {
                        // Ignore errors.
                    });
                });
            }
        }).finally(function () {
            // Remove pending unregisters for this site.
            _this.appDB.deleteRecords(CorePushNotificationsProvider_1.PENDING_UNREGISTER_TABLE, { siteid: site.id }).catch(function () {
                // Ignore errors.
            });
        });
    };
    /**
     * Get the addon/site badge counter from the database.
     *
     * @param  {string} siteId   Site ID.
     * @param  {string} [addon='site'] Registered addon name. If not defined it will store the site total.
     * @return {Promise<any>}         Promise resolved with the stored badge counter for the addon or site or 0 if none.
     */
    CorePushNotificationsProvider.prototype.getAddonBadge = function (siteId, addon) {
        if (addon === void 0) { addon = 'site'; }
        return this.appDB.getRecord(CorePushNotificationsProvider_1.BADGE_TABLE, { siteid: siteId, addon: addon }).then(function (entry) {
            return (entry && entry.number) || 0;
        }).catch(function () {
            return 0;
        });
    };
    /**
     * Retry pending unregisters.
     *
     * @param {string} [siteId] If defined, retry only for that site if needed. Otherwise, retry all pending unregisters.
     * @return {Promise<any>} Promise resolved when done.
     */
    CorePushNotificationsProvider.prototype.retryUnregisters = function (siteId) {
        var _this = this;
        var promise;
        if (siteId) {
            // Check if the site has a pending unregister.
            promise = this.appDB.getRecords(CorePushNotificationsProvider_1.PENDING_UNREGISTER_TABLE, { siteid: siteId });
        }
        else {
            // Get all pending unregisters.
            promise = this.appDB.getAllRecords(CorePushNotificationsProvider_1.PENDING_UNREGISTER_TABLE);
        }
        return promise.then(function (results) {
            var promises = [];
            results.forEach(function (result) {
                // Create a temporary site to unregister.
                var tmpSite = _this.sitesFactory.makeSite(result.siteid, result.siteurl, result.token, _this.textUtils.parseJSON(result.info, {}));
                promises.push(_this.unregisterDeviceOnMoodle(tmpSite));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Save the addon/site badgecounter on the database.
     *
     * @param  {number} value   The number to be stored.
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @param  {string} [addon='site'] Registered addon name. If not defined it will store the site total.
     * @return {Promise<any>}         Promise resolved with the stored badge counter for the addon or site.
     */
    CorePushNotificationsProvider.prototype.saveAddonBadge = function (value, siteId, addon) {
        if (addon === void 0) { addon = 'site'; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var entry = {
            siteid: siteId,
            addon: addon,
            number: value
        };
        return this.appDB.insertRecord(CorePushNotificationsProvider_1.BADGE_TABLE, entry).then(function () {
            return value;
        });
    };
    /**
     * Check if device should be registered (and unregistered first).
     *
     * @param {CorePushNotificationsRegisterData} data Data of the device.
     * @param {CoreSite} site Site to use.
     * @return {Promise<{register: boolean, unregister: boolean}>} Promise resolved with booleans: whether to register/unregister.
     */
    CorePushNotificationsProvider.prototype.shouldRegister = function (data, site) {
        // Check if the device is already registered.
        return site.getDb().getRecords(CorePushNotificationsProvider_1.REGISTERED_DEVICES_TABLE, {
            appid: data.appid,
            uuid: data.uuid
        }).catch(function () {
            // Ignore errors.
            return [];
        }).then(function (records) {
            var isStored = false, versionOrPushChanged = false;
            records.forEach(function (record) {
                if (record.name == data.name && record.model == data.model && record.platform == data.platform) {
                    if (record.version == data.version && record.pushid == data.pushid) {
                        // The device is already stored.
                        isStored = true;
                    }
                    else {
                        // The version or pushid has changed.
                        versionOrPushChanged = true;
                    }
                }
            });
            if (isStored) {
                // The device has already been registered, no need to register it again.
                return {
                    register: false,
                    unregister: false
                };
            }
            else if (versionOrPushChanged) {
                // This data can be updated by calling register WS, no need to call unregister.
                return {
                    register: true,
                    unregister: false
                };
            }
            else {
                return {
                    register: true,
                    unregister: true
                };
            }
        });
    };
    CorePushNotificationsProvider.COMPONENT = 'CorePushNotificationsProvider';
    // Variables for database. The name still contains the name "addon" for backwards compatibility.
    CorePushNotificationsProvider.BADGE_TABLE = 'addon_pushnotifications_badge';
    CorePushNotificationsProvider.PENDING_UNREGISTER_TABLE = 'addon_pushnotifications_pending_unregister';
    CorePushNotificationsProvider.REGISTERED_DEVICES_TABLE = 'addon_pushnotifications_registered_devices';
    CorePushNotificationsProvider = CorePushNotificationsProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_init__["a" /* CoreInitDelegate */],
            __WEBPACK_IMPORTED_MODULE_11__delegate__["a" /* CorePushNotificationsDelegate */], __WEBPACK_IMPORTED_MODULE_9__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__ionic_native_badge__["a" /* Badge */], __WEBPACK_IMPORTED_MODULE_12__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */],
            __WEBPACK_IMPORTED_MODULE_13__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_14__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_push__["a" /* Push */],
            __WEBPACK_IMPORTED_MODULE_15__providers_config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__["a" /* Device */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["M" /* NgZone */],
            __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_10__providers_sites_factory__["a" /* CoreSitesFactoryProvider */]])
    ], CorePushNotificationsProvider);
    return CorePushNotificationsProvider;
    var CorePushNotificationsProvider_1;
}());

//# sourceMappingURL=pushnotifications.js.map

/***/ }),
/* 141 */,
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInitDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/*
 * Provider for initialisation mechanisms.
 */
var CoreInitDelegate = /** @class */ (function () {
    function CoreInitDelegate(logger, platform, utils) {
        this.utils = utils;
        this.initProcesses = {};
        this.logger = logger.getInstance('CoreInitDelegate');
    }
    CoreInitDelegate_1 = CoreInitDelegate;
    /**
     * Executes the registered init processes.
     *
     * Reserved for core use, do not call directly.
     */
    CoreInitDelegate.prototype.executeInitProcesses = function () {
        var _this = this;
        var ordered = [];
        if (typeof this.readiness == 'undefined') {
            this.initReadiness();
        }
        // Re-ordering by priority.
        for (var name_1 in this.initProcesses) {
            ordered.push(this.initProcesses[name_1]);
        }
        ordered.sort(function (a, b) {
            return b.priority - a.priority;
        });
        ordered = ordered.map(function (data) {
            return {
                context: _this,
                func: _this.prepareProcess,
                params: [data],
                blocking: !!data.blocking
            };
        });
        // Execute all the processes in order to solve dependencies.
        this.utils.executeOrderedPromises(ordered).finally(this.readiness.resolve);
    };
    /**
     * Init the readiness promise.
     */
    CoreInitDelegate.prototype.initReadiness = function () {
        var _this = this;
        this.readiness = this.utils.promiseDefer();
        this.readiness.promise.then(function () { return _this.readiness.resolved = true; });
    };
    /**
     * Instantly returns if the app is ready.
     *
     * @return {boolean} Whether it's ready.
     */
    CoreInitDelegate.prototype.isReady = function () {
        return this.readiness.resolved;
    };
    /**
     * Convenience function to return a function that executes the process.
     *
     * @param {CoreInitHandler} data The data of the process.
     * @return {Promise<any>} Promise of the process.
     */
    CoreInitDelegate.prototype.prepareProcess = function (data) {
        var promise;
        this.logger.debug("Executing init process '" + data.name + "'");
        try {
            promise = data.load();
        }
        catch (e) {
            this.logger.error('Error while calling the init process \'' + data.name + '\'. ' + e);
            return;
        }
        return promise;
    };
    /**
     * Notifies when the app is ready. This returns a promise that is resolved when the app is initialised.
     *
     * @return {Promise<any>} Resolved when the app is initialised. Never rejected.
     */
    CoreInitDelegate.prototype.ready = function () {
        if (typeof this.readiness === 'undefined') {
            // Prevent race conditions if this is called before executeInitProcesses.
            this.initReadiness();
        }
        return this.readiness.promise;
    };
    /**
     * Registers an initialisation process.
     *
     * @description
     * Init processes can be used to add initialisation logic to the app. Anything that should block the user interface while
     * some processes are done should be an init process. It is recommended to use a priority lower than MAX_RECOMMENDED_PRIORITY
     * to make sure that your process does not happen before some essential other core processes.
     *
     * An init process should never change state or prompt user interaction.
     *
     * This delegate cannot be used by site plugins.
     *
     * @param {CoreInitHandler} instance The instance of the handler.
     */
    CoreInitDelegate.prototype.registerProcess = function (handler) {
        if (typeof handler.priority == 'undefined') {
            handler.priority = CoreInitDelegate_1.DEFAULT_PRIORITY;
        }
        if (typeof this.initProcesses[handler.name] != 'undefined') {
            this.logger.log("Process '" + handler.name + "' already registered.");
            return;
        }
        this.logger.log("Registering process '" + handler.name + "'.");
        this.initProcesses[handler.name] = handler;
    };
    CoreInitDelegate.DEFAULT_PRIORITY = 100; // Default priority for init processes.
    CoreInitDelegate.MAX_RECOMMENDED_PRIORITY = 600;
    CoreInitDelegate = CoreInitDelegate_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_3__utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreInitDelegate);
    return CoreInitDelegate;
    var CoreInitDelegate_1;
}());

//# sourceMappingURL=init.js.map

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCompileProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser_dynamic__ = __webpack_require__(564);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app_app_module__ = __webpack_require__(747);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_block_block_module__ = __webpack_require__(565);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_contentlinks_contentlinks_module__ = __webpack_require__(567);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_course_module__ = __webpack_require__(568);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_courses_courses_module__ = __webpack_require__(570);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_fileuploader_fileuploader_module__ = __webpack_require__(572);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_grades_grades_module__ = __webpack_require__(573);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_login_login_module__ = __webpack_require__(574);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_mainmenu_mainmenu_module__ = __webpack_require__(575);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_question_question_module__ = __webpack_require__(576);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_sharedfiles_sharedfiles_module__ = __webpack_require__(579);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__core_sitehome_sitehome_module__ = __webpack_require__(580);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__core_user_user_module__ = __webpack_require__(581);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__core_pushnotifications_pushnotifications_module__ = __webpack_require__(583);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__core_emulator_emulator_module__ = __webpack_require__(584);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__core_siteplugins_providers_siteplugins__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__angular_platform_browser__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__angular_forms__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__angular_http__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__angular_common_http__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__configconstants__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_moment__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_27_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_ts_md5_dist_md5__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_28_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__classes_base_sync__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__classes_cache__ = __webpack_require__(1016);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__core_contentlinks_classes_base_handler__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__core_contentlinks_classes_module_grade_handler__ = __webpack_require__(435);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__core_contentlinks_classes_module_index_handler__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__core_course_classes_activity_prefetch_handler__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__core_course_classes_resource_prefetch_handler__ = __webpack_require__(257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__components_components_module__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__directives_directives_module__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__pipes_pipes_module__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__core_course_components_components_module__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__core_course_directives_directives_module__ = __webpack_require__(1862);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__core_courses_components_components_module__ = __webpack_require__(262);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__core_siteplugins_directives_directives_module__ = __webpack_require__(1863);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__core_sitehome_components_components_module__ = __webpack_require__(1428);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__core_user_components_components_module__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__core_question_components_components_module__ = __webpack_require__(1434);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__core_block_components_components_module__ = __webpack_require__(707);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__core_course_components_unsupported_module_unsupported_module__ = __webpack_require__(376);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__core_course_formats_singleactivity_components_singleactivity__ = __webpack_require__(431);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__core_siteplugins_components_module_index_module_index__ = __webpack_require__(371);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__core_siteplugins_components_block_block__ = __webpack_require__(436);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__core_siteplugins_components_course_option_course_option__ = __webpack_require__(437);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__core_siteplugins_components_course_format_course_format__ = __webpack_require__(438);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__core_siteplugins_components_question_question__ = __webpack_require__(439);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__core_siteplugins_components_question_behaviour_question_behaviour__ = __webpack_require__(440);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__core_siteplugins_components_user_profile_field_user_profile_field__ = __webpack_require__(441);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__core_siteplugins_components_quiz_access_rule_quiz_access_rule__ = __webpack_require__(442);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__core_siteplugins_components_assign_feedback_assign_feedback__ = __webpack_require__(443);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__core_siteplugins_components_assign_submission_assign_submission__ = __webpack_require__(444);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__addon_badges_badges_module__ = __webpack_require__(591);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__addon_calendar_calendar_module__ = __webpack_require__(592);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__addon_competency_competency_module__ = __webpack_require__(593);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__addon_files_files_module__ = __webpack_require__(594);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__addon_messageoutput_messageoutput_module__ = __webpack_require__(595);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_65__addon_messages_messages_module__ = __webpack_require__(596);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_66__addon_mod_assign_assign_module__ = __webpack_require__(599);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_67__addon_mod_book_book_module__ = __webpack_require__(610);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_68__addon_mod_chat_chat_module__ = __webpack_require__(611);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_69__addon_mod_choice_choice_module__ = __webpack_require__(612);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_70__addon_mod_feedback_feedback_module__ = __webpack_require__(613);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_71__addon_mod_folder_folder_module__ = __webpack_require__(615);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_72__addon_mod_forum_forum_module__ = __webpack_require__(616);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_73__addon_mod_glossary_glossary_module__ = __webpack_require__(617);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_74__addon_mod_imscp_imscp_module__ = __webpack_require__(619);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_75__addon_mod_lesson_lesson_module__ = __webpack_require__(621);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_76__addon_mod_lti_lti_module__ = __webpack_require__(622);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_77__addon_mod_page_page_module__ = __webpack_require__(623);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_78__addon_mod_quiz_quiz_module__ = __webpack_require__(624);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_79__addon_mod_resource_resource_module__ = __webpack_require__(628);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_80__addon_mod_scorm_scorm_module__ = __webpack_require__(629);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_81__addon_mod_survey_survey_module__ = __webpack_require__(630);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_82__addon_mod_url_url_module__ = __webpack_require__(632);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_83__addon_mod_wiki_wiki_module__ = __webpack_require__(633);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_84__addon_mod_workshop_workshop_module__ = __webpack_require__(635);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_85__addon_notes_notes_module__ = __webpack_require__(640);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_86__addon_notifications_notifications_module__ = __webpack_require__(641);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_87__addon_remotethemes_remotethemes_module__ = __webpack_require__(642);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_88__addon_mod_assign_components_components_module__ = __webpack_require__(1410);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_89__addon_mod_workshop_components_components_module__ = __webpack_require__(465);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// Import core providers.















// Import only this provider to prevent circular dependencies.

// Import other libraries and providers.








// Import core classes that can be useful for site plugins.








// Import all core modules that define components, directives and pipes.











// Import some components listed in entryComponents so they can be injected dynamically.












// Import addon providers. Do not import database module because it causes circular dependencies.




























// Import some addon modules that define components, directives and pipes. Only import the important ones.


/**
 * Service to provide functionalities regarding compiling dynamic HTML and Javascript.
 */
var CoreCompileProvider = /** @class */ (function () {
    function CoreCompileProvider(injector, logger, compilerFactory) {
        this.injector = injector;
        // Other Ionic/Angular providers that don't depend on where they are injected.
        this.OTHER_PROVIDERS = [
            __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_23__angular_http__["d" /* Http */], __WEBPACK_IMPORTED_MODULE_24__angular_common_http__["c" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_21__angular_platform_browser__["c" /* DomSanitizer */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["a" /* ActionSheetController */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["b" /* AlertController */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* LoadingController */],
            __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* ModalController */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["w" /* PopoverController */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["D" /* ToastController */], __WEBPACK_IMPORTED_MODULE_22__angular_forms__["d" /* FormBuilder */]
        ];
        // List of imports for dynamic module. Since the template can have any component we need to import all core components modules.
        this.IMPORTS = [
            __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* IonicModule */], __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(), __WEBPACK_IMPORTED_MODULE_37__components_components_module__["a" /* CoreComponentsModule */], __WEBPACK_IMPORTED_MODULE_38__directives_directives_module__["a" /* CoreDirectivesModule */], __WEBPACK_IMPORTED_MODULE_39__pipes_pipes_module__["a" /* CorePipesModule */],
            __WEBPACK_IMPORTED_MODULE_40__core_course_components_components_module__["a" /* CoreCourseComponentsModule */], __WEBPACK_IMPORTED_MODULE_42__core_courses_components_components_module__["a" /* CoreCoursesComponentsModule */], __WEBPACK_IMPORTED_MODULE_44__core_sitehome_components_components_module__["a" /* CoreSiteHomeComponentsModule */], __WEBPACK_IMPORTED_MODULE_45__core_user_components_components_module__["a" /* CoreUserComponentsModule */],
            __WEBPACK_IMPORTED_MODULE_41__core_course_directives_directives_module__["a" /* CoreCourseDirectivesModule */], __WEBPACK_IMPORTED_MODULE_43__core_siteplugins_directives_directives_module__["a" /* CoreSitePluginsDirectivesModule */], __WEBPACK_IMPORTED_MODULE_46__core_question_components_components_module__["a" /* CoreQuestionComponentsModule */], __WEBPACK_IMPORTED_MODULE_88__addon_mod_assign_components_components_module__["a" /* AddonModAssignComponentsModule */],
            __WEBPACK_IMPORTED_MODULE_89__addon_mod_workshop_components_components_module__["a" /* AddonModWorkshopComponentsModule */], __WEBPACK_IMPORTED_MODULE_47__core_block_components_components_module__["a" /* CoreBlockComponentsModule */]
        ];
        this.logger = logger.getInstance('CoreCompileProvider');
        this.compiler = compilerFactory.createCompiler();
    }
    /**
     * Create and compile a dynamic component.
     *
     * @param {string} template The template of the component.
     * @param {any} componentClass The JS class of the component.
     * @param {any[]} [extraImports] Extra imported modules if needed and not imported by this class.
     * @return {Promise<ComponentFactory<any>>} Promise resolved with the factory to instantiate the component.
     */
    CoreCompileProvider.prototype.createAndCompileComponent = function (template, componentClass, extraImports) {
        if (extraImports === void 0) { extraImports = []; }
        // Create the component using the template and the class.
        var component = Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            template: template
        })(componentClass);
        var imports = this.IMPORTS.concat(extraImports);
        // Now create the module containing the component.
        var module = Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({ imports: imports, declarations: [component] })(/** @class */ (function () {
            function class_1() {
            }
            return class_1;
        }()));
        try {
            // Compile the module and the component.
            return this.compiler.compileModuleAndAllComponentsAsync(module).then(function (factories) {
                // Search and return the factory of the component we just created.
                for (var i in factories.componentFactories) {
                    var factory = factories.componentFactories[i];
                    if (factory.componentType == component) {
                        return factory;
                    }
                }
            });
        }
        catch (ex) {
            return Promise.reject({ message: 'Template has some errors and cannot be displayed.', debuginfo: ex });
        }
    };
    /**
     * Eval some javascript using the context of the function.
     *
     * @param {string} javascript The javascript to eval.
     * @return {any} Result of the eval.
     */
    CoreCompileProvider.prototype.evalInContext = function (javascript) {
        // tslint:disable: no-eval
        return eval(javascript);
    };
    /**
     * Execute some javascript code, using a certain instance as the context.
     *
     * @param {any} instance Instance to use as the context. In the JS code, "this" will be this instance.
     * @param {string} javascript The javascript code to eval.
     * @return {any} Result of the javascript execution.
     */
    CoreCompileProvider.prototype.executeJavascript = function (instance, javascript) {
        try {
            return this.evalInContext.call(instance, javascript);
        }
        catch (ex) {
            this.logger.error('Error evaluating javascript', ex);
        }
    };
    /**
     * Inject all the core libraries in a certain object.
     *
     * @param {any} instance The instance where to inject the libraries.
     * @param {any[]} [extraProviders] Extra imported providers if needed and not imported by this class.
     */
    CoreCompileProvider.prototype.injectLibraries = function (instance, extraProviders) {
        if (extraProviders === void 0) { extraProviders = []; }
        var providers = __WEBPACK_IMPORTED_MODULE_5__app_app_module__["b" /* CORE_PROVIDERS */].concat(__WEBPACK_IMPORTED_MODULE_7__core_contentlinks_contentlinks_module__["a" /* CORE_CONTENTLINKS_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_8__core_course_course_module__["a" /* CORE_COURSE_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_9__core_courses_courses_module__["a" /* CORE_COURSES_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_10__core_fileuploader_fileuploader_module__["a" /* CORE_FILEUPLOADER_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_11__core_grades_grades_module__["a" /* CORE_GRADES_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_12__core_login_login_module__["a" /* CORE_LOGIN_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_13__core_mainmenu_mainmenu_module__["a" /* CORE_MAINMENU_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_15__core_sharedfiles_sharedfiles_module__["a" /* CORE_SHAREDFILES_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_16__core_sitehome_sitehome_module__["a" /* CORE_SITEHOME_PROVIDERS */]).concat([__WEBPACK_IMPORTED_MODULE_20__core_siteplugins_providers_siteplugins__["a" /* CoreSitePluginsProvider */]]).concat(__WEBPACK_IMPORTED_MODULE_17__core_user_user_module__["a" /* CORE_USER_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_14__core_question_question_module__["a" /* CORE_QUESTION_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_19__core_emulator_emulator_module__["b" /* IONIC_NATIVE_PROVIDERS */]).concat(this.OTHER_PROVIDERS).concat(extraProviders)
            .concat(__WEBPACK_IMPORTED_MODULE_60__addon_badges_badges_module__["a" /* ADDON_BADGES_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_61__addon_calendar_calendar_module__["a" /* ADDON_CALENDAR_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_62__addon_competency_competency_module__["a" /* ADDON_COMPETENCY_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_63__addon_files_files_module__["a" /* ADDON_FILES_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_64__addon_messageoutput_messageoutput_module__["a" /* ADDON_MESSAGEOUTPUT_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_65__addon_messages_messages_module__["a" /* ADDON_MESSAGES_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_66__addon_mod_assign_assign_module__["a" /* ADDON_MOD_ASSIGN_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_67__addon_mod_book_book_module__["a" /* ADDON_MOD_BOOK_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_68__addon_mod_chat_chat_module__["a" /* ADDON_MOD_CHAT_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_69__addon_mod_choice_choice_module__["a" /* ADDON_MOD_CHOICE_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_70__addon_mod_feedback_feedback_module__["a" /* ADDON_MOD_FEEDBACK_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_71__addon_mod_folder_folder_module__["a" /* ADDON_MOD_FOLDER_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_72__addon_mod_forum_forum_module__["a" /* ADDON_MOD_FORUM_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_73__addon_mod_glossary_glossary_module__["a" /* ADDON_MOD_GLOSSARY_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_74__addon_mod_imscp_imscp_module__["a" /* ADDON_MOD_IMSCP_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_75__addon_mod_lesson_lesson_module__["a" /* ADDON_MOD_LESSON_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_76__addon_mod_lti_lti_module__["a" /* ADDON_MOD_LTI_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_77__addon_mod_page_page_module__["a" /* ADDON_MOD_PAGE_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_78__addon_mod_quiz_quiz_module__["a" /* ADDON_MOD_QUIZ_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_79__addon_mod_resource_resource_module__["a" /* ADDON_MOD_RESOURCE_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_80__addon_mod_scorm_scorm_module__["a" /* ADDON_MOD_SCORM_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_81__addon_mod_survey_survey_module__["a" /* ADDON_MOD_SURVEY_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_82__addon_mod_url_url_module__["a" /* ADDON_MOD_URL_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_83__addon_mod_wiki_wiki_module__["a" /* ADDON_MOD_WIKI_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_84__addon_mod_workshop_workshop_module__["a" /* ADDON_MOD_WORKSHOP_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_85__addon_notes_notes_module__["a" /* ADDON_NOTES_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_86__addon_notifications_notifications_module__["a" /* ADDON_NOTIFICATIONS_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_18__core_pushnotifications_pushnotifications_module__["a" /* CORE_PUSHNOTIFICATIONS_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_87__addon_remotethemes_remotethemes_module__["a" /* ADDON_REMOTETHEMES_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_6__core_block_block_module__["a" /* CORE_BLOCK_PROVIDERS */]);
        // We cannot inject anything to this constructor. Use the Injector to inject all the providers into the instance.
        for (var i in providers) {
            var providerDef = providers[i];
            if (typeof providerDef == 'function' && providerDef.name) {
                try {
                    // Inject the provider to the instance. We use the class name as the property name.
                    instance[providerDef.name] = this.injector.get(providerDef);
                }
                catch (ex) {
                    this.logger.warn('Error injecting provider', providerDef.name, ex);
                }
            }
        }
        // Inject current service.
        instance['CoreCompileProvider'] = this;
        // Add some final classes.
        instance['injector'] = this.injector;
        instance['Validators'] = __WEBPACK_IMPORTED_MODULE_22__angular_forms__["u" /* Validators */];
        instance['CoreConfigConstants'] = __WEBPACK_IMPORTED_MODULE_25__configconstants__["a" /* CoreConfigConstants */];
        instance['CoreConstants'] = __WEBPACK_IMPORTED_MODULE_26__core_constants__["a" /* CoreConstants */];
        instance['moment'] = __WEBPACK_IMPORTED_MODULE_27_moment__;
        instance['Md5'] = __WEBPACK_IMPORTED_MODULE_28_ts_md5_dist_md5__["Md5"];
        instance['CoreSyncBaseProvider'] = __WEBPACK_IMPORTED_MODULE_29__classes_base_sync__["a" /* CoreSyncBaseProvider */];
        instance['CoreCache'] = __WEBPACK_IMPORTED_MODULE_30__classes_cache__["a" /* CoreCache */];
        instance['CoreDelegate'] = __WEBPACK_IMPORTED_MODULE_31__classes_delegate__["a" /* CoreDelegate */];
        instance['CoreContentLinksHandlerBase'] = __WEBPACK_IMPORTED_MODULE_32__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */];
        instance['CoreContentLinksModuleGradeHandler'] = __WEBPACK_IMPORTED_MODULE_33__core_contentlinks_classes_module_grade_handler__["a" /* CoreContentLinksModuleGradeHandler */];
        instance['CoreContentLinksModuleIndexHandler'] = __WEBPACK_IMPORTED_MODULE_34__core_contentlinks_classes_module_index_handler__["a" /* CoreContentLinksModuleIndexHandler */];
        instance['CoreCourseActivityPrefetchHandlerBase'] = __WEBPACK_IMPORTED_MODULE_35__core_course_classes_activity_prefetch_handler__["a" /* CoreCourseActivityPrefetchHandlerBase */];
        instance['CoreCourseResourcePrefetchHandlerBase'] = __WEBPACK_IMPORTED_MODULE_36__core_course_classes_resource_prefetch_handler__["a" /* CoreCourseResourcePrefetchHandlerBase */];
        instance['CoreCourseUnsupportedModuleComponent'] = __WEBPACK_IMPORTED_MODULE_48__core_course_components_unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */];
        instance['CoreCourseFormatSingleActivityComponent'] = __WEBPACK_IMPORTED_MODULE_49__core_course_formats_singleactivity_components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */];
        instance['CoreSitePluginsModuleIndexComponent'] = __WEBPACK_IMPORTED_MODULE_50__core_siteplugins_components_module_index_module_index__["a" /* CoreSitePluginsModuleIndexComponent */];
        instance['CoreSitePluginsBlockComponent'] = __WEBPACK_IMPORTED_MODULE_51__core_siteplugins_components_block_block__["a" /* CoreSitePluginsBlockComponent */];
        instance['CoreSitePluginsCourseOptionComponent'] = __WEBPACK_IMPORTED_MODULE_52__core_siteplugins_components_course_option_course_option__["a" /* CoreSitePluginsCourseOptionComponent */];
        instance['CoreSitePluginsCourseFormatComponent'] = __WEBPACK_IMPORTED_MODULE_53__core_siteplugins_components_course_format_course_format__["a" /* CoreSitePluginsCourseFormatComponent */];
        instance['CoreSitePluginsQuestionComponent'] = __WEBPACK_IMPORTED_MODULE_54__core_siteplugins_components_question_question__["a" /* CoreSitePluginsQuestionComponent */];
        instance['CoreSitePluginsQuestionBehaviourComponent'] = __WEBPACK_IMPORTED_MODULE_55__core_siteplugins_components_question_behaviour_question_behaviour__["a" /* CoreSitePluginsQuestionBehaviourComponent */];
        instance['CoreSitePluginsUserProfileFieldComponent'] = __WEBPACK_IMPORTED_MODULE_56__core_siteplugins_components_user_profile_field_user_profile_field__["a" /* CoreSitePluginsUserProfileFieldComponent */];
        instance['CoreSitePluginsQuizAccessRuleComponent'] = __WEBPACK_IMPORTED_MODULE_57__core_siteplugins_components_quiz_access_rule_quiz_access_rule__["a" /* CoreSitePluginsQuizAccessRuleComponent */];
        instance['CoreSitePluginsAssignFeedbackComponent'] = __WEBPACK_IMPORTED_MODULE_58__core_siteplugins_components_assign_feedback_assign_feedback__["a" /* CoreSitePluginsAssignFeedbackComponent */];
        instance['CoreSitePluginsAssignSubmissionComponent'] = __WEBPACK_IMPORTED_MODULE_59__core_siteplugins_components_assign_submission_assign_submission__["a" /* CoreSitePluginsAssignSubmissionComponent */];
    };
    /**
     * Instantiate a dynamic component.
     *
     * @param {string} template The template of the component.
     * @param {any} componentClass The JS class of the component.
     * @param {Injector} [injector] The injector to use. It's recommended to pass it so NavController and similar can be injected.
     * @return {Promise<ComponentRef<any>>} Promise resolved with the component instance.
     */
    CoreCompileProvider.prototype.instantiateDynamicComponent = function (template, componentClass, injector) {
        injector = injector || this.injector;
        return this.createAndCompileComponent(template, componentClass).then(function (factory) {
            if (factory) {
                // Create and return the component.
                return factory.create(injector, undefined, undefined, injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__["K" /* NgModuleRef */]));
            }
        });
    };
    CoreCompileProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */], __WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser_dynamic__["a" /* JitCompilerFactory */]])
    ], CoreCompileProvider);
    return CoreCompileProvider;
}());

//# sourceMappingURL=compile.js.map

/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsPluginContentComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_siteplugins__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





/**
 * Component to render a site plugin content.
 */
var CoreSitePluginsPluginContentComponent = /** @class */ (function () {
    function CoreSitePluginsPluginContentComponent(domUtils, sitePluginsProvider, navCtrl, differs) {
        this.domUtils = domUtils;
        this.sitePluginsProvider = sitePluginsProvider;
        this.navCtrl = navCtrl;
        this.onContentLoaded = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onLoadingContent = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.invalidateObservable = new __WEBPACK_IMPORTED_MODULE_4_rxjs__["Subject"]();
        this.differ = differs.find([]).create();
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsPluginContentComponent.prototype.ngOnInit = function () {
        this.fetchContent();
    };
    /**
     * Detect and act upon changes that Angular can’t or won’t detect on its own (objects and arrays).
     */
    CoreSitePluginsPluginContentComponent.prototype.ngDoCheck = function () {
        if (!this.data || !this.jsData) {
            return;
        }
        // Check if there's any change in the data object.
        var changes = this.differ.diff(this.data);
        if (changes) {
            this.jsData = Object.assign(this.jsData, this.data);
        }
    };
    /**
     * Fetches the content to render.
     *
     * @param {boolean} [refresh] Whether the user is refreshing.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsPluginContentComponent.prototype.fetchContent = function (refresh) {
        var _this = this;
        this.onLoadingContent.emit(refresh);
        this.forceCompile = false;
        return this.sitePluginsProvider.getContent(this.component, this.method, this.args, this.preSets).then(function (result) {
            _this.content = result.templates.length ? result.templates[0].html : ''; // Load first template.
            _this.javascript = result.javascript;
            _this.otherData = result.otherdata;
            _this.data = _this.data || {};
            _this.forceCompile = true;
            _this.jsData = Object.assign(_this.data, _this.sitePluginsProvider.createDataForJS(_this.initResult, result));
            // Pass some methods as jsData so they can be called from the template too.
            _this.jsData.openContent = _this.openContent.bind(_this);
            _this.jsData.refreshContent = _this.refreshContent.bind(_this);
            _this.jsData.updateContent = _this.updateContent.bind(_this);
            _this.onContentLoaded.emit(refresh);
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.errorloadingcontent', true);
        }).finally(function () {
            _this.dataLoaded = true;
        });
    };
    /**
     * Open a new page with a new content.
     *
     * @param {string} title The title to display with the new content.
     * @param {any} args New params.
     * @param {string} [component] New component. If not provided, current component
     * @param {string} [method] New method. If not provided, current method
     * @param {any} [jsData] JS variables to pass to the new view so they can be used in the template or JS.
     *                       If true is supplied instead of an object, all initial variables from current page will be copied.
     * @param {any} [preSets] The preSets for the WS call of the new content.
     */
    CoreSitePluginsPluginContentComponent.prototype.openContent = function (title, args, component, method, jsData, preSets) {
        if (jsData === true) {
            jsData = this.data;
        }
        this.navCtrl.push('CoreSitePluginsPluginPage', {
            title: title,
            component: component || this.component,
            method: method || this.method,
            args: args,
            initResult: this.initResult,
            jsData: jsData,
            preSets: preSets
        });
    };
    /**
     * Refresh the data.
     *
     * @param {boolean} [showSpinner=true] Whether to show spinner while refreshing.
     */
    CoreSitePluginsPluginContentComponent.prototype.refreshContent = function (showSpinner) {
        var _this = this;
        if (showSpinner === void 0) { showSpinner = true; }
        if (showSpinner) {
            this.dataLoaded = false;
        }
        this.invalidateObservable.next(); // Notify observers.
        return this.sitePluginsProvider.invalidateContent(this.component, this.method, this.args).finally(function () {
            return _this.fetchContent(true);
        });
    };
    /**
     * Update the content, usually with a different method or params.
     *
     * @param {any} args New params.
     * @param {string} [component] New component. If not provided, current component
     * @param {string} [method] New method. If not provided, current method
     * @param {string} [jsData] JS variables to pass to the new view so they can be used in the template or JS.
     */
    CoreSitePluginsPluginContentComponent.prototype.updateContent = function (args, component, method, jsData) {
        this.component = component || this.component;
        this.method = method || this.method;
        this.args = args;
        this.dataLoaded = false;
        if (jsData) {
            Object.assign(this.data, jsData);
        }
        this.fetchContent();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('compile'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreSitePluginsPluginContentComponent.prototype, "compileComponent", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsPluginContentComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsPluginContentComponent.prototype, "method", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsPluginContentComponent.prototype, "args", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsPluginContentComponent.prototype, "initResult", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsPluginContentComponent.prototype, "data", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsPluginContentComponent.prototype, "preSets", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSitePluginsPluginContentComponent.prototype, "onContentLoaded", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSitePluginsPluginContentComponent.prototype, "onLoadingContent", void 0);
    CoreSitePluginsPluginContentComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-site-plugins-plugin-content',
            templateUrl: 'core-siteplugins-plugin-content.html',
        }),
        __param(2, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_siteplugins__["a" /* CoreSitePluginsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* KeyValueDiffers */]])
    ], CoreSitePluginsPluginContentComponent);
    return CoreSitePluginsPluginContentComponent;
}());

//# sourceMappingURL=plugin-content.js.map

/***/ }),
/* 145 */,
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleMainActivityComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_module_prefetch_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_network__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__main_resource_component__ = __webpack_require__(256);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Template class to easily create CoreCourseModuleMainComponent of activities.
 */
var CoreCourseModuleMainActivityComponent = /** @class */ (function (_super) {
    __extends(CoreCourseModuleMainActivityComponent, _super);
    function CoreCourseModuleMainActivityComponent(injector, content, loggerName) {
        if (loggerName === void 0) { loggerName = 'CoreCourseModuleMainResourceComponent'; }
        var _this = _super.call(this, injector, loggerName) || this;
        _this.content = content;
        _this.sitesProvider = injector.get(__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */]);
        _this.courseProvider = injector.get(__WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__["a" /* CoreCourseProvider */]);
        _this.appProvider = injector.get(__WEBPACK_IMPORTED_MODULE_6__providers_app__["a" /* CoreAppProvider */]);
        _this.eventsProvider = injector.get(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */]);
        _this.modulePrefetchDelegate = injector.get(__WEBPACK_IMPORTED_MODULE_3__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */]);
        var network = injector.get(__WEBPACK_IMPORTED_MODULE_5__ionic_native_network__["a" /* Network */]);
        var zone = injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__["M" /* NgZone */]);
        // Refresh online status when changes.
        _this.onlineObserver = network.onchange().subscribe(function (online) {
            // Execute the callback in the Angular zone, so change detection doesn't stop working.
            zone.run(function () {
                _this.isOnline = online;
            });
        });
        return _this;
    }
    /**
     * Component being initialized.
     */
    CoreCourseModuleMainActivityComponent.prototype.ngOnInit = function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.hasOffline = false;
        this.syncIcon = 'spinner';
        this.siteId = this.sitesProvider.getCurrentSiteId();
        this.moduleName = this.courseProvider.translateModuleName(this.moduleName);
        if (this.syncEventName) {
            // Refresh data if this discussion is synchronized automatically.
            this.syncObserver = this.eventsProvider.on(this.syncEventName, function (data) {
                _this.autoSyncEventReceived(data);
            }, this.siteId);
        }
    };
    /**
     * Compares sync event data with current data to check if refresh content is needed.
     *
     * @param {any} syncEventData Data received on sync observer.
     * @return {boolean}          True if refresh is needed, false otherwise.
     */
    CoreCourseModuleMainActivityComponent.prototype.isRefreshSyncNeeded = function (syncEventData) {
        return false;
    };
    /**
     * An autosync event has been received, check if refresh is needed and update the view.
     *
     * @param {any} syncEventData Data receiven on sync observer.
     */
    CoreCourseModuleMainActivityComponent.prototype.autoSyncEventReceived = function (syncEventData) {
        if (this.isRefreshSyncNeeded(syncEventData)) {
            // Refresh the data.
            this.showLoadingAndRefresh(false);
        }
    };
    /**
     * Perform the refresh content function.
     *
     * @param  {boolean}      [sync=false]       If the refresh needs syncing.
     * @param  {boolean}      [showErrors=false] Wether to show errors to the user or hide them.
     * @return {Promise<any>} Resolved when done.
     */
    CoreCourseModuleMainActivityComponent.prototype.refreshContent = function (sync, showErrors) {
        var _this = this;
        if (sync === void 0) { sync = false; }
        if (showErrors === void 0) { showErrors = false; }
        if (!this.module) {
            // This can happen if course format changes from single activity to weekly/topics.
            return Promise.resolve();
        }
        this.refreshIcon = 'spinner';
        this.syncIcon = 'spinner';
        // Wrap the call in a try/catch so the workflow isn't interrupted if an error occurs.
        // E.g. when changing course format we cannot know when will this.module become undefined, so it could cause errors.
        var promise;
        try {
            promise = this.invalidateContent();
        }
        catch (ex) {
            // An error ocurred in the function, log the error and just resolve the promise so the workflow continues.
            this.logger.error(ex);
            promise = Promise.resolve();
        }
        return promise.catch(function () {
            // Ignore errors.
        }).then(function () {
            return _this.loadContent(true, sync, showErrors);
        }).finally(function () {
            _this.refreshIcon = 'refresh';
            _this.syncIcon = 'sync';
        });
    };
    /**
     * Show loading and perform the load content function.
     *
     * @param  {boolean}      [sync=false]       If the fetch needs syncing.
     * @param  {boolean}      [showErrors=false] Wether to show errors to the user or hide them.
     * @return {Promise<any>} Resolved when done.
     */
    CoreCourseModuleMainActivityComponent.prototype.showLoadingAndFetch = function (sync, showErrors) {
        var _this = this;
        if (sync === void 0) { sync = false; }
        if (showErrors === void 0) { showErrors = false; }
        this.refreshIcon = 'spinner';
        this.syncIcon = 'spinner';
        this.loaded = false;
        this.domUtils.scrollToTop(this.content);
        return this.loadContent(false, sync, showErrors).finally(function () {
            _this.refreshIcon = 'refresh';
            _this.syncIcon = 'sync';
        });
    };
    /**
     * Show loading and perform the refresh content function.
     *
     * @param  {boolean}      [sync=false]       If the refresh needs syncing.
     * @param  {boolean}      [showErrors=false] Wether to show errors to the user or hide them.
     * @return {Promise<any>} Resolved when done.
     */
    CoreCourseModuleMainActivityComponent.prototype.showLoadingAndRefresh = function (sync, showErrors) {
        if (sync === void 0) { sync = false; }
        if (showErrors === void 0) { showErrors = false; }
        this.refreshIcon = 'spinner';
        this.syncIcon = 'spinner';
        this.loaded = false;
        this.domUtils.scrollToTop(this.content);
        return this.refreshContent(sync, showErrors);
    };
    /**
     * Download the component contents.
     *
     * @param {boolean}       [refresh=false] Whether we're refreshing data.
     * @param  {boolean}      [sync=false]       If the refresh needs syncing.
     * @param  {boolean}      [showErrors=false] Wether to show errors to the user or hide them.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainActivityComponent.prototype.fetchContent = function (refresh, sync, showErrors) {
        if (refresh === void 0) { refresh = false; }
        if (sync === void 0) { sync = false; }
        if (showErrors === void 0) { showErrors = false; }
        return Promise.resolve();
    };
    /**
     * Loads the component contents and shows the corresponding error.
     *
     * @param {boolean}       [refresh=false] Whether we're refreshing data.
     * @param  {boolean}      [sync=false]       If the refresh needs syncing.
     * @param  {boolean}      [showErrors=false] Wether to show errors to the user or hide them.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainActivityComponent.prototype.loadContent = function (refresh, sync, showErrors) {
        var _this = this;
        if (sync === void 0) { sync = false; }
        if (showErrors === void 0) { showErrors = false; }
        this.isOnline = this.appProvider.isOnline();
        if (!this.module) {
            // This can happen if course format changes from single activity to weekly/topics.
            return Promise.resolve();
        }
        // Wrap the call in a try/catch so the workflow isn't interrupted if an error occurs.
        // E.g. when changing course format we cannot know when will this.module become undefined, so it could cause errors.
        var promise;
        try {
            promise = this.fetchContent(refresh, sync, showErrors);
        }
        catch (ex) {
            // An error ocurred in the function, log the error and just resolve the promise so the workflow continues.
            this.logger.error(ex);
            promise = Promise.resolve();
        }
        return promise.catch(function (error) {
            if (!refresh) {
                // Some call failed, retry without using cache since it might be a new activity.
                return _this.refreshContent(sync);
            }
            // Error getting data, fail.
            _this.domUtils.showErrorModalDefault(error, _this.fetchContentDefaultError, true);
        }).finally(function () {
            _this.loaded = true;
            _this.refreshIcon = 'refresh';
            _this.syncIcon = 'sync';
        });
    };
    /**
     * Displays some data based on the current status.
     *
     * @param {string} status The current status.
     * @param {string} [previousStatus] The previous status. If not defined, there is no previous status.
     */
    CoreCourseModuleMainActivityComponent.prototype.showStatus = function (status, previousStatus) {
        // To be overridden.
    };
    /**
     * Watch for changes on the status.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainActivityComponent.prototype.setStatusListener = function () {
        var _this = this;
        if (typeof this.statusObserver == 'undefined') {
            // Listen for changes on this module status.
            this.statusObserver = this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].PACKAGE_STATUS_CHANGED, function (data) {
                if (data.componentId === _this.module.id && data.component === _this.component) {
                    // The status has changed, update it.
                    var previousStatus = _this.currentStatus;
                    _this.currentStatus = data.status;
                    _this.showStatus(_this.currentStatus, previousStatus);
                }
            }, this.siteId);
            // Also, get the current status.
            return this.modulePrefetchDelegate.getModuleStatus(this.module, this.courseId).then(function (status) {
                _this.currentStatus = status;
                _this.showStatus(status);
            });
        }
        return Promise.resolve();
    };
    /**
     * Performs the sync of the activity.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainActivityComponent.prototype.sync = function () {
        return Promise.resolve(true);
    };
    /**
     * Checks if sync has succeed from result sync data.
     *
     * @param  {any}     result Data returned on the sync function.
     * @return {boolean}        If suceed or not.
     */
    CoreCourseModuleMainActivityComponent.prototype.hasSyncSucceed = function (result) {
        return true;
    };
    /**
     * Tries to synchronize the activity.
     *
     * @param  {boolean}      [showErrors=false] If show errors to the user of hide them.
     * @return {Promise<boolean>} Promise resolved with true if sync succeed, or false if failed.
     */
    CoreCourseModuleMainActivityComponent.prototype.syncActivity = function (showErrors) {
        var _this = this;
        if (showErrors === void 0) { showErrors = false; }
        return this.sync().then(function (result) {
            if (result.warnings && result.warnings.length) {
                _this.domUtils.showErrorModal(result.warnings[0]);
            }
            return _this.hasSyncSucceed(result);
        }).catch(function (error) {
            if (showErrors) {
                _this.domUtils.showErrorModalDefault(error, 'core.errorsync', true);
            }
            return false;
        });
    };
    /**
     * Component being destroyed.
     */
    CoreCourseModuleMainActivityComponent.prototype.ngOnDestroy = function () {
        _super.prototype.ngOnDestroy.call(this);
        this.onlineObserver && this.onlineObserver.unsubscribe();
        this.syncObserver && this.syncObserver.off();
        this.statusObserver && this.statusObserver.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreCourseModuleMainActivityComponent.prototype, "group", void 0);
    return CoreCourseModuleMainActivityComponent;
}(__WEBPACK_IMPORTED_MODULE_7__main_resource_component__["a" /* CoreCourseModuleMainResourceComponent */]));

//# sourceMappingURL=main-activity-component.js.map

/***/ }),
/* 147 */,
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__messages_offline__ = __webpack_require__(361);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_emulator_providers_helper__ = __webpack_require__(293);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service to handle messages.
 */
var AddonMessagesProvider = /** @class */ (function () {
    function AddonMessagesProvider(logger, sitesProvider, appProvider, userProvider, messagesOffline, utils, timeUtils, emulatorHelper, eventsProvider) {
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        this.userProvider = userProvider;
        this.messagesOffline = messagesOffline;
        this.utils = utils;
        this.timeUtils = timeUtils;
        this.emulatorHelper = emulatorHelper;
        this.eventsProvider = eventsProvider;
        this.ROOT_CACHE_KEY = 'mmaMessages:';
        this.LIMIT_MESSAGES = AddonMessagesProvider_1.LIMIT_MESSAGES;
        this.logger = logger.getInstance('AddonMessagesProvider');
    }
    AddonMessagesProvider_1 = AddonMessagesProvider;
    /**
     * Add a contact.
     *
     * @param {number} userId  User ID of the person to add.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @return {Promise<any>}  Resolved when done.
     * @deprecated since Moodle 3.6
     */
    AddonMessagesProvider.prototype.addContact = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userids: [userId]
            };
            return site.write('core_message_create_contacts', params).then(function () {
                return _this.invalidateAllContactsCache(site.getUserId(), site.getId());
            });
        });
    };
    /**
     * Block a user.
     *
     * @param {number} userId User ID of the person to block.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.blockContact = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promise;
            if (site.wsAvailable('core_message_block_user')) {
                // Since Moodle 3.6
                var params = {
                    userid: site.getUserId(),
                    blockeduserid: userId,
                };
                promise = site.write('core_message_block_user', params);
            }
            else {
                var params = {
                    userids: [userId]
                };
                promise = site.write('core_message_block_contacts', params);
            }
            return promise.then(function () {
                return _this.invalidateAllMemberInfo(userId, site).finally(function () {
                    var data = { userId: userId, userBlocked: true };
                    _this.eventsProvider.trigger(AddonMessagesProvider_1.MEMBER_INFO_CHANGED_EVENT, data, site.id);
                });
            });
        });
    };
    /**
     * Confirm a contact request from another user.
     *
     * @param {number} userId ID of the user who made the contact request.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved when done.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.confirmContactRequest = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userid: userId,
                requesteduserid: site.getUserId(),
            };
            return site.write('core_message_confirm_contact_request', params).then(function () {
                return _this.utils.allPromises([
                    _this.invalidateAllMemberInfo(userId, site),
                    _this.invalidateContactsCache(site.id),
                    _this.invalidateUserContacts(site.id),
                    _this.refreshContactRequestsCount(site.id),
                ]).finally(function () {
                    var data = { userId: userId, contactRequestConfirmed: true };
                    _this.eventsProvider.trigger(AddonMessagesProvider_1.MEMBER_INFO_CHANGED_EVENT, data, site.id);
                });
            });
        });
    };
    /**
     * Send a contact request to another user.
     *
     * @param {number} userId ID of the receiver of the contact request.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved when done.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.createContactRequest = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userid: site.getUserId(),
                requesteduserid: userId,
            };
            return site.write('core_message_create_contact_request', params).then(function () {
                return _this.invalidateAllMemberInfo(userId, site).finally(function () {
                    var data = { userId: userId, contactRequestCreated: true };
                    _this.eventsProvider.trigger(AddonMessagesProvider_1.MEMBER_INFO_CHANGED_EVENT, data, site.id);
                });
            });
        });
    };
    /**
     * Decline a contact request from another user.
     *
     * @param {number} userId ID of the user who made the contact request.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved when done.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.declineContactRequest = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userid: userId,
                requesteduserid: site.getUserId(),
            };
            return site.write('core_message_decline_contact_request', params).then(function () {
                return _this.utils.allPromises([
                    _this.invalidateAllMemberInfo(userId, site),
                    _this.refreshContactRequestsCount(site.id),
                ]).finally(function () {
                    var data = { userId: userId, contactRequestDeclined: true };
                    _this.eventsProvider.trigger(AddonMessagesProvider_1.MEMBER_INFO_CHANGED_EVENT, data, site.id);
                });
            });
        });
    };
    /**
     * Delete a conversation.
     *
     * @param {number} conversationId Conversation to delete.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Promise resolved when the conversation has been deleted.
     */
    AddonMessagesProvider.prototype.deleteConversation = function (conversationId, siteId, userId) {
        return this.deleteConversations([conversationId], siteId, userId);
    };
    /**
     * Delete several conversations.
     *
     * @param {number[]} conversationIds Conversations to delete.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Promise resolved when the conversations have been deleted.
     */
    AddonMessagesProvider.prototype.deleteConversations = function (conversationIds, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                userid: userId,
                conversationids: conversationIds
            };
            return site.write('core_message_delete_conversations_by_id', params).then(function () {
                var promises = [];
                conversationIds.forEach(function (conversationId) {
                    promises.push(_this.messagesOffline.deleteConversationMessages(conversationId, site.getId()).catch(function () {
                        // Ignore errors (shouldn't happen).
                    }));
                });
                return Promise.all(promises);
            });
        });
    };
    /**
     * Delete a message (online or offline).
     *
     * @param {any} message    Message to delete.
     * @param {boolean} [deleteForAll] Whether the message should be deleted for all users.
     * @return {Promise<any>}  Promise resolved when the message has been deleted.
     */
    AddonMessagesProvider.prototype.deleteMessage = function (message, deleteForAll) {
        if (message.id) {
            // Message has ID, it means it has been sent to the server.
            if (deleteForAll) {
                return this.deleteMessageForAllOnline(message.id);
            }
            else {
                return this.deleteMessageOnline(message.id, message.read);
            }
        }
        // It's an offline message.
        if (message.conversationid) {
            return this.messagesOffline.deleteConversationMessage(message.conversationid, message.text, message.timecreated);
        }
        else {
            return this.messagesOffline.deleteMessage(message.touserid, message.smallmessage, message.timecreated);
        }
    };
    /**
     * Delete a message from the server.
     *
     * @param {number} id       Message ID.
     * @param {number} read     1 if message is read, 0 otherwise.
     * @param {number} [userId] User we want to delete the message for. If not defined, use current user.
     * @return {Promise<any>}   Promise resolved when the message has been deleted.
     */
    AddonMessagesProvider.prototype.deleteMessageOnline = function (id, read, userId) {
        var _this = this;
        var params = {
            messageid: id,
            userid: userId || this.sitesProvider.getCurrentSiteUserId()
        };
        if (typeof read != 'undefined') {
            params.read = read;
        }
        return this.sitesProvider.getCurrentSite().write('core_message_delete_message', params).then(function () {
            return _this.invalidateDiscussionCache(userId);
        });
    };
    /**
     * Delete a message for all users.
     *
     * @param {number} id Message ID.
     * @param {number} [userId] User we want to delete the message for. If not defined, use current user.
     * @return {Promise<any>} Promise resolved when the message has been deleted.
     */
    AddonMessagesProvider.prototype.deleteMessageForAllOnline = function (id, userId) {
        var _this = this;
        var params = {
            messageid: id,
            userid: userId || this.sitesProvider.getCurrentSiteUserId()
        };
        return this.sitesProvider.getCurrentSite().write('core_message_delete_message_for_all_users', params).then(function () {
            return _this.invalidateDiscussionCache(userId);
        });
    };
    /**
     * Format a conversation.
     *
     * @param {any} conversation Conversation to format.
     * @param {number} userId User ID viewing the conversation.
     * @return {any} Formatted conversation.
     */
    AddonMessagesProvider.prototype.formatConversation = function (conversation, userId) {
        var numMessages = conversation.messages.length, lastMessage = numMessages ? conversation.messages[numMessages - 1] : null;
        conversation.lastmessage = lastMessage ? lastMessage.text : null;
        conversation.lastmessagedate = lastMessage ? lastMessage.timecreated : null;
        conversation.sentfromcurrentuser = lastMessage ? lastMessage.useridfrom == userId : null;
        if (conversation.type != AddonMessagesProvider_1.MESSAGE_CONVERSATION_TYPE_GROUP) {
            var isIndividual_1 = conversation.type == AddonMessagesProvider_1.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL, otherUser = conversation.members.reduce(function (carry, member) {
                if (!carry && ((isIndividual_1 && member.id != userId) || (!isIndividual_1 && member.id == userId))) {
                    carry = member;
                }
                return carry;
            }, null);
            conversation.name = conversation.name ? conversation.name : otherUser.fullname;
            conversation.imageurl = conversation.imageurl ? conversation.imageurl : otherUser.profileimageurl;
            conversation.userid = otherUser.id;
            conversation.showonlinestatus = otherUser.showonlinestatus;
            conversation.isonline = otherUser.isonline;
            conversation.isblocked = otherUser.isblocked;
            conversation.otherUser = otherUser;
        }
        return conversation;
    };
    /**
     * Get the cache key for blocked contacts.
     *
     * @param {number} userId The user who's contacts we're looking for.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForBlockedContacts = function (userId) {
        return this.ROOT_CACHE_KEY + 'blockedContacts:' + userId;
    };
    /**
     * Get the cache key for contacts.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForContacts = function () {
        return this.ROOT_CACHE_KEY + 'contacts';
    };
    /**
     * Get the cache key for comfirmed contacts.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForUserContacts = function () {
        return this.ROOT_CACHE_KEY + 'userContacts';
    };
    /**
     * Get the cache key for contact requests.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForContactRequests = function () {
        return this.ROOT_CACHE_KEY + 'contactRequests';
    };
    /**
     * Get the cache key for contact requests count.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForContactRequestsCount = function () {
        return this.ROOT_CACHE_KEY + 'contactRequestsCount';
    };
    /**
     * Get the cache key for a discussion.
     *
     * @param {number} userId The other person with whom the current user is having the discussion.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForDiscussion = function (userId) {
        return this.ROOT_CACHE_KEY + 'discussion:' + userId;
    };
    /**
     * Get the cache key for the message count.
     *
     * @param {number} userId  User ID.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForMessageCount = function (userId) {
        return this.ROOT_CACHE_KEY + 'count:' + userId;
    };
    /**
     * Get the cache key for unread conversation counts.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForUnreadConversationCounts = function () {
        return this.ROOT_CACHE_KEY + 'unreadConversationCounts';
    };
    /**
     * Get the cache key for the list of discussions.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForDiscussions = function () {
        return this.ROOT_CACHE_KEY + 'discussions';
    };
    /**
     * Get cache key for get conversations.
     *
     * @param {number} userId User ID.
     * @param {number} conversationId Conversation ID.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForConversation = function (userId, conversationId) {
        return this.ROOT_CACHE_KEY + 'conversation:' + userId + ':' + conversationId;
    };
    /**
     * Get cache key for get conversations between users.
     *
     * @param {number} userId User ID.
     * @param {number} otherUserId Other user ID.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForConversationBetweenUsers = function (userId, otherUserId) {
        return this.ROOT_CACHE_KEY + 'conversationBetweenUsers:' + userId + ':' + otherUserId;
    };
    /**
     * Get cache key for get conversation members.
     *
     * @param {number} userId User ID.
     * @param {number} conversationId Conversation ID.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForConversationMembers = function (userId, conversationId) {
        return this.ROOT_CACHE_KEY + 'conversationMembers:' + userId + ':' + conversationId;
    };
    /**
     * Get cache key for get conversation messages.
     *
     * @param {number} userId User ID.
     * @param {number} conversationId Conversation ID.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForConversationMessages = function (userId, conversationId) {
        return this.ROOT_CACHE_KEY + 'conversationMessages:' + userId + ':' + conversationId;
    };
    /**
     * Get cache key for get conversations.
     *
     * @param {number} userId User ID.
     * @param {number} [type] Filter by type.
     * @param {boolean} [favourites] Filter favourites.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForConversations = function (userId, type, favourites) {
        return this.getCommonCacheKeyForUserConversations(userId) + ':' + type + ':' + favourites;
    };
    /**
     * Get cache key for conversation counts.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForConversationCounts = function () {
        return this.ROOT_CACHE_KEY + 'conversationCounts';
    };
    /**
     * Get cache key for member info.
     *
     * @param {number} userId User ID.
     * @param {number} otherUserId The other user ID.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForMemberInfo = function (userId, otherUserId) {
        return this.ROOT_CACHE_KEY + 'memberInfo:' + userId + ':' + otherUserId;
    };
    /**
     * Get cache key for get self conversation.
     *
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForSelfConversation = function (userId) {
        return this.ROOT_CACHE_KEY + 'selfconversation:' + userId;
    };
    /**
     * Get common cache key for get user conversations.
     *
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCommonCacheKeyForUserConversations = function (userId) {
        return this.getRootCacheKeyForConversations() + userId;
    };
    /**
     * Get root cache key for get conversations.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getRootCacheKeyForConversations = function () {
        return this.ROOT_CACHE_KEY + 'conversations:';
    };
    /**
     * Get all the contacts of the current user.
     *
     * @param  {string} [siteId]  Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved with the WS data.
     * @deprecated since Moodle 3.6
     */
    AddonMessagesProvider.prototype.getAllContacts = function (siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getContacts(siteId).then(function (contacts) {
            return _this.getBlockedContacts(siteId).then(function (blocked) {
                contacts.blocked = blocked.users;
                _this.storeUsersFromAllContacts(contacts);
                return contacts;
            }).catch(function () {
                // The WS for blocked contacts might fail, but we still want the contacts.
                contacts.blocked = [];
                _this.storeUsersFromAllContacts(contacts);
                return contacts;
            });
        });
    };
    /**
     * Get all the users blocked by the current user.
     *
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved with the WS data.
     */
    AddonMessagesProvider.prototype.getBlockedContacts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userId = site.getUserId(), params = {
                userid: userId
            }, preSets = {
                cacheKey: _this.getCacheKeyForBlockedContacts(userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            return site.read('core_message_get_blocked_users', params, preSets);
        });
    };
    /**
     * Get the contacts of the current user.
     *
     * This excludes the blocked users.
     *
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved with the WS data.
     * @deprecated since Moodle 3.6
     */
    AddonMessagesProvider.prototype.getContacts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getCacheKeyForContacts(),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            return site.read('core_message_get_contacts', undefined, preSets).then(function (contacts) {
                // Filter contacts with negative ID, they are notifications.
                var validContacts = {};
                var _loop_1 = function (typeName) {
                    if (!validContacts[typeName]) {
                        validContacts[typeName] = [];
                    }
                    contacts[typeName].forEach(function (contact) {
                        if (contact.id > 0) {
                            validContacts[typeName].push(contact);
                        }
                    });
                };
                for (var typeName in contacts) {
                    _loop_1(typeName);
                }
                return validContacts;
            });
        });
    };
    /**
     * Get the list of user contacts.
     *
     * @param {number} [limitFrom=0] Position of the first contact to fetch.
     * @param {number} [limitNum] Number of contacts to fetch. Default is AddonMessagesProvider.LIMIT_CONTACTS.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{contacts: any[], canLoadMore: boolean}>} Resolved with the list of user contacts.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getUserContacts = function (limitFrom, limitNum, siteId) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = AddonMessagesProvider_1.LIMIT_CONTACTS; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userid: site.getUserId(),
                limitfrom: limitFrom,
                limitnum: limitNum <= 0 ? 0 : limitNum + 1
            };
            var preSets = {
                cacheKey: _this.getCacheKeyForUserContacts(),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            return site.read('core_message_get_user_contacts', params, preSets).then(function (contacts) {
                if (!contacts || !contacts.length) {
                    return { contacts: [], canLoadMore: false };
                }
                _this.userProvider.storeUsers(contacts, site.id);
                if (limitNum <= 0) {
                    return { contacts: contacts, canLoadMore: false };
                }
                return {
                    contacts: contacts.slice(0, limitNum),
                    canLoadMore: contacts.length > limitNum
                };
            });
        });
    };
    /**
     * Get the contact request sent to the current user.
     *
     * @param {number} [limitFrom=0] Position of the first contact request to fetch.
     * @param {number} [limitNum] Number of contact requests to fetch. Default is AddonMessagesProvider.LIMIT_CONTACTS.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{requests: any[], canLoadMore: boolean}>} Resolved with the list of contact requests.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getContactRequests = function (limitFrom, limitNum, siteId) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = AddonMessagesProvider_1.LIMIT_CONTACTS; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                userid: site.getUserId(),
                limitfrom: limitFrom,
                limitnum: limitNum <= 0 ? 0 : limitNum + 1
            };
            var preSets = {
                cacheKey: _this.getCacheKeyForContactRequests(),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            return site.read('core_message_get_contact_requests', data, preSets).then(function (requests) {
                if (!requests || !requests.length) {
                    return { requests: [], canLoadMore: false };
                }
                _this.userProvider.storeUsers(requests, site.id);
                if (limitNum <= 0) {
                    return { requests: requests, canLoadMore: false };
                }
                return {
                    requests: requests.slice(0, limitNum),
                    canLoadMore: requests.length > limitNum
                };
            });
        });
    };
    /**
     * Get the number of contact requests sent to the current user.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<number>} Resolved with the number of contact requests.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getContactRequestsCount = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                userid: site.getUserId(),
            };
            var preSets = {
                cacheKey: _this.getCacheKeyForContactRequestsCount(),
                typeExpected: 'number'
            };
            return site.read('core_message_get_received_contact_requests_count', data, preSets).then(function (count) {
                // Notify the new count so all badges are updated.
                _this.eventsProvider.trigger(AddonMessagesProvider_1.CONTACT_REQUESTS_COUNT_EVENT, { count: count }, site.id);
                return count;
            });
        });
    };
    /**
     * Get a conversation by the conversation ID.
     *
     * @param {number} conversationId Conversation ID to fetch.
     * @param {boolean} [includeContactRequests] Include contact requests.
     * @param {boolean} [includePrivacyInfo] Include privacy info.
     * @param {number} [messageOffset=0] Offset for messages list.
     * @param {number} [messageLimit=1] Limit of messages. Defaults to 1 (last message).
     *                                  We recommend getConversationMessages to get them.
     * @param {number} [memberOffset=0] Offset for members list.
     * @param {number} [memberLimit=2] Limit of members. Defaults to 2 (to be able to know the other user in individual ones).
     *                                 We recommend getConversationMembers to get them.
     * @param {boolean} [newestFirst=true] Whether to order messages by newest first.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Promise resolved with the response.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getConversation = function (conversationId, includeContactRequests, includePrivacyInfo, messageOffset, messageLimit, memberOffset, memberLimit, newestFirst, siteId, userId) {
        var _this = this;
        if (messageOffset === void 0) { messageOffset = 0; }
        if (messageLimit === void 0) { messageLimit = 1; }
        if (memberOffset === void 0) { memberOffset = 0; }
        if (memberLimit === void 0) { memberLimit = 2; }
        if (newestFirst === void 0) { newestFirst = true; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var preSets = {
                cacheKey: _this.getCacheKeyForConversation(userId, conversationId)
            }, params = {
                userid: userId,
                conversationid: conversationId,
                includecontactrequests: includeContactRequests ? 1 : 0,
                includeprivacyinfo: includePrivacyInfo ? 1 : 0,
                messageoffset: messageOffset,
                messagelimit: messageLimit,
                memberoffset: memberOffset,
                memberlimit: memberLimit,
                newestmessagesfirst: newestFirst ? 1 : 0
            };
            return site.read('core_message_get_conversation', params, preSets).then(function (conversation) {
                return _this.formatConversation(conversation, userId);
            });
        });
    };
    /**
     * Get a conversation between two users.
     *
     * @param {number} otherUserId The other user ID.
     * @param {boolean} [includeContactRequests] Include contact requests.
     * @param {boolean} [includePrivacyInfo] Include privacy info.
     * @param {number} [messageOffset=0] Offset for messages list.
     * @param {number} [messageLimit=1] Limit of messages. Defaults to 1 (last message).
     *                                  We recommend getConversationMessages to get them.
     * @param {number} [memberOffset=0] Offset for members list.
     * @param {number} [memberLimit=2] Limit of members. Defaults to 2 (to be able to know the other user in individual ones).
     *                                 We recommend getConversationMembers to get them.
     * @param {boolean} [newestFirst=true] Whether to order messages by newest first.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @return {Promise<any>} Promise resolved with the response.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getConversationBetweenUsers = function (otherUserId, includeContactRequests, includePrivacyInfo, messageOffset, messageLimit, memberOffset, memberLimit, newestFirst, siteId, userId, preferCache) {
        var _this = this;
        if (messageOffset === void 0) { messageOffset = 0; }
        if (messageLimit === void 0) { messageLimit = 1; }
        if (memberOffset === void 0) { memberOffset = 0; }
        if (memberLimit === void 0) { memberLimit = 2; }
        if (newestFirst === void 0) { newestFirst = true; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var preSets = {
                cacheKey: _this.getCacheKeyForConversationBetweenUsers(userId, otherUserId),
                omitExpires: !!preferCache,
            }, params = {
                userid: userId,
                otheruserid: otherUserId,
                includecontactrequests: includeContactRequests ? 1 : 0,
                includeprivacyinfo: includePrivacyInfo ? 1 : 0,
                messageoffset: messageOffset,
                messagelimit: messageLimit,
                memberoffset: memberOffset,
                memberlimit: memberLimit,
                newestmessagesfirst: newestFirst ? 1 : 0
            };
            return site.read('core_message_get_conversation_between_users', params, preSets).then(function (conversation) {
                return _this.formatConversation(conversation, userId);
            });
        });
    };
    /**
     * Get a conversation members.
     *
     * @param {number} conversationId Conversation ID to fetch.
     * @param {number} [limitFrom=0] Offset for members list.
     * @param {number} [limitTo] Limit of members.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Promise resolved with the response.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getConversationMembers = function (conversationId, limitFrom, limitTo, includeContactRequests, siteId, userId) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            if (typeof limitTo == 'undefined' || limitTo === null) {
                limitTo = _this.LIMIT_MESSAGES;
            }
            var preSets = {
                cacheKey: _this.getCacheKeyForConversationMembers(userId, conversationId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            }, params = {
                userid: userId,
                conversationid: conversationId,
                limitfrom: limitFrom,
                limitnum: limitTo < 1 ? limitTo : limitTo + 1,
                includecontactrequests: includeContactRequests ? 1 : 0,
                includeprivacyinfo: 1,
            };
            return site.read('core_message_get_conversation_members', params, preSets).then(function (members) {
                var result = {};
                if (limitTo < 1) {
                    result.canLoadMore = false;
                    result.members = members;
                }
                else {
                    result.canLoadMore = members.length > limitTo;
                    result.members = members.slice(0, limitTo);
                }
                return result;
            });
        });
    };
    /**
     * Get a conversation by the conversation ID.
     *
     * @param {number} conversationId Conversation ID to fetch.
     * @param {boolean} excludePending True to exclude messages pending to be sent.
     * @param {number} [limitFrom=0] Offset for messages list.
     * @param {number} [limitTo] Limit of messages.
     * @param {boolean} [newestFirst=true] Whether to order messages by newest first.
     * @param {number} [timeFrom] The timestamp from which the messages were created.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Promise resolved with the response.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getConversationMessages = function (conversationId, excludePending, limitFrom, limitTo, newestFirst, timeFrom, siteId, userId) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        if (newestFirst === void 0) { newestFirst = true; }
        if (timeFrom === void 0) { timeFrom = 0; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            if (typeof limitTo == 'undefined' || limitTo === null) {
                limitTo = _this.LIMIT_MESSAGES;
            }
            var preSets = {
                cacheKey: _this.getCacheKeyForConversationMessages(userId, conversationId)
            }, params = {
                currentuserid: userId,
                convid: conversationId,
                limitfrom: limitFrom,
                limitnum: limitTo < 1 ? limitTo : limitTo + 1,
                newest: newestFirst ? 1 : 0,
                timefrom: timeFrom
            };
            if (limitFrom > 0) {
                // Do not use cache when retrieving older messages.
                // This is to prevent storing too much data and to prevent inconsistencies between "pages" loaded.
                preSets['getFromCache'] = false;
                preSets['saveToCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return site.read('core_message_get_conversation_messages', params, preSets).then(function (result) {
                if (limitTo < 1) {
                    result.canLoadMore = false;
                    result.messages = result.messages;
                }
                else {
                    result.canLoadMore = result.messages.length > limitTo;
                    result.messages = result.messages.slice(0, limitTo);
                }
                var lastReceived;
                result.messages.forEach(function (message) {
                    // Convert time to milliseconds.
                    message.timecreated = message.timecreated ? message.timecreated * 1000 : 0;
                    if (!lastReceived && message.useridfrom != userId) {
                        lastReceived = message;
                    }
                });
                if (_this.appProvider.isDesktop() && limitFrom === 0 && lastReceived) {
                    // Store the last received message (we cannot know if it's unread or not). Don't block the user for this.
                    _this.storeLastReceivedMessageIfNeeded(conversationId, lastReceived, site.getId());
                }
                if (excludePending) {
                    // No need to get offline messages, return the ones we have.
                    return result;
                }
                // Get offline messages.
                return _this.messagesOffline.getConversationMessages(conversationId).then(function (offlineMessages) {
                    // Mark offline messages as pending.
                    offlineMessages.forEach(function (message) {
                        message.pending = true;
                        message.useridfrom = userId;
                    });
                    result.messages = result.messages.concat(offlineMessages);
                    return result;
                });
            });
        });
    };
    /**
     * Get the discussions of a certain user. This function is used in Moodle sites higher than 3.6.
     * If the site is older than 3.6, please use getDiscussions.
     *
     * @param {number} [type] Filter by type.
     * @param {boolean} [favourites] Whether to restrict the results to contain NO favourite conversations (false), ONLY favourite
     *                               conversation (true), or ignore any restriction altogether (undefined or null).
     * @param {number} [limitFrom=0] The offset to start at.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @param {boolean} [forceCache] True if it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>} Promise resolved with the conversations.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getConversations = function (type, favourites, limitFrom, siteId, userId, forceCache, ignoreCache) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var preSets = {
                cacheKey: _this.getCacheKeyForConversations(userId, type, favourites)
            }, params = {
                userid: userId,
                limitfrom: limitFrom,
                limitnum: _this.LIMIT_MESSAGES + 1,
            };
            if (forceCache) {
                preSets['omitExpires'] = true;
            }
            else if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            if (typeof type != 'undefined' && type != null) {
                params.type = type;
            }
            if (typeof favourites != 'undefined' && favourites != null) {
                params.favourites = favourites ? 1 : 0;
            }
            if (site.isVersionGreaterEqualThan('3.7') && type != AddonMessagesProvider_1.MESSAGE_CONVERSATION_TYPE_GROUP) {
                // Add self conversation to the list.
                params.mergeself = 1;
            }
            return site.read('core_message_get_conversations', params, preSets).catch(function (error) {
                if (params.mergeself) {
                    // Try again without the new param. Maybe the user is offline and he has a previous request cached.
                    delete params.mergeself;
                    return site.read('core_message_get_conversations', params, preSets);
                }
                return Promise.reject(error);
            }).then(function (response) {
                // Format the conversations, adding some calculated fields.
                var conversations = response.conversations.slice(0, _this.LIMIT_MESSAGES).map(function (conversation) {
                    return _this.formatConversation(conversation, userId);
                }), conv = conversations[0], lastMessage = conv && conv.messages[0];
                if (_this.appProvider.isDesktop() && limitFrom === 0 && lastMessage && !conv.sentfromcurrentuser) {
                    // Store the last received message (we cannot know if it's unread or not). Don't block the user for this.
                    _this.storeLastReceivedMessageIfNeeded(conv.id, lastMessage, site.getId());
                }
                return {
                    conversations: conversations,
                    canLoadMore: response.conversations.length > _this.LIMIT_MESSAGES
                };
            });
        });
    };
    /**
     * Get conversation counts by type.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<favourites: number, individual: number, group: number, self: number>} Promise resolved with favourite,
     *                                      individual, group and self conversation counts.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getConversationCounts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getCacheKeyForConversationCounts()
            };
            return site.read('core_message_get_conversation_counts', {}, preSets).then(function (result) {
                var counts = {
                    favourites: result.favourites,
                    individual: result.types[AddonMessagesProvider_1.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL],
                    group: result.types[AddonMessagesProvider_1.MESSAGE_CONVERSATION_TYPE_GROUP],
                    self: result.types[AddonMessagesProvider_1.MESSAGE_CONVERSATION_TYPE_SELF] || 0
                };
                return counts;
            });
        });
    };
    /**
     * Return the current user's discussion with another user.
     *
     * @param  {number} userId               The ID of the other user.
     * @param  {boolean} excludePending      True to exclude messages pending to be sent.
     * @param  {number} [lfReceivedUnread=0] Number of unread received messages already fetched, so fetch will be done from this.
     * @param  {number} [lfReceivedRead=0]   Number of read received messages already fetched, so fetch will be done from this.
     * @param  {number} [lfSentUnread=0]     Number of unread sent messages already fetched, so fetch will be done from this.
     * @param  {number} [lfSentRead=0]       Number of read sent messages already fetched, so fetch will be done from this.
     * @param  {boolean} [toDisplay=true]    True if messages will be displayed to the user, either in view or in a notification.
     * @param  {string} [siteId]             Site ID. If not defined, use current site.
     * @return {Promise<any>}                     Promise resolved with messages and a boolean telling if can load more messages.
     */
    AddonMessagesProvider.prototype.getDiscussion = function (userId, excludePending, lfReceivedUnread, lfReceivedRead, lfSentUnread, lfSentRead, toDisplay, siteId) {
        var _this = this;
        if (lfReceivedUnread === void 0) { lfReceivedUnread = 0; }
        if (lfReceivedRead === void 0) { lfReceivedRead = 0; }
        if (lfSentUnread === void 0) { lfSentUnread = 0; }
        if (lfSentRead === void 0) { lfSentRead = 0; }
        if (toDisplay === void 0) { toDisplay = true; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var result = {}, preSets = {
                cacheKey: _this.getCacheKeyForDiscussion(userId)
            }, params = {
                useridto: site.getUserId(),
                useridfrom: userId,
                limitnum: _this.LIMIT_MESSAGES
            };
            var hasReceived, hasSent;
            if (lfReceivedUnread > 0 || lfReceivedRead > 0 || lfSentUnread > 0 || lfSentRead > 0) {
                // Do not use cache when retrieving older messages.
                // This is to prevent storing too much data and to prevent inconsistencies between "pages" loaded.
                preSets['getFromCache'] = false;
                preSets['saveToCache'] = false;
                preSets['emergencyCache'] = false;
            }
            // Get message received by current user.
            return _this.getRecentMessages(params, preSets, lfReceivedUnread, lfReceivedRead, toDisplay, site.getId())
                .then(function (response) {
                result['messages'] = response;
                params.useridto = userId;
                params.useridfrom = site.getUserId();
                hasReceived = response.length > 0;
                // Get message sent by current user.
                return _this.getRecentMessages(params, preSets, lfSentUnread, lfSentRead, toDisplay, siteId);
            }).then(function (response) {
                result['messages'] = result['messages'].concat(response);
                hasSent = response.length > 0;
                if (result['messages'].length > _this.LIMIT_MESSAGES) {
                    // Sort messages and get the more recent ones.
                    result['canLoadMore'] = true;
                    result['messages'] = _this.sortMessages(result['messages']);
                    result['messages'] = result['messages'].slice(-_this.LIMIT_MESSAGES);
                }
                else {
                    result['canLoadMore'] = result['messages'].length == _this.LIMIT_MESSAGES && (!hasReceived || !hasSent);
                }
                if (excludePending) {
                    // No need to get offline messages, return the ones we have.
                    return result;
                }
                // Get offline messages.
                return _this.messagesOffline.getMessages(userId).then(function (offlineMessages) {
                    // Mark offline messages as pending.
                    offlineMessages.forEach(function (message) {
                        message.pending = true;
                        message.text = message.smallmessage;
                    });
                    result['messages'] = result['messages'].concat(offlineMessages);
                    return result;
                });
            });
        });
    };
    /**
     * Get the discussions of the current user. This function is used in Moodle sites older than 3.6.
     * If the site is 3.6 or higher, please use getConversations.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved with an object where the keys are the user ID of the other user.
     */
    AddonMessagesProvider.prototype.getDiscussions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var discussions = {}, currentUserId = site.getUserId(), params = {
                useridto: currentUserId,
                useridfrom: 0,
                limitnum: _this.LIMIT_MESSAGES
            }, preSets = {
                cacheKey: _this.getCacheKeyForDiscussions()
            };
            /**
             * Convenience function to treat a recent message, adding it to discussions list if needed.
             */
            var treatRecentMessage = function (message, userId, userFullname) {
                if (typeof discussions[userId] === 'undefined') {
                    discussions[userId] = {
                        fullname: userFullname,
                        profileimageurl: ''
                    };
                    if (!message.timeread && !message.pending && message.useridfrom != currentUserId) {
                        discussions[userId].unread = true;
                    }
                }
                // Extract the most recent message. Pending messages are considered more recent than messages already sent.
                var discMessage = discussions[userId].message;
                if (typeof discMessage === 'undefined' || (!discMessage.pending && message.pending) ||
                    (discMessage.pending == message.pending && (discMessage.timecreated < message.timecreated ||
                        (discMessage.timecreated == message.timecreated && discMessage.id < message.id)))) {
                    discussions[userId].message = {
                        id: message.id,
                        user: userId,
                        message: message.text,
                        timecreated: message.timecreated,
                        pending: !!message.pending
                    };
                }
            };
            // Get recent messages sent to current user.
            return _this.getRecentMessages(params, preSets, undefined, undefined, undefined, site.getId()).then(function (messages) {
                // Extract the discussions by filtering same senders.
                messages.forEach(function (message) {
                    treatRecentMessage(message, message.useridfrom, message.userfromfullname);
                });
                // Now get the last messages sent by the current user.
                params.useridfrom = params.useridto;
                params.useridto = 0;
                return _this.getRecentMessages(params, preSets);
            }).then(function (messages) {
                // Extract the discussions by filtering same senders.
                messages.forEach(function (message) {
                    treatRecentMessage(message, message.useridto, message.usertofullname);
                });
                // Now get unsent messages.
                return _this.messagesOffline.getAllMessages(site.getId());
            }).then(function (offlineMessages) {
                offlineMessages.forEach(function (message) {
                    message.pending = true;
                    message.text = message.smallmessage;
                    treatRecentMessage(message, message.touserid, '');
                });
                return _this.getDiscussionsUserImg(discussions, site.getId()).then(function (discussions) {
                    _this.storeUsersFromDiscussions(discussions);
                    return discussions;
                });
            });
        });
    };
    /**
     * Get user images for all the discussions that don't have one already.
     *
     * @param {any} discussions List of discussions.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}             Promise always resolved. Resolve param is the formatted discussions.
     */
    AddonMessagesProvider.prototype.getDiscussionsUserImg = function (discussions, siteId) {
        var promises = [];
        var _loop_2 = function (userId) {
            if (!discussions[userId].profileimageurl) {
                // We don't have the user image. Try to retrieve it.
                promises.push(this_1.userProvider.getProfile(discussions[userId].message.user, 0, true, siteId).then(function (user) {
                    discussions[userId].profileimageurl = user.profileimageurl;
                }).catch(function () {
                    // Error getting profile, resolve promise without adding any extra data.
                }));
            }
        };
        var this_1 = this;
        for (var userId in discussions) {
            _loop_2(userId);
        }
        return Promise.all(promises).then(function () {
            return discussions;
        });
    };
    /**
     * Get conversation member info by user id, works even if no conversation betwen the users exists.
     *
     * @param {number} otherUserId The other user ID.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Promise resolved with the member info.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.getMemberInfo = function (otherUserId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var preSets = {
                cacheKey: _this.getCacheKeyForMemberInfo(userId, otherUserId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            }, params = {
                referenceuserid: userId,
                userids: [otherUserId],
                includecontactrequests: 1,
                includeprivacyinfo: 1,
            };
            return site.read('core_message_get_member_info', params, preSets).then(function (members) {
                if (!members || members.length < 1) {
                    // Should never happen.
                    return Promise.reject(null);
                }
                return members[0];
            });
        });
    };
    /**
     * Get the cache key for the get message preferences call.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getMessagePreferencesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'messagePreferences';
    };
    /**
     * Get message preferences.
     *
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>}         Promise resolved with the message preferences.
     */
    AddonMessagesProvider.prototype.getMessagePreferences = function (siteId) {
        var _this = this;
        this.logger.debug('Get message preferences');
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getMessagePreferencesCacheKey(),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('core_message_get_user_message_preferences', {}, preSets).then(function (data) {
                if (data.preferences) {
                    data.preferences.blocknoncontacts = data.blocknoncontacts;
                    return data.preferences;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get messages according to the params.
     *
     * @param  {any} params            Parameters to pass to the WS.
     * @param  {any} preSets           Set of presets for the WS.
     * @param  {boolean} [toDisplay=true] True if messages will be displayed to the user, either in view or in a notification.
     * @param  {string} [siteId]          Site ID. If not defined, use current site.
     * @return {Promise<any>}
     */
    AddonMessagesProvider.prototype.getMessages = function (params, preSets, toDisplay, siteId) {
        var _this = this;
        if (toDisplay === void 0) { toDisplay = true; }
        params['type'] = 'conversations';
        params['newestfirst'] = 1;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userId = site.getUserId();
            return site.read('core_message_get_messages', params, preSets).then(function (response) {
                response.messages.forEach(function (message) {
                    message.read = params.read == 0 ? 0 : 1;
                    // Convert times to milliseconds.
                    message.timecreated = message.timecreated ? message.timecreated * 1000 : 0;
                    message.timeread = message.timeread ? message.timeread * 1000 : 0;
                });
                if (toDisplay && _this.appProvider.isDesktop() && !params.read && params.useridto == userId &&
                    params.limitfrom === 0) {
                    // Store the last unread received messages. Don't block the user for this.
                    _this.storeLastReceivedMessageIfNeeded(params.useridfrom, response.messages[0], site.getId());
                }
                return response;
            });
        });
    };
    /**
     * Get the most recent messages.
     *
     * @param  {any} params              Parameters to pass to the WS.
     * @param  {any} preSets             Set of presets for the WS.
     * @param  {number} [limitFromUnread=0] Number of read messages already fetched, so fetch will be done from this number.
     * @param  {number} [limitFromRead=0]   Number of unread messages already fetched, so fetch will be done from this number.
     * @param  {boolean} [toDisplay=true]   True if messages will be displayed to the user, either in view or in a notification.
     * @param  {string} [siteId]            Site ID. If not defined, use current site.
     * @return {Promise<any>}
     */
    AddonMessagesProvider.prototype.getRecentMessages = function (params, preSets, limitFromUnread, limitFromRead, toDisplay, siteId) {
        var _this = this;
        if (limitFromUnread === void 0) { limitFromUnread = 0; }
        if (limitFromRead === void 0) { limitFromRead = 0; }
        if (toDisplay === void 0) { toDisplay = true; }
        limitFromUnread = limitFromUnread || 0;
        limitFromRead = limitFromRead || 0;
        params['read'] = 0;
        params['limitfrom'] = limitFromUnread;
        return this.getMessages(params, preSets, toDisplay, siteId).then(function (response) {
            var messages = response.messages;
            if (messages) {
                if (messages.length >= params.limitnum) {
                    return messages;
                }
                // We need to fetch more messages.
                params.limitnum = params.limitnum - messages.length;
                params.read = 1;
                params.limitfrom = limitFromRead;
                return _this.getMessages(params, preSets, toDisplay, siteId).then(function (response) {
                    if (response.messages) {
                        messages = messages.concat(response.messages);
                    }
                    return messages;
                }).catch(function () {
                    return messages;
                });
            }
            else {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Get a self conversation.
     *
     * @param {number} [messageOffset=0] Offset for messages list.
     * @param {number} [messageLimit=1] Limit of messages. Defaults to 1 (last message).
     *                                  We recommend getConversationMessages to get them.
     * @param {boolean} [newestFirst=true] Whether to order messages by newest first.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @param {string} [userId] User ID to get the self conversation for. If not defined, current user in the site.
     * @return {Promise<any>} Promise resolved with the response.
     * @since 3.7
     */
    AddonMessagesProvider.prototype.getSelfConversation = function (messageOffset, messageLimit, newestFirst, siteId, userId) {
        var _this = this;
        if (messageOffset === void 0) { messageOffset = 0; }
        if (messageLimit === void 0) { messageLimit = 1; }
        if (newestFirst === void 0) { newestFirst = true; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var preSets = {
                cacheKey: _this.getCacheKeyForSelfConversation(userId)
            }, params = {
                userid: userId,
                messageoffset: messageOffset,
                messagelimit: messageLimit,
                newestmessagesfirst: newestFirst ? 1 : 0
            };
            return site.read('core_message_get_self_conversation', params, preSets).then(function (conversation) {
                return _this.formatConversation(conversation, userId);
            });
        });
    };
    /**
     * Get unread conversation counts by type.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved with the unread favourite, individual and group conversation counts.
     */
    AddonMessagesProvider.prototype.getUnreadConversationCounts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promise;
            if (_this.isGroupMessagingEnabled()) {
                // @since 3.6
                var preSets = {
                    cacheKey: _this.getCacheKeyForUnreadConversationCounts()
                };
                promise = site.read('core_message_get_unread_conversation_counts', {}, preSets).then(function (result) {
                    return {
                        favourites: result.favourites,
                        individual: result.types[AddonMessagesProvider_1.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL],
                        group: result.types[AddonMessagesProvider_1.MESSAGE_CONVERSATION_TYPE_GROUP],
                        self: result.types[AddonMessagesProvider_1.MESSAGE_CONVERSATION_TYPE_SELF] || 0
                    };
                });
            }
            else if (_this.isMessageCountEnabled()) {
                // @since 3.2
                var params = {
                    useridto: site.getUserId(),
                }, preSets = {
                    cacheKey: _this.getCacheKeyForMessageCount(site.getUserId()),
                    typeExpected: 'number'
                };
                promise = site.read('core_message_get_unread_conversations_count', params, preSets).then(function (count) {
                    return { favourites: 0, individual: count, group: 0, self: 0 };
                });
            }
            else {
                // Fallback call.
                var params = {
                    read: 0,
                    limitfrom: 0,
                    limitnum: _this.LIMIT_MESSAGES + 1,
                    useridto: site.getUserId(),
                    useridfrom: 0,
                };
                promise = _this.getMessages(params, undefined, false, siteId).then(function (response) {
                    // Count the discussions by filtering same senders.
                    var discussions = {};
                    response.messages.forEach(function (message) {
                        discussions[message.useridto] = 1;
                    });
                    var count = Object.keys(discussions).length;
                    return {
                        favourites: 0,
                        individual: count,
                        group: 0,
                        self: 0,
                        orMore: count > _this.LIMIT_MESSAGES
                    };
                });
            }
            return promise.then(function (counts) {
                // Notify the new counts so all views are updated.
                _this.eventsProvider.trigger(AddonMessagesProvider_1.UNREAD_CONVERSATION_COUNTS_EVENT, counts, site.id);
                return counts;
            });
        });
    };
    /**
     * Get the latest unread received messages.
     *
     * @param  {boolean} [toDisplay=true] True if messages will be displayed to the user, either in view or in a notification.
     * @param  {boolean} [forceCache]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean} [ignoreCache]    True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string} [siteId]          Site ID. If not defined, use current site.
     * @return {Promise<any>}                  Promise resolved with the message unread count.
     */
    AddonMessagesProvider.prototype.getUnreadReceivedMessages = function (toDisplay, forceCache, ignoreCache, siteId) {
        var _this = this;
        if (toDisplay === void 0) { toDisplay = true; }
        if (forceCache === void 0) { forceCache = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                read: 0,
                limitfrom: 0,
                limitnum: _this.LIMIT_MESSAGES,
                useridto: site.getUserId(),
                useridfrom: 0
            }, preSets = {};
            if (forceCache) {
                preSets['omitExpires'] = true;
            }
            else if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return _this.getMessages(params, preSets, toDisplay, siteId);
        });
    };
    /**
     * Invalidate all contacts cache.
     *
     * @param {number} userId    The user ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateAllContactsCache = function (userId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.invalidateContactsCache(siteId).then(function () {
            return _this.invalidateBlockedContactsCache(userId, siteId);
        });
    };
    /**
     * Invalidate blocked contacts cache.
     *
     * @param {number} userId    The user ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}
     */
    AddonMessagesProvider.prototype.invalidateBlockedContactsCache = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForBlockedContacts(userId));
        });
    };
    /**
     * Invalidate contacts cache.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateContactsCache = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForContacts());
        });
    };
    /**
     * Invalidate user contacts cache.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateUserContacts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForUserContacts());
        });
    };
    /**
     * Invalidate contact requests cache.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateContactRequestsCache = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForContactRequests());
        });
    };
    /**
     * Invalidate contact requests count cache.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateContactRequestsCountCache = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForContactRequestsCount());
        });
    };
    /**
     * Invalidate conversation.
     *
     * @param {number} conversationId Conversation ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateConversation = function (conversationId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCacheKeyForConversation(userId, conversationId));
        });
    };
    /**
     * Invalidate conversation between users.
     *
     * @param {number} otherUserId Other user ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateConversationBetweenUsers = function (otherUserId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCacheKeyForConversationBetweenUsers(userId, otherUserId));
        });
    };
    /**
     * Invalidate conversation members cache.
     *
     * @param {number} conversationId Conversation ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateConversationMembers = function (conversationId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCacheKeyForConversationMembers(userId, conversationId));
        });
    };
    /**
     * Invalidate conversation messages cache.
     *
     * @param {number} conversationId Conversation ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateConversationMessages = function (conversationId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCacheKeyForConversationMessages(userId, conversationId));
        });
    };
    /**
     * Invalidate conversations cache.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateConversations = function (siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKeyStartingWith(_this.getCommonCacheKeyForUserConversations(userId));
        });
    };
    /**
     * Invalidate conversation counts cache.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateConversationCounts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForConversationCounts());
        });
    };
    /**
     * Invalidate discussion cache.
     *
     * @param {number} userId    The user ID with whom the current user is having the discussion.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateDiscussionCache = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForDiscussion(userId));
        });
    };
    /**
     * Invalidate discussions cache.
     *
     * Note that {@link this.getDiscussions} uses the contacts, so we need to invalidate contacts too.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateDiscussionsCache = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [];
            promises.push(site.invalidateWsCacheForKey(_this.getCacheKeyForDiscussions()));
            promises.push(_this.invalidateContactsCache(site.getId()));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidate member info cache.
     *
     * @param {number} otherUserId The other user ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateMemberInfo = function (otherUserId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCacheKeyForMemberInfo(userId, otherUserId));
        });
    };
    /**
     * Invalidate get message preferences.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when data is invalidated.
     */
    AddonMessagesProvider.prototype.invalidateMessagePreferences = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getMessagePreferencesCacheKey());
        });
    };
    /**
     * Invalidate all cache entries with member info.
     *
     * @param {number} userId Id of the user to invalidate.
     * @param {CoreSite} site Site object.
     * @return {Promie<any>} Promise resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateAllMemberInfo = function (userId, site) {
        var _this = this;
        return this.utils.allPromises([
            this.invalidateMemberInfo(userId, site.id),
            this.invalidateUserContacts(site.id),
            this.invalidateContactRequestsCache(site.id),
            this.invalidateConversations(site.id),
            this.getConversationBetweenUsers(userId, undefined, undefined, undefined, undefined, undefined, undefined, undefined, site.id, undefined, true).then(function (conversation) {
                return _this.utils.allPromises([
                    _this.invalidateConversation(conversation.id),
                    _this.invalidateConversationMembers(conversation.id, site.id),
                ]);
            }).catch(function () {
                // The conversation does not exist or we can't fetch it now, ignore it.
            })
        ]);
    };
    /**
     * Invalidate a self conversation.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateSelfConversation = function (siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCacheKeyForSelfConversation(userId));
        });
    };
    /**
     * Invalidate unread conversation counts cache.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateUnreadConversationCounts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (_this.isGroupMessagingEnabled()) {
                // @since 3.6
                return site.invalidateWsCacheForKey(_this.getCacheKeyForUnreadConversationCounts());
            }
            else if (_this.isMessageCountEnabled()) {
                // @since 3.2
                return site.invalidateWsCacheForKey(_this.getCacheKeyForMessageCount(site.getUserId()));
            }
        });
    };
    /**
     * Checks if the a user is blocked by the current user.
     *
     * @param {number} userId The user ID to check against.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<boolean>} Resolved with boolean, rejected when we do not know.
     */
    AddonMessagesProvider.prototype.isBlocked = function (userId, siteId) {
        if (this.isGroupMessagingEnabled()) {
            return this.getMemberInfo(userId, siteId).then(function (member) {
                return member.isblocked;
            });
        }
        return this.getBlockedContacts(siteId).then(function (blockedContacts) {
            if (!blockedContacts.users || blockedContacts.users.length < 1) {
                return false;
            }
            return blockedContacts.users.some(function (user) {
                return userId == user.id;
            });
        });
    };
    /**
     * Checks if the a user is a contact of the current user.
     *
     * @param {number} userId The user ID to check against.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<boolean>} Resolved with boolean, rejected when we do not know.
     */
    AddonMessagesProvider.prototype.isContact = function (userId, siteId) {
        if (this.isGroupMessagingEnabled()) {
            return this.getMemberInfo(userId, siteId).then(function (member) {
                return member.iscontact;
            });
        }
        return this.getContacts(siteId).then(function (contacts) {
            return ['online', 'offline'].some(function (type) {
                if (contacts[type] && contacts[type].length > 0) {
                    return contacts[type].some(function (user) {
                        return userId == user.id;
                    });
                }
                return false;
            });
        });
    };
    /**
     * Returns whether or not group messaging is supported.
     *
     * @return {boolean} If related WS is available on current site.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.isGroupMessagingEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_get_conversations');
    };
    /**
     * Returns whether or not group messaging is supported in a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether related WS is available on a certain site.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.isGroupMessagingEnabledInSite = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('core_message_get_conversations');
        }).catch(function () {
            return false;
        });
    };
    /**
     * Returns whether or not we can mark all messages as read.
     *
     * @return {boolean} If related WS is available on current site.
     * @since  3.2
     */
    AddonMessagesProvider.prototype.isMarkAllMessagesReadEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_mark_all_messages_as_read');
    };
    /**
     * Returns whether or not we can count unread messages.
     *
     * @return {boolean} True if enabled, false otherwise.
     * @since  3.2
     */
    AddonMessagesProvider.prototype.isMessageCountEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_get_unread_conversations_count');
    };
    /**
     * Returns whether or not the message preferences are enabled for the current site.
     *
     * @return {boolean} True if enabled, false otherwise.
     * @since  3.2
     */
    AddonMessagesProvider.prototype.isMessagePreferencesEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_get_user_message_preferences');
    };
    /**
     * Returns whether or not messaging is enabled for a certain site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Resolved when enabled, otherwise rejected.
     */
    AddonMessagesProvider.prototype.isMessagingEnabledForSite = function (siteId) {
        return this.isPluginEnabled(siteId).then(function (enabled) {
            if (!enabled) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Returns whether or not a site supports muting or unmuting a conversation.
     *
     * @param {CoreSite} [site] The site to check, undefined for current site.
     * @return {boolean} If related WS is available on current site.
     * @since 3.7
     */
    AddonMessagesProvider.prototype.isMuteConversationEnabled = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.wsAvailable('core_message_mute_conversations');
    };
    /**
     * Returns whether or not a site supports muting or unmuting a conversation.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether related WS is available on a certain site.
     * @since 3.7
     */
    AddonMessagesProvider.prototype.isMuteConversationEnabledInSite = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isMuteConversationEnabled(site);
        }).catch(function () {
            return false;
        });
    };
    /**
     * Returns whether or not the plugin is enabled in a certain site.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved with true if enabled, rejected or resolved with false otherwise.
     */
    AddonMessagesProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canUseAdvancedFeature('messaging');
        });
    };
    /**
     * Returns whether or not we can search messages.
     *
     * @return {boolean}
     * @since  3.2
     */
    AddonMessagesProvider.prototype.isSearchMessagesEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_data_for_messagearea_search_messages');
    };
    /**
     * Returns whether or not self conversation is supported in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, current site.
     * @return {boolean} If related WS is available on the site.
     * @since 3.7
     */
    AddonMessagesProvider.prototype.isSelfConversationEnabled = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.wsAvailable('core_message_get_self_conversation');
    };
    /**
     * Returns whether or not self conversation is supported in a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether related WS is available on a certain site.
     * @since 3.7
     */
    AddonMessagesProvider.prototype.isSelfConversationEnabledInSite = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isSelfConversationEnabled(site);
        }).catch(function () {
            return false;
        });
    };
    /**
     * Mark message as read.
     *
     * @param {number} messageId ID of message to mark as read
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @returns {Promise<any>} Promise resolved with boolean marking success or not.
     */
    AddonMessagesProvider.prototype.markMessageRead = function (messageId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                messageid: messageId,
                timeread: _this.timeUtils.timestamp()
            };
            return site.write('core_message_mark_message_read', params);
        });
    };
    /**
     * Mark all messages of a conversation as read.
     *
     * @param {number} conversationId Conversation ID.
     * @returns {Promise<any>} Promise resolved if success.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.markAllConversationMessagesRead = function (conversationId) {
        var params = {
            userid: this.sitesProvider.getCurrentSiteUserId(),
            conversationid: conversationId
        }, preSets = {
            responseExpected: false
        };
        return this.sitesProvider.getCurrentSite().write('core_message_mark_all_conversation_messages_as_read', params, preSets);
    };
    /**
     * Mark all messages of a discussion as read.
     *
     * @param   {number}  userIdFrom  User Id for the sender.
     * @returns {Promise<any>} Promise resolved with boolean marking success or not.
     */
    AddonMessagesProvider.prototype.markAllMessagesRead = function (userIdFrom) {
        var params = {
            useridto: this.sitesProvider.getCurrentSiteUserId(),
            useridfrom: userIdFrom
        }, preSets = {
            typeExpected: 'boolean'
        };
        return this.sitesProvider.getCurrentSite().write('core_message_mark_all_messages_as_read', params, preSets);
    };
    /**
     * Mute or unmute a conversation.
     *
     * @param {number} conversationId Conversation ID.
     * @param {boolean} set Whether to mute or unmute.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>}  Resolved when done.
     */
    AddonMessagesProvider.prototype.muteConversation = function (conversationId, set, siteId, userId) {
        return this.muteConversations([conversationId], set, siteId, userId);
    };
    /**
     * Mute or unmute some conversations.
     *
     * @param {number[]} conversations Conversation IDs.
     * @param {boolean} set Whether to mute or unmute.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>}  Resolved when done.
     */
    AddonMessagesProvider.prototype.muteConversations = function (conversations, set, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                userid: userId,
                conversationids: conversations
            }, wsName = set ? 'core_message_mute_conversations' : 'core_message_unmute_conversations';
            return site.write(wsName, params).then(function () {
                // Invalidate the conversations data.
                var promises = [];
                conversations.forEach(function (conversationId) {
                    promises.push(_this.invalidateConversation(conversationId, site.getId(), userId));
                });
                return Promise.all(promises).catch(function () {
                    // Ignore errors.
                });
            });
        });
    };
    /**
     * Refresh the number of contact requests sent to the current user.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<number>} Resolved with the number of contact requests.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.refreshContactRequestsCount = function (siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.invalidateContactRequestsCountCache(siteId).then(function () {
            return _this.getContactRequestsCount(siteId);
        });
    };
    /**
     * Refresh unread conversation counts and trigger event.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved with the unread favourite, individual and group conversation counts.
     */
    AddonMessagesProvider.prototype.refreshUnreadConversationCounts = function (siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.invalidateUnreadConversationCounts(siteId).then(function () {
            return _this.getUnreadConversationCounts(siteId);
        });
    };
    /**
     * Remove a contact.
     *
     * @param {number} userId User ID of the person to remove.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @return {Promise<any>}  Resolved when done.
     */
    AddonMessagesProvider.prototype.removeContact = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userids: [userId]
            }, preSets = {
                responseExpected: false
            };
            return site.write('core_message_delete_contacts', params, preSets).then(function () {
                if (_this.isGroupMessagingEnabled()) {
                    return _this.utils.allPromises([
                        _this.invalidateUserContacts(site.id),
                        _this.invalidateAllMemberInfo(userId, site),
                    ]).then(function () {
                        var data = { userId: userId, contactRemoved: true };
                        _this.eventsProvider.trigger(AddonMessagesProvider_1.MEMBER_INFO_CHANGED_EVENT, data, site.id);
                    });
                }
                else {
                    return _this.invalidateContactsCache(site.id);
                }
            });
        });
    };
    /**
     * Search for contacts.
     *
     * By default this only returns the first 100 contacts, but note that the WS can return thousands
     * of results which would take a while to process. The limit here is just a convenience to
     * prevent viewed to crash because too many DOM elements are created.
     *
     * @param {string} query The query string.
     * @param {number} [limit=100] The number of results to return, 0 for none.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}
     */
    AddonMessagesProvider.prototype.searchContacts = function (query, limit, siteId) {
        var _this = this;
        if (limit === void 0) { limit = 100; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                searchtext: query,
                onlymycourses: 0
            }, preSets = {
                getFromCache: false // Always try to get updated data. If it fails, it will get it from cache.
            };
            return site.read('core_message_search_contacts', data, preSets).then(function (contacts) {
                if (limit && contacts.length > limit) {
                    contacts = contacts.splice(0, limit);
                }
                _this.userProvider.storeUsers(contacts);
                return contacts;
            });
        });
    };
    /**
     * Search for all the messges with a specific text.
     *
     * @param {string} query The query string.
     * @param {number} [userId] The user ID. If not defined, current user.
     * @param {number} [limitFrom=0] Position of the first result to get. Defaults to 0.
     * @param {number} [limitNum] Number of results to get. Defaults to AddonMessagesProvider.LIMIT_SEARCH.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the results.
     */
    AddonMessagesProvider.prototype.searchMessages = function (query, userId, limitFrom, limitNum, siteId) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = AddonMessagesProvider_1.LIMIT_SEARCH; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userid: userId || site.getUserId(),
                search: query,
                limitfrom: limitFrom,
                limitnum: limitNum <= 0 ? 0 : limitNum + 1
            }, preSets = {
                getFromCache: false // Always try to get updated data. If it fails, it will get it from cache.
            };
            return site.read('core_message_data_for_messagearea_search_messages', params, preSets).then(function (result) {
                if (!result.contacts || !result.contacts.length) {
                    return { messages: [], canLoadMore: false };
                }
                result.contacts.forEach(function (result) {
                    result.id = result.userid;
                });
                _this.userProvider.storeUsers(result.contacts, site.id);
                if (limitNum <= 0) {
                    return { messages: result.contacts, canLoadMore: false };
                }
                return {
                    messages: result.contacts.slice(0, limitNum),
                    canLoadMore: result.contacts.length > limitNum
                };
            });
        });
    };
    /**
     * Search for users.
     *
     * @param {string} query Text to search for.
     * @param {number} [limitFrom=0] Position of the first found user to fetch.
     * @param {number} [limitNum] Number of found users to fetch. Defaults to AddonMessagesProvider.LIMIT_SEARCH.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved with two lists of found users: contacts and non-contacts.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.searchUsers = function (query, limitFrom, limitNum, siteId) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = AddonMessagesProvider_1.LIMIT_SEARCH; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                userid: site.getUserId(),
                search: query,
                limitfrom: limitFrom,
                limitnum: limitNum <= 0 ? 0 : limitNum + 1
            }, preSets = {
                getFromCache: false // Always try to get updated data. If it fails, it will get it from cache.
            };
            return site.read('core_message_message_search_users', data, preSets).then(function (result) {
                var contacts = result.contacts || [];
                var nonContacts = result.noncontacts || [];
                _this.userProvider.storeUsers(contacts, site.id);
                _this.userProvider.storeUsers(nonContacts, site.id);
                if (limitNum <= 0) {
                    return { contacts: contacts, nonContacts: nonContacts, canLoadMoreContacts: false, canLoadMoreNonContacts: false };
                }
                return {
                    contacts: contacts.slice(0, limitNum),
                    nonContacts: nonContacts.slice(0, limitNum),
                    canLoadMoreContacts: contacts.length > limitNum,
                    canLoadMoreNonContacts: nonContacts.length > limitNum
                };
            });
        });
    };
    /**
     * Send a message to someone.
     *
     * @param {number} userIdTo  User ID to send the message to.
     * @param {string} message   The message to send
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}       Promise resolved with:
     *                                 - sent (Boolean) True if message was sent to server, false if stored in device.
     *                                 - message (Object) If sent=false, contains the stored message.
     */
    AddonMessagesProvider.prototype.sendMessage = function (toUserId, message, siteId) {
        var _this = this;
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.messagesOffline.saveMessage(toUserId, message, siteId).then(function (entry) {
                return {
                    sent: false,
                    message: entry
                };
            });
        };
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!this.appProvider.isOnline()) {
            // App is offline, store the message.
            return storeOffline();
        }
        // Check if this conversation already has offline messages.
        // If so, store this message since they need to be sent in order.
        return this.messagesOffline.hasMessages(toUserId, siteId).catch(function () {
            // Error, it's safer to assume it has messages.
            return true;
        }).then(function (hasStoredMessages) {
            if (hasStoredMessages) {
                return storeOffline();
            }
            // Online and no messages stored. Send it to server.
            return _this.sendMessageOnline(toUserId, message).then(function (result) {
                return {
                    sent: true,
                    message: result
                };
            }).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // It's a WebService error, the user cannot send the message so don't store it.
                    return Promise.reject(error);
                }
                // Error sending message, store it to retry later.
                return storeOffline();
            });
        });
    };
    /**
     * Send a message to someone. It will fail if offline or cannot connect.
     *
     * @param {number} toUserId  User ID to send the message to.
     * @param {string} message   The message to send
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if success, rejected if failure.
     */
    AddonMessagesProvider.prototype.sendMessageOnline = function (toUserId, message, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var messages = [
            {
                touserid: toUserId,
                text: message,
                textformat: 1
            }
        ];
        return this.sendMessagesOnline(messages, siteId).then(function (response) {
            if (response && response[0] && response[0].msgid === -1) {
                // There was an error, and it should be translated already.
                return Promise.reject(_this.utils.createFakeWSError(response[0].errormessage));
            }
            return _this.invalidateDiscussionCache(toUserId, siteId).catch(function () {
                // Ignore errors.
            }).then(function () {
                return response[0];
            });
        });
    };
    /**
     * Send some messages. It will fail if offline or cannot connect.
     * IMPORTANT: Sending several messages at once for the same discussions can cause problems with display order,
     * since messages with same timecreated aren't ordered by ID.
     *
     * @param  {any} messages Messages to send. Each message must contain touserid, text and textformat.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if success, rejected if failure. Promise resolved doesn't mean that messages
     *                           have been sent, the resolve param can contain errors for messages not sent.
     */
    AddonMessagesProvider.prototype.sendMessagesOnline = function (messages, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                messages: messages
            };
            return site.write('core_message_send_instant_messages', data);
        });
    };
    /**
     * Send a message to a conversation.
     *
     * @param {any} conversation Conversation.
     * @param {string} message The message to send.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with:
     *                                - sent (boolean) True if message was sent to server, false if stored in device.
     *                                - message (any) If sent=false, contains the stored message.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.sendMessageToConversation = function (conversation, message, siteId) {
        var _this = this;
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.messagesOffline.saveConversationMessage(conversation, message, siteId).then(function (entry) {
                return {
                    sent: false,
                    message: entry
                };
            });
        };
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!this.appProvider.isOnline()) {
            // App is offline, store the message.
            return storeOffline();
        }
        // Check if this conversation already has offline messages.
        // If so, store this message since they need to be sent in order.
        return this.messagesOffline.hasConversationMessages(conversation.id, siteId).catch(function () {
            // Error, it's safer to assume it has messages.
            return true;
        }).then(function (hasStoredMessages) {
            if (hasStoredMessages) {
                return storeOffline();
            }
            // Online and no messages stored. Send it to server.
            return _this.sendMessageToConversationOnline(conversation.id, message).then(function (result) {
                return {
                    sent: true,
                    message: result
                };
            }).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // It's a WebService error, the user cannot send the message so don't store it.
                    return Promise.reject(error);
                }
                // Error sending message, store it to retry later.
                return storeOffline();
            });
        });
    };
    /**
     * Send a message to a conversation. It will fail if offline or cannot connect.
     *
     * @param {number} conversationId Conversation ID.
     * @param {string} message The message to send
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if success, rejected if failure.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.sendMessageToConversationOnline = function (conversationId, message, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var messages = [
            {
                text: message,
                textformat: 1
            }
        ];
        return this.sendMessagesToConversationOnline(conversationId, messages, siteId).then(function (response) {
            return _this.invalidateConversationMessages(conversationId, siteId).catch(function () {
                // Ignore errors.
            }).then(function () {
                return response[0];
            });
        });
    };
    /**
     * Send some messages to a conversation. It will fail if offline or cannot connect.
     *
     * @param {number} conversationId Conversation ID.
     * @param {any} messages Messages to send. Each message must contain text and, optionally, textformat.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if success, rejected if failure.
     * @since 3.6
     */
    AddonMessagesProvider.prototype.sendMessagesToConversationOnline = function (conversationId, messages, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                conversationid: conversationId,
                messages: messages.map(function (message) {
                    return {
                        text: message.text,
                        textformat: typeof message.textformat != 'undefined' ? message.textformat : 1
                    };
                })
            };
            return site.write('core_message_send_messages_to_conversation', params);
        });
    };
    /**
     * Set or unset a conversation as favourite.
     *
     * @param {number} conversationId Conversation ID.
     * @param {boolean} set Whether to set or unset it as favourite.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>}  Resolved when done.
     */
    AddonMessagesProvider.prototype.setFavouriteConversation = function (conversationId, set, siteId, userId) {
        return this.setFavouriteConversations([conversationId], set, siteId, userId);
    };
    /**
     * Set or unset some conversations as favourites.
     *
     * @param {number[]} conversations Conversation IDs.
     * @param {boolean} set Whether to set or unset them as favourites.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @return {Promise<any>}  Resolved when done.
     */
    AddonMessagesProvider.prototype.setFavouriteConversations = function (conversations, set, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                userid: userId,
                conversations: conversations
            }, wsName = set ? 'core_message_set_favourite_conversations' : 'core_message_unset_favourite_conversations';
            return site.write(wsName, params).then(function () {
                // Invalidate the conversations data.
                var promises = [];
                conversations.forEach(function (conversationId) {
                    promises.push(_this.invalidateConversation(conversationId, site.getId(), userId));
                });
                return Promise.all(promises).catch(function () {
                    // Ignore errors.
                });
            });
        });
    };
    /**
     * Helper method to sort conversations by last message time.
     *
     * @param {any[]} conversations Array of conversations.
     * @return {any[]} Conversations sorted with most recent last.
     */
    AddonMessagesProvider.prototype.sortConversations = function (conversations) {
        return conversations.sort(function (a, b) {
            var timeA = parseInt(a.lastmessagedate, 10), timeB = parseInt(b.lastmessagedate, 10);
            if (timeA == timeB && a.id) {
                // Same time, sort by ID.
                return a.id <= b.id ? 1 : -1;
            }
            return timeA <= timeB ? 1 : -1;
        });
    };
    /**
     * Helper method to sort messages by time.
     *
     * @param {any[]} messages Array of messages containing the key 'timecreated'.
     * @return {any[]} Messages sorted with most recent last.
     */
    AddonMessagesProvider.prototype.sortMessages = function (messages) {
        return messages.sort(function (a, b) {
            // Pending messages last.
            if (a.pending && !b.pending) {
                return 1;
            }
            else if (!a.pending && b.pending) {
                return -1;
            }
            var timecreatedA = parseInt(a.timecreated, 10), timecreatedB = parseInt(b.timecreated, 10);
            if (timecreatedA == timecreatedB && a.id) {
                // Same time, sort by ID.
                return a.id >= b.id ? 1 : -1;
            }
            return timecreatedA >= timecreatedB ? 1 : -1;
        });
    };
    /**
     * Store the last received message if it's newer than the last stored.
     *
     * @param  {number} convIdOrUserIdFrom Conversation ID (3.6+) or ID of the useridfrom retrieved (3.5-), 0 for all users.
     * @param  {any} message       Last message received.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when done.
     */
    AddonMessagesProvider.prototype.storeLastReceivedMessageIfNeeded = function (convIdOrUserIdFrom, message, siteId) {
        var _this = this;
        var component = AddonMessagesProvider_1.PUSH_SIMULATION_COMPONENT;
        // Get the last received message.
        return this.emulatorHelper.getLastReceivedNotification(component, siteId).then(function (lastMessage) {
            if (convIdOrUserIdFrom > 0 && (!message || !lastMessage)) {
                // Seeing a single discussion. No received message or cannot know if it really is the last received message. Stop.
                return;
            }
            if (message && lastMessage && message.timecreated <= lastMessage.timecreated) {
                // The message isn't newer than the stored message, don't store it.
                return;
            }
            return _this.emulatorHelper.storeLastReceivedNotification(component, message, siteId);
        });
    };
    /**
     * Store user data from contacts in local DB.
     *
     * @param {any} contactTypes List of contacts grouped in types.
     */
    AddonMessagesProvider.prototype.storeUsersFromAllContacts = function (contactTypes) {
        for (var x in contactTypes) {
            this.userProvider.storeUsers(contactTypes[x]);
        }
    };
    /**
     * Store user data from discussions in local DB.
     *
     * @param {any} discussions List of discussions.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    AddonMessagesProvider.prototype.storeUsersFromDiscussions = function (discussions, siteId) {
        var users = [];
        for (var userId in discussions) {
            users.push({
                id: userId,
                fullname: discussions[userId].fullname,
                profileimageurl: discussions[userId].profileimageurl
            });
        }
        this.userProvider.storeUsers(users, siteId);
    };
    /**
     * Unblock a user.
     *
     * @param {number} userId User ID of the person to unblock.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.unblockContact = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promise;
            if (site.wsAvailable('core_message_unblock_user')) {
                // Since Moodle 3.6
                var params = {
                    userid: site.getUserId(),
                    unblockeduserid: userId,
                };
                promise = site.write('core_message_unblock_user', params);
            }
            else {
                var params = {
                    userids: [userId]
                };
                var preSets = {
                    responseExpected: false
                };
                promise = site.write('core_message_unblock_contacts', params, preSets);
            }
            return promise.then(function () {
                return _this.invalidateAllMemberInfo(userId, site).finally(function () {
                    var data = { userId: userId, userUnblocked: true };
                    _this.eventsProvider.trigger(AddonMessagesProvider_1.MEMBER_INFO_CHANGED_EVENT, data, site.id);
                });
            });
        });
    };
    AddonMessagesProvider.NEW_MESSAGE_EVENT = 'addon_messages_new_message_event';
    AddonMessagesProvider.READ_CHANGED_EVENT = 'addon_messages_read_changed_event';
    AddonMessagesProvider.OPEN_CONVERSATION_EVENT = 'addon_messages_open_conversation_event'; // Notify that a conversation should be opened.
    AddonMessagesProvider.SPLIT_VIEW_LOAD_EVENT = 'addon_messages_split_view_load_event';
    AddonMessagesProvider.UPDATE_CONVERSATION_LIST_EVENT = 'addon_messages_update_conversation_list_event';
    AddonMessagesProvider.MEMBER_INFO_CHANGED_EVENT = 'addon_messages_member_changed_event';
    AddonMessagesProvider.UNREAD_CONVERSATION_COUNTS_EVENT = 'addon_messages_unread_conversation_counts_event';
    AddonMessagesProvider.CONTACT_REQUESTS_COUNT_EVENT = 'addon_messages_contact_requests_count_event';
    AddonMessagesProvider.POLL_INTERVAL = 10000;
    AddonMessagesProvider.PUSH_SIMULATION_COMPONENT = 'AddonMessagesPushSimulation';
    AddonMessagesProvider.MESSAGE_PRIVACY_COURSEMEMBER = 0; // Privacy setting for being messaged by anyone within courses user is member of.
    AddonMessagesProvider.MESSAGE_PRIVACY_ONLYCONTACTS = 1; // Privacy setting for being messaged only by contacts.
    AddonMessagesProvider.MESSAGE_PRIVACY_SITE = 2; // Privacy setting for being messaged by anyone on the site.
    AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_INDIVIDUAL = 1; // An individual conversation.
    AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_GROUP = 2; // A group conversation.
    AddonMessagesProvider.MESSAGE_CONVERSATION_TYPE_SELF = 3; // A self conversation.
    AddonMessagesProvider.LIMIT_CONTACTS = 50;
    AddonMessagesProvider.LIMIT_MESSAGES = 50;
    AddonMessagesProvider.LIMIT_INITIAL_USER_SEARCH = 3;
    AddonMessagesProvider.LIMIT_SEARCH = 50;
    AddonMessagesProvider.NOTIFICATION_PREFERENCES_KEY = 'message_provider_moodle_instantmessage';
    AddonMessagesProvider = AddonMessagesProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user__["a" /* CoreUserProvider */], __WEBPACK_IMPORTED_MODULE_5__messages_offline__["a" /* AddonMessagesOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__core_emulator_providers_helper__["a" /* CoreEmulatorHelperProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_events__["a" /* CoreEventsProvider */]])
    ], AddonMessagesProvider);
    return AddonMessagesProvider;
    var AddonMessagesProvider_1;
}());

//# sourceMappingURL=messages.js.map

/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCompetencyProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_pushnotifications_providers_pushnotifications__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to handle caompetency learning plans.
 */
var AddonCompetencyProvider = /** @class */ (function () {
    function AddonCompetencyProvider(loggerProvider, sitesProvider, pushNotificationsProvider) {
        this.sitesProvider = sitesProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.ROOT_CACHE_KEY = 'mmaCompetency:';
        this.logger = loggerProvider.getInstance('AddonCompetencyProvider');
    }
    AddonCompetencyProvider_1 = AddonCompetencyProvider;
    /**
     * Check if all competencies features are disabled.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether all competency features are disabled.
     */
    AddonCompetencyProvider.prototype.allCompetenciesDisabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.isFeatureDisabled('CoreMainMenuDelegate_AddonCompetency') &&
                site.isFeatureDisabled('CoreCourseOptionsDelegate_AddonCompetency') &&
                site.isFeatureDisabled('CoreUserDelegate_AddonCompetency');
        });
    };
    /**
     * Get cache key for user learning plans data WS calls.
     *
     * @param {number} userId User ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getLearningPlansCacheKey = function (userId) {
        return this.ROOT_CACHE_KEY + 'userplans:' + userId;
    };
    /**
     * Get cache key for learning plan data WS calls.
     *
     * @param {number} planId Plan ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getLearningPlanCacheKey = function (planId) {
        return this.ROOT_CACHE_KEY + 'learningplan:' + planId;
    };
    /**
     * Get cache key for competency in plan data WS calls.
     *
     * @param {number} planId Plan ID.
     * @param {number} competencyId Competency ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getCompetencyInPlanCacheKey = function (planId, competencyId) {
        return this.ROOT_CACHE_KEY + 'plancompetency:' + planId + ':' + competencyId;
    };
    /**
     * Get cache key for competency in course data WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} competencyId Competency ID.
     * @param {number} userId User ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getCompetencyInCourseCacheKey = function (courseId, competencyId, userId) {
        return this.ROOT_CACHE_KEY + 'coursecompetency:' + userId + ':' + courseId + ':' + competencyId;
    };
    /**
     * Get cache key for competency summary data WS calls.
     *
     * @param {number} competencyId Competency ID.
     * @param {number} userId User ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getCompetencySummaryCacheKey = function (competencyId, userId) {
        return this.ROOT_CACHE_KEY + 'competencysummary:' + userId + ':' + competencyId;
    };
    /**
     * Get cache key for course competencies data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getCourseCompetenciesCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'coursecompetencies:' + courseId;
    };
    /**
     * Returns whether competencies are enabled.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} competencies if enabled for the given course, false otherwise.
     */
    AddonCompetencyProvider.prototype.isPluginForCourseEnabled = function (courseId, siteId) {
        if (!this.sitesProvider.isLoggedIn()) {
            return Promise.resolve(false);
        }
        return this.getCourseCompetencies(courseId, 0, siteId).catch(function () {
            return false;
        });
    };
    /**
     * Get plans for a certain user.
     *
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getLearningPlans = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Get plans for user ' + userId);
            var params = {
                userid: userId
            }, preSets = {
                cacheKey: _this.getLearningPlansCacheKey(userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_4__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('tool_lp_data_for_plans_page', params, preSets).then(function (response) {
                if (response.plans) {
                    return response.plans;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a certain plan.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getLearningPlan = function (planId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Get plan ' + planId);
            var params = {
                planid: planId
            }, preSets = {
                cacheKey: _this.getLearningPlanCacheKey(planId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_4__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('tool_lp_data_for_plan_page', params, preSets).then(function (response) {
                if (response.plan) {
                    return response;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a certain competency in a plan.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {number} competencyId    ID of the competency.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getCompetencyInPlan = function (planId, competencyId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Get competency ' + competencyId + ' in plan ' + planId);
            var params = {
                planid: planId,
                competencyid: competencyId
            }, preSets = {
                cacheKey: _this.getCompetencyInPlanCacheKey(planId, competencyId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_4__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('tool_lp_data_for_user_competency_summary_in_plan', params, preSets).then(function (response) {
                if (response.usercompetencysummary) {
                    return response;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a certain competency in a course.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} competencyId    ID of the competency.
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getCompetencyInCourse = function (courseId, competencyId, userId, siteId, ignoreCache) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Get competency ' + competencyId + ' in course ' + courseId);
            var params = {
                courseid: courseId,
                competencyid: competencyId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getCompetencyInCourseCacheKey(courseId, competencyId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_4__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('tool_lp_data_for_user_competency_summary_in_course', params, preSets).then(function (response) {
                if (response.usercompetencysummary) {
                    return response;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a certain competency summary.
     *
     * @param  {number} competencyId    ID of the competency.
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getCompetencySummary = function (competencyId, userId, siteId, ignoreCache) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Get competency ' + competencyId + ' summary for user' + userId);
            var params = {
                competencyid: competencyId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getCompetencySummaryCacheKey(competencyId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_4__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('tool_lp_data_for_user_competency_summary', params, preSets).then(function (response) {
                if (response.competency) {
                    return response.competency;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get all competencies in a course.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} [userId]    ID of the user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}            Promise to be resolved when the course competencies are retrieved.
     */
    AddonCompetencyProvider.prototype.getCourseCompetencies = function (courseId, userId, siteId, ignoreCache) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Get course competencies for course ' + courseId);
            var params = {
                courseid: courseId
            }, preSets = {
                cacheKey: _this.getCourseCompetenciesCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_4__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('tool_lp_data_for_course_competencies_page', params, preSets).then(function (response) {
                if (response.competencies) {
                    return response;
                }
                return Promise.reject(null);
            });
        }).then(function (response) {
            if (!userId || userId == _this.sitesProvider.getCurrentSiteUserId()) {
                return response;
            }
            var promises = response.competencies.map(function (competency) {
                return _this.getCompetencyInCourse(courseId, competency.competency.id, userId, siteId);
            });
            return Promise.all(promises).then(function (responses) {
                responses.forEach(function (resp, index) {
                    response.competencies[index].usercompetencycourse = resp.usercompetencysummary.usercompetencycourse;
                });
                return response;
            });
        });
    };
    /**
     * Invalidates User Learning Plans data.
     *
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateLearningPlans = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getLearningPlansCacheKey(userId));
        });
    };
    /**
     * Invalidates Learning Plan data.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateLearningPlan = function (planId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getLearningPlanCacheKey(planId));
        });
    };
    /**
     * Invalidates Competency in Plan data.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {number} competencyId    ID of the competency.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateCompetencyInPlan = function (planId, competencyId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCompetencyInPlanCacheKey(planId, competencyId));
        });
    };
    /**
     * Invalidates Competency in Course data.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} competencyId    ID of the competency.
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateCompetencyInCourse = function (courseId, competencyId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCompetencyInCourseCacheKey(courseId, competencyId, userId));
        });
    };
    /**
     * Invalidates Competency Summary data.
     *
     * @param  {number} competencyId    ID of the competency.
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateCompetencySummary = function (competencyId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCompetencySummaryCacheKey(competencyId, userId));
        });
    };
    /**
     * Invalidates Course Competencies data.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} [userId]      ID of the user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateCourseCompetencies = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseCompetenciesCacheKey(courseId));
        }).then(function () {
            if (!userId || userId == _this.sitesProvider.getCurrentSiteUserId()) {
                return;
            }
            /* Competencies for other users are fetched with getCompetencyInCourse (and saved in their own cache).
               We need to fecth the list of competencies to know which ones to invalidate. We can pass 0 as userId
               to getCourseCompetencies, we just need the competency IDs and this way we avid extra WS calls. */
            return _this.getCourseCompetencies(courseId, 0, siteId).then(function (competencies) {
                var promises = competencies.competencies.map(function (competency) {
                    return _this.invalidateCompetencyInCourse(courseId, competency.competency.id, userId, siteId);
                });
                return Promise.all(promises);
            });
        });
    };
    /**
     * Report the competency as being viewed in plan.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {number} competencyId  ID of the competency.
     * @param  {number} planStatus    Current plan Status to decide what action should be logged.
     * @param  {string} [name] Name of the competency.
     * @param  {number} [userId] User ID. If not defined, current user.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonCompetencyProvider.prototype.logCompetencyInPlanView = function (planId, competencyId, planStatus, name, userId, siteId) {
        var _this = this;
        if (planId && competencyId) {
            return this.sitesProvider.getSite(siteId).then(function (site) {
                userId = userId || site.getUserId();
                var params = {
                    planid: planId,
                    competencyid: competencyId,
                    userid: userId
                }, preSets = {
                    typeExpected: 'boolean'
                }, wsName = planStatus == AddonCompetencyProvider_1.STATUS_COMPLETE ?
                    'core_competency_user_competency_plan_viewed' : 'core_competency_user_competency_viewed_in_plan';
                _this.pushNotificationsProvider.logViewEvent(competencyId, name, 'competency', wsName, {
                    planid: planId,
                    planstatus: planStatus,
                    userid: userId
                }, siteId);
                return site.write(wsName, params, preSets);
            });
        }
        return Promise.reject(null);
    };
    /**
     * Report the competency as being viewed in course.
     *
     * @param  {number} courseId        ID of the course.
     * @param  {number} competencyId    ID of the competency.
     * @param  {string} [name] Name of the competency.
     * @param  {number} [userId] User ID. If not defined, current user.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonCompetencyProvider.prototype.logCompetencyInCourseView = function (courseId, competencyId, name, userId, siteId) {
        var _this = this;
        if (courseId && competencyId) {
            return this.sitesProvider.getSite(siteId).then(function (site) {
                userId = userId || site.getUserId();
                var params = {
                    courseid: courseId,
                    competencyid: competencyId,
                    userid: userId
                };
                var preSets = {
                    typeExpected: 'boolean'
                };
                var wsName = 'core_competency_user_competency_viewed_in_course';
                _this.pushNotificationsProvider.logViewEvent(competencyId, name, 'competency', wsName, {
                    courseid: courseId,
                    userid: userId
                }, siteId);
                return site.write(wsName, params, preSets);
            });
        }
        return Promise.reject(null);
    };
    /**
     * Report the competency as being viewed.
     *
     * @param  {number} competencyId    ID of the competency.
     * @param  {string} [name] Name of the competency.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonCompetencyProvider.prototype.logCompetencyView = function (competencyId, name, siteId) {
        var _this = this;
        if (competencyId) {
            return this.sitesProvider.getSite(siteId).then(function (site) {
                var params = {
                    id: competencyId,
                };
                var preSets = {
                    typeExpected: 'boolean'
                };
                var wsName = 'core_competency_competency_viewed';
                _this.pushNotificationsProvider.logViewEvent(competencyId, name, 'competency', wsName, {}, siteId);
                return site.write('core_competency_competency_viewed', params, preSets);
            });
        }
        return Promise.reject(null);
    };
    // Learning plan status.
    AddonCompetencyProvider.STATUS_DRAFT = 0;
    AddonCompetencyProvider.STATUS_ACTIVE = 1;
    AddonCompetencyProvider.STATUS_COMPLETE = 2;
    AddonCompetencyProvider.STATUS_WAITING_FOR_REVIEW = 3;
    AddonCompetencyProvider.STATUS_IN_REVIEW = 4;
    // Competency status.
    AddonCompetencyProvider.REVIEW_STATUS_IDLE = 0;
    AddonCompetencyProvider.REVIEW_STATUS_WAITING_FOR_REVIEW = 1;
    AddonCompetencyProvider.REVIEW_STATUS_IN_REVIEW = 2;
    AddonCompetencyProvider = AddonCompetencyProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_pushnotifications_providers_pushnotifications__["a" /* CorePushNotificationsProvider */]])
    ], AddonCompetencyProvider);
    return AddonCompetencyProvider;
    var AddonCompetencyProvider_1;
}());

//# sourceMappingURL=competency.js.map

/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLocalNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_local_notifications__ = __webpack_require__(337);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_push__ = __webpack_require__(336);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__config__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__configconstants__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/*
 * Generated class for the LocalNotificationsProvider provider.
 *
 * See https://angular.io/guide/dependency-injection for more info on providers
 * and Angular DI.
*/
var CoreLocalNotificationsProvider = /** @class */ (function () {
    function CoreLocalNotificationsProvider(logger, localNotifications, platform, appProvider, utils, configProvider, textUtils, translate, alertCtrl, eventsProvider, push, zone) {
        var _this = this;
        this.localNotifications = localNotifications;
        this.platform = platform;
        this.appProvider = appProvider;
        this.utils = utils;
        this.configProvider = configProvider;
        this.textUtils = textUtils;
        this.translate = translate;
        this.alertCtrl = alertCtrl;
        this.push = push;
        this.zone = zone;
        // Variables for the database.
        this.SITES_TABLE = 'notification_sites'; // Store to asigne unique codes to each site.
        this.COMPONENTS_TABLE = 'notification_components'; // Store to asigne unique codes to each component.
        this.TRIGGERED_TABLE = 'notifications_triggered'; // Store to prevent re-triggering notifications.
        this.tablesSchema = [
            {
                name: this.SITES_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'code',
                        type: 'INTEGER',
                        notNull: true
                    }
                ]
            },
            {
                name: this.COMPONENTS_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'code',
                        type: 'INTEGER',
                        notNull: true
                    }
                ]
            },
            {
                name: this.TRIGGERED_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'at',
                        type: 'INTEGER',
                        notNull: true
                    }
                ]
            }
        ];
        this.codes = {};
        this.codeRequestsQueue = {};
        this.observables = {};
        this.currentNotification = {
            title: '',
            texts: [],
            ids: [],
            timeouts: []
        };
        this.logger = logger.getInstance('CoreLocalNotificationsProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTablesFromSchema(this.tablesSchema);
        platform.ready().then(function () {
            // Listen to events.
            _this.triggerSubscription = localNotifications.on('trigger').subscribe(function (notification) {
                _this.trigger(notification);
                _this.handleEvent('trigger', notification);
            });
            _this.clickSubscription = localNotifications.on('click').subscribe(function (notification) {
                _this.handleEvent('click', notification);
            });
            _this.clearSubscription = localNotifications.on('clear').subscribe(function (notification) {
                _this.handleEvent('clear', notification);
            });
            _this.cancelSubscription = localNotifications.on('cancel').subscribe(function (notification) {
                _this.handleEvent('cancel', notification);
            });
            _this.addSubscription = localNotifications.on('schedule').subscribe(function (notification) {
                _this.handleEvent('schedule', notification);
            });
            _this.updateSubscription = localNotifications.on('update').subscribe(function (notification) {
                _this.handleEvent('update', notification);
            });
            // Create the default channel for local notifications.
            _this.createDefaultChannel();
            translate.onLangChange.subscribe(function (event) {
                // Update the channel name.
                _this.createDefaultChannel();
            });
        });
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_7__events__["a" /* CoreEventsProvider */].SITE_DELETED, function (site) {
            if (site) {
                _this.cancelSiteNotifications(site.id);
            }
        });
    }
    /**
     * Cancel a local notification.
     *
     * @param {number} id Notification id.
     * @param {string} component Component of the notification.
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the notification is cancelled.
     */
    CoreLocalNotificationsProvider.prototype.cancel = function (id, component, siteId) {
        var _this = this;
        return this.getUniqueNotificationId(id, component, siteId).then(function (uniqueId) {
            return _this.localNotifications.cancel(uniqueId);
        });
    };
    /**
     * Cancel all the scheduled notifications belonging to a certain site.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the notifications are cancelled.
     */
    CoreLocalNotificationsProvider.prototype.cancelSiteNotifications = function (siteId) {
        var _this = this;
        if (!this.isAvailable()) {
            return Promise.resolve();
        }
        else if (!siteId) {
            return Promise.reject(null);
        }
        return this.localNotifications.getScheduled().then(function (scheduled) {
            var ids = [];
            scheduled.forEach(function (notif) {
                if (typeof notif.data == 'string') {
                    notif.data = _this.textUtils.parseJSON(notif.data);
                }
                if (typeof notif.data == 'object' && notif.data.siteId === siteId) {
                    ids.push(notif.id);
                }
            });
            return _this.localNotifications.cancel(ids);
        });
    };
    /**
     * Check whether sound can be disabled for notifications.
     *
     * @return {boolean} Whether sound can be disabled for notifications.
     */
    CoreLocalNotificationsProvider.prototype.canDisableSound = function () {
        // Only allow disabling sound in Android 7 or lower. In iOS and Android 8+ it can easily be done with system settings.
        return this.isAvailable() && !this.appProvider.isDesktop() && this.platform.is('android') &&
            this.platform.version().major < 8;
    };
    /**
     * Create the default channel. It is used to change the name.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLocalNotificationsProvider.prototype.createDefaultChannel = function () {
        var _this = this;
        if (!this.platform.is('android')) {
            return Promise.resolve();
        }
        return this.push.createChannel({
            id: 'default-channel-id',
            description: this.translate.instant('addon.calendar.calendarreminders'),
            importance: 4
        }).catch(function (error) {
            _this.logger.error('Error changing channel name', error);
        });
    };
    /**
     * Get a code to create unique notifications. If there's no code assigned, create a new one.
     *
     * @param {string} table Table to search in local DB.
     * @param {string} id ID of the element to get its code.
     * @return {Promise<number>} Promise resolved when the code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.getCode = function (table, id) {
        var _this = this;
        var key = table + '#' + id;
        // Check if the code is already in memory.
        if (typeof this.codes[key] != 'undefined') {
            return Promise.resolve(this.codes[key]);
        }
        // Check if we already have a code stored for that ID.
        return this.appDB.getRecord(table, { id: id }).then(function (entry) {
            _this.codes[key] = entry.code;
            return entry.code;
        }).catch(function () {
            // No code stored for that ID. Create a new code for it.
            return _this.appDB.getRecords(table, undefined, 'code DESC').then(function (entries) {
                var newCode = 0;
                if (entries.length > 0) {
                    newCode = entries[0].code + 1;
                }
                return _this.appDB.insertRecord(table, { id: id, code: newCode }).then(function () {
                    _this.codes[key] = newCode;
                    return newCode;
                });
            });
        });
    };
    /**
     * Get a notification component code to be used.
     * If it's the first time this component is used to send notifications, create a new code for it.
     *
     * @param {string} component Component name.
     * @return {Promise<number>} Promise resolved when the component code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.getComponentCode = function (component) {
        return this.requestCode(this.COMPONENTS_TABLE, component);
    };
    /**
     * Get a site code to be used.
     * If it's the first time this site is used to send notifications, create a new code for it.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<number>} Promise resolved when the site code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.getSiteCode = function (siteId) {
        return this.requestCode(this.SITES_TABLE, siteId);
    };
    /**
     * Create a unique notification ID, trying to prevent collisions. Generated ID must be a Number (Android).
     * The generated ID shouldn't be higher than 2147483647 or it's going to cause problems in Android.
     * This function will prevent collisions and keep the number under Android limit if:
     *     -User has used less than 21 sites.
     *     -There are less than 11 components.
     *     -The notificationId passed as parameter is lower than 10000000.
     *
     * @param {number} notificationId Notification ID.
     * @param {string} component Component triggering the notification.
     * @param {string} siteId Site ID.
     * @return {Promise<number>} Promise resolved when the notification ID is generated.
     */
    CoreLocalNotificationsProvider.prototype.getUniqueNotificationId = function (notificationId, component, siteId) {
        var _this = this;
        if (!siteId || !component) {
            return Promise.reject(null);
        }
        return this.getSiteCode(siteId).then(function (siteCode) {
            return _this.getComponentCode(component).then(function (componentCode) {
                // We use the % operation to keep the number under Android's limit.
                return (siteCode * 100000000 + componentCode * 10000000 + notificationId) % 2147483647;
            });
        });
    };
    /**
     * Handle an event triggered by the local notifications plugin.
     *
     * @param {string} eventName Name of the event.
     * @param {any} notification Notification.
     */
    CoreLocalNotificationsProvider.prototype.handleEvent = function (eventName, notification) {
        if (notification && notification.data) {
            this.logger.debug('Notification event: ' + eventName + '. Data:', notification.data);
            this.notifyEvent(eventName, notification.data);
        }
    };
    /**
     * Returns whether local notifications plugin is installed.
     *
     * @return {boolean} Whether local notifications plugin is installed.
     */
    CoreLocalNotificationsProvider.prototype.isAvailable = function () {
        var win = window;
        return this.appProvider.isDesktop() || !!(win.cordova && win.cordova.plugins && win.cordova.plugins.notification &&
            win.cordova.plugins.notification.local);
    };
    /**
     * Check if a notification has been triggered with the same trigger time.
     *
     * @param {ILocalNotification} notification Notification to check.
     * @return {Promise<any>} Promise resolved with a boolean indicating if promise is triggered (true) or not.
     */
    CoreLocalNotificationsProvider.prototype.isTriggered = function (notification) {
        var _this = this;
        return this.appDB.getRecord(this.TRIGGERED_TABLE, { id: notification.id }).then(function (stored) {
            var triggered = (notification.trigger && notification.trigger.at) || 0;
            if (typeof triggered != 'number') {
                triggered = triggered.getTime();
            }
            return stored.at === triggered;
        }).catch(function () {
            return _this.localNotifications.isTriggered(notification.id);
        });
    };
    /**
     * Notify notification click to observers. Only the observers with the same component as the notification will be notified.
     *
     * @param {any} data Data received by the notification.
     */
    CoreLocalNotificationsProvider.prototype.notifyClick = function (data) {
        this.notifyEvent('click', data);
    };
    /**
     * Notify a certain event to observers. Only the observers with the same component as the notification will be notified.
     *
     * @param {string} eventName Name of the event to notify.
     * @param {any} data Data received by the notification.
     */
    CoreLocalNotificationsProvider.prototype.notifyEvent = function (eventName, data) {
        var _this = this;
        // Execute the code in the Angular zone, so change detection doesn't stop working.
        this.zone.run(function () {
            var component = data.component;
            if (component) {
                if (_this.observables[eventName] && _this.observables[eventName][component]) {
                    _this.observables[eventName][component].next(data);
                }
            }
        });
    };
    /**
     * Process the next request in queue.
     */
    CoreLocalNotificationsProvider.prototype.processNextRequest = function () {
        var _this = this;
        var nextKey = Object.keys(this.codeRequestsQueue)[0];
        var request, promise;
        if (typeof nextKey == 'undefined') {
            // No more requests in queue, stop.
            return;
        }
        request = this.codeRequestsQueue[nextKey];
        // Check if request is valid.
        if (typeof request == 'object' && typeof request.table != 'undefined' && typeof request.id != 'undefined') {
            // Get the code and resolve/reject all the promises of this request.
            promise = this.getCode(request.table, request.id).then(function (code) {
                request.promises.forEach(function (p) {
                    p.resolve(code);
                });
            }).catch(function (error) {
                request.promises.forEach(function (p) {
                    p.reject(error);
                });
            });
        }
        else {
            promise = Promise.resolve();
        }
        // Once this item is treated, remove it and process next.
        promise.finally(function () {
            delete _this.codeRequestsQueue[nextKey];
            _this.processNextRequest();
        });
    };
    /**
     * Register an observer to be notified when a notification belonging to a certain component is clicked.
     *
     * @param {string} component Component to listen notifications for.
     * @param {Function} callback Function to call with the data received by the notification.
     * @return {any} Object with an "off" property to stop listening for clicks.
     */
    CoreLocalNotificationsProvider.prototype.registerClick = function (component, callback) {
        return this.registerObserver('click', component, callback);
    };
    /**
     * Register an observer to be notified when a certain event is fired for a notification belonging to a certain component.
     *
     * @param {string} eventName Name of the event to listen to.
     * @param {string} component Component to listen notifications for.
     * @param {Function} callback Function to call with the data received by the notification.
     * @return {any} Object with an "off" property to stop listening for events.
     */
    CoreLocalNotificationsProvider.prototype.registerObserver = function (eventName, component, callback) {
        var _this = this;
        this.logger.debug("Register observer '" + component + "' for event '" + eventName + "'.");
        if (typeof this.observables[eventName] == 'undefined') {
            this.observables[eventName] = {};
        }
        if (typeof this.observables[eventName][component] == 'undefined') {
            // No observable for this component, create a new one.
            this.observables[eventName][component] = new __WEBPACK_IMPORTED_MODULE_13_rxjs__["Subject"]();
        }
        this.observables[eventName][component].subscribe(callback);
        return {
            off: function () {
                _this.observables[eventName][component].unsubscribe(callback);
            }
        };
    };
    /**
     * Remove a notification from triggered store.
     *
     * @param {number} id Notification ID.
     * @return {Promise<any>} Promise resolved when it is removed.
     */
    CoreLocalNotificationsProvider.prototype.removeTriggered = function (id) {
        return this.appDB.deleteRecords(this.TRIGGERED_TABLE, { id: id });
    };
    /**
     * Request a unique code. The request will be added to the queue and the queue is going to be started if it's paused.
     *
     * @param {string} table Table to search in local DB.
     * @param {string} id ID of the element to get its code.
     * @return {Promise}      Promise resolved when the code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.requestCode = function (table, id) {
        var deferred = this.utils.promiseDefer(), key = table + '#' + id, isQueueEmpty = Object.keys(this.codeRequestsQueue).length == 0;
        if (typeof this.codeRequestsQueue[key] != 'undefined') {
            // There's already a pending request for this store and ID, add the promise to it.
            this.codeRequestsQueue[key].promises.push(deferred);
        }
        else {
            // Add a pending request to the queue.
            this.codeRequestsQueue[key] = {
                table: table,
                id: id,
                promises: [deferred]
            };
        }
        if (isQueueEmpty) {
            this.processNextRequest();
        }
        return deferred.promise;
    };
    /**
     * Reschedule all notifications that are already scheduled.
     *
     * @return {Promise<any>} Promise resolved when all notifications have been rescheduled.
     */
    CoreLocalNotificationsProvider.prototype.rescheduleAll = function () {
        var _this = this;
        // Get all the scheduled notifications.
        return this.localNotifications.getScheduled().then(function (notifications) {
            var promises = [];
            notifications.forEach(function (notification) {
                // Convert some properties to the needed types.
                notification.data = notification.data ? _this.textUtils.parseJSON(notification.data, {}) : {};
                promises.push(_this.scheduleNotification(notification));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Schedule a local notification.
     *
     * @param {ILocalNotification} notification Notification to schedule. Its ID should be lower than 10000000 and it should
     *                                          be unique inside its component and site.
     * @param {string} component Component triggering the notification. It is used to generate unique IDs.
     * @param {string} siteId Site ID.
     * @param {boolean} [alreadyUnique] Whether the ID is already unique.
     * @return {Promise<any>} Promise resolved when the notification is scheduled.
     */
    CoreLocalNotificationsProvider.prototype.schedule = function (notification, component, siteId, alreadyUnique) {
        var _this = this;
        var promise;
        if (alreadyUnique) {
            promise = Promise.resolve(notification.id);
        }
        else {
            promise = this.getUniqueNotificationId(notification.id, component, siteId);
        }
        return promise.then(function (uniqueId) {
            notification.id = uniqueId;
            notification.data = notification.data || {};
            notification.data.component = component;
            notification.data.siteId = siteId;
            if (_this.platform.is('android')) {
                notification.icon = notification.icon || 'res://icon';
                notification.smallIcon = notification.smallIcon || 'res://smallicon';
                notification.color = notification.color || __WEBPACK_IMPORTED_MODULE_12__configconstants__["a" /* CoreConfigConstants */].notificoncolor;
                var led = notification.led || {};
                notification.led = {
                    color: led.color || 'FF9900',
                    on: led.on || 1000,
                    off: led.off || 1000
                };
            }
            return _this.scheduleNotification(notification);
        });
    };
    /**
     * Helper function to schedule a notification object if it hasn't been triggered already.
     *
     * @param {ILocalNotification} notification Notification to schedule.
     * @return {Promise<any>} Promise resolved when scheduled.
     */
    CoreLocalNotificationsProvider.prototype.scheduleNotification = function (notification) {
        var _this = this;
        // Check if the notification has been triggered already.
        return this.isTriggered(notification).then(function (triggered) {
            // Cancel the current notification in case it gets scheduled twice.
            return _this.localNotifications.cancel(notification.id).finally(function () {
                if (!triggered) {
                    // Check if sound is enabled for notifications.
                    var promise = void 0;
                    if (_this.canDisableSound()) {
                        promise = _this.configProvider.get(__WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].SETTINGS_NOTIFICATION_SOUND, true);
                    }
                    else {
                        promise = Promise.resolve(true);
                    }
                    return promise.then(function (soundEnabled) {
                        if (!soundEnabled) {
                            notification.sound = null;
                        }
                        else {
                            delete notification.sound; // Use default value.
                        }
                        notification.foreground = true;
                        // Remove from triggered, since the notification could be in there with a different time.
                        _this.removeTriggered(notification.id);
                        _this.localNotifications.schedule(notification);
                    });
                }
            });
        });
    };
    /**
     * Show an in app notification popover.
     * This function was used because local notifications weren't displayed when the app was in foreground in iOS10+,
     * but the issue was fixed in the plugin and this function is no longer used.
     *
     * @param {ILocalNotification} notification Notification.
     */
    CoreLocalNotificationsProvider.prototype.showNotificationPopover = function (notification) {
        var _this = this;
        if (!notification || !notification.title || !notification.text) {
            // Invalid data.
            return;
        }
        var clearAlert = function (all) {
            if (all === void 0) { all = false; }
            // Only erase first notification.
            if (!all && _this.alertNotification && _this.currentNotification.ids.length > 1) {
                _this.currentNotification.texts.shift();
                _this.currentNotification.ids.shift();
                clearTimeout(_this.currentNotification.timeouts.shift());
                var text_1 = '<p>' + _this.currentNotification.texts.join('</p><p>') + '</p>';
                _this.alertNotification.setMessage(text_1);
            }
            else {
                // Close the alert and reset the current object.
                if (_this.alertNotification && !all) {
                    _this.alertNotification.dismiss();
                }
                _this.alertNotification = null;
                _this.currentNotification.title = '';
                _this.currentNotification.texts = [];
                _this.currentNotification.ids = [];
                _this.currentNotification.timeouts.forEach(function (time) {
                    clearTimeout(time);
                });
                _this.currentNotification.timeouts = [];
            }
        };
        if (this.alertNotification && this.currentNotification.title == notification.title) {
            if (this.currentNotification.ids.indexOf(notification.id) != -1) {
                // Notification already shown, don't show it again, just renew the timeout.
                return;
            }
            // Same title and the notification is shown, update it.
            this.currentNotification.texts.push(notification.text);
            this.currentNotification.ids.push(notification.id);
            if (this.currentNotification.texts.length > 3) {
                this.currentNotification.texts.shift();
                this.currentNotification.ids.shift();
                clearTimeout(this.currentNotification.timeouts.shift());
            }
        }
        else {
            this.currentNotification.timeouts.forEach(function (time) {
                clearTimeout(time);
            });
            this.currentNotification.timeouts = [];
            // Not shown or title is different, set new data.
            this.currentNotification.title = notification.title;
            this.currentNotification.texts = [notification.text];
            this.currentNotification.ids = [notification.id];
        }
        var text = '<p>' + this.currentNotification.texts.join('</p><p>') + '</p>';
        if (this.alertNotification) {
            this.alertNotification.setTitle(this.currentNotification.title);
            this.alertNotification.setMessage(text);
        }
        else {
            this.alertNotification = this.alertCtrl.create({
                title: this.currentNotification.title,
                message: text,
                cssClass: 'core-inapp-notification',
                enableBackdropDismiss: false,
                buttons: [{
                        text: this.translate.instant('core.dismiss'),
                        role: 'cancel',
                        handler: function () {
                            clearAlert(true);
                        }
                    }]
            });
        }
        this.alertNotification.present();
        this.currentNotification.timeouts.push(setTimeout(function () {
            clearAlert();
        }, 4000));
    };
    /**
     * Function to call when a notification is triggered. Stores the notification so it's not scheduled again unless the
     * time is changed.
     *
     * @param {ILocalNotification} notification Triggered notification.
     * @return {Promise<any>} Promise resolved when stored, rejected otherwise.
     */
    CoreLocalNotificationsProvider.prototype.trigger = function (notification) {
        var entry = {
            id: notification.id,
            at: notification.trigger && notification.trigger.at ? notification.trigger.at : Date.now()
        };
        return this.appDB.insertRecord(this.TRIGGERED_TABLE, entry);
    };
    /**
     * Update a component name.
     *
     * @param {string} oldName The old name.
     * @param {string}  newName The new name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLocalNotificationsProvider.prototype.updateComponentName = function (oldName, newName) {
        var oldId = this.COMPONENTS_TABLE + '#' + oldName, newId = this.COMPONENTS_TABLE + '#' + newName;
        return this.appDB.updateRecords(this.COMPONENTS_TABLE, { id: newId }, { id: oldId });
    };
    CoreLocalNotificationsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_local_notifications__["a" /* LocalNotifications */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_5__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_10__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__config__["a" /* CoreConfigProvider */],
            __WEBPACK_IMPORTED_MODULE_9__utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["b" /* AlertController */],
            __WEBPACK_IMPORTED_MODULE_7__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_push__["a" /* Push */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["M" /* NgZone */]])
    ], CoreLocalNotificationsProvider);
    return CoreLocalNotificationsProvider;
}());

//# sourceMappingURL=local-notifications.js.map

/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModAssignFeedbackDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__default_feedback_handler__ = __webpack_require__(558);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Delegate to register plugins for assign feedback.
 */
var AddonModAssignFeedbackDelegate = /** @class */ (function (_super) {
    __extends(AddonModAssignFeedbackDelegate, _super);
    function AddonModAssignFeedbackDelegate(logger, sitesProvider, eventsProvider, defaultHandler) {
        var _this = _super.call(this, 'AddonModAssignFeedbackDelegate', logger, sitesProvider, eventsProvider) || this;
        _this.defaultHandler = defaultHandler;
        _this.handlerNameProperty = 'type';
        return _this;
    }
    /**
     * Discard the draft data of the feedback plugin.
     *
     * @param {number} assignId The assignment ID.
     * @param {number} userId User ID.
     * @param {any} plugin The plugin object.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModAssignFeedbackDelegate.prototype.discardPluginFeedbackData = function (assignId, userId, plugin, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'discardDraft', [assignId, userId, siteId]));
    };
    /**
     * Get the component to use for a certain feedback plugin.
     *
     * @param {Injector} injector Injector.
     * @param {any} plugin The plugin object.
     * @return {Promise<any>} Promise resolved with the component to use, undefined if not found.
     */
    AddonModAssignFeedbackDelegate.prototype.getComponentForPlugin = function (injector, plugin) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'getComponent', [injector, plugin]));
    };
    /**
     * Return the draft saved data of the feedback plugin.
     *
     * @param {number} assignId The assignment ID.
     * @param {number} userId User ID.
     * @param {any} plugin The plugin object.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the draft data.
     */
    AddonModAssignFeedbackDelegate.prototype.getPluginDraftData = function (assignId, userId, plugin, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'getDraft', [assignId, userId, siteId]));
    };
    /**
     * Get files used by this plugin.
     * The files returned by this function will be prefetched when the user prefetches the assign.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    AddonModAssignFeedbackDelegate.prototype.getPluginFiles = function (assign, submission, plugin, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'getPluginFiles', [assign, submission, plugin, siteId]));
    };
    /**
     * Get a readable name to use for a certain feedback plugin.
     *
     * @param {any} plugin Plugin to get the name for.
     * @return {string} Human readable name.
     */
    AddonModAssignFeedbackDelegate.prototype.getPluginName = function (plugin) {
        return this.executeFunctionOnEnabled(plugin.type, 'getPluginName', [plugin]);
    };
    /**
     * Check if the feedback data has changed for a certain plugin.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {any} inputData Data entered by the user for the feedback.
     * @param {number} userId User ID of the submission.
     * @return {Promise<boolean>} Promise resolved with true if data has changed, resolved with false otherwise.
     */
    AddonModAssignFeedbackDelegate.prototype.hasPluginDataChanged = function (assign, submission, plugin, inputData, userId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'hasDataChanged', [assign, submission, plugin, inputData, userId]));
    };
    /**
     * Check whether the plugin has draft data stored.
     *
     * @param {number} assignId The assignment ID.
     * @param {number} userId User ID.
     * @param {any} plugin The plugin object.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if it has draft data.
     */
    AddonModAssignFeedbackDelegate.prototype.hasPluginDraftData = function (assignId, userId, plugin, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'hasDraftData', [assignId, userId, siteId]));
    };
    /**
     * Check if a feedback plugin is supported.
     *
     * @param {string} pluginType Type of the plugin.
     * @return {boolean} Whether it's supported.
     */
    AddonModAssignFeedbackDelegate.prototype.isPluginSupported = function (pluginType) {
        return this.hasHandler(pluginType, true);
    };
    /**
     * Prefetch any required data for a feedback plugin.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModAssignFeedbackDelegate.prototype.prefetch = function (assign, submission, plugin, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'prefetch', [assign, submission, plugin, siteId]));
    };
    /**
     * Prepare and add to pluginData the data to submit for a certain feedback plugin.
     *
     * @param {number} assignId The assignment ID.
     * @param {number} userId User ID.
     * @param {any} plugin The plugin object.
     * @param {any} pluginData Object where to store the data to send.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data has been gathered.
     */
    AddonModAssignFeedbackDelegate.prototype.preparePluginFeedbackData = function (assignId, userId, plugin, pluginData, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'prepareFeedbackData', [assignId, userId, plugin, pluginData, siteId]));
    };
    /**
     * Save draft data of the feedback plugin.
     *
     * @param {number} assignId The assignment ID.
     * @param {number} userId User ID.
     * @param {any} plugin The plugin object.
     * @param {any} inputData Data to save.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data has been saved.
     */
    AddonModAssignFeedbackDelegate.prototype.saveFeedbackDraft = function (assignId, userId, plugin, inputData, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'saveDraft', [assignId, userId, plugin, inputData, siteId]));
    };
    AddonModAssignFeedbackDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__default_feedback_handler__["a" /* AddonModAssignDefaultFeedbackHandler */]])
    ], AddonModAssignFeedbackDelegate);
    return AddonModAssignFeedbackDelegate;
}(__WEBPACK_IMPORTED_MODULE_4__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=feedback-delegate.js.map

/***/ }),
/* 152 */,
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModAssignSubmissionDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__default_submission_handler__ = __webpack_require__(561);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Delegate to register plugins for assign submission.
 */
var AddonModAssignSubmissionDelegate = /** @class */ (function (_super) {
    __extends(AddonModAssignSubmissionDelegate, _super);
    function AddonModAssignSubmissionDelegate(logger, sitesProvider, eventsProvider, defaultHandler) {
        var _this = _super.call(this, 'AddonModAssignSubmissionDelegate', logger, sitesProvider, eventsProvider) || this;
        _this.defaultHandler = defaultHandler;
        _this.handlerNameProperty = 'type';
        return _this;
    }
    /**
     * Whether the plugin can be edited in offline for existing submissions.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @return {boolean|Promise<boolean>} Promise resolved with boolean: whether it can be edited in offline.
     */
    AddonModAssignSubmissionDelegate.prototype.canPluginEditOffline = function (assign, submission, plugin) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'canEditOffline', [assign, submission, plugin]));
    };
    /**
     * Clear some temporary data for a certain plugin because a submission was cancelled.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {any} inputData Data entered by the user for the submission.
     */
    AddonModAssignSubmissionDelegate.prototype.clearTmpData = function (assign, submission, plugin, inputData) {
        return this.executeFunctionOnEnabled(plugin.type, 'clearTmpData', [assign, submission, plugin, inputData]);
    };
    /**
     * Copy the data from last submitted attempt to the current submission for a certain plugin.
     *
     * @param {any} assign The assignment.
     * @param {any} plugin The plugin object.
     * @param {any} pluginData Object where to store the data to send.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data has been copied.
     */
    AddonModAssignSubmissionDelegate.prototype.copyPluginSubmissionData = function (assign, plugin, pluginData, userId, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'copySubmissionData', [assign, plugin, pluginData, userId, siteId]));
    };
    /**
     * Delete offline data stored for a certain submission and plugin.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {any} offlineData Offline data stored.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModAssignSubmissionDelegate.prototype.deletePluginOfflineData = function (assign, submission, plugin, offlineData, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'deleteOfflineData', [assign, submission, plugin, offlineData, siteId]));
    };
    /**
     * Get the component to use for a certain submission plugin.
     *
     * @param {Injector} injector Injector.
     * @param {any} plugin The plugin object.
     * @param {boolean} [edit] Whether the user is editing.
     * @return {Promise<any>} Promise resolved with the component to use, undefined if not found.
     */
    AddonModAssignSubmissionDelegate.prototype.getComponentForPlugin = function (injector, plugin, edit) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'getComponent', [injector, plugin, edit]));
    };
    /**
     * Get files used by this plugin.
     * The files returned by this function will be prefetched when the user prefetches the assign.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    AddonModAssignSubmissionDelegate.prototype.getPluginFiles = function (assign, submission, plugin, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'getPluginFiles', [assign, submission, plugin, siteId]));
    };
    /**
     * Get a readable name to use for a certain submission plugin.
     *
     * @param {any} plugin Plugin to get the name for.
     * @return {string} Human readable name.
     */
    AddonModAssignSubmissionDelegate.prototype.getPluginName = function (plugin) {
        return this.executeFunctionOnEnabled(plugin.type, 'getPluginName', [plugin]);
    };
    /**
     * Get the size of data (in bytes) this plugin will send to copy a previous submission.
     *
     * @param {any} assign The assignment.
     * @param {any} plugin The plugin object.
     * @return {Promise<number>} Promise resolved with size.
     */
    AddonModAssignSubmissionDelegate.prototype.getPluginSizeForCopy = function (assign, plugin) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'getSizeForCopy', [assign, plugin]));
    };
    /**
     * Get the size of data (in bytes) this plugin will send to add or edit a submission.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {any} inputData Data entered by the user for the submission.
     * @return {Promise<number>} Promise resolved with size.
     */
    AddonModAssignSubmissionDelegate.prototype.getPluginSizeForEdit = function (assign, submission, plugin, inputData) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'getSizeForEdit', [assign, submission, plugin, inputData]));
    };
    /**
     * Check if the submission data has changed for a certain plugin.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {any} inputData Data entered by the user for the submission.
     * @return {Promise<boolean>} Promise resolved with true if data has changed, resolved with false otherwise.
     */
    AddonModAssignSubmissionDelegate.prototype.hasPluginDataChanged = function (assign, submission, plugin, inputData) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'hasDataChanged', [assign, submission, plugin, inputData]));
    };
    /**
     * Check if a submission plugin is supported.
     *
     * @param {string} pluginType Type of the plugin.
     * @return {boolean} Whether it's supported.
     */
    AddonModAssignSubmissionDelegate.prototype.isPluginSupported = function (pluginType) {
        return this.hasHandler(pluginType, true);
    };
    /**
     * Check if a submission plugin is supported for edit.
     *
     * @param {string} pluginType Type of the plugin.
     * @return {Promise<boolean>} Whether it's supported for edit.
     */
    AddonModAssignSubmissionDelegate.prototype.isPluginSupportedForEdit = function (pluginType) {
        return Promise.resolve(this.executeFunctionOnEnabled(pluginType, 'isEnabledForEdit'));
    };
    /**
     * Prefetch any required data for a submission plugin.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModAssignSubmissionDelegate.prototype.prefetch = function (assign, submission, plugin, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'prefetch', [assign, submission, plugin, siteId]));
    };
    /**
     * Prepare and add to pluginData the data to submit for a certain submission plugin.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {any} inputData Data entered by the user for the submission.
     * @param {any} pluginData Object where to store the data to send.
     * @param {boolean} [offline] Whether the user is editing in offline.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data has been gathered.
     */
    AddonModAssignSubmissionDelegate.prototype.preparePluginSubmissionData = function (assign, submission, plugin, inputData, pluginData, offline, userId, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'prepareSubmissionData', [assign, submission, plugin, inputData, pluginData, offline, userId, siteId]));
    };
    /**
     * Prepare and add to pluginData the data to send to server to synchronize an offline submission.
     *
     * @param {any} assign The assignment.
     * @param {any} submission The submission.
     * @param {any} plugin The plugin object.
     * @param {any} offlineData Offline data stored.
     * @param {any} pluginData Object where to store the data to send.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data has been gathered.
     */
    AddonModAssignSubmissionDelegate.prototype.preparePluginSyncData = function (assign, submission, plugin, offlineData, pluginData, siteId) {
        return Promise.resolve(this.executeFunctionOnEnabled(plugin.type, 'prepareSyncData', [assign, submission, plugin, offlineData, pluginData, siteId]));
    };
    AddonModAssignSubmissionDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__default_submission_handler__["a" /* AddonModAssignDefaultSubmissionHandler */]])
    ], AddonModAssignSubmissionDelegate);
    return AddonModAssignSubmissionDelegate;
}(__WEBPACK_IMPORTED_MODULE_4__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=submission-delegate.js.map

/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModQuizProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_grades_providers_helper__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_question_providers_delegate__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__access_rules_delegate__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__quiz_offline__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_pushnotifications_providers_pushnotifications__ = __webpack_require__(140);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
















/**
 * Service that provides some features for quiz.
 */
var AddonModQuizProvider = /** @class */ (function () {
    function AddonModQuizProvider(logger, sitesProvider, utils, translate, textUtils, gradesHelper, questionDelegate, filepoolProvider, timeUtils, accessRulesDelegate, quizOfflineProvider, domUtils, logHelper, pushNotificationsProvider) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.translate = translate;
        this.textUtils = textUtils;
        this.gradesHelper = gradesHelper;
        this.questionDelegate = questionDelegate;
        this.filepoolProvider = filepoolProvider;
        this.timeUtils = timeUtils;
        this.accessRulesDelegate = accessRulesDelegate;
        this.quizOfflineProvider = quizOfflineProvider;
        this.domUtils = domUtils;
        this.logHelper = logHelper;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.ROOT_CACHE_KEY = 'mmaModQuiz:';
        this.logger = logger.getInstance('AddonModQuizProvider');
    }
    AddonModQuizProvider_1 = AddonModQuizProvider;
    /**
     * Formats a grade to be displayed.
     *
     * @param {number} grade Grade.
     * @param {number} decimals Decimals to use.
     * @return {string} Grade to display.
     */
    AddonModQuizProvider.prototype.formatGrade = function (grade, decimals) {
        if (typeof grade == 'undefined' || grade == -1 || grade === null) {
            return this.translate.instant('addon.mod_quiz.notyetgraded');
        }
        return this.utils.formatFloat(this.textUtils.roundToDecimals(grade, decimals));
    };
    /**
     * Get attempt questions. Returns all of them or just the ones in certain pages.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @param {any} preflightData Preflight required data (like password).
     * @param {number[]} [pages] List of pages to get. If not defined, all pages.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the questions.
     */
    AddonModQuizProvider.prototype.getAllQuestionsData = function (quiz, attempt, preflightData, pages, offline, ignoreCache, siteId) {
        var _this = this;
        var promises = [], questions = {}, isSequential = this.isNavigationSequential(quiz);
        if (!pages) {
            pages = this.getPagesFromLayout(attempt.layout);
        }
        pages.forEach(function (page) {
            if (isSequential && page < attempt.currentpage) {
                // Sequential quiz, cannot get pages before the current one.
                return;
            }
            // Get the questions in the page.
            promises.push(_this.getAttemptData(attempt.id, page, preflightData, offline, ignoreCache, siteId).then(function (data) {
                // Add the questions to the result object.
                data.questions.forEach(function (question) {
                    questions[question.slot] = question;
                });
            }));
        });
        return Promise.all(promises).then(function () {
            return questions;
        });
    };
    /**
     * Get cache key for get attempt access information WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} attemptId Attempt ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getAttemptAccessInformationCacheKey = function (quizId, attemptId) {
        return this.getAttemptAccessInformationCommonCacheKey(quizId) + ':' + attemptId;
    };
    /**
     * Get common cache key for get attempt access information WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getAttemptAccessInformationCommonCacheKey = function (quizId) {
        return this.ROOT_CACHE_KEY + 'attemptAccessInformation:' + quizId;
    };
    /**
     * Get access information for an attempt.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} attemptId Attempt ID. 0 for user's last attempt.
     * @param {boolean} offline Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} ignoreCache Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the access information.
     */
    AddonModQuizProvider.prototype.getAttemptAccessInformation = function (quizId, attemptId, offline, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                quizid: quizId,
                attemptid: attemptId
            }, preSets = {
                cacheKey: _this.getAttemptAccessInformationCacheKey(quizId, attemptId)
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_attempt_access_information', params, preSets);
        });
    };
    /**
     * Get cache key for get attempt data WS calls.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} page Page.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getAttemptDataCacheKey = function (attemptId, page) {
        return this.getAttemptDataCommonCacheKey(attemptId) + ':' + page;
    };
    /**
     * Get common cache key for get attempt data WS calls.
     *
     * @param {number} attemptId Attempt ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getAttemptDataCommonCacheKey = function (attemptId) {
        return this.ROOT_CACHE_KEY + 'attemptData:' + attemptId;
    };
    /**
     * Get an attempt's data.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} page Page number.
     * @param {any} preflightData Preflight required data (like password).
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the attempt data.
     */
    AddonModQuizProvider.prototype.getAttemptData = function (attemptId, page, preflightData, offline, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                attemptid: attemptId,
                page: page,
                preflightdata: _this.utils.objectToArrayOfObjects(preflightData, 'name', 'value', true)
            }, preSets = {
                cacheKey: _this.getAttemptDataCacheKey(attemptId, page)
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_attempt_data', params, preSets);
        });
    };
    /**
     * Get an attempt's due date.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @return {number} Attempt's due date, 0 if no due date or invalid data.
     */
    AddonModQuizProvider.prototype.getAttemptDueDate = function (quiz, attempt) {
        var deadlines = [];
        if (quiz.timelimit) {
            deadlines.push(parseInt(attempt.timestart, 10) + parseInt(quiz.timelimit, 10));
        }
        if (quiz.timeclose) {
            deadlines.push(parseInt(quiz.timeclose, 10));
        }
        if (!deadlines.length) {
            return 0;
        }
        // Get min due date.
        var dueDate = Math.min.apply(null, deadlines);
        if (!dueDate) {
            return 0;
        }
        switch (attempt.state) {
            case AddonModQuizProvider_1.ATTEMPT_IN_PROGRESS:
                return dueDate * 1000;
            case AddonModQuizProvider_1.ATTEMPT_OVERDUE:
                return (dueDate + parseInt(quiz.graceperiod, 10)) * 1000;
            default:
                this.logger.warn('Unexpected state when getting due date: ' + attempt.state);
                return 0;
        }
    };
    /**
     * Get an attempt's warning because of due date.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @return {string} Attempt's warning, undefined if no due date.
     */
    AddonModQuizProvider.prototype.getAttemptDueDateWarning = function (quiz, attempt) {
        var dueDate = this.getAttemptDueDate(quiz, attempt);
        if (attempt.state === AddonModQuizProvider_1.ATTEMPT_OVERDUE) {
            return this.translate.instant('addon.mod_quiz.overduemustbesubmittedby', { $a: this.timeUtils.userDate(dueDate) });
        }
        else if (dueDate) {
            return this.translate.instant('addon.mod_quiz.mustbesubmittedby', { $a: this.timeUtils.userDate(dueDate) });
        }
    };
    /**
     * Turn attempt's state into a readable state, including some extra data depending on the state.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @return {string[]} List of state sentences.
     */
    AddonModQuizProvider.prototype.getAttemptReadableState = function (quiz, attempt) {
        if (attempt.finishedOffline) {
            return [this.translate.instant('addon.mod_quiz.finishnotsynced')];
        }
        switch (attempt.state) {
            case AddonModQuizProvider_1.ATTEMPT_IN_PROGRESS:
                return [this.translate.instant('addon.mod_quiz.stateinprogress')];
            case AddonModQuizProvider_1.ATTEMPT_OVERDUE:
                var sentences = [], dueDate = this.getAttemptDueDate(quiz, attempt);
                sentences.push(this.translate.instant('addon.mod_quiz.stateoverdue'));
                if (dueDate) {
                    sentences.push(this.translate.instant('addon.mod_quiz.stateoverduedetails', { $a: this.timeUtils.userDate(dueDate) }));
                }
                return sentences;
            case AddonModQuizProvider_1.ATTEMPT_FINISHED:
                return [
                    this.translate.instant('addon.mod_quiz.statefinished'),
                    this.translate.instant('addon.mod_quiz.statefinisheddetails', { $a: this.timeUtils.userDate(attempt.timefinish * 1000) })
                ];
            case AddonModQuizProvider_1.ATTEMPT_ABANDONED:
                return [this.translate.instant('addon.mod_quiz.stateabandoned')];
            default:
                return [];
        }
    };
    /**
     * Turn attempt's state into a readable state name, without any more data.
     *
     * @param {string} state State.
     * @return {string} Readable state name.
     */
    AddonModQuizProvider.prototype.getAttemptReadableStateName = function (state) {
        switch (state) {
            case AddonModQuizProvider_1.ATTEMPT_IN_PROGRESS:
                return this.translate.instant('addon.mod_quiz.stateinprogress');
            case AddonModQuizProvider_1.ATTEMPT_OVERDUE:
                return this.translate.instant('addon.mod_quiz.stateoverdue');
            case AddonModQuizProvider_1.ATTEMPT_FINISHED:
                return this.translate.instant('addon.mod_quiz.statefinished');
            case AddonModQuizProvider_1.ATTEMPT_ABANDONED:
                return this.translate.instant('addon.mod_quiz.stateabandoned');
            default:
                return '';
        }
    };
    /**
     * Get cache key for get attempt review WS calls.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} page Page.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getAttemptReviewCacheKey = function (attemptId, page) {
        return this.getAttemptReviewCommonCacheKey(attemptId) + ':' + page;
    };
    /**
     * Get common cache key for get attempt review WS calls.
     *
     * @param {number} attemptId Attempt ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getAttemptReviewCommonCacheKey = function (attemptId) {
        return this.ROOT_CACHE_KEY + 'attemptReview:' + attemptId;
    };
    /**
     * Get an attempt's review.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} [page] Page number. If not defined, return all the questions in all the pages.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the attempt review.
     */
    AddonModQuizProvider.prototype.getAttemptReview = function (attemptId, page, ignoreCache, siteId) {
        var _this = this;
        if (typeof page == 'undefined') {
            page = -1;
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                attemptid: attemptId,
                page: page
            }, preSets = {
                cacheKey: _this.getAttemptReviewCacheKey(attemptId, page),
                cacheErrors: ['noreview']
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_attempt_review', params, preSets);
        });
    };
    /**
     * Get cache key for get attempt summary WS calls.
     *
     * @param {number} attemptId Attempt ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getAttemptSummaryCacheKey = function (attemptId) {
        return this.ROOT_CACHE_KEY + 'attemptSummary:' + attemptId;
    };
    /**
     * Get an attempt's summary.
     *
     * @param {number} attemptId Attempt ID.
     * @param {any} preflightData Preflight required data (like password).
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {boolean} [loadLocal] Whether it should load local state for each question. Only applicable if offline=true.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of questions for the attempt summary.
     */
    AddonModQuizProvider.prototype.getAttemptSummary = function (attemptId, preflightData, offline, ignoreCache, loadLocal, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                attemptid: attemptId,
                preflightdata: _this.utils.objectToArrayOfObjects(preflightData, 'name', 'value', true)
            }, preSets = {
                cacheKey: _this.getAttemptSummaryCacheKey(attemptId)
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_attempt_summary', params, preSets).then(function (response) {
                if (response && response.questions) {
                    if (offline && loadLocal) {
                        return _this.quizOfflineProvider.loadQuestionsLocalStates(attemptId, response.questions, site.getId());
                    }
                    return response.questions;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get combined review options WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getCombinedReviewOptionsCacheKey = function (quizId, userId) {
        return this.getCombinedReviewOptionsCommonCacheKey(quizId) + ':' + userId;
    };
    /**
     * Get common cache key for get combined review options WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getCombinedReviewOptionsCommonCacheKey = function (quizId) {
        return this.ROOT_CACHE_KEY + 'combinedReviewOptions:' + quizId;
    };
    /**
     * Get a quiz combined review options.
     *
     * @param {number} quizId  Quiz ID.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>}Promise resolved with the combined review options.
     */
    AddonModQuizProvider.prototype.getCombinedReviewOptions = function (quizId, ignoreCache, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                quizid: quizId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getCombinedReviewOptionsCacheKey(quizId, userId)
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_combined_review_options', params, preSets).then(function (response) {
                if (response && response.someoptions && response.alloptions) {
                    // Convert the arrays to objects with name -> value.
                    response.someoptions = _this.utils.objectToKeyValueMap(response.someoptions, 'name', 'value');
                    response.alloptions = _this.utils.objectToKeyValueMap(response.alloptions, 'name', 'value');
                    return response;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get feedback for grade WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} grade  Grade.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getFeedbackForGradeCacheKey = function (quizId, grade) {
        return this.getFeedbackForGradeCommonCacheKey(quizId) + ':' + grade;
    };
    /**
     * Get common cache key for get feedback for grade WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getFeedbackForGradeCommonCacheKey = function (quizId) {
        return this.ROOT_CACHE_KEY + 'feedbackForGrade:' + quizId;
    };
    /**
     * Get the feedback for a certain grade.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} grade Grade.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the feedback.
     */
    AddonModQuizProvider.prototype.getFeedbackForGrade = function (quizId, grade, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                quizid: quizId,
                grade: grade
            }, preSets = {
                cacheKey: _this.getFeedbackForGradeCacheKey(quizId, grade),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_quiz_feedback_for_grade', params, preSets);
        });
    };
    /**
     * Determine the correct number of decimal places required to format a grade.
     * Based on Moodle's quiz_get_grade_format.
     *
     * @param {any} quiz Quiz.
     * @return {number} Number of decimals.
     */
    AddonModQuizProvider.prototype.getGradeDecimals = function (quiz) {
        if (typeof quiz.questiondecimalpoints == 'undefined') {
            quiz.questiondecimalpoints = -1;
        }
        if (quiz.questiondecimalpoints == -1) {
            return quiz.decimalpoints;
        }
        return quiz.questiondecimalpoints;
    };
    /**
     * Gets a quiz grade and feedback from the gradebook.
     *
     * @param {number} courseId Course ID.
     * @param {number} moduleId Quiz module ID.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved with an object containing the grade and the feedback.
     */
    AddonModQuizProvider.prototype.getGradeFromGradebook = function (courseId, moduleId, ignoreCache, siteId, userId) {
        return this.gradesHelper.getGradeModuleItems(courseId, moduleId, userId, null, siteId, ignoreCache).then(function (items) {
            return items.shift();
        });
    };
    /**
     * Given a list of attempts, returns the last finished attempt.
     *
     * @param {any[]} attempts Attempts.
     * @return {any} Last finished attempt.
     */
    AddonModQuizProvider.prototype.getLastFinishedAttemptFromList = function (attempts) {
        if (attempts && attempts.length) {
            for (var i = attempts.length - 1; i >= 0; i--) {
                var attempt = attempts[i];
                if (this.isAttemptFinished(attempt.state)) {
                    return attempt;
                }
            }
        }
    };
    /**
     * Given a list of questions, check if the quiz can be submitted.
     * Will return an array with the messages to prevent the submit. Empty array if quiz can be submitted.
     *
     * @param {any[]} questions Questions.
     * @return {string[]} List of prevent submit messages. Empty array if quiz can be submitted.
     */
    AddonModQuizProvider.prototype.getPreventSubmitMessages = function (questions) {
        var _this = this;
        var messages = [];
        questions.forEach(function (question) {
            var message = _this.questionDelegate.getPreventSubmitMessage(question);
            if (message) {
                message = _this.translate.instant(message);
                messages.push(_this.translate.instant('core.question.questionmessage', { $a: question.slot, $b: message }));
            }
        });
        return messages;
    };
    /**
     * Get cache key for quiz data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getQuizDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'quiz:' + courseId;
    };
    /**
     * Get a Quiz with key=value. If more than one is found, only the first will be returned.
     *
     * @param {number} courseId Course ID.
     * @param {string} key Name of the property to check.
     * @param {any} value Value to search.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the Quiz is retrieved.
     */
    AddonModQuizProvider.prototype.getQuizByField = function (courseId, key, value, forceCache, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getQuizDataCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_quizzes_by_courses', params, preSets).then(function (response) {
                if (response && response.quizzes) {
                    // Search the quiz.
                    for (var i in response.quizzes) {
                        var quiz = response.quizzes[i];
                        if (quiz[key] == value) {
                            return quiz;
                        }
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a quiz by module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId Course module ID.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the quiz is retrieved.
     */
    AddonModQuizProvider.prototype.getQuiz = function (courseId, cmId, forceCache, ignoreCache, siteId) {
        return this.getQuizByField(courseId, 'coursemodule', cmId, forceCache, ignoreCache, siteId);
    };
    /**
     * Get a quiz by quiz ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} id Quiz ID.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the quiz is retrieved.
     */
    AddonModQuizProvider.prototype.getQuizById = function (courseId, id, forceCache, ignoreCache, siteId) {
        return this.getQuizByField(courseId, 'id', id, forceCache, ignoreCache, siteId);
    };
    /**
     * Get cache key for get quiz access information WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getQuizAccessInformationCacheKey = function (quizId) {
        return this.ROOT_CACHE_KEY + 'quizAccessInformation:' + quizId;
    };
    /**
     * Get access information for an attempt.
     *
     * @param {number} quizId Quiz ID.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the access information.
     */
    AddonModQuizProvider.prototype.getQuizAccessInformation = function (quizId, offline, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                quizid: quizId
            }, preSets = {
                cacheKey: _this.getQuizAccessInformationCacheKey(quizId)
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_quiz_access_information', params, preSets);
        });
    };
    /**
     * Get a readable Quiz grade method.
     *
     * @param {number|string} method Grading method.
     * @return {string} Readable grading method.
     */
    AddonModQuizProvider.prototype.getQuizGradeMethod = function (method) {
        if (typeof method == 'string') {
            method = parseInt(method, 10);
        }
        switch (method) {
            case AddonModQuizProvider_1.GRADEHIGHEST:
                return this.translate.instant('addon.mod_quiz.gradehighest');
            case AddonModQuizProvider_1.GRADEAVERAGE:
                return this.translate.instant('addon.mod_quiz.gradeaverage');
            case AddonModQuizProvider_1.ATTEMPTFIRST:
                return this.translate.instant('addon.mod_quiz.attemptfirst');
            case AddonModQuizProvider_1.ATTEMPTLAST:
                return this.translate.instant('addon.mod_quiz.attemptlast');
            default:
                return '';
        }
    };
    /**
     * Get cache key for get quiz required qtypes WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getQuizRequiredQtypesCacheKey = function (quizId) {
        return this.ROOT_CACHE_KEY + 'quizRequiredQtypes:' + quizId;
    };
    /**
     * Get the potential question types that would be required for a given quiz.
     *
     * @param {number} quizId Quiz ID.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the access information.
     */
    AddonModQuizProvider.prototype.getQuizRequiredQtypes = function (quizId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                quizid: quizId
            }, preSets = {
                cacheKey: _this.getQuizRequiredQtypesCacheKey(quizId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_quiz_required_qtypes', params, preSets).then(function (response) {
                if (response && response.questiontypes) {
                    return response.questiontypes;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Given an attempt's layout, return the list of pages.
     *
     * @param {string} layout Attempt's layout.
     * @return {number[]} Pages.
     * @description
     * An attempt's layout is a string with the question numbers separated by commas. A 0 indicates a change of page.
     * Example: 1,2,3,0,4,5,6,0
     * In the example above, first page has questions 1, 2 and 3. Second page has questions 4, 5 and 6.
     *
     * This function returns a list of pages.
     */
    AddonModQuizProvider.prototype.getPagesFromLayout = function (layout) {
        var split = layout.split(','), pages = [];
        var page = 0;
        for (var i = 0; i < split.length; i++) {
            if (split[i] == '0') {
                pages.push(page);
                page++;
            }
        }
        return pages;
    };
    /**
     * Given an attempt's layout and a list of questions identified by question slot,
     * return the list of pages that have at least 1 of the questions.
     *
     * @param {string} layout Attempt's layout.
     * @param {any} questions List of questions. It needs to be an object where the keys are question slot.
     * @return {number[]} Pages.
     * @description
     * An attempt's layout is a string with the question numbers separated by commas. A 0 indicates a change of page.
     * Example: 1,2,3,0,4,5,6,0
     * In the example above, first page has questions 1, 2 and 3. Second page has questions 4, 5 and 6.
     *
     * This function returns a list of pages.
     */
    AddonModQuizProvider.prototype.getPagesFromLayoutAndQuestions = function (layout, questions) {
        var split = layout.split(','), pages = [];
        var page = 0, pageAdded = false;
        for (var i = 0; i < split.length; i++) {
            var value = Number(split[i]);
            if (value == 0) {
                page++;
                pageAdded = false;
            }
            else if (!pageAdded && questions[value]) {
                pages.push(page);
                pageAdded = true;
            }
        }
        return pages;
    };
    /**
     * Given a list of question types, returns the types that aren't supported.
     *
     * @param {string[]} questionTypes Question types to check.
     * @return {string[]} Not supported question types.
     */
    AddonModQuizProvider.prototype.getUnsupportedQuestions = function (questionTypes) {
        var _this = this;
        var notSupported = [];
        questionTypes.forEach(function (type) {
            if (type != 'random' && !_this.questionDelegate.isQuestionSupported(type)) {
                notSupported.push(type);
            }
        });
        return notSupported;
    };
    /**
     * Given a list of access rules names, returns the rules that aren't supported.
     *
     * @param {string[]} rulesNames Rules to check.
     * @return {string[]} Not supported rules names.
     */
    AddonModQuizProvider.prototype.getUnsupportedRules = function (rulesNames) {
        var _this = this;
        var notSupported = [];
        rulesNames.forEach(function (name) {
            if (!_this.accessRulesDelegate.isAccessRuleSupported(name)) {
                notSupported.push(name);
            }
        });
        return notSupported;
    };
    /**
     * Get cache key for get user attempts WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getUserAttemptsCacheKey = function (quizId, userId) {
        return this.getUserAttemptsCommonCacheKey(quizId) + ':' + userId;
    };
    /**
     * Get common cache key for get user attempts WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getUserAttemptsCommonCacheKey = function (quizId) {
        return this.ROOT_CACHE_KEY + 'userAttempts:' + quizId;
    };
    /**
     * Get quiz attempts for a certain user.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} [status=all]  Status of the attempts to get. By default, 'all'.
     * @param {boolean} [includePreviews=true] Whether to include previews. Defaults to true.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any[]>} Promise resolved with the attempts.
     */
    AddonModQuizProvider.prototype.getUserAttempts = function (quizId, status, includePreviews, offline, ignoreCache, siteId, userId) {
        var _this = this;
        if (status === void 0) { status = 'all'; }
        if (includePreviews === void 0) { includePreviews = true; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                quizid: quizId,
                userid: userId,
                status: status,
                includepreviews: includePreviews ? 1 : 0
            }, preSets = {
                cacheKey: _this.getUserAttemptsCacheKey(quizId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_user_attempts', params, preSets).then(function (response) {
                if (response && response.attempts) {
                    return response.attempts;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get user best grade WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getUserBestGradeCacheKey = function (quizId, userId) {
        return this.getUserBestGradeCommonCacheKey(quizId) + ':' + userId;
    };
    /**
     * Get common cache key for get user best grade WS calls.
     *
     * @param {number} quizId Quiz ID.
     * @return {string} Cache key.
     */
    AddonModQuizProvider.prototype.getUserBestGradeCommonCacheKey = function (quizId) {
        return this.ROOT_CACHE_KEY + 'userBestGrade:' + quizId;
    };
    /**
     * Get best grade in a quiz for a certain user.
     *
     * @param {number} quizId Quiz ID.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved with the best grade data.
     */
    AddonModQuizProvider.prototype.getUserBestGrade = function (quizId, ignoreCache, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                quizid: quizId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getUserBestGradeCacheKey(quizId, userId)
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_quiz_get_user_best_grade', params, preSets);
        });
    };
    /**
     * Invalidates all the data related to a certain quiz.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} [courseId] Course ID.
     * @param {number} [attemptId] Attempt ID to invalidate some WS calls.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateAllQuizData = function (quizId, courseId, attemptId, siteId, userId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.invalidateAttemptAccessInformation(quizId, siteId));
        promises.push(this.invalidateCombinedReviewOptionsForUser(quizId, siteId, userId));
        promises.push(this.invalidateFeedback(quizId, siteId));
        promises.push(this.invalidateQuizAccessInformation(quizId, siteId));
        promises.push(this.invalidateQuizRequiredQtypes(quizId, siteId));
        promises.push(this.invalidateUserAttemptsForUser(quizId, siteId, userId));
        promises.push(this.invalidateUserBestGradeForUser(quizId, siteId, userId));
        if (attemptId) {
            promises.push(this.invalidateAttemptData(attemptId, siteId));
            promises.push(this.invalidateAttemptReview(attemptId, siteId));
            promises.push(this.invalidateAttemptSummary(attemptId, siteId));
        }
        if (courseId) {
            promises.push(this.invalidateGradeFromGradebook(courseId, siteId, userId));
        }
        return Promise.all(promises);
    };
    /**
     * Invalidates attempt access information for all attempts in a quiz.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateAttemptAccessInformation = function (quizId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getAttemptAccessInformationCommonCacheKey(quizId));
        });
    };
    /**
     * Invalidates attempt access information for an attempt.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateAttemptAccessInformationForAttempt = function (quizId, attemptId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAttemptAccessInformationCacheKey(quizId, attemptId));
        });
    };
    /**
     * Invalidates attempt data for all pages.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateAttemptData = function (attemptId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getAttemptDataCommonCacheKey(attemptId));
        });
    };
    /**
     * Invalidates attempt data for a certain page.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} page Page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateAttemptDataForPage = function (attemptId, page, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAttemptDataCacheKey(attemptId, page));
        });
    };
    /**
     * Invalidates attempt review for all pages.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateAttemptReview = function (attemptId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getAttemptReviewCommonCacheKey(attemptId));
        });
    };
    /**
     * Invalidates attempt review for a certain page.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} page Page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateAttemptReviewForPage = function (attemptId, page, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAttemptReviewCacheKey(attemptId, page));
        });
    };
    /**
     * Invalidates attempt summary.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateAttemptSummary = function (attemptId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAttemptSummaryCacheKey(attemptId));
        });
    };
    /**
     * Invalidates combined review options for all users.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateCombinedReviewOptions = function (quizId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getCombinedReviewOptionsCommonCacheKey(quizId));
        });
    };
    /**
     * Invalidates combined review options for a certain user.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateCombinedReviewOptionsForUser = function (quizId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCombinedReviewOptionsCacheKey(quizId, userId));
        });
    };
    /**
     * Invalidate the prefetched content except files.
     * To invalidate files, use AddonModQuizProvider.invalidateFiles.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get required data to call the invalidate functions.
        return this.getQuiz(courseId, moduleId, true, false, siteId).then(function (quiz) {
            return _this.getUserAttempts(quiz.id, 'all', true, false, false, siteId).then(function (attempts) {
                // Now invalidate it.
                var lastAttemptId = attempts.length ? attempts[attempts.length - 1].id : undefined;
                return _this.invalidateAllQuizData(quiz.id, courseId, lastAttemptId, siteId);
            });
        });
    };
    /**
     * Invalidates feedback for all grades of a quiz.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateFeedback = function (quizId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getFeedbackForGradeCommonCacheKey(quizId));
        });
    };
    /**
     * Invalidates feedback for a certain grade.
     *
     * @param {number} quizId Quiz ID.
     * @param {number} grade Grade.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateFeedbackForGrade = function (quizId, grade, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getFeedbackForGradeCacheKey(quizId, grade));
        });
    };
    /**
     * Invalidate the prefetched files.
     *
     * @param {number} moduleId The module ID.
     * @return {Promise<any>} Promise resolved when the files are invalidated.
     */
    AddonModQuizProvider.prototype.invalidateFiles = function (moduleId) {
        return this.filepoolProvider.invalidateFilesByComponent(this.sitesProvider.getCurrentSiteId(), AddonModQuizProvider_1.COMPONENT, moduleId);
    };
    /**
     * Invalidates grade from gradebook for a certain user.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateGradeFromGradebook = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return _this.gradesHelper.invalidateGradeModuleItems(courseId, userId, null, siteId);
        });
    };
    /**
     * Invalidates quiz access information for a quiz.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateQuizAccessInformation = function (quizId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getQuizAccessInformationCacheKey(quizId));
        });
    };
    /**
     * Invalidates required qtypes for a quiz.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateQuizRequiredQtypes = function (quizId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getQuizRequiredQtypesCacheKey(quizId));
        });
    };
    /**
     * Invalidates user attempts for all users.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateUserAttempts = function (quizId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserAttemptsCommonCacheKey(quizId));
        });
    };
    /**
     * Invalidates user attempts for a certain user.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateUserAttemptsForUser = function (quizId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getUserAttemptsCacheKey(quizId, userId));
        });
    };
    /**
     * Invalidates user best grade for all users.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateUserBestGrade = function (quizId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserBestGradeCommonCacheKey(quizId));
        });
    };
    /**
     * Invalidates user best grade for a certain user.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateUserBestGradeForUser = function (quizId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getUserBestGradeCacheKey(quizId, userId));
        });
    };
    /**
     * Invalidates quiz data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizProvider.prototype.invalidateQuizData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getQuizDataCacheKey(courseId));
        });
    };
    /**
     * Check if an attempt is finished based on its state.
     *
     * @param {string} state Attempt's state.
     * @return {boolean} Whether it's finished.
     */
    AddonModQuizProvider.prototype.isAttemptFinished = function (state) {
        return state == AddonModQuizProvider_1.ATTEMPT_FINISHED || state == AddonModQuizProvider_1.ATTEMPT_ABANDONED;
    };
    /**
     * Check if an attempt is finished in offline but not synced.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: true if finished in offline but not synced, false otherwise.
     */
    AddonModQuizProvider.prototype.isAttemptFinishedOffline = function (attemptId, siteId) {
        return this.quizOfflineProvider.getAttemptById(attemptId, siteId).then(function (attempt) {
            return !!attempt.finished;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Check if an attempt is nearly over. We consider an attempt nearly over or over if:
     * - Is not in progress
     * OR
     * - It finished before autosaveperiod passes.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @return {boolean} Whether it's nearly over or over.
     */
    AddonModQuizProvider.prototype.isAttemptTimeNearlyOver = function (quiz, attempt) {
        if (attempt.state != AddonModQuizProvider_1.ATTEMPT_IN_PROGRESS) {
            // Attempt not in progress, return true.
            return true;
        }
        var dueDate = this.getAttemptDueDate(quiz, attempt), autoSavePeriod = quiz.autosaveperiod || 0;
        if (dueDate > 0 && Date.now() + autoSavePeriod >= dueDate) {
            return true;
        }
        return false;
    };
    /**
     * Check if last attempt is offline and unfinished.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, user current site's user.
     * @return {Promise<boolean>} Promise resolved with boolean: true if last offline attempt is unfinished, false otherwise.
     */
    AddonModQuizProvider.prototype.isLastAttemptOfflineUnfinished = function (quiz, siteId, userId) {
        return this.quizOfflineProvider.getQuizAttempts(quiz.id, siteId, userId).then(function (attempts) {
            var last = attempts.pop();
            return last && !last.finished;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Check if a quiz navigation is sequential.
     *
     * @param {any} quiz Quiz.
     * @return {boolean} Whether navigation is sequential.
     */
    AddonModQuizProvider.prototype.isNavigationSequential = function (quiz) {
        return quiz.navmethod == 'sequential';
    };
    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the quiz WS are available.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {boolean} Whether the plugin is enabled.
     */
    AddonModQuizProvider.prototype.isPluginEnabled = function (siteId) {
        // Quiz WebServices were introduced in 3.1, it will always be enabled.
        return true;
    };
    /**
     * Check if a question is blocked.
     *
     * @param {any} question Question.
     * @return {boolean} Whether it's blocked.
     */
    AddonModQuizProvider.prototype.isQuestionBlocked = function (question) {
        var element = this.domUtils.convertToElement(question.html);
        return !!element.querySelector('.mod_quiz-blocked_question_warning');
    };
    /**
     * Check if a quiz is enabled to be used in offline.
     *
     * @param {any} quiz Quiz.
     * @return {boolean} Whether offline is enabled.
     */
    AddonModQuizProvider.prototype.isQuizOffline = function (quiz) {
        // Don't allow downloading the quiz if offline is disabled to prevent wasting a lot of data when opening it.
        return !!quiz.allowofflineattempts && !this.sitesProvider.getCurrentSite().isOfflineDisabled();
    };
    /**
     * Given a list of attempts, add finishedOffline=true to those attempts that are finished in offline but not synced.
     *
     * @param {any[]} attempts List of attempts.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when done.
     */
    AddonModQuizProvider.prototype.loadFinishedOfflineData = function (attempts, siteId) {
        if (attempts.length) {
            // We only need to check the last attempt because the user can only have 1 local attempt.
            var lastAttempt_1 = attempts[attempts.length - 1];
            return this.isAttemptFinishedOffline(lastAttempt_1.id, siteId).then(function (finished) {
                lastAttempt_1.finishedOffline = finished;
            });
        }
        return Promise.resolve();
    };
    /**
     * Report an attempt as being viewed. It did not store logs offline because order of the log is important.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} [page=0] Page number.
     * @param {any} [preflightData] Preflight required data (like password).
     * @param {boolean} [offline] Whether attempt is offline.
     * @param {string} [quiz] Quiz instance. If set, a Firebase event will be stored.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModQuizProvider.prototype.logViewAttempt = function (attemptId, page, preflightData, offline, quiz, siteId) {
        var _this = this;
        if (page === void 0) { page = 0; }
        if (preflightData === void 0) { preflightData = {}; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                attemptid: attemptId,
                page: page,
                preflightdata: _this.utils.objectToArrayOfObjects(preflightData, 'name', 'value', true)
            }, promises = [];
            promises.push(site.write('mod_quiz_view_attempt', params));
            if (offline) {
                promises.push(_this.quizOfflineProvider.setAttemptCurrentPage(attemptId, page, site.getId()));
            }
            if (quiz) {
                _this.pushNotificationsProvider.logViewEvent(quiz.id, quiz.name, 'quiz', 'mod_quiz_view_attempt', { attemptid: attemptId, page: page }, siteId);
            }
            return Promise.all(promises);
        });
    };
    /**
     * Report an attempt's review as being viewed.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} quizId Quiz ID.
     * @param {string} [name] Name of the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModQuizProvider.prototype.logViewAttemptReview = function (attemptId, quizId, name, siteId) {
        var params = {
            attemptid: attemptId
        };
        return this.logHelper.logSingle('mod_quiz_view_attempt_review', params, AddonModQuizProvider_1.COMPONENT, quizId, name, 'quiz', params, siteId);
    };
    /**
     * Report an attempt's summary as being viewed.
     *
     * @param {number} attemptId Attempt ID.
     * @param {any} preflightData Preflight required data (like password).
     * @param {number} quizId Quiz ID.
     * @param {string} [name] Name of the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModQuizProvider.prototype.logViewAttemptSummary = function (attemptId, preflightData, quizId, name, siteId) {
        var params = {
            attemptid: attemptId,
            preflightdata: this.utils.objectToArrayOfObjects(preflightData, 'name', 'value', true)
        };
        return this.logHelper.logSingle('mod_quiz_view_attempt_summary', params, AddonModQuizProvider_1.COMPONENT, quizId, name, 'quiz', { attemptid: attemptId }, siteId);
    };
    /**
     * Report a quiz as being viewed.
     *
     * @param {number} id Module ID.
     * @param {string} [name] Name of the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModQuizProvider.prototype.logViewQuiz = function (id, name, siteId) {
        var params = {
            quizid: id
        };
        return this.logHelper.logSingle('mod_quiz_view_quiz', params, AddonModQuizProvider_1.COMPONENT, id, name, 'quiz', {}, siteId);
    };
    /**
     * Process an attempt, saving its data.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @param {any} data Data to save.
     * @param {any} preflightData Preflight required data (like password).
     * @param {boolean} [finish] Whether to finish the quiz.
     * @param {boolean} [timeUp] Whether the quiz time is up, false otherwise.
     * @param {boolean} [offline] Whether the attempt is offline.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModQuizProvider.prototype.processAttempt = function (quiz, attempt, data, preflightData, finish, timeUp, offline, siteId) {
        if (offline) {
            return this.processAttemptOffline(quiz, attempt, data, preflightData, finish, siteId);
        }
        return this.processAttemptOnline(attempt.id, data, preflightData, finish, timeUp, siteId);
    };
    /**
     * Process an online attempt, saving its data.
     *
     * @param {number} attemptId Attempt ID.
     * @param {any} data Data to save.
     * @param {any} preflightData Preflight required data (like password).
     * @param {boolean} [finish] Whether to finish the quiz.
     * @param {boolean} [timeUp] Whether the quiz time is up, false otherwise.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModQuizProvider.prototype.processAttemptOnline = function (attemptId, data, preflightData, finish, timeUp, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                attemptid: attemptId,
                data: _this.utils.objectToArrayOfObjects(data, 'name', 'value'),
                finishattempt: finish ? 1 : 0,
                timeup: timeUp ? 1 : 0,
                preflightdata: _this.utils.objectToArrayOfObjects(preflightData, 'name', 'value')
            };
            return site.write('mod_quiz_process_attempt', params).then(function (response) {
                if (response && response.warnings && response.warnings.length) {
                    // Reject with the first warning.
                    return Promise.reject(response.warnings[0]);
                }
                else if (response && response.state) {
                    return response.state;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Process an offline attempt, saving its data.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @param {any} data Data to save.
     * @param {any} preflightData Preflight required data (like password).
     * @param {boolean} [finish] Whether to finish the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModQuizProvider.prototype.processAttemptOffline = function (quiz, attempt, data, preflightData, finish, siteId) {
        var _this = this;
        // Get attempt summary to have the list of questions.
        return this.getAttemptSummary(attempt.id, preflightData, true, false, true, siteId).then(function (questionArray) {
            // Convert the question array to an object.
            var questions = _this.utils.arrayToObject(questionArray, 'slot');
            return _this.quizOfflineProvider.processAttempt(quiz, attempt, questions, data, finish, siteId);
        });
    };
    /**
     * Check if it's a graded quiz. Based on Moodle's quiz_has_grades.
     *
     * @param {any} quiz Quiz.
     * @return {boolean} Whether quiz is graded.
     */
    AddonModQuizProvider.prototype.quizHasGrades = function (quiz) {
        return quiz.grade >= 0.000005 && quiz.sumgrades >= 0.000005;
    };
    /**
     * Convert the raw grade into a grade out of the maximum grade for this quiz.
     * Based on Moodle's quiz_rescale_grade.
     *
     * @param {string} rawGrade The unadjusted grade, for example attempt.sumgrades.
     * @param {any} quiz Quiz.
     * @param {boolean|string} format True to format the results for display, 'question' to format a question grade
     *                                 (different number of decimal places), false to not format it.
     * @return {string} Grade to display.
     */
    AddonModQuizProvider.prototype.rescaleGrade = function (rawGrade, quiz, format) {
        if (format === void 0) { format = true; }
        var grade;
        var rawGradeNum = parseFloat(rawGrade);
        if (!isNaN(rawGradeNum)) {
            if (quiz.sumgrades >= 0.000005) {
                grade = rawGradeNum * quiz.grade / quiz.sumgrades;
            }
            else {
                grade = 0;
            }
        }
        if (format === 'question') {
            return this.formatGrade(grade, this.getGradeDecimals(quiz));
        }
        else if (format) {
            return this.formatGrade(grade, quiz.decimalpoints);
        }
        if (grade === null) {
            return null;
        }
        else if (typeof grade == 'undefined') {
            return undefined;
        }
        return String(grade);
    };
    /**
     * Save an attempt data.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @param {any} data Data to save.
     * @param {any} preflightData Preflight required data (like password).
     * @param {boolean} [offline] Whether attempt is offline.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModQuizProvider.prototype.saveAttempt = function (quiz, attempt, data, preflightData, offline, siteId) {
        try {
            if (offline) {
                return this.processAttemptOffline(quiz, attempt, data, preflightData, false, siteId);
            }
            return this.saveAttemptOnline(attempt.id, data, preflightData, siteId);
        }
        catch (ex) {
            this.logger.error(ex);
            return Promise.reject(null);
        }
    };
    /**
     * Save an attempt data.
     *
     * @param {number} attemptId Attempt ID.
     * @param {any} data Data to save.
     * @param {any} preflightData Preflight required data (like password).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved in success, rejected otherwise.
     */
    AddonModQuizProvider.prototype.saveAttemptOnline = function (attemptId, data, preflightData, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                attemptid: attemptId,
                data: _this.utils.objectToArrayOfObjects(data, 'name', 'value'),
                preflightdata: _this.utils.objectToArrayOfObjects(preflightData, 'name', 'value')
            };
            return site.write('mod_quiz_save_attempt', params).then(function (response) {
                if (response && response.warnings && response.warnings.length) {
                    // Reject with the first warning.
                    return Promise.reject(response.warnings[0]);
                }
                else if (!response || !response.status) {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Check if time left should be shown.
     *
     * @param {string[]} rules List of active rules names.
     * @param {any} attempt Attempt.
     * @param {number} endTime The attempt end time (in seconds).
     * @return {boolean} Whether time left should be displayed.
     */
    AddonModQuizProvider.prototype.shouldShowTimeLeft = function (rules, attempt, endTime) {
        var timeNow = this.timeUtils.timestamp();
        if (attempt.state != AddonModQuizProvider_1.ATTEMPT_IN_PROGRESS) {
            return false;
        }
        return this.accessRulesDelegate.shouldShowTimeLeft(rules, attempt, endTime, timeNow);
    };
    /**
     * Start an attempt.
     *
     * @param {number} quizId Quiz ID.
     * @param {any} preflightData Preflight required data (like password).
     * @param {boolean} [forceNew] Whether to force a new attempt or not.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the attempt data.
     */
    AddonModQuizProvider.prototype.startAttempt = function (quizId, preflightData, forceNew, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                quizid: quizId,
                preflightdata: _this.utils.objectToArrayOfObjects(preflightData, 'name', 'value', true),
                forcenew: forceNew ? 1 : 0
            };
            return site.write('mod_quiz_start_attempt', params).then(function (response) {
                if (response && response.warnings && response.warnings.length) {
                    // Reject with the first warning.
                    return Promise.reject(response.warnings[0]);
                }
                else if (response && response.attempt) {
                    return response.attempt;
                }
                return Promise.reject(null);
            });
        });
    };
    AddonModQuizProvider.COMPONENT = 'mmaModQuiz';
    AddonModQuizProvider.ATTEMPT_FINISHED_EVENT = 'addon_mod_quiz_attempt_finished';
    // Grade methods.
    AddonModQuizProvider.GRADEHIGHEST = 1;
    AddonModQuizProvider.GRADEAVERAGE = 2;
    AddonModQuizProvider.ATTEMPTFIRST = 3;
    AddonModQuizProvider.ATTEMPTLAST = 4;
    // Question options.
    AddonModQuizProvider.QUESTION_OPTIONS_MAX_ONLY = 1;
    AddonModQuizProvider.QUESTION_OPTIONS_MARK_AND_MAX = 2;
    // Attempt state.
    AddonModQuizProvider.ATTEMPT_IN_PROGRESS = 'inprogress';
    AddonModQuizProvider.ATTEMPT_OVERDUE = 'overdue';
    AddonModQuizProvider.ATTEMPT_FINISHED = 'finished';
    AddonModQuizProvider.ATTEMPT_ABANDONED = 'abandoned';
    // Show the countdown timer if there is less than this amount of time left before the the quiz close date.
    AddonModQuizProvider.QUIZ_SHOW_TIME_BEFORE_DEADLINE = 3600;
    AddonModQuizProvider = AddonModQuizProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__core_grades_providers_helper__["a" /* CoreGradesHelperProvider */], __WEBPACK_IMPORTED_MODULE_11__core_question_providers_delegate__["a" /* CoreQuestionDelegate */],
            __WEBPACK_IMPORTED_MODULE_2__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_13__access_rules_delegate__["a" /* AddonModQuizAccessRuleDelegate */], __WEBPACK_IMPORTED_MODULE_14__quiz_offline__["a" /* AddonModQuizOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_15__core_pushnotifications_providers_pushnotifications__["a" /* CorePushNotificationsProvider */]])
    ], AddonModQuizProvider);
    return AddonModQuizProvider;
    var AddonModQuizProvider_1;
}());

//# sourceMappingURL=quiz.js.map

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCommentsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding comments.
 */
var CoreCommentsProvider = /** @class */ (function () {
    function CoreCommentsProvider(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.ROOT_CACHE_KEY = 'mmComments:';
    }
    /**
     * Check if Calendar is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCommentsProvider.prototype.areCommentsDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('NoDelegate_CoreComments');
    };
    /**
     * Check if comments are disabled in a certain site.
     *
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreCommentsProvider.prototype.areCommentsDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.areCommentsDisabledInSite(site);
        });
    };
    /**
     * Get cache key for get comments data WS calls.
     *
     * @param  {string} contextLevel Contextlevel system, course, user...
     * @param  {number} instanceId   The Instance id of item associated with the context level.
     * @param  {string} component    Component name.
     * @param  {number} itemId       Associated id.
     * @param  {string} [area='']    String comment area. Default empty.
     * @param  {number} [page=0]     Page number (0 based). Default 0.
     * @return {string} Cache key.
     */
    CoreCommentsProvider.prototype.getCommentsCacheKey = function (contextLevel, instanceId, component, itemId, area, page) {
        if (area === void 0) { area = ''; }
        if (page === void 0) { page = 0; }
        return this.getCommentsPrefixCacheKey(contextLevel, instanceId) + ':' + component + ':' + itemId + ':' + area + ':' + page;
    };
    /**
     * Get cache key for get comments instance data WS calls.
     *
     * @param  {string} contextLevel Contextlevel system, course, user...
     * @param  {number} instanceId   The Instance id of item associated with the context level.
     * @return {string} Cache key.
     */
    CoreCommentsProvider.prototype.getCommentsPrefixCacheKey = function (contextLevel, instanceId) {
        return this.ROOT_CACHE_KEY + 'comments:' + contextLevel + ':' + instanceId;
    };
    /**
     * Retrieve a list of comments.
     *
     * @param  {string} contextLevel Contextlevel system, course, user...
     * @param  {number} instanceId   The Instance id of item associated with the context level.
     * @param  {string} component    Component name.
     * @param  {number} itemId       Associated id.
     * @param  {string} [area='']    String comment area. Default empty.
     * @param  {number} [page=0]     Page number (0 based). Default 0.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the comments.
     */
    CoreCommentsProvider.prototype.getComments = function (contextLevel, instanceId, component, itemId, area, page, siteId) {
        var _this = this;
        if (area === void 0) { area = ''; }
        if (page === void 0) { page = 0; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                contextlevel: contextLevel,
                instanceid: instanceId,
                component: component,
                itemid: itemId,
                area: area,
                page: page,
            };
            var preSets = {
                cacheKey: _this.getCommentsCacheKey(contextLevel, instanceId, component, itemId, area, page),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('core_comment_get_comments', params, preSets).then(function (response) {
                if (response.comments) {
                    return response.comments;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidates comments data.
     *
     * @param  {string} contextLevel Contextlevel system, course, user...
     * @param  {number} instanceId   The Instance id of item associated with the context level.
     * @param  {string} component    Component name.
     * @param  {number} itemId       Associated id.
     * @param  {string} [area='']    String comment area. Default empty.
     * @param  {number} [page=0]     Page number (0 based). Default 0.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCommentsProvider.prototype.invalidateCommentsData = function (contextLevel, instanceId, component, itemId, area, page, siteId) {
        var _this = this;
        if (area === void 0) { area = ''; }
        if (page === void 0) { page = 0; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCommentsCacheKey(contextLevel, instanceId, component, itemId, area, page));
        });
    };
    /**
     * Invalidates all comments data for an instance.
     *
     * @param  {string} contextLevel Contextlevel system, course, user...
     * @param  {number} instanceId   The Instance id of item associated with the context level.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCommentsProvider.prototype.invalidateCommentsByInstance = function (contextLevel, instanceId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getCommentsPrefixCacheKey(contextLevel, instanceId));
        });
    };
    CoreCommentsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreCommentsProvider);
    return CoreCommentsProvider;
}());

//# sourceMappingURL=comments.js.map

/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModForumProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_groups__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__offline__ = __webpack_require__(216);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service that provides some features for forums.
 */
var AddonModForumProvider = /** @class */ (function () {
    function AddonModForumProvider(appProvider, sitesProvider, groupsProvider, filepoolProvider, userProvider, translate, utils, forumOffline, logHelper) {
        this.appProvider = appProvider;
        this.sitesProvider = sitesProvider;
        this.groupsProvider = groupsProvider;
        this.filepoolProvider = filepoolProvider;
        this.userProvider = userProvider;
        this.translate = translate;
        this.utils = utils;
        this.forumOffline = forumOffline;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModForum:';
    }
    AddonModForumProvider_1 = AddonModForumProvider;
    /**
     * Get cache key for can add discussion WS calls.
     *
     * @param  {number} forumId Forum ID.
     * @param  {number} groupId Group ID.
     * @return {string}         Cache key.
     */
    AddonModForumProvider.prototype.getCanAddDiscussionCacheKey = function (forumId, groupId) {
        return this.getCommonCanAddDiscussionCacheKey(forumId) + groupId;
    };
    /**
     * Get common part of cache key for can add discussion WS calls.
     *
     * @param  {number} forumId Forum ID.
     * @return {string}         Cache key.
     */
    AddonModForumProvider.prototype.getCommonCanAddDiscussionCacheKey = function (forumId) {
        return this.ROOT_CACHE_KEY + 'canadddiscussion:' + forumId + ':';
    };
    /**
     * Get cache key for forum data WS calls.
     *
     * @param  {number} courseId Course ID.
     * @return {string}          Cache key.
     */
    AddonModForumProvider.prototype.getForumDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'forum:' + courseId;
    };
    /**
     * Get cache key for forum access information WS calls.
     *
     * @param  {number} forumId Forum ID.
     * @return {string}         Cache key.
     */
    AddonModForumProvider.prototype.getAccessInformationCacheKey = function (forumId) {
        return this.ROOT_CACHE_KEY + 'accessInformation:' + forumId;
    };
    /**
     * Get cache key for forum discussion posts WS calls.
     *
     * @param  {number} discussionId Discussion ID.
     * @return {string}              Cache key.
     */
    AddonModForumProvider.prototype.getDiscussionPostsCacheKey = function (discussionId) {
        return this.ROOT_CACHE_KEY + 'discussion:' + discussionId;
    };
    /**
     * Get cache key for forum discussions list WS calls.
     *
     * @param  {number} forumId Forum ID.
     * @param  {number} sortOrder Sort order.
     * @return {string} Cache key.
     */
    AddonModForumProvider.prototype.getDiscussionsListCacheKey = function (forumId, sortOrder) {
        var key = this.ROOT_CACHE_KEY + 'discussions:' + forumId;
        if (sortOrder != AddonModForumProvider_1.SORTORDER_LASTPOST_DESC) {
            key += ':' + sortOrder;
        }
        return key;
    };
    /**
     * Add a new discussion. It will fail if offline or cannot connect.
     *
     * @param  {number} forumId   Forum ID.
     * @param  {string} subject   New discussion's subject.
     * @param  {string} message   New discussion's message.
     * @param  {any}    [options] Options (subscribe, pin, ...).
     * @param  {string} [groupId] Group this discussion belongs to.
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>}     Promise resolved when the discussion is created.
     */
    AddonModForumProvider.prototype.addNewDiscussionOnline = function (forumId, subject, message, options, groupId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                forumid: forumId,
                subject: subject,
                message: message,
                options: _this.utils.objectToArrayOfObjects(options, 'name', 'value')
            };
            if (groupId) {
                params.groupid = groupId;
            }
            return site.write('mod_forum_add_discussion', params).then(function (response) {
                // Other errors ocurring.
                if (!response || !response.discussionid) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                else {
                    return response.discussionid;
                }
            });
        });
    };
    /**
     * Check if a user can post to a certain group.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {number} groupId  Group ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved with an object with the following properties:
     *                            - status (boolean)
     *                            - canpindiscussions (boolean)
     *                            - cancreateattachment (boolean)
     */
    AddonModForumProvider.prototype.canAddDiscussion = function (forumId, groupId, siteId) {
        var params = {
            forumid: forumId,
            groupid: groupId
        };
        var preSets = {
            cacheKey: this.getCanAddDiscussionCacheKey(forumId, groupId)
        };
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.read('mod_forum_can_add_discussion', params, preSets).then(function (result) {
                if (result) {
                    if (typeof result.canpindiscussions == 'undefined') {
                        // WS doesn't support it yet, default it to false to prevent students from seing the option.
                        result.canpindiscussions = false;
                    }
                    if (typeof result.cancreateattachment == 'undefined') {
                        // WS doesn't support it yet, default it to true since usually the users will be able to create them.
                        result.cancreateattachment = true;
                    }
                    return result;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Check if a user can post to all groups.
     *
     * @param  {number} forumId Forum ID.
     * @return {Promise<any>}   Promise resolved with an object with the following properties:
     *                           - status (boolean)
     *                           - canpindiscussions (boolean)
     *                           - cancreateattachment (boolean)
     */
    AddonModForumProvider.prototype.canAddDiscussionToAll = function (forumId) {
        return this.canAddDiscussion(forumId, AddonModForumProvider_1.ALL_PARTICIPANTS);
    };
    /**
     * Extract the starting post of a discussion from a list of posts. The post is removed from the array passed as a parameter.
     *
     * @param  {any[]} posts Posts to search.
     * @return {any}         Starting post or undefined if not found.
     */
    AddonModForumProvider.prototype.extractStartingPost = function (posts) {
        // Check the last post first, since they'll usually be ordered by create time.
        for (var i = posts.length - 1; i >= 0; i--) {
            if (posts[i].parent == 0) {
                return posts.splice(i, 1).pop(); // Remove it from the array.
            }
        }
        return undefined;
    };
    /**
     * There was a bug adding new discussions to All Participants (see MDL-57962). Check if it's fixed.
     *
     * @return {boolean} True if fixed, false otherwise.
     */
    AddonModForumProvider.prototype.isAllParticipantsFixed = function () {
        return this.sitesProvider.getCurrentSite().isVersionGreaterEqualThan(['3.1.5', '3.2.2']);
    };
    /**
     * Format discussions, setting groupname if the discussion group is valid.
     *
     * @param  {number} cmId        Forum cmid.
     * @param  {any[]}  discussions List of discussions to format.
     * @return {Promise<any[]>}     Promise resolved with the formatted discussions.
     */
    AddonModForumProvider.prototype.formatDiscussionsGroups = function (cmId, discussions) {
        var _this = this;
        discussions = this.utils.clone(discussions);
        return this.groupsProvider.getActivityAllowedGroups(cmId).then(function (forumGroups) {
            var strAllParts = _this.translate.instant('core.allparticipants');
            var strAllGroups = _this.translate.instant('core.allgroups');
            // Turn groups into an object where each group is identified by id.
            var groups = {};
            forumGroups.forEach(function (fg) {
                groups[fg.id] = fg;
            });
            // Format discussions.
            discussions.forEach(function (disc) {
                if (disc.groupid == AddonModForumProvider_1.ALL_PARTICIPANTS) {
                    disc.groupname = strAllParts;
                }
                else if (disc.groupid == AddonModForumProvider_1.ALL_GROUPS) {
                    // Offline discussions only.
                    disc.groupname = strAllGroups;
                }
                else {
                    var group = groups[disc.groupid];
                    if (group) {
                        disc.groupname = group.name;
                    }
                }
            });
            return discussions;
        }).catch(function () {
            return discussions;
        });
    };
    /**
     * Get all course forums.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Promise resolved when the forums are retrieved.
     */
    AddonModForumProvider.prototype.getCourseForums = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            };
            var preSets = {
                cacheKey: _this.getForumDataCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_forum_get_forums_by_courses', params, preSets);
        });
    };
    /**
     * Get a forum by course module ID.
     *
     * @param  {number} courseId Course ID.
     * @param  {number} cmId     Course module ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the forum is retrieved.
     */
    AddonModForumProvider.prototype.getForum = function (courseId, cmId, siteId) {
        return this.getCourseForums(courseId, siteId).then(function (forums) {
            var forum = forums.find(function (forum) { return forum.cmid == cmId; });
            if (forum) {
                return forum;
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get a forum by forum ID.
     *
     * @param  {number} courseId Course ID.
     * @param  {number} forumId  Forum ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the forum is retrieved.
     */
    AddonModForumProvider.prototype.getForumById = function (courseId, forumId, siteId) {
        return this.getCourseForums(courseId, siteId).then(function (forums) {
            var forum = forums.find(function (forum) { return forum.id == forumId; });
            if (forum) {
                return forum;
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get access information for a given forum.
     *
     * @param  {number}  forumId      Forum ID.
     * @param  {boolean} [forceCache] True to always get the value from cache. false otherwise.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>} Object with access information.
     * @since 3.7
     */
    AddonModForumProvider.prototype.getAccessInformation = function (forumId, forceCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.wsAvailable('mod_forum_get_forum_access_information')) {
                // Access information not available for 3.6 or older sites.
                return Promise.resolve({});
            }
            var params = {
                forumid: forumId
            };
            var preSets = {
                cacheKey: _this.getAccessInformationCacheKey(forumId),
                omitExpires: forceCache
            };
            return site.read('mod_forum_get_forum_access_information', params, preSets);
        });
    };
    /**
     * Get forum discussion posts.
     *
     * @param  {number} discussionId Discussion ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<{posts: any[], ratinginfo?: CoreRatingInfo}>} Promise resolved with forum posts and rating info.
     */
    AddonModForumProvider.prototype.getDiscussionPosts = function (discussionId, siteId) {
        var _this = this;
        var params = {
            discussionid: discussionId
        };
        var preSets = {
            cacheKey: this.getDiscussionPostsCacheKey(discussionId)
        };
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.read('mod_forum_get_forum_discussion_posts', params, preSets).then(function (response) {
                if (response) {
                    _this.storeUserData(response.posts);
                    return response;
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Sort forum discussion posts by an specified field.
     *
     * @param {any[]}  posts     Discussion posts to be sorted in place.
     * @param {string} direction Direction of the sorting (ASC / DESC).
     */
    AddonModForumProvider.prototype.sortDiscussionPosts = function (posts, direction) {
        // @todo: Check children when sorting.
        posts.sort(function (a, b) {
            a = parseInt(a.created, 10);
            b = parseInt(b.created, 10);
            if (direction == 'ASC') {
                return a - b;
            }
            else {
                return b - a;
            }
        });
    };
    /**
     * Return whether discussion lists can be sorted.
     *
     * @param {CoreSite} [site] Site. If not defined, current site.
     * @return {boolean} True if discussion lists can be sorted.
     */
    AddonModForumProvider.prototype.isDiscussionListSortingAvailable = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isVersionGreaterEqualThan('3.7');
    };
    /**
     * Return the list of available sort orders.
     *
     * @return {{label: string, value: number}[]} List of sort orders.
     */
    AddonModForumProvider.prototype.getAvailableSortOrders = function () {
        var sortOrders = [
            {
                label: 'addon.mod_forum.discussionlistsortbylastpostdesc',
                value: AddonModForumProvider_1.SORTORDER_LASTPOST_DESC
            },
        ];
        if (this.isDiscussionListSortingAvailable()) {
            sortOrders.push({
                label: 'addon.mod_forum.discussionlistsortbylastpostasc',
                value: AddonModForumProvider_1.SORTORDER_LASTPOST_ASC
            }, {
                label: 'addon.mod_forum.discussionlistsortbycreateddesc',
                value: AddonModForumProvider_1.SORTORDER_CREATED_DESC
            }, {
                label: 'addon.mod_forum.discussionlistsortbycreatedasc',
                value: AddonModForumProvider_1.SORTORDER_CREATED_ASC
            }, {
                label: 'addon.mod_forum.discussionlistsortbyrepliesdesc',
                value: AddonModForumProvider_1.SORTORDER_REPLIES_DESC
            }, {
                label: 'addon.mod_forum.discussionlistsortbyrepliesasc',
                value: AddonModForumProvider_1.SORTORDER_REPLIES_ASC
            });
        }
        return sortOrders;
    };
    /**
     * Get forum discussions.
     *
     * @param  {number}  forumId      Forum ID.
     * @param  {number}  [sortOrder]  Sort order.
     * @param  {number}  [page=0]     Page.
     * @param  {boolean} [forceCache] True to always get the value from cache. false otherwise.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved with an object with:
     *                                 - discussions: List of discussions.
     *                                 - canLoadMore: True if there may be more discussions to load.
     */
    AddonModForumProvider.prototype.getDiscussions = function (forumId, sortOrder, page, forceCache, siteId) {
        var _this = this;
        if (page === void 0) { page = 0; }
        sortOrder = sortOrder || AddonModForumProvider_1.SORTORDER_LASTPOST_DESC;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var method = 'mod_forum_get_forum_discussions_paginated';
            var params = {
                forumid: forumId,
                page: page,
                perpage: AddonModForumProvider_1.DISCUSSIONS_PER_PAGE
            };
            if (site.wsAvailable('mod_forum_get_forum_discussions')) {
                // Since Moodle 3.7.
                method = 'mod_forum_get_forum_discussions';
                params.sortorder = sortOrder;
            }
            else {
                if (sortOrder == AddonModForumProvider_1.SORTORDER_LASTPOST_DESC) {
                    params.sortby = 'timemodified';
                    params.sortdirection = 'DESC';
                }
                else {
                    // Sorting not supported with the old WS method.
                    return Promise.reject(null);
                }
            }
            var preSets = {
                cacheKey: _this.getDiscussionsListCacheKey(forumId, sortOrder)
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read(method, params, preSets).catch(function (error) {
                // Try to get the data from cache stored with the old WS method.
                if (!_this.appProvider.isOnline() && method == 'mod_forum_get_forum_discussion' &&
                    sortOrder == AddonModForumProvider_1.SORTORDER_LASTPOST_DESC) {
                    var params_1 = {
                        forumid: forumId,
                        page: page,
                        perpage: AddonModForumProvider_1.DISCUSSIONS_PER_PAGE,
                        sortby: 'timemodified',
                        sortdirection: 'DESC'
                    };
                    var preSets_1 = {
                        cacheKey: _this.getDiscussionsListCacheKey(forumId, sortOrder),
                        omitExpires: true
                    };
                    return site.read('mod_forum_get_forum_discussions_paginated', params_1, preSets_1);
                }
                return Promise.reject(error);
            }).then(function (response) {
                if (response) {
                    _this.storeUserData(response.discussions);
                    return Promise.resolve({
                        discussions: response.discussions,
                        canLoadMore: response.discussions.length >= AddonModForumProvider_1.DISCUSSIONS_PER_PAGE,
                    });
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Get forum discussions in several pages.
     * If a page fails, the discussions until that page will be returned along with a flag indicating an error occurred.
     *
     * @param  {number}  forumId     Forum ID.
     * @param  {number}  [sortOrder] Sort order.
     * @param  {boolean} [forceCache] True to always get the value from cache, false otherwise.
     * @param  {number}  [numPages]  Number of pages to get. If not defined, all pages.
     * @param  {number}  [startPage] Page to start. If not defined, first page.
     * @param  {string}  [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with an object with:
     *                                - discussions: List of discussions.
     *                                - error: True if an error occurred, false otherwise.
     */
    AddonModForumProvider.prototype.getDiscussionsInPages = function (forumId, sortOrder, forceCache, numPages, startPage, siteId) {
        var _this = this;
        if (typeof numPages == 'undefined') {
            numPages = -1;
        }
        startPage = startPage || 0;
        var result = {
            discussions: [],
            error: false
        };
        if (!numPages) {
            return Promise.resolve(result);
        }
        var getPage = function (page) {
            // Get page discussions.
            return _this.getDiscussions(forumId, sortOrder, page, forceCache, siteId).then(function (response) {
                result.discussions = result.discussions.concat(response.discussions);
                numPages--;
                if (response.canLoadMore && numPages !== 0) {
                    return getPage(page + 1); // Get next page.
                }
                else {
                    return result;
                }
            }).catch(function () {
                // Error getting a page.
                result.error = true;
                return result;
            });
        };
        return getPage(startPage);
    };
    /**
     * Invalidates can add discussion WS calls.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModForumProvider.prototype.invalidateCanAddDiscussion = function (forumId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getCommonCanAddDiscussionCacheKey(forumId));
        });
    };
    /**
     * Invalidate the prefetched content except files.
     * To invalidate files, use AddonModForum#invalidateFiles.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID.
     * @return {Promise<any>}    Promise resolved when data is invalidated.
     */
    AddonModForumProvider.prototype.invalidateContent = function (moduleId, courseId) {
        var _this = this;
        // Get the forum first, we need the forum ID.
        return this.getForum(courseId, moduleId).then(function (forum) {
            var promises = [];
            promises.push(_this.invalidateForumData(courseId));
            promises.push(_this.invalidateDiscussionsList(forum.id));
            promises.push(_this.invalidateCanAddDiscussion(forum.id));
            promises.push(_this.invalidateAccessInformation(forum.id));
            _this.getAvailableSortOrders().forEach(function (sortOrder) {
                // We need to get the list of discussions to be able to invalidate their posts.
                promises.push(_this.getDiscussionsInPages(forum.id, sortOrder.value, true).then(function (response) {
                    // Now invalidate the WS calls.
                    var promises = [];
                    response.discussions.forEach(function (discussion) {
                        promises.push(_this.invalidateDiscussionPosts(discussion.discussion));
                    });
                    return _this.utils.allPromises(promises);
                }));
            });
            if (_this.isDiscussionListSortingAvailable()) {
                promises.push(_this.userProvider.invalidateUserPreference(AddonModForumProvider_1.PREFERENCE_SORTORDER));
            }
            return _this.utils.allPromises(promises);
        });
    };
    /**
     * Invalidates access information.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModForumProvider.prototype.invalidateAccessInformation = function (forumId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAccessInformationCacheKey(forumId));
        });
    };
    /**
     * Invalidates forum discussion posts.
     *
     * @param  {number} discussionId Discussion ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModForumProvider.prototype.invalidateDiscussionPosts = function (discussionId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getDiscussionPostsCacheKey(discussionId));
        });
    };
    /**
     * Invalidates discussion list.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModForumProvider.prototype.invalidateDiscussionsList = function (forumId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.utils.allPromises(_this.getAvailableSortOrders().map(function (sortOrder) {
                return site.invalidateWsCacheForKey(_this.getDiscussionsListCacheKey(forumId, sortOrder.value));
            }));
        });
    };
    /**
     * Invalidate the prefetched files.
     *
     * @param  {number} moduleId The module ID.
     * @return {Promise<any>}   Promise resolved when the files are invalidated.
     */
    AddonModForumProvider.prototype.invalidateFiles = function (moduleId) {
        var siteId = this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModForumProvider_1.COMPONENT, moduleId);
    };
    /**
     * Invalidates forum data.
     *
     * @param  {number} courseId Course ID.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModForumProvider.prototype.invalidateForumData = function (courseId) {
        return this.sitesProvider.getCurrentSite().invalidateWsCacheForKey(this.getForumDataCacheKey(courseId));
    };
    /**
     * Report a forum as being viewed.
     *
     * @param  {number} id    Module ID.
     * @param {string} [name] Name of the forum.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModForumProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            forumid: id
        };
        return this.logHelper.logSingle('mod_forum_view_forum', params, AddonModForumProvider_1.COMPONENT, id, name, 'forum', {}, siteId);
    };
    /**
     * Report a forum discussion as being viewed.
     *
     * @param  {number} id    Discussion ID.
     * @param  {number} forumId  Forum ID.
     * @param {string} [name] Name of the forum.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModForumProvider.prototype.logDiscussionView = function (id, forumId, name, siteId) {
        var params = {
            discussionid: id
        };
        return this.logHelper.logSingle('mod_forum_view_forum_discussion', params, AddonModForumProvider_1.COMPONENT, forumId, name, 'forum', params, siteId);
    };
    /**
     * Reply to a certain post.
     *
     * @param  {number}  postId         ID of the post being replied.
     * @param  {number}  discussionId   ID of the discussion the user is replying to.
     * @param  {number}  forumId        ID of the forum the user is replying to.
     * @param  {string}  name           Forum name.
     * @param  {number}  courseId       Course ID the forum belongs to.
     * @param  {string}  subject        New post's subject.
     * @param  {string}  message        New post's message.
     * @param  {any}     [options]      Options (subscribe, attachments, ...).
     * @param  {string}  [siteId]       Site ID. If not defined, current site.
     * @param  {boolean} [allowOffline] True if it can be stored in offline, false otherwise.
     * @return {Promise<any>}           Promise resolved with post ID if sent online, resolved with false if stored offline.
     */
    AddonModForumProvider.prototype.replyPost = function (postId, discussionId, forumId, name, courseId, subject, message, options, siteId, allowOffline) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            if (!forumId) {
                // Not enough data to store in offline, reject.
                return Promise.reject(_this.translate.instant('core.networkerrormsg'));
            }
            return _this.forumOffline.replyPost(postId, discussionId, forumId, name, courseId, subject, message, options, siteId)
                .then(function () {
                return false;
            });
        };
        if (!this.appProvider.isOnline() && allowOffline) {
            // App is offline, store the action.
            return storeOffline();
        }
        // If there's already a reply to be sent to the server, discard it first.
        return this.forumOffline.deleteReply(postId, siteId).then(function () {
            return _this.replyPostOnline(postId, subject, message, options, siteId).then(function () {
                return true;
            }).catch(function (error) {
                if (allowOffline && !_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Reply to a certain post. It will fail if offline or cannot connect.
     *
     * @param  {number} postId    ID of the post being replied.
     * @param  {string} subject   New post's subject.
     * @param  {string} message   New post's message.
     * @param  {any}    [options] Options (subscribe, attachments, ...).
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<number>}  Promise resolved with the created post id.
     */
    AddonModForumProvider.prototype.replyPostOnline = function (postId, subject, message, options, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                postid: postId,
                subject: subject,
                message: message,
                options: _this.utils.objectToArrayOfObjects(options, 'name', 'value')
            };
            return site.write('mod_forum_add_discussion_post', params).then(function (response) {
                if (!response || !response.postid) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                else {
                    return response.postid;
                }
            });
        });
    };
    /**
     * Lock or unlock a discussion.
     *
     * @param {number} forumId Forum id.
     * @param {number} discussionId DIscussion id.
     * @param {boolean} locked True to lock, false to unlock.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resvoled when done.
     * @since 3.7
     */
    AddonModForumProvider.prototype.setLockState = function (forumId, discussionId, locked, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                forumid: forumId,
                discussionid: discussionId,
                targetstate: locked ? 0 : 1
            };
            return site.write('mod_forum_set_lock_state', params);
        });
    };
    /**
     * Returns whether the set pin state WS is available.
     *
     * @param  {CoreSite} [site] Site. If not defined, current site.
     * @return {boolean} Whether it's available.
     * @since 3.7
     */
    AddonModForumProvider.prototype.isSetPinStateAvailableForSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return this.sitesProvider.wsAvailableInCurrentSite('mod_forum_set_pin_state');
    };
    /**
     * Pin or unpin a discussion.
     *
     * @param {number} discussionId Discussion id.
     * @param {boolean} locked True to pin, false to unpin.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resvoled when done.
     * @since 3.7
     */
    AddonModForumProvider.prototype.setPinState = function (discussionId, pinned, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                discussionid: discussionId,
                targetstate: pinned ? 1 : 0
            };
            return site.write('mod_forum_set_pin_state', params);
        });
    };
    /**
     * Star or unstar a discussion.
     *
     * @param {number} discussionId Discussion id.
     * @param {boolean} starred True to star, false to unstar.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resvoled when done.
     * @since 3.7
     */
    AddonModForumProvider.prototype.toggleFavouriteState = function (discussionId, starred, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                discussionid: discussionId,
                targetstate: starred ? 1 : 0
            };
            return site.write('mod_forum_toggle_favourite_state', params);
        });
    };
    /**
     * Store the users data from a discussions/posts list.
     *
     * @param {any[]} list Array of posts or discussions.
     */
    AddonModForumProvider.prototype.storeUserData = function (list) {
        var users = {};
        list.forEach(function (entry) {
            var userId = parseInt(entry.userid);
            if (!isNaN(userId) && !users[userId]) {
                users[userId] = {
                    id: userId,
                    fullname: entry.userfullname,
                    profileimageurl: entry.userpictureurl
                };
            }
            var userModified = parseInt(entry.usermodified);
            if (!isNaN(userModified) && !users[userModified]) {
                users[userModified] = {
                    id: userModified,
                    fullname: entry.usermodifiedfullname,
                    profileimageurl: entry.usermodifiedpictureurl
                };
            }
        });
        this.userProvider.storeUsers(this.utils.objectToArray(users));
    };
    AddonModForumProvider.COMPONENT = 'mmaModForum';
    AddonModForumProvider.DISCUSSIONS_PER_PAGE = 10; // Max of discussions per page.
    AddonModForumProvider.NEW_DISCUSSION_EVENT = 'addon_mod_forum_new_discussion';
    AddonModForumProvider.REPLY_DISCUSSION_EVENT = 'addon_mod_forum_reply_discussion';
    AddonModForumProvider.VIEW_DISCUSSION_EVENT = 'addon_mod_forum_view_discussion';
    AddonModForumProvider.CHANGE_DISCUSSION_EVENT = 'addon_mod_forum_lock_discussion';
    AddonModForumProvider.MARK_READ_EVENT = 'addon_mod_forum_mark_read';
    AddonModForumProvider.PREFERENCE_SORTORDER = 'forum_discussionlistsortorder';
    AddonModForumProvider.SORTORDER_LASTPOST_DESC = 1;
    AddonModForumProvider.SORTORDER_LASTPOST_ASC = 2;
    AddonModForumProvider.SORTORDER_CREATED_DESC = 3;
    AddonModForumProvider.SORTORDER_CREATED_ASC = 4;
    AddonModForumProvider.SORTORDER_REPLIES_DESC = 5;
    AddonModForumProvider.SORTORDER_REPLIES_ASC = 6;
    AddonModForumProvider.ALL_PARTICIPANTS = -1;
    AddonModForumProvider.ALL_GROUPS = -2;
    AddonModForumProvider = AddonModForumProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_groups__["a" /* CoreGroupsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_7__core_user_providers_user__["a" /* CoreUserProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__offline__["a" /* AddonModForumOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_9__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModForumProvider);
    return AddonModForumProvider;
    var AddonModForumProvider_1;
}());

//# sourceMappingURL=forum.js.map

/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_pushnotifications_providers_pushnotifications__ = __webpack_require__(140);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to provide grade functionalities.
 */
var CoreGradesProvider = /** @class */ (function () {
    function CoreGradesProvider(logger, sitesProvider, coursesProvider, pushNotificationsProvider) {
        this.sitesProvider = sitesProvider;
        this.coursesProvider = coursesProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.ROOT_CACHE_KEY = 'mmGrades:';
        this.logger = logger.getInstance('CoreGradesProvider');
    }
    /**
     * Get cache key for grade table data WS calls.
     *
     * @param {number} courseId ID of the course to get the grades from.
     * @param {number} userId   ID of the user to get the grades from.
     * @return {string}         Cache key.
     */
    CoreGradesProvider.prototype.getCourseGradesCacheKey = function (courseId, userId) {
        return this.getCourseGradesPrefixCacheKey(courseId) + userId;
    };
    /**
     * Get cache key for grade items data WS calls.
     *
     * @param {number} courseId     ID of the course to get the grades from.
     * @param {number} userId       ID of the user to get the grades from.
     * @param {number} [groupId]    ID of the group to get the grades from. Default: 0.
     * @return {string}         Cache key.
     */
    CoreGradesProvider.prototype.getCourseGradesItemsCacheKey = function (courseId, userId, groupId) {
        groupId = groupId || 0;
        return this.getCourseGradesPrefixCacheKey(courseId) + userId + ':' + groupId;
    };
    /**
     * Get prefix cache key for grade table data WS calls.
     *
     * @param {number} courseId ID of the course to get the grades from.
     * @return {string}         Cache key.
     */
    CoreGradesProvider.prototype.getCourseGradesPrefixCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'items:' + courseId + ':';
    };
    /**
     * Get cache key for courses grade WS calls.
     *
     * @return {string}   Cache key.
     */
    CoreGradesProvider.prototype.getCoursesGradesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'coursesgrades';
    };
    /**
     * Get the grade items for a certain module. Keep in mind that may have more than one item to include outcomes and scales.
     * Fallback function only used if 'gradereport_user_get_grade_items' WS is not avalaible Moodle < 3.2.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  [userId]             ID of the user to get the grades from. If not defined use site's current user.
     * @param  {number}  [groupId]            ID of the group to get the grades from. Not used for old gradebook table.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                Promise to be resolved when the grades are retrieved.
     */
    CoreGradesProvider.prototype.getGradeItems = function (courseId, userId, groupId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return _this.isGradeItemsAvalaible(siteId).then(function (enabled) {
                if (enabled) {
                    return _this.getCourseGradesItems(courseId, userId, groupId, siteId, ignoreCache).catch(function () {
                        // FallBack while solving MDL-57255.
                        return _this.getCourseGradesTable(courseId, userId, siteId, ignoreCache);
                    });
                }
                else {
                    return _this.getCourseGradesTable(courseId, userId, siteId, ignoreCache);
                }
            });
        });
    };
    /**
     * Get the grade items for a certain course.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  [userId]             ID of the user to get the grades from.
     * @param  {number}  [groupId]            ID of the group to get the grades from. Default 0.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                      Promise to be resolved when the grades table is retrieved.
     */
    CoreGradesProvider.prototype.getCourseGradesItems = function (courseId, userId, groupId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            groupId = groupId || 0;
            _this.logger.debug("Get grades for course '" + courseId + "' and user '" + userId + "'");
            var data = {
                courseid: courseId,
                userid: userId,
                groupid: groupId
            }, preSets = {
                cacheKey: _this.getCourseGradesItemsCacheKey(courseId, userId, groupId)
            };
            if (ignoreCache) {
                preSets['getFromCache'] = 0;
                preSets['emergencyCache'] = 0;
            }
            return site.read('gradereport_user_get_grade_items', data, preSets).then(function (grades) {
                if (grades && grades.usergrades && grades.usergrades[0]) {
                    return grades.usergrades[0].gradeitems;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get the grades for a certain course.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  [userId]             ID of the user to get the grades from.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                      Promise to be resolved when the grades table is retrieved.
     */
    CoreGradesProvider.prototype.getCourseGradesTable = function (courseId, userId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug("Get grades for course '" + courseId + "' and user '" + userId + "'");
            var data = {
                courseid: courseId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getCourseGradesCacheKey(courseId, userId)
            };
            if (ignoreCache) {
                preSets['getFromCache'] = 0;
                preSets['emergencyCache'] = 0;
            }
            return site.read('gradereport_user_get_grades_table', data, preSets).then(function (table) {
                if (table && table.tables && table.tables[0]) {
                    return table.tables[0];
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get the grades for a certain course.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise to be resolved when the grades are retrieved.
     */
    CoreGradesProvider.prototype.getCoursesGrades = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Get course grades');
            var preSets = {
                cacheKey: _this.getCoursesGradesCacheKey()
            };
            return site.read('gradereport_overview_get_course_grades', undefined, preSets).then(function (data) {
                if (data && data.grades) {
                    return data.grades;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidates courses grade table and items WS calls for all users.
     *
     * @param {number} courseId ID of the course to get the grades from.
     * @param {string} [siteId] Site ID (empty for current site).
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGradesProvider.prototype.invalidateAllCourseGradesData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getCourseGradesPrefixCacheKey(courseId));
        });
    };
    /**
     * Invalidates grade table data WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} [userId]   User ID.
     * @param {string} [siteId]   Site id (empty for current site).
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    CoreGradesProvider.prototype.invalidateCourseGradesData = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCourseGradesCacheKey(courseId, userId));
        });
    };
    /**
     * Invalidates courses grade data WS calls.
     *
     * @param {string} [siteId]   Site id (empty for current site).
     * @return {Promise<any>}     Promise resolved when the data is invalidated.
     */
    CoreGradesProvider.prototype.invalidateCoursesGradesData = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCoursesGradesCacheKey());
        });
    };
    /**
     * Invalidates courses grade items data WS calls.
     *
     * @param {number} courseId     ID of the course to get the grades from.
     * @param {number} userId       ID of the user to get the grades from.
     * @param {number} [groupId]    ID of the group to get the grades from. Default: 0.
     * @param {string} [siteId]     Site id (empty for current site).
     * @return {Promise<any>}     Promise resolved when the data is invalidated.
     */
    CoreGradesProvider.prototype.invalidateCourseGradesItemsData = function (courseId, userId, groupId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseGradesItemsCacheKey(courseId, userId, groupId));
        });
    };
    /**
     * Returns whether or not the plugin is enabled for a certain site.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>}  Resolve with true if plugin is enabled, false otherwise.
     * @since  Moodle 3.2
     */
    CoreGradesProvider.prototype.isCourseGradesEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.wsAvailable('gradereport_overview_get_course_grades')) {
                return false;
            }
            // Now check that the configurable mygradesurl is pointing to the gradereport_overview plugin.
            var url = site.getStoredConfig('mygradesurl') || '';
            return url.indexOf('/grade/report/overview/') !== -1;
        });
    };
    /**
     * Returns whether or not the grade addon is enabled for a certain course.
     *
     * @param {number} courseId  Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promisee<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    CoreGradesProvider.prototype.isPluginEnabledForCourse = function (courseId, siteId) {
        if (!courseId) {
            return Promise.reject(null);
        }
        return this.coursesProvider.getUserCourse(courseId, true, siteId).then(function (course) {
            return !(course && typeof course.showgrades != 'undefined' && course.showgrades == 0);
        });
    };
    /**
     * Returns whether or not WS Grade Items is avalaible.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>}         True if ws is avalaible, false otherwise.
     * @since  Moodle 3.2
     */
    CoreGradesProvider.prototype.isGradeItemsAvalaible = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('gradereport_user_get_grade_items');
        });
    };
    /**
     * Log Course grades view in Moodle.
     *
     * @param  {number}  courseId Course ID.
     * @param  {number}  userId   User ID.
     * @param  {string}  [name]   Course name. If not set, it will be calculated.
     * @return {Promise<any>}     Promise resolved when done.
     */
    CoreGradesProvider.prototype.logCourseGradesView = function (courseId, userId, name) {
        var _this = this;
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        var wsName = 'gradereport_user_view_grade_report';
        if (!name) {
            this.coursesProvider.getUserCourse(courseId, true).catch(function () {
                return {};
            }).then(function (course) {
                _this.pushNotificationsProvider.logViewEvent(courseId, course.fullname || '', 'grades', wsName, { userid: userId });
            });
        }
        else {
            this.pushNotificationsProvider.logViewEvent(courseId, name, 'grades', wsName, { userid: userId });
        }
        return this.sitesProvider.getCurrentSite().write(wsName, {
            courseid: courseId,
            userid: userId
        });
    };
    /**
     * Log Courses grades view in Moodle.
     *
     * @param  {number}  [courseId] Course ID. If not defined, site Home ID.
     * @return {Promise<any>}     Promise resolved when done.
     */
    CoreGradesProvider.prototype.logCoursesGradesView = function (courseId) {
        if (!courseId) {
            courseId = this.sitesProvider.getCurrentSiteHomeId();
        }
        var params = {
            courseid: courseId
        };
        this.pushNotificationsProvider.logViewListEvent('grades', 'gradereport_overview_view_grade_report', params);
        return this.sitesProvider.getCurrentSite().write('gradereport_overview_view_grade_report', params);
    };
    CoreGradesProvider.TYPE_NONE = 0; // Moodle's GRADE_TYPE_NONE.
    CoreGradesProvider.TYPE_VALUE = 1; // Moodle's GRADE_TYPE_VALUE.
    CoreGradesProvider.TYPE_SCALE = 2; // Moodle's GRADE_TYPE_SCALE.
    CoreGradesProvider.TYPE_TEXT = 3; // Moodle's GRADE_TYPE_TEXT.
    CoreGradesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_4__core_pushnotifications_providers_pushnotifications__["a" /* CorePushNotificationsProvider */]])
    ], CoreGradesProvider);
    return CoreGradesProvider;
}());

//# sourceMappingURL=grades.js.map

/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModLessonProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_grades_providers_grades__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__lesson_offline__ = __webpack_require__(270);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












/**
 * Service that provides some features for lesson.
 *
 * Lesson terminology is a bit confusing and ambiguous in Moodle. For that reason, in the app it has been decided to use
 * the following terminology:
 *     - Retake: An attempt in a lesson. In Moodle it's sometimes called "attempt", "try" or "retry".
 *     - Attempt: An attempt in a page inside a retake. In the app, this includes content pages.
 *     - Content page: A page with only content (no question). In Moodle it's sometimes called "branch table".
 *     - Page answers: List of possible answers for a page (configured by the teacher). NOT the student answer for the page.
 *
 * This terminology sometimes won't match with WebServices names, params or responses.
 */
var AddonModLessonProvider = /** @class */ (function () {
    function AddonModLessonProvider(logger, sitesProvider, utils, translate, textUtils, domUtils, lessonOfflineProvider, logHelper, eventsProvider) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.translate = translate;
        this.textUtils = textUtils;
        this.domUtils = domUtils;
        this.lessonOfflineProvider = lessonOfflineProvider;
        this.logHelper = logHelper;
        this.eventsProvider = eventsProvider;
        this.siteSchema = {
            name: 'AddonModLessonProvider',
            version: 1,
            tables: [
                {
                    name: AddonModLessonProvider_1.PASSWORD_TABLE,
                    columns: [
                        {
                            name: 'lessonid',
                            type: 'INTEGER',
                            primaryKey: true
                        },
                        {
                            name: 'password',
                            type: 'TEXT'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        }
                    ]
                }
            ]
        };
        this.ROOT_CACHE_KEY = 'mmaModLesson:';
        this.logger = logger.getInstance('AddonModLessonProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModLessonProvider_1 = AddonModLessonProvider;
    /**
     * Add an answer and its response to a feedback string (HTML).
     *
     * @param {string} feedback The current feedback.
     * @param {string} answer Student answer.
     * @param {number} answerFormat Answer format.
     * @param {string} response Response.
     * @param {string} className Class to add to the response.
     * @return {string} New feedback.
     */
    AddonModLessonProvider.prototype.addAnswerAndResponseToFeedback = function (feedback, answer, answerFormat, response, className) {
        // Add a table row containing the answer.
        feedback += '<tr><td class="cell c0 lastcol">' + (answerFormat ? answer : this.textUtils.cleanTags(answer)) +
            '</td></tr>';
        // If the response exists, add a table row containing the response. If not, add en empty row.
        if (response && response.trim()) {
            feedback += '<tr><td class="cell c0 lastcol ' + className + '"><em>' +
                this.translate.instant('addon.mod_lesson.response') + '</em>: <br/>' +
                response + '</td></tr>';
        }
        else {
            feedback += '<tr><td class="cell c0 lastcol"></td></tr>';
        }
        return feedback;
    };
    /**
     * Add a message to a list of messages, following the format of the messages returned by WS.
     *
     * @param {any[]} messages List of messages where to add the message.
     * @param {string} stringName The ID of the message to be translated. E.g. 'addon.mod_lesson.numberofpagesviewednotice'.
     * @param {any} [stringParams] The params of the message (if any).
     */
    AddonModLessonProvider.prototype.addMessage = function (messages, stringName, stringParams) {
        messages.push({
            message: this.translate.instant(stringName, stringParams)
        });
    };
    /**
     * Add a property to the result of the "process EOL page" simulation in offline.
     *
     * @param {any} result Result where to add the value.
     * @param {string} name Name of the property.
     * @param {any} value Value to add.
     * @param {boolean} addMessage Whether to add a message related to the value.
     */
    AddonModLessonProvider.prototype.addResultValueEolPage = function (result, name, value, addMessage) {
        var message = '';
        if (addMessage) {
            var params = typeof value != 'boolean' ? { $a: value } : undefined;
            message = this.translate.instant('addon.mod_lesson.' + name, params);
        }
        result.data[name] = {
            name: name,
            value: value,
            message: message
        };
    };
    /**
     * Check if an answer page (from getUserRetake) is a content page.
     *
     * @param {any} page Answer page.
     * @return {boolean} Whether it's a content page.
     */
    AddonModLessonProvider.prototype.answerPageIsContent = function (page) {
        // The page doesn't have any reliable field to use for checking this. Check qtype first (translated string).
        if (page.qtype == this.translate.instant('addon.mod_lesson.branchtable')) {
            return true;
        }
        // The qtype doesn't match, but that doesn't mean it's not a content page, maybe the language is different.
        // Check it's not a question page.
        if (page.answerdata && !this.answerPageIsQuestion(page)) {
            // It isn't a question page, but it can be an end of branch, etc. Check if the first answer has a button.
            if (page.answerdata.answers && page.answerdata.answers[0]) {
                var element = this.domUtils.convertToElement(page.answerdata.answers[0][0]);
                return !!element.querySelector('input[type="button"]');
            }
        }
        return false;
    };
    /**
     * Check if an answer page (from getUserRetake) is a question page.
     *
     * @param {any} page Answer page.
     * @return {boolean} Whether it's a question page.
     */
    AddonModLessonProvider.prototype.answerPageIsQuestion = function (page) {
        if (!page.answerdata) {
            return false;
        }
        if (page.answerdata.score) {
            // Only question pages have a score.
            return true;
        }
        if (page.answerdata.answers) {
            for (var i = 0; i < page.answerdata.answers.length; i++) {
                var answer = page.answerdata.answers[i];
                if (answer[1]) {
                    // Only question pages have a statistic.
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Calculate some offline data like progress and ongoingscore.
     *
     * @param {any} lesson Lesson.
     * @param {any} accessInfo Result of get access info.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {any} [pageIndex] Object containing all the pages indexed by ID. If not defined, it will be calculated.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{reviewmode: boolean, progress: number, ongoingscore: string}>} Promise resolved with the data.
     */
    AddonModLessonProvider.prototype.calculateOfflineData = function (lesson, accessInfo, password, review, pageIndex, siteId) {
        accessInfo = accessInfo || {};
        var reviewMode = review || accessInfo.reviewmode, promises = [];
        var ongoingMessage = '', progress;
        if (!accessInfo.canmanage) {
            if (lesson.ongoing && !reviewMode) {
                promises.push(this.getOngoingScoreMessage(lesson, accessInfo, password, review, pageIndex, siteId)
                    .then(function (message) {
                    ongoingMessage = message;
                }));
            }
            if (lesson.progressbar) {
                promises.push(this.calculateProgress(lesson.id, accessInfo, password, review, pageIndex, siteId).then(function (p) {
                    progress = p;
                }));
            }
        }
        return Promise.all(promises).then(function () {
            return {
                reviewmode: reviewMode,
                progress: progress,
                ongoingscore: ongoingMessage
            };
        });
    };
    /**
     * Calculate the progress of the current user in the lesson.
     * Based on Moodle's calculate_progress.
     *
     * @param {number} lessonId Lesson ID.
     * @param {any} accessInfo Result of get access info.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {any} [pageIndex] Object containing all the pages indexed by ID. If not defined, it will be calculated.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with a number: the progress (scale 0-100).
     */
    AddonModLessonProvider.prototype.calculateProgress = function (lessonId, accessInfo, password, review, pageIndex, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Check if the user is reviewing the attempt.
        if (review) {
            return Promise.resolve(100);
        }
        var retake = accessInfo.attemptscount;
        var viewedPagesIds, promise;
        if (pageIndex) {
            promise = Promise.resolve();
        }
        else {
            // Retrieve the index.
            promise = this.getPages(lessonId, password, true, false, siteId).then(function (pages) {
                pageIndex = _this.createPagesIndex(pages);
            });
        }
        return promise.then(function () {
            // Get the list of question pages attempted.
            return _this.getPagesIdsWithQuestionAttempts(lessonId, retake, false, siteId);
        }).then(function (ids) {
            viewedPagesIds = ids;
            // Get the list of viewed content pages.
            return _this.getContentPagesViewedIds(lessonId, retake, siteId);
        }).then(function (viewedContentPagesIds) {
            var validPages = {};
            var pageId = accessInfo.firstpageid;
            viewedPagesIds = _this.utils.mergeArraysWithoutDuplicates(viewedPagesIds, viewedContentPagesIds);
            // Filter out the following pages:
            // - End of Cluster
            // - End of Branch
            // - Pages found inside of Clusters
            // Do not filter out Cluster Page(s) because we count a cluster as one.
            // By keeping the cluster page, we get our 1.
            while (pageId) {
                pageId = _this.validPageAndView(pageIndex, pageIndex[pageId], validPages, viewedPagesIds);
            }
            // Progress calculation as a percent.
            return _this.textUtils.roundToDecimals(viewedPagesIds.length / Object.keys(validPages).length, 2) * 100;
        });
    };
    /**
     * Check if the answer provided by the user is correct or not and return the result object.
     * This method is based on the check_answer implementation of all page types (Moodle).
     *
     * @param {any} lesson Lesson.
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {any} data Data containing the user answer.
     * @param {any} jumps Result of get pages possible jumps.
     * @param {any} pageIndex Object containing all the pages indexed by ID.
     * @return {AddonModLessonCheckAnswerResult} Result.
     */
    AddonModLessonProvider.prototype.checkAnswer = function (lesson, pageData, data, jumps, pageIndex) {
        // Default result.
        var result = {
            answerid: 0,
            noanswer: false,
            correctanswer: false,
            isessayquestion: false,
            response: '',
            newpageid: 0,
            studentanswer: '',
            userresponse: null,
            feedback: '',
            nodefaultresponse: false,
            inmediatejump: false
        };
        switch (pageData.page.qtype) {
            case AddonModLessonProvider_1.LESSON_PAGE_BRANCHTABLE:
                // Load the new page immediately.
                result.inmediatejump = true;
                result.newpageid = this.getNewPageId(pageData.page.id, data.jumpto, jumps);
                break;
            case AddonModLessonProvider_1.LESSON_PAGE_ESSAY:
                this.checkAnswerEssay(pageData, data, result);
                break;
            case AddonModLessonProvider_1.LESSON_PAGE_MATCHING:
                this.checkAnswerMatching(pageData, data, result);
                break;
            case AddonModLessonProvider_1.LESSON_PAGE_MULTICHOICE:
                this.checkAnswerMultichoice(lesson, pageData, data, pageIndex, result);
                break;
            case AddonModLessonProvider_1.LESSON_PAGE_NUMERICAL:
                this.checkAnswerNumerical(lesson, pageData, data, pageIndex, result);
                break;
            case AddonModLessonProvider_1.LESSON_PAGE_SHORTANSWER:
                this.checkAnswerShort(lesson, pageData, data, pageIndex, result);
                break;
            case AddonModLessonProvider_1.LESSON_PAGE_TRUEFALSE:
                this.checkAnswerTruefalse(lesson, pageData, data, pageIndex, result);
                break;
            default:
        }
        return result;
    };
    /**
     * Check an essay answer.
     *
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {any} data Data containing the user answer.
     * @param {AddonModLessonCheckAnswerResult} result Object where to store the result.
     */
    AddonModLessonProvider.prototype.checkAnswerEssay = function (pageData, data, result) {
        var studentAnswer;
        result.isessayquestion = true;
        if (!data) {
            result.inmediatejump = true;
            result.newpageid = pageData.page.id;
            return;
        }
        // The name was changed to "answer_editor" in 3.7. Before it was just "answer". Support both cases.
        if (typeof data['answer_editor[text]'] != 'undefined') {
            studentAnswer = data['answer_editor[text]'];
        }
        else if (typeof data.answer_editor == 'object') {
            studentAnswer = data.answer_editor.text;
        }
        else if (typeof data['answer[text]'] != 'undefined') {
            studentAnswer = data['answer[text]'];
        }
        else if (typeof data.answer == 'object') {
            studentAnswer = data.answer.text;
        }
        else {
            studentAnswer = data.answer;
        }
        if (!studentAnswer || studentAnswer.trim() === '') {
            result.noanswer = true;
            return;
        }
        // Essay pages should only have 1 possible answer.
        pageData.answers.forEach(function (answer) {
            result.answerid = answer.id;
            result.newpageid = answer.jumpto;
        });
        result.userresponse = {
            sent: 0,
            graded: 0,
            score: 0,
            answer: studentAnswer,
            answerformat: 1,
            response: '',
            responseformat: 1
        };
        result.studentanswerformat = 1;
        result.studentanswer = studentAnswer;
    };
    /**
     * Check a matching answer.
     *
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {any} data Data containing the user answer.
     * @param {AddonModLessonCheckAnswerResult} result Object where to store the result.
     */
    AddonModLessonProvider.prototype.checkAnswerMatching = function (pageData, data, result) {
        if (!data) {
            result.inmediatejump = true;
            result.newpageid = pageData.page.id;
            return;
        }
        var response = this.getUserResponseMatching(data), getAnswers = this.utils.clone(pageData.answers), correct = getAnswers.shift(), wrong = getAnswers.shift(), answers = {};
        getAnswers.forEach(function (answer) {
            if (answer.answer !== '' || answer.response !== '') {
                answers[answer.id] = answer;
            }
        });
        // Get the user's exact responses for record keeping.
        var userResponse = [];
        var hits = 0;
        result.studentanswer = '';
        result.studentanswerformat = 1;
        for (var id in response) {
            var value = response[id];
            if (!value) {
                result.noanswer = true;
                return;
            }
            value = this.textUtils.decodeHTML(value);
            userResponse.push(value);
            if (typeof answers[id] != 'undefined') {
                var answer = answers[id];
                result.studentanswer += '<br />' + answer.answer + ' = ' + value;
                if (answer.response && answer.response.trim() == value.trim()) {
                    hits++;
                }
            }
        }
        result.userresponse = userResponse.join(',');
        if (hits == Object.keys(answers).length) {
            result.correctanswer = true;
            result.response = correct.answer;
            result.answerid = correct.id;
            result.newpageid = correct.jumpto;
        }
        else {
            result.correctanswer = false;
            result.response = wrong.answer;
            result.answerid = wrong.id;
            result.newpageid = wrong.jumpto;
        }
    };
    /**
     * Check a multichoice answer.
     *
     * @param {any} lesson Lesson.
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {any} data Data containing the user answer.
     * @param {any} pageIndex Object containing all the pages indexed by ID.
     * @param {AddonModLessonCheckAnswerResult} result Object where to store the result.
     */
    AddonModLessonProvider.prototype.checkAnswerMultichoice = function (lesson, pageData, data, pageIndex, result) {
        var _this = this;
        if (!data) {
            result.inmediatejump = true;
            result.newpageid = pageData.page.id;
            return;
        }
        var answers = this.getUsedAnswersMultichoice(pageData);
        if (pageData.page.qoption) {
            // Multianswer allowed, user's answer is an array.
            var studentAnswers_1 = this.getUserResponseMultichoice(data);
            if (!studentAnswers_1 || !Array.isArray(studentAnswers_1)) {
                result.noanswer = true;
                return;
            }
            // Get what the user answered.
            result.userresponse = studentAnswers_1.join(',');
            // Get the answers in a set order, the id order.
            var studentAswersArray_1 = [], responses_1 = [];
            var nHits_1 = 0, nCorrect_1 = 0, correctAnswerId_1 = 0, wrongAnswerId_1 = 0, correctPageId_1, wrongPageId_1;
            // Store student's answers for displaying on feedback page.
            result.studentanswer = '';
            result.studentanswerformat = 1;
            answers.forEach(function (answer) {
                for (var i in studentAnswers_1) {
                    var answerId = studentAnswers_1[i];
                    if (answerId == answer.id) {
                        studentAswersArray_1.push(answer.answer);
                        responses_1.push(answer.response);
                        break;
                    }
                }
            });
            result.studentanswer = studentAswersArray_1.join(AddonModLessonProvider_1.MULTIANSWER_DELIMITER);
            // Iterate over all the possible answers.
            answers.forEach(function (answer) {
                var correctAnswer = _this.isAnswerCorrect(lesson, pageData.page.id, answer, pageIndex);
                // Iterate over all the student answers to check if he selected the current possible answer.
                studentAnswers_1.forEach(function (answerId) {
                    if (answerId == answer.id) {
                        if (correctAnswer) {
                            nHits_1++;
                        }
                        else {
                            // Always use the first student wrong answer.
                            if (typeof wrongPageId_1 == 'undefined') {
                                wrongPageId_1 = answer.jumpto;
                            }
                            // Save the answer id for scoring.
                            if (!wrongAnswerId_1) {
                                wrongAnswerId_1 = answer.id;
                            }
                        }
                    }
                });
                if (correctAnswer) {
                    nCorrect_1++;
                    // Save the first jumpto.
                    if (typeof correctPageId_1 == 'undefined') {
                        correctPageId_1 = answer.jumpto;
                    }
                    // Save the answer id for scoring.
                    if (!correctAnswerId_1) {
                        correctAnswerId_1 = answer.id;
                    }
                }
            });
            if (studentAnswers_1.length == nCorrect_1 && nHits_1 == nCorrect_1) {
                result.correctanswer = true;
                result.response = responses_1.join(AddonModLessonProvider_1.MULTIANSWER_DELIMITER);
                result.newpageid = correctPageId_1;
                result.answerid = correctAnswerId_1;
            }
            else {
                result.correctanswer = false;
                result.response = responses_1.join(AddonModLessonProvider_1.MULTIANSWER_DELIMITER);
                result.newpageid = wrongPageId_1;
                result.answerid = wrongAnswerId_1;
            }
        }
        else {
            // Only one answer allowed.
            if (typeof data.answerid == 'undefined' || (!data.answerid && Number(data.answerid) !== 0)) {
                result.noanswer = true;
                return;
            }
            result.answerid = data.answerid;
            // Search the answer.
            for (var i in pageData.answers) {
                var answer = pageData.answers[i];
                if (answer.id == data.answerid) {
                    result.correctanswer = this.isAnswerCorrect(lesson, pageData.page.id, answer, pageIndex);
                    result.newpageid = answer.jumpto;
                    result.response = answer.response;
                    result.userresponse = result.studentanswer = answer.answer;
                    break;
                }
            }
        }
    };
    /**
     * Check a numerical answer.
     *
     * @param {any} lesson Lesson.
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {any} data Data containing the user answer.
     * @param {any} pageIndex Object containing all the pages indexed by ID.
     * @param {any} result Object where to store the result.
     */
    AddonModLessonProvider.prototype.checkAnswerNumerical = function (lesson, pageData, data, pageIndex, result) {
        var parsedAnswer = parseFloat(data.answer);
        // Set defaults.
        result.response = '';
        result.newpageid = 0;
        if (!data.answer || isNaN(parsedAnswer)) {
            result.noanswer = true;
            return;
        }
        else {
            result.useranswer = parsedAnswer;
        }
        result.studentanswer = result.userresponse = result.useranswer;
        // Find the answer.
        for (var i in pageData.answers) {
            var answer = pageData.answers[i];
            var max = void 0, min = void 0;
            if (answer.answer && answer.answer.indexOf(':') != -1) {
                // There's a pair of values.
                var split = answer.answer.split(':');
                min = parseFloat(split[0]);
                max = parseFloat(split[1]);
            }
            else {
                // Only one value.
                min = parseFloat(answer.answer);
                max = min;
            }
            if (result.useranswer >= min && result.useranswer <= max) {
                result.newpageid = answer.jumpto;
                result.response = answer.response;
                result.correctanswer = this.isAnswerCorrect(lesson, pageData.page.id, answer, pageIndex);
                result.answerid = answer.id;
                break;
            }
        }
        this.checkOtherAnswers(lesson, pageData, result);
    };
    /**
     * Check a short answer.
     *
     * @param {any} lesson Lesson.
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {any} data Data containing the user answer.
     * @param {any} pageIndex Object containing all the pages indexed by ID.
     * @param {any} result Object where to store the result.
     */
    AddonModLessonProvider.prototype.checkAnswerShort = function (lesson, pageData, data, pageIndex, result) {
        var studentAnswer = data.answer && data.answer.trim ? data.answer.trim() : false;
        if (!studentAnswer) {
            result.noanswer = true;
            return;
        }
        // Search the answer in the list of possible answers.
        for (var i in pageData.answers) {
            var answer = pageData.answers[i], useRegExp = pageData.page.qoption;
            var expectedAnswer = answer.answer, isMatch = false, ignoreCase = void 0;
            if (useRegExp) {
                ignoreCase = '';
                if (expectedAnswer.substr(-2) == '/i') {
                    expectedAnswer = expectedAnswer.substr(0, expectedAnswer.length - 2);
                    ignoreCase = 'i';
                }
            }
            else {
                expectedAnswer = expectedAnswer.replace('*', '#####');
                expectedAnswer = this.textUtils.escapeForRegex(expectedAnswer);
                expectedAnswer = expectedAnswer.replace('#####', '.*');
            }
            // See if user typed in any of the correct answers.
            if (this.isAnswerCorrect(lesson, pageData.page.id, answer, pageIndex)) {
                if (!useRegExp) {
                    if (studentAnswer.match(new RegExp('^' + expectedAnswer + '$', 'i'))) {
                        isMatch = true;
                    }
                }
                else {
                    if (studentAnswer.match(new RegExp('^' + expectedAnswer + '$', ignoreCase))) {
                        isMatch = true;
                    }
                }
                if (isMatch) {
                    result.correctanswer = true;
                }
            }
            else {
                if (!useRegExp) {
                    // See if user typed in any of the wrong answers; don't worry about case.
                    if (studentAnswer.match(new RegExp('^' + expectedAnswer + '$', 'i'))) {
                        isMatch = true;
                    }
                }
                else {
                    var startCode = expectedAnswer.substr(0, 2);
                    switch (startCode) {
                        // 1- Check for absence of required string in studentAnswer (coded by initial '--').
                        case '--':
                            expectedAnswer = expectedAnswer.substr(2);
                            if (!studentAnswer.match(new RegExp('^' + expectedAnswer + '$', ignoreCase))) {
                                isMatch = true;
                            }
                            break;
                        // 2- Check for code for marking wrong strings (coded by initial '++').
                        case '++':
                            expectedAnswer = expectedAnswer.substr(2);
                            // Check for one or several matches.
                            var matches = studentAnswer.match(new RegExp(expectedAnswer, 'g' + ignoreCase));
                            if (matches) {
                                isMatch = true;
                                var nb = matches[0].length, original = [], marked = [];
                                for (var j = 0; j < nb; j++) {
                                    original.push(matches[0][j]);
                                    marked.push('<span class="incorrect matches">' + matches[0][j] + '</span>');
                                }
                                studentAnswer = studentAnswer.replace(original, marked);
                            }
                            break;
                        // 3- Check for wrong answers belonging neither to -- nor to ++ categories.
                        default:
                            if (studentAnswer.match(new RegExp('^' + expectedAnswer + '$', ignoreCase))) {
                                isMatch = true;
                            }
                            break;
                    }
                    result.correctanswer = false;
                }
            }
            if (isMatch) {
                result.newpageid = answer.jumpto;
                result.response = answer.response;
                result.answerid = answer.id;
                break; // Quit answer analysis immediately after a match has been found.
            }
        }
        this.checkOtherAnswers(lesson, pageData, result);
        result.userresponse = studentAnswer;
        result.studentanswer = this.textUtils.s(studentAnswer); // Clean student answer as it goes to output.
    };
    /**
     * Check a truefalse answer.
     *
     * @param {any} lesson Lesson.
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {any} data Data containing the user answer.
     * @param {any} pageIndex Object containing all the pages indexed by ID.
     * @param {any} result Object where to store the result.
     */
    AddonModLessonProvider.prototype.checkAnswerTruefalse = function (lesson, pageData, data, pageIndex, result) {
        if (!data.answerid) {
            result.noanswer = true;
            return;
        }
        result.answerid = data.answerid;
        // Get the answer.
        for (var i in pageData.answers) {
            var answer = pageData.answers[i];
            if (answer.id == data.answerid) {
                // Answer found.
                result.correctanswer = this.isAnswerCorrect(lesson, pageData.page.id, answer, pageIndex);
                result.newpageid = answer.jumpto;
                result.response = answer.response;
                result.studentanswer = result.userresponse = answer.answer;
                break;
            }
        }
    };
    /**
     * Check the "other answers" value.
     *
     * @param {any} lesson Lesson.
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {AddonModLessonCheckAnswerResult} result Object where to store the result.
     */
    AddonModLessonProvider.prototype.checkOtherAnswers = function (lesson, pageData, result) {
        // We could check here to see if we have a wrong answer jump to use.
        if (result.answerid == 0) {
            // Use the all other answers jump details if it is set up.
            var lastAnswer = pageData.answers[pageData.answers.length - 1] || {};
            // Double check that this is the OTHER_ANSWERS answer.
            if (typeof lastAnswer.answer == 'string' &&
                lastAnswer.answer.indexOf(AddonModLessonProvider_1.LESSON_OTHER_ANSWERS) != -1) {
                result.newpageid = lastAnswer.jumpto;
                result.response = lastAnswer.response;
                if (lesson.custom) {
                    result.correctanswer = lastAnswer.score > 0;
                }
                result.answerid = lastAnswer.id;
            }
        }
    };
    /**
     * Create a list of pages indexed by page ID based on a list of pages.
     *
     * @param {Object[]} pageList Result of get pages.
     * @return {any} Pages index.
     */
    AddonModLessonProvider.prototype.createPagesIndex = function (pageList) {
        // Index the pages by page ID.
        var pages = {};
        pageList.forEach(function (pageData) {
            pages[pageData.page.id] = pageData.page;
        });
        return pages;
    };
    /**
     * Finishes a retake.
     *
     * @param {any} lesson Lesson.
     * @param {number} courseId Course ID the lesson belongs to.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [outOfTime] If the user ran out of time.
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {boolean} [offline] Whether it's offline mode.
     * @param {any} [accessInfo] Result of get access info. Required if offline is true.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModLessonProvider.prototype.finishRetake = function (lesson, courseId, password, outOfTime, review, offline, accessInfo, siteId) {
        var _this = this;
        if (offline) {
            var retake_1 = accessInfo.attemptscount;
            return this.lessonOfflineProvider.finishRetake(lesson.id, courseId, retake_1, true, outOfTime, siteId).then(function () {
                // Get the lesson grade.
                return _this.lessonGrade(lesson, retake_1, password, review, undefined, siteId).catch(function () {
                    // Ignore errors.
                    return {};
                });
            }).then(function (gradeInfo) {
                // Retake marked, now return the response. We won't return all the possible data.
                // This code is based in Moodle's process_eol_page.
                var result = {
                    data: {},
                    messages: [],
                    warnings: []
                }, promises = [];
                var gradeLesson = true, messageParams, entryData;
                _this.addResultValueEolPage(result, 'offline', true); // Mark the result as offline.
                _this.addResultValueEolPage(result, 'gradeinfo', gradeInfo);
                if (lesson.custom && !accessInfo.canmanage) {
                    /* Before we calculate the custom score make sure they answered the minimum number of questions.
                       We only need to do this for custom scoring as we can not get the miniumum score the user should achieve.
                       If we are not using custom scoring (so all questions are valued as 1) then we simply check if they
                       answered more than the minimum questions, if not, we mark it out of the number specified in the minimum
                       questions setting - which is done in lesson_grade(). */
                    // Get the number of answers given.
                    if (gradeInfo.nquestions < lesson.minquestions) {
                        gradeLesson = false;
                        messageParams = {
                            nquestions: gradeInfo.nquestions,
                            minquestions: lesson.minquestions
                        };
                        _this.addMessage(result.messages, 'addon.mod_lesson.numberofpagesviewednotice', { $a: messageParams });
                    }
                }
                if (!accessInfo.canmanage) {
                    if (gradeLesson) {
                        promises.push(_this.calculateProgress(lesson.id, accessInfo, password, review, undefined, siteId)
                            .then(function (progress) {
                            _this.addResultValueEolPage(result, 'progresscompleted', progress);
                        }));
                        if (gradeInfo.attempts) {
                            // User has answered questions.
                            if (!lesson.custom) {
                                _this.addResultValueEolPage(result, 'numberofpagesviewed', gradeInfo.nquestions, true);
                                if (lesson.minquestions) {
                                    if (gradeInfo.nquestions < lesson.minquestions) {
                                        _this.addResultValueEolPage(result, 'youshouldview', lesson.minquestions, true);
                                    }
                                }
                                _this.addResultValueEolPage(result, 'numberofcorrectanswers', gradeInfo.earned, true);
                            }
                            entryData = {
                                score: gradeInfo.earned,
                                grade: gradeInfo.total
                            };
                            if (gradeInfo.nmanual) {
                                entryData.tempmaxgrade = gradeInfo.total - gradeInfo.manualpoints;
                                entryData.essayquestions = gradeInfo.nmanual;
                                _this.addResultValueEolPage(result, 'displayscorewithessays', entryData, true);
                            }
                            else {
                                _this.addResultValueEolPage(result, 'displayscorewithoutessays', entryData, true);
                            }
                            if (lesson.grade != __WEBPACK_IMPORTED_MODULE_8__core_grades_providers_grades__["a" /* CoreGradesProvider */].TYPE_NONE) {
                                entryData = {
                                    grade: _this.textUtils.roundToDecimals(gradeInfo.grade * lesson.grade / 100, 1),
                                    total: lesson.grade
                                };
                                _this.addResultValueEolPage(result, 'yourcurrentgradeisoutof', entryData, true);
                            }
                        }
                        else {
                            // User hasn't answered any question, only content pages.
                            if (lesson.timelimit) {
                                if (outOfTime) {
                                    _this.addResultValueEolPage(result, 'eolstudentoutoftimenoanswers', true, true);
                                }
                            }
                            else {
                                _this.addResultValueEolPage(result, 'welldone', true, true);
                            }
                        }
                    }
                }
                else {
                    // Display for teacher.
                    if (lesson.grade != __WEBPACK_IMPORTED_MODULE_8__core_grades_providers_grades__["a" /* CoreGradesProvider */].TYPE_NONE) {
                        _this.addResultValueEolPage(result, 'displayofgrade', true, true);
                    }
                }
                if (lesson.modattempts && accessInfo.canmanage) {
                    _this.addResultValueEolPage(result, 'modattemptsnoteacher', true, true);
                }
                if (gradeLesson) {
                    _this.addResultValueEolPage(result, 'gradelesson', 1);
                }
                return result;
            });
        }
        return this.finishRetakeOnline(lesson.id, password, outOfTime, review, siteId).then(function (response) {
            _this.eventsProvider.trigger(AddonModLessonProvider_1.DATA_SENT_EVENT, {
                lessonId: lesson.id,
                type: 'finish',
                courseId: courseId,
                outOfTime: outOfTime,
                review: review
            }, _this.sitesProvider.getCurrentSiteId());
            return response;
        });
    };
    /**
     * Finishes a retake. It will fail if offline or cannot connect.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [outOfTime] If the user ran out of time.
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModLessonProvider.prototype.finishRetakeOnline = function (lessonId, password, outOfTime, review, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: lessonId,
                outoftime: outOfTime ? 1 : 0,
                review: review ? 1 : 0
            };
            if (typeof password == 'string') {
                params.password = password;
            }
            return site.write('mod_lesson_finish_attempt', params).then(function (response) {
                // Convert the data array into an object and decode the values.
                var map = {};
                response.data.forEach(function (entry) {
                    if (entry.value && typeof entry.value == 'string' && entry.value !== '1') {
                        // It's a JSON encoded object. Try to decode it.
                        entry.value = _this.textUtils.parseJSON(entry.value);
                    }
                    map[entry.name] = entry;
                });
                response.data = map;
                return response;
            });
        });
    };
    /**
     * Get the access information of a certain lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the access information.
     */
    AddonModLessonProvider.prototype.getAccessInformation = function (lessonId, forceCache, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: lessonId
            }, preSets = {
                cacheKey: _this.getAccessInformationCacheKey(lessonId)
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_lesson_access_information', params, preSets);
        });
    };
    /**
     * Get cache key for access information WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getAccessInformationCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'accessInfo:' + lessonId;
    };
    /**
     * Get content pages viewed in online and offline.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{online: any[], offline: any[]}>} Promise resolved with an object with the online and offline viewed pages.
     */
    AddonModLessonProvider.prototype.getContentPagesViewed = function (lessonId, retake, siteId) {
        var promises = [], type = AddonModLessonProvider_1.TYPE_STRUCTURE, result = {
            online: [],
            offline: []
        };
        // Get the online pages.
        promises.push(this.getContentPagesViewedOnline(lessonId, retake, false, false, siteId).then(function (pages) {
            result.online = pages;
        }));
        // Get the offline pages.
        promises.push(this.lessonOfflineProvider.getRetakeAttemptsForType(lessonId, retake, type, siteId).catch(function () {
            return [];
        }).then(function (pages) {
            result.offline = pages;
        }));
        return Promise.all(promises).then(function () {
            return result;
        });
    };
    /**
     * Get cache key for get content pages viewed WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getContentPagesViewedCacheKey = function (lessonId, retake) {
        return this.getContentPagesViewedCommonCacheKey(lessonId) + ':' + retake;
    };
    /**
     * Get common cache key for get content pages viewed WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getContentPagesViewedCommonCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'contentPagesViewed:' + lessonId;
    };
    /**
     * Get IDS of content pages viewed in online and offline.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number[]>} Promise resolved with list of IDs.
     */
    AddonModLessonProvider.prototype.getContentPagesViewedIds = function (lessonId, retake, siteId) {
        return this.getContentPagesViewed(lessonId, retake, siteId).then(function (result) {
            var ids = {}, pages = result.online.concat(result.offline);
            pages.forEach(function (page) {
                if (!ids[page.pageid]) {
                    ids[page.pageid] = true;
                }
            });
            return Object.keys(ids).map(function (id) {
                return Number(id);
            });
        });
    };
    /**
     * Get the list of content pages viewed in the site for a certain retake.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the viewed pages.
     */
    AddonModLessonProvider.prototype.getContentPagesViewedOnline = function (lessonId, retake, forceCache, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: lessonId,
                lessonattempt: retake
            }, preSets = {
                cacheKey: _this.getContentPagesViewedCacheKey(lessonId, retake)
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_content_pages_viewed', params, preSets).then(function (result) {
                return result.pages;
            });
        });
    };
    /**
     * Get the last content page viewed.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the last content page viewed.
     */
    AddonModLessonProvider.prototype.getLastContentPageViewed = function (lessonId, retake, siteId) {
        return this.getContentPagesViewed(lessonId, retake, siteId).then(function (data) {
            var lastPage, maxTime = 0;
            data.online.forEach(function (page) {
                if (page.timeseen > maxTime) {
                    lastPage = page;
                    maxTime = page.timeseen;
                }
            });
            data.offline.forEach(function (page) {
                if (page.timemodified > maxTime) {
                    lastPage = page;
                    maxTime = page.timemodified;
                }
            });
            return lastPage;
        }).catch(function () {
            // Error getting last page, don't return anything.
        });
    };
    /**
     * Get the last page seen.
     * Based on Moodle's get_last_page_seen.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the last page seen.
     */
    AddonModLessonProvider.prototype.getLastPageSeen = function (lessonId, retake, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var lastPageSeen;
        // Get the last question answered.
        return this.lessonOfflineProvider.getLastQuestionPageAttempt(lessonId, retake, siteId).then(function (answer) {
            if (answer) {
                lastPageSeen = answer.newpageid;
            }
            // Now get the last content page viewed.
            return _this.getLastContentPageViewed(lessonId, retake, siteId).then(function (page) {
                if (page) {
                    if (answer) {
                        if (page.timemodified > answer.timemodified) {
                            // This content page was viewed more recently than the question page.
                            lastPageSeen = page.newpageid || page.pageid;
                        }
                    }
                    else {
                        // Has not answered any questions but has viewed a content page.
                        lastPageSeen = page.newpageid || page.pageid;
                    }
                }
                return lastPageSeen;
            });
        });
    };
    /**
     * Get a Lesson by module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmid Course module ID.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the lesson is retrieved.
     */
    AddonModLessonProvider.prototype.getLesson = function (courseId, cmId, forceCache, ignoreCache, siteId) {
        return this.getLessonByField(courseId, 'coursemodule', cmId, forceCache, ignoreCache, siteId);
    };
    /**
     * Get a Lesson with key=value. If more than one is found, only the first will be returned.
     *
     * @param {number} courseId Course ID.
     * @param {string} key Name of the property to check.
     * @param {any} value Value to search.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the lesson is retrieved.
     */
    AddonModLessonProvider.prototype.getLessonByField = function (courseId, key, value, forceCache, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getLessonDataCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_lessons_by_courses', params, preSets).then(function (response) {
                if (response && response.lessons) {
                    var currentLesson = response.lessons.find(function (lesson) {
                        return lesson[key] == value;
                    });
                    if (currentLesson) {
                        return currentLesson;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a Lesson by lesson ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} id Lesson ID.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the lesson is retrieved.
     */
    AddonModLessonProvider.prototype.getLessonById = function (courseId, id, forceCache, ignoreCache, siteId) {
        return this.getLessonByField(courseId, 'id', id, forceCache, ignoreCache, siteId);
    };
    /**
     * Get cache key for Lesson data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getLessonDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'lesson:' + courseId;
    };
    /**
     * Get a lesson protected with password.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [password] Password.
     * @param {boolean} [validatePassword=true] If true, the function will fail if the password is wrong.
     *                                          If false, it will return a lesson with the basic data if password is wrong.
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the lesson.
     */
    AddonModLessonProvider.prototype.getLessonWithPassword = function (lessonId, password, validatePassword, forceCache, ignoreCache, siteId) {
        var _this = this;
        if (validatePassword === void 0) { validatePassword = true; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: lessonId
            }, preSets = {
                cacheKey: _this.getLessonWithPasswordCacheKey(lessonId)
            };
            if (typeof password == 'string') {
                params.password = password;
            }
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_lesson', params, preSets).then(function (response) {
                if (typeof response.lesson.ongoing == 'undefined') {
                    // Basic data not received, password is wrong. Remove stored password.
                    _this.removeStoredPassword(lessonId, site.id);
                    if (validatePassword) {
                        // Invalidate the data and reject.
                        return _this.invalidateLessonWithPassword(lessonId, site.id).catch(function () {
                            // Shouldn't happen.
                        }).then(function () {
                            return Promise.reject(_this.translate.instant('addon.mod_lesson.loginfail'));
                        });
                    }
                }
                return response.lesson;
            });
        });
    };
    /**
     * Get cache key for get lesson with password WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getLessonWithPasswordCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'lessonWithPswrd:' + lessonId;
    };
    /**
     * Given a page ID, a jumpto and all the possible jumps, calcualate the new page ID.
     *
     * @param {number} pageId Current page ID.
     * @param {number} jumpTo The jumpto.
     * @param {any} jumps Result of get pages possible jumps.
     * @return {number} New page ID.
     */
    AddonModLessonProvider.prototype.getNewPageId = function (pageId, jumpTo, jumps) {
        // If jump not found, return current jumpTo.
        if (jumps && jumps[pageId] && jumps[pageId][jumpTo]) {
            return jumps[pageId][jumpTo].calculatedjump;
        }
        else if (!jumpTo) {
            // Return current page.
            return pageId;
        }
        return jumpTo;
    };
    /**
     * Get the ongoing score message for the user (depending on the user permission and lesson settings).
     *
     * @param {any} lesson Lesson.
     * @param {any} accessInfo Result of get access info.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {any} [pageIndex] Object containing all the pages indexed by ID. If not provided, it will be calculated.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the ongoing score message.
     */
    AddonModLessonProvider.prototype.getOngoingScoreMessage = function (lesson, accessInfo, password, review, pageIndex, siteId) {
        var _this = this;
        if (accessInfo.canmanage) {
            return Promise.resolve(this.translate.instant('addon.mod_lesson.teacherongoingwarning'));
        }
        else {
            var retake = accessInfo.attemptscount;
            if (review) {
                retake--;
            }
            return this.lessonGrade(lesson, retake, password, review, pageIndex, siteId).then(function (gradeInfo) {
                var data = {};
                if (lesson.custom) {
                    data.score = gradeInfo.earned;
                    data.currenthigh = gradeInfo.total;
                    return _this.translate.instant('addon.mod_lesson.ongoingcustom', { $a: data });
                }
                else {
                    data.correct = gradeInfo.earned;
                    data.viewed = gradeInfo.attempts;
                    return _this.translate.instant('addon.mod_lesson.ongoingnormal', { $a: data });
                }
            });
        }
    };
    /**
     * Get the possible answers from a page.
     *
     * @param {any} lesson Lesson.
     * @param {number} pageId Page ID.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the list of possible answers.
     */
    AddonModLessonProvider.prototype.getPageAnswers = function (lesson, pageId, password, review, siteId) {
        return this.getPageData(lesson, pageId, password, review, true, true, false, undefined, undefined, siteId).then(function (data) {
            return data.answers;
        });
    };
    /**
     * Get all the possible answers from a list of pages, indexed by answerId.
     *
     * @param {any} lesson Lesson.
     * @param {number[]} pageIds List of page IDs.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with an object containing the answers.
     */
    AddonModLessonProvider.prototype.getPagesAnswers = function (lesson, pageIds, password, review, siteId) {
        var _this = this;
        var answers = {}, promises = [];
        pageIds.forEach(function (pageId) {
            promises.push(_this.getPageAnswers(lesson, pageId, password, review, siteId).then(function (pageAnswers) {
                pageAnswers.forEach(function (answer) {
                    // Include the pageid in each answer and add them to the final list.
                    answer.pageid = pageId;
                    answers[answer.id] = answer;
                });
            }));
        });
        return Promise.all(promises).then(function () {
            return answers;
        });
    };
    /**
     * Get page data.
     *
     * @param {any} lesson Lesson.
     * @param {number} pageId Page ID.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {boolean} [includeContents] Include the page rendered contents.
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {any} [accessInfo] Result of get access info. Required if offline is true.
     * @param {any} [jumps] Result of get pages possible jumps. Required if offline is true.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the page data.
     */
    AddonModLessonProvider.prototype.getPageData = function (lesson, pageId, password, review, includeContents, forceCache, ignoreCache, accessInfo, jumps, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: lesson.id,
                pageid: Number(pageId),
                review: review ? 1 : 0,
                returncontents: includeContents ? 1 : 0
            }, preSets = {
                cacheKey: _this.getPageDataCacheKey(lesson.id, pageId)
            };
            if (typeof password == 'string') {
                params.password = password;
            }
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            if (review) {
                // Force online mode in review.
                preSets.getFromCache = false;
                preSets.saveToCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_page_data', params, preSets).then(function (data) {
                if (forceCache && accessInfo && data.page) {
                    // Offline mode and valid page. Calculate the data that might be affected.
                    return _this.calculateOfflineData(lesson, accessInfo, password, review, undefined, siteId).then(function (calcData) {
                        Object.assign(data, calcData);
                        return _this.getPageViewMessages(lesson, accessInfo, data.page, review, jumps, password, siteId);
                    }).then(function (messages) {
                        data.messages = messages;
                        return data;
                    });
                }
                return data;
            });
        });
    };
    /**
     * Get cache key for get page data WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} pageId Page ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getPageDataCacheKey = function (lessonId, pageId) {
        return this.getPageDataCommonCacheKey(lessonId) + ':' + pageId;
    };
    /**
     * Get common cache key for get page data WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getPageDataCommonCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'pageData:' + lessonId;
    };
    /**
     * Get lesson pages.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the pages.
     */
    AddonModLessonProvider.prototype.getPages = function (lessonId, password, forceCache, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: lessonId,
            }, preSets = {
                cacheKey: _this.getPagesCacheKey(lessonId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (typeof password == 'string') {
                params.password = password;
            }
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_pages', params, preSets).then(function (response) {
                return response.pages;
            });
        });
    };
    /**
     * Get cache key for get pages WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getPagesCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'pages:' + lessonId;
    };
    /**
     * Get possible jumps for a lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the jumps.
     */
    AddonModLessonProvider.prototype.getPagesPossibleJumps = function (lessonId, forceCache, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: lessonId,
            }, preSets = {
                cacheKey: _this.getPagesPossibleJumpsCacheKey(lessonId)
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_pages_possible_jumps', params, preSets).then(function (response) {
                // Index the jumps by page and jumpto.
                if (response.jumps) {
                    var jumps_1 = {};
                    response.jumps.forEach(function (jump) {
                        if (typeof jumps_1[jump.pageid] == 'undefined') {
                            jumps_1[jump.pageid] = {};
                        }
                        jumps_1[jump.pageid][jump.jumpto] = jump;
                    });
                    return jumps_1;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get pages possible jumps WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getPagesPossibleJumpsCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'pagesJumps:' + lessonId;
    };
    /**
     * Get different informative messages when processing a lesson page.
     * Please try to use WS response messages instead of this function if possible.
     * Based on Moodle's add_messages_on_page_process.
     *
     * @param {any} lesson Lesson.
     * @param {any} accessInfo Result of get access info.
     * @param {any} result Result of process page.
     * @param {boolean} review If the user wants to review just after finishing (1 hour margin).
     * @param {any} jumps Result of get pages possible jumps.
     * @return {any[]} Array with the messages.
     */
    AddonModLessonProvider.prototype.getPageProcessMessages = function (lesson, accessInfo, result, review, jumps) {
        var messages = [];
        if (accessInfo.canmanage) {
            // Warning for teachers to inform them that cluster and unseen does not work while logged in as a teacher.
            if (this.lessonDisplayTeacherWarning(jumps)) {
                this.addMessage(messages, 'addon.mod_lesson.teacherjumpwarning', { $a: {
                        cluster: this.translate.instant('addon.mod_lesson.clusterjump'),
                        unseen: this.translate.instant('addon.mod_lesson.unseenpageinbranch')
                    } });
            }
            // Inform teacher that s/he will not see the timer.
            if (lesson.timelimit) {
                this.addMessage(messages, 'addon.mod_lesson.teachertimerwarning');
            }
        }
        // Report attempts remaining.
        if (result.attemptsremaining > 0 && lesson.review && !review) {
            this.addMessage(messages, 'addon.mod_lesson.attemptsremaining', { $a: result.attemptsremaining });
        }
        return messages;
    };
    /**
     * Get the IDs of all the pages that have at least 1 question attempt.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {boolean} [correct] True to only fetch correct attempts, false to get them all.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, site's user.
     * @return {Promise<number[]>} Promise resolved with the IDs.
     */
    AddonModLessonProvider.prototype.getPagesIdsWithQuestionAttempts = function (lessonId, retake, correct, siteId, userId) {
        return this.getQuestionsAttempts(lessonId, retake, correct, undefined, siteId, userId).then(function (result) {
            var ids = {}, attempts = result.online.concat(result.offline);
            attempts.forEach(function (attempt) {
                if (!ids[attempt.pageid]) {
                    ids[attempt.pageid] = true;
                }
            });
            return Object.keys(ids).map(function (id) {
                return Number(id);
            });
        });
    };
    /**
     * Get different informative messages when viewing a lesson page.
     * Please try to use WS response messages instead of this function if possible.
     * Based on Moodle's add_messages_on_page_view.
     *
     * @param {any} lesson Lesson.
     * @param {any} accessInfo Result of get access info. Required if offline is true.
     * @param {any} page Page loaded.
     * @param {boolean} review If the user wants to review just after finishing (1 hour margin).
     * @param {any} jumps Result of get pages possible jumps.
     * @param {string} [password] Lesson password (if any).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of messages.
     */
    AddonModLessonProvider.prototype.getPageViewMessages = function (lesson, accessInfo, page, review, jumps, password, siteId) {
        var _this = this;
        var messages = [];
        var promise = Promise.resolve();
        if (!accessInfo.canmanage) {
            if (page.qtype == AddonModLessonProvider_1.LESSON_PAGE_BRANCHTABLE && lesson.minquestions) {
                // Tell student how many questions they have seen, how many are required and their grade.
                var retake = accessInfo.attemptscount;
                promise = this.lessonGrade(lesson, retake, password, review, undefined, siteId).then(function (gradeInfo) {
                    if (gradeInfo.attempts) {
                        if (gradeInfo.nquestions < lesson.minquestions) {
                            _this.addMessage(messages, 'addon.mod_lesson.numberofpagesviewednotice', { $a: {
                                    nquestions: gradeInfo.nquestions,
                                    minquestions: lesson.minquestions
                                } });
                        }
                        if (!review && !lesson.retake) {
                            _this.addMessage(messages, 'addon.mod_lesson.numberofcorrectanswers', { $a: gradeInfo.earned });
                            if (lesson.grade != __WEBPACK_IMPORTED_MODULE_8__core_grades_providers_grades__["a" /* CoreGradesProvider */].TYPE_NONE) {
                                _this.addMessage(messages, 'addon.mod_lesson.yourcurrentgradeisoutof', { $a: {
                                        grade: _this.textUtils.roundToDecimals(gradeInfo.grade * lesson.grade / 100, 1),
                                        total: lesson.grade
                                    } });
                            }
                        }
                    }
                }).catch(function () {
                    // Ignore errors.
                });
            }
        }
        else {
            if (lesson.timelimit) {
                this.addMessage(messages, 'addon.mod_lesson.teachertimerwarning');
            }
            if (this.lessonDisplayTeacherWarning(jumps)) {
                // Warning for teachers to inform them that cluster and unseen does not work while logged in as a teacher.
                this.addMessage(messages, 'addon.mod_lesson.teacherjumpwarning', { $a: {
                        cluster: this.translate.instant('addon.mod_lesson.clusterjump'),
                        unseen: this.translate.instant('addon.mod_lesson.unseenpageinbranch')
                    } });
            }
        }
        return promise.then(function () {
            return messages;
        });
    };
    /**
     * Get questions attempts, including offline attempts.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {boolean} [correct] True to only fetch correct attempts, false to get them all.
     * @param {number} [pageId] If defined, only get attempts on this page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, site's user.
     * @return {Promise<{online: any[], offline: any[]}>} Promise resolved with the questions attempts.
     */
    AddonModLessonProvider.prototype.getQuestionsAttempts = function (lessonId, retake, correct, pageId, siteId, userId) {
        var promises = [], result = {
            online: [],
            offline: []
        };
        promises.push(this.getQuestionsAttemptsOnline(lessonId, retake, correct, pageId, false, false, siteId, userId)
            .then(function (attempts) {
            result.online = attempts;
        }));
        promises.push(this.lessonOfflineProvider.getQuestionsAttempts(lessonId, retake, correct, pageId, siteId).catch(function () {
            // Error, assume no attempts.
            return [];
        }).then(function (attempts) {
            result.offline = attempts;
        }));
        return Promise.all(promises).then(function () {
            return result;
        });
    };
    /**
     * Get cache key for get questions attempts WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getQuestionsAttemptsCacheKey = function (lessonId, retake, userId) {
        return this.getQuestionsAttemptsCommonCacheKey(lessonId) + ':' + userId + ':' + retake;
    };
    /**
     * Get common cache key for get questions attempts WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getQuestionsAttemptsCommonCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'questionsAttempts:' + lessonId;
    };
    /**
     * Get questions attempts from the site.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {boolean} [correct] True to only fetch correct attempts, false to get them all.
     * @param {number} [pageId] If defined, only get attempts on this page.
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, site's user.
     * @return {Promise<any[]>} Promise resolved with the questions attempts.
     */
    AddonModLessonProvider.prototype.getQuestionsAttemptsOnline = function (lessonId, retake, correct, pageId, forceCache, ignoreCache, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            // Don't pass "pageId" and "correct" params, they will be filtered locally.
            var params = {
                lessonid: lessonId,
                attempt: retake,
                userid: userId
            }, preSets = {
                cacheKey: _this.getQuestionsAttemptsCacheKey(lessonId, retake, userId)
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_questions_attempts', params, preSets).then(function (response) {
                if (pageId || correct) {
                    // Filter the attempts.
                    return response.attempts.filter(function (attempt) {
                        if (correct && !attempt.correct) {
                            return false;
                        }
                        if (pageId && attempt.pageid != pageId) {
                            return false;
                        }
                        return true;
                    });
                }
                return response.attempts;
            });
        });
    };
    /**
     * Get the overview of retakes in a lesson (named "attempts overview" in Moodle).
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} [groupId] The group to get. If not defined, all participants.
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the retakes overview.
     */
    AddonModLessonProvider.prototype.getRetakesOverview = function (lessonId, groupId, forceCache, ignoreCache, siteId) {
        var _this = this;
        groupId = groupId || 0;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: lessonId,
                groupid: groupId
            }, preSets = {
                cacheKey: _this.getRetakesOverviewCacheKey(lessonId, groupId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_attempts_overview', params, preSets).then(function (response) {
                return response.data;
            });
        });
    };
    /**
     * Get cache key for get retakes overview WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} groupId Group ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getRetakesOverviewCacheKey = function (lessonId, groupId) {
        return this.getRetakesOverviewCommonCacheKey(lessonId) + ':' + groupId;
    };
    /**
     * Get common cache key for get retakes overview WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getRetakesOverviewCommonCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'retakesOverview:' + lessonId;
    };
    /**
     * Get a password stored in DB.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with password on success, rejected otherwise.
     */
    AddonModLessonProvider.prototype.getStoredPassword = function (lessonId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(AddonModLessonProvider_1.PASSWORD_TABLE, { lessonid: lessonId }).then(function (entry) {
                return entry.password;
            });
        });
    };
    /**
     * Finds all pages that appear to be a subtype of the provided pageId until an end point specified within "ends" is
     * encountered or no more pages exist.
     * Based on Moodle's get_sub_pages_of.
     *
     * @param {any} pages Index of lesson pages, indexed by page ID. See createPagesIndex.
     * @param {number} pageId Page ID to get subpages of.
     * @param {number[]} end An array of LESSON_PAGE_* types that signify an end of the subtype.
     * @return {Object[]} List of subpages.
     */
    AddonModLessonProvider.prototype.getSubpagesOf = function (pages, pageId, ends) {
        var subPages = [];
        pageId = pages[pageId].nextpageid; // Move to the first page after the given page.
        ends = ends || [];
        while (true) {
            if (!pageId || ends.indexOf(pages[pageId].qtype) != -1) {
                // No more pages or it reached a page of the searched types. Stop.
                break;
            }
            subPages.push(pages[pageId]);
            pageId = pages[pageId].nextpageid;
        }
        return subPages;
    };
    /**
     * Get lesson timers.
     *
     * @param {number} lessonId Lesson ID.
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @return {Promise<any[]>} Promise resolved with the pages.
     */
    AddonModLessonProvider.prototype.getTimers = function (lessonId, forceCache, ignoreCache, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                lessonid: lessonId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getTimersCacheKey(lessonId, userId)
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_user_timers', params, preSets).then(function (response) {
                return response.timers;
            });
        });
    };
    /**
     * Get cache key for get timers WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getTimersCacheKey = function (lessonId, userId) {
        return this.getTimersCommonCacheKey(lessonId) + ':' + userId;
    };
    /**
     * Get common cache key for get timers WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getTimersCommonCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'timers:' + lessonId;
    };
    /**
     * Get the list of used answers (with valid answer) in a multichoice question page.
     *
     * @param {any} pageData Result of getPageData for the page to process.
     * @return {any[]} List of used answers.
     */
    AddonModLessonProvider.prototype.getUsedAnswersMultichoice = function (pageData) {
        var answers = this.utils.clone(pageData.answers);
        return answers.filter(function (entry) {
            return entry.answer !== '';
        });
    };
    /**
     * Get the user's response in a matching question page.
     *
     * @param {any} data Data containing the user answer.
     * @return {any} User response.
     */
    AddonModLessonProvider.prototype.getUserResponseMatching = function (data) {
        if (data.response) {
            // The data is already stored as expected. Return it.
            return data.response;
        }
        // Data is stored in properties like 'response[379]'. Recreate the response object.
        var response = {};
        for (var key in data) {
            var match = key.match(/^response\[(\d+)\]/);
            if (match && match.length > 1) {
                response[match[1]] = data[key];
            }
        }
        return response;
    };
    /**
     * Get the user's response in a multichoice page if multiple answers are allowed.
     *
     * @param {any} data Data containing the user answer.
     * @return {any[]} User response.
     */
    AddonModLessonProvider.prototype.getUserResponseMultichoice = function (data) {
        if (data.answer) {
            // The data is already stored as expected. If it's valid, parse the values to int.
            if (Array.isArray(data.answer)) {
                return data.answer.map(function (value) {
                    return parseInt(value, 10);
                });
            }
            return data.answer;
        }
        // Data is stored in properties like 'answer[379]'. Recreate the answer array.
        var answer = [];
        for (var key in data) {
            var match = key.match(/^answer\[(\d+)\]/);
            if (match && match.length > 1) {
                answer.push(parseInt(match[1], 10));
            }
        }
        return answer;
    };
    /**
     * Get a user's retake.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number
     * @param {number} [userId] User ID. Undefined for current user.
     * @param {boolean} [forceCache] Whether it should always return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the retake data.
     */
    AddonModLessonProvider.prototype.getUserRetake = function (lessonId, retake, userId, forceCache, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                lessonid: lessonId,
                userid: userId,
                lessonattempt: retake
            }, preSets = {
                cacheKey: _this.getUserRetakeCacheKey(lessonId, userId, retake),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_lesson_get_user_attempt', params, preSets);
        });
    };
    /**
     * Get cache key for get user retake WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} userId User ID.
     * @param {number} retake Retake number
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getUserRetakeCacheKey = function (lessonId, userId, retake) {
        return this.getUserRetakeUserCacheKey(lessonId, userId) + ':' + retake;
    };
    /**
     * Get user cache key for get user retake WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getUserRetakeUserCacheKey = function (lessonId, userId) {
        return this.getUserRetakeLessonCacheKey(lessonId) + ':' + userId;
    };
    /**
     * Get lesson cache key for get user retake WS calls.
     *
     * @param {number} lessonId Lesson ID.
     * @return {string} Cache key.
     */
    AddonModLessonProvider.prototype.getUserRetakeLessonCacheKey = function (lessonId) {
        return this.ROOT_CACHE_KEY + 'userRetake:' + lessonId;
    };
    /**
     * Get the prevent access reason to display for a certain lesson.
     *
     * @param {any} info Lesson access info.
     * @param {boolean} [ignorePassword] Whether password protected reason should be ignored (user already entered the password).
     * @param {boolean} [isReview] Whether user is reviewing a retake.
     * @return {any} Prevent access reason.
     */
    AddonModLessonProvider.prototype.getPreventAccessReason = function (info, ignorePassword, isReview) {
        var result;
        if (info && info.preventaccessreasons) {
            for (var i = 0; i < info.preventaccessreasons.length; i++) {
                var entry = info.preventaccessreasons[i];
                if (entry.reason == 'lessonopen' || entry.reason == 'lessonclosed') {
                    // Time restrictions are the most prioritary, return it.
                    return entry;
                }
                else if (entry.reason == 'passwordprotectedlesson') {
                    if (!ignorePassword) {
                        // Treat password before all other reasons.
                        result = entry;
                    }
                }
                else if (entry.reason == 'noretake' && isReview) {
                    // Ignore noretake error when reviewing.
                }
                else if (!result) {
                    // Rest of cases, just return any of them.
                    result = entry;
                }
            }
        }
        return result;
    };
    /**
     * Check if a jump is correct.
     * Based in Moodle's jumpto_is_correct.
     *
     * @param {number} pageId ID of the page from which you are jumping from.
     * @param {number} jumpTo The jumpto number.
     * @param {any} pageIndex Object containing all the pages indexed by ID. See createPagesIndex.
     * @return {boolean} Whether jump is correct.
     */
    AddonModLessonProvider.prototype.jumptoIsCorrect = function (pageId, jumpTo, pageIndex) {
        // First test the special values.
        if (!jumpTo) {
            // Same page
            return false;
        }
        else if (jumpTo == AddonModLessonProvider_1.LESSON_NEXTPAGE) {
            return true;
        }
        else if (jumpTo == AddonModLessonProvider_1.LESSON_UNSEENBRANCHPAGE) {
            return true;
        }
        else if (jumpTo == AddonModLessonProvider_1.LESSON_RANDOMPAGE) {
            return true;
        }
        else if (jumpTo == AddonModLessonProvider_1.LESSON_CLUSTERJUMP) {
            return true;
        }
        else if (jumpTo == AddonModLessonProvider_1.LESSON_EOL) {
            return true;
        }
        var aPageId = pageIndex[pageId].nextpageid;
        while (aPageId) {
            if (jumpTo == aPageId) {
                return true;
            }
            aPageId = pageIndex[aPageId].nextpageid;
        }
        return false;
    };
    /**
     * Invalidates Lesson data.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateAccessInformation = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAccessInformationCacheKey(lessonId));
        });
    };
    /**
     * Invalidates content pages viewed for all retakes.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateContentPagesViewed = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getContentPagesViewedCommonCacheKey(lessonId));
        });
    };
    /**
     * Invalidates content pages viewed for a certain retake.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateContentPagesViewedForRetake = function (lessonId, retake, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getContentPagesViewedCacheKey(lessonId, retake));
        });
    };
    /**
     * Invalidates Lesson data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateLessonData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getLessonDataCacheKey(courseId));
        });
    };
    /**
     * Invalidates lesson with password.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateLessonWithPassword = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getLessonWithPasswordCacheKey(lessonId));
        });
    };
    /**
     * Invalidates page data for all pages.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidatePageData = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getPageDataCommonCacheKey(lessonId));
        });
    };
    /**
     * Invalidates page data for a certain page.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} pageId Page ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidatePageDataForPage = function (lessonId, pageId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getPageDataCacheKey(lessonId, pageId));
        });
    };
    /**
     * Invalidates pages.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidatePages = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getPagesCacheKey(lessonId));
        });
    };
    /**
     * Invalidates pages possible jumps.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidatePagesPossibleJumps = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getPagesPossibleJumpsCacheKey(lessonId));
        });
    };
    /**
     * Invalidates questions attempts for all retakes.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateQuestionsAttempts = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getQuestionsAttemptsCommonCacheKey(lessonId));
        });
    };
    /**
     * Invalidates question attempts for a certain retake and user.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site..
     * @param {number} [userId] User ID. If not defined, site's user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateQuestionsAttemptsForRetake = function (lessonId, retake, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getQuestionsAttemptsCacheKey(lessonId, retake, userId));
        });
    };
    /**
     * Invalidates retakes overview for all groups in a lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateRetakesOverview = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getRetakesOverviewCommonCacheKey(lessonId));
        });
    };
    /**
     * Invalidates retakes overview for a certain group in a lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} groupId Group ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateRetakesOverviewForGroup = function (lessonId, groupId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getRetakesOverviewCacheKey(lessonId, groupId));
        });
    };
    /**
     * Invalidates timers for all users in a lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateTimers = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getTimersCommonCacheKey(lessonId));
        });
    };
    /**
     * Invalidates timers for a certain user.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateTimersForUser = function (lessonId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getTimersCacheKey(lessonId, userId));
        });
    };
    /**
     * Invalidates a certain retake for a certain user.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {number} [userId] User ID. Undefined for current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateUserRetake = function (lessonId, retake, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getUserRetakeCacheKey(lessonId, userId, retake));
        });
    };
    /**
     * Invalidates all retakes for all users in a lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateUserRetakesForLesson = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserRetakeLessonCacheKey(lessonId));
        });
    };
    /**
     * Invalidates all retakes for a certain user in a lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} [userId] User ID. Undefined for current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonProvider.prototype.invalidateUserRetakesForUser = function (lessonId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserRetakeUserCacheKey(lessonId, userId));
        });
    };
    /**
     * Check if a page answer is correct.
     *
     * @param {any} lesson Lesson.
     * @param {number} pageId The page ID.
     * @param {any} answer The answer to check.
     * @param {any} pageIndex Object containing all the pages indexed by ID.
     * @return {boolean} Whether the answer is correct.
     */
    AddonModLessonProvider.prototype.isAnswerCorrect = function (lesson, pageId, answer, pageIndex) {
        if (lesson.custom) {
            // Custom scores. If score on answer is positive, it is correct.
            return answer.score > 0;
        }
        else {
            return this.jumptoIsCorrect(pageId, answer.jumpto, pageIndex);
        }
    };
    /**
     * Check if a lesson is enabled to be used in offline.
     *
     * @param {any} lesson Lesson.
     * @return {boolean} Whether offline is enabled.
     */
    AddonModLessonProvider.prototype.isLessonOffline = function (lesson) {
        return !!lesson.allowofflineattempts;
    };
    /**
     * Check if a lesson is password protected based in the access info.
     *
     * @param {any} info Lesson access info.
     * @return {boolean} Whether the lesson is password protected.
     */
    AddonModLessonProvider.prototype.isPasswordProtected = function (info) {
        if (info && info.preventaccessreasons) {
            for (var i = 0; i < info.preventaccessreasons.length; i++) {
                var entry = info.preventaccessreasons[i];
                if (entry.reason == 'passwordprotectedlesson') {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the lesson WS are available.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonModLessonProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // All WS were introduced at the same time so checking one is enough.
            return site.wsAvailable('mod_lesson_get_lesson_access_information');
        });
    };
    /**
     * Check if a page is a question page or a content page.
     *
     * @param {number} type Type of the page.
     * @return {boolean} True if question page, false if content page.
     */
    AddonModLessonProvider.prototype.isQuestionPage = function (type) {
        return type == AddonModLessonProvider_1.TYPE_QUESTION;
    };
    /**
     * Start or continue a retake.
     *
     * @param {string} id Lesson ID.
     * @param {string} [password] Lesson password (if any).
     * @param {number} [pageId] Page id to continue from (only when continuing a retake).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModLessonProvider.prototype.launchRetake = function (id, password, pageId, review, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: id,
                review: review ? 1 : 0
            };
            if (typeof password == 'string') {
                params.password = password;
            }
            if (typeof pageId == 'number') {
                params.pageid = pageId;
            }
            return site.write('mod_lesson_launch_attempt', params).then(function (response) {
                _this.eventsProvider.trigger(AddonModLessonProvider_1.DATA_SENT_EVENT, {
                    lessonId: id,
                    type: 'launch'
                }, _this.sitesProvider.getCurrentSiteId());
                return response;
            });
        });
    };
    /**
     * Check if the user left during a timed session.
     *
     * @param {any} info Lesson access info.
     * @return {boolean} True if left during timed, false otherwise.
     */
    AddonModLessonProvider.prototype.leftDuringTimed = function (info) {
        return info && info.lastpageseen && info.lastpageseen != AddonModLessonProvider_1.LESSON_EOL && info.leftduringtimedsession;
    };
    /**
     * Checks to see if a LESSON_CLUSTERJUMP or a LESSON_UNSEENBRANCHPAGE is used in a lesson.
     * Based on Moodle's lesson_display_teacher_warning.
     *
     * @param {any} jumps Result of get pages possible jumps.
     * @return {boolean} Whether the lesson uses one of those jumps.
     */
    AddonModLessonProvider.prototype.lessonDisplayTeacherWarning = function (jumps) {
        if (!jumps) {
            return false;
        }
        // Check if any jump is to cluster or unseen content page.
        for (var pageId in jumps) {
            for (var jumpto in jumps[pageId]) {
                var jumptoNum = Number(jumpto);
                if (jumptoNum == AddonModLessonProvider_1.LESSON_CLUSTERJUMP ||
                    jumptoNum == AddonModLessonProvider_1.LESSON_UNSEENBRANCHPAGE) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Calculates a user's grade for a lesson.
     * Based on Moodle's lesson_grade.
     *
     * @param {any} lesson Lesson.
     * @param {number} retake Retake number.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {any} [pageIndex] Object containing all the pages indexed by ID. If not provided, it will be calculated.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, site's user.
     * @return {Promise<AddonModLessonCheckAnswerResult>} Promise resolved with the grade data.
     */
    AddonModLessonProvider.prototype.lessonGrade = function (lesson, retake, password, review, pageIndex, siteId, userId) {
        var _this = this;
        // Initialize all variables.
        var nViewed = 0, nManual = 0, manualPoints = 0, theGrade = 0, nQuestions = 0, total = 0, earned = 0;
        // Get the questions attempts for the user.
        return this.getQuestionsAttempts(lesson.id, retake, false, undefined, siteId, userId).then(function (attemptsData) {
            var attempts = attemptsData.online.concat(attemptsData.offline);
            if (!attempts.length) {
                // No attempts.
                return;
            }
            var attemptSet = {};
            var promise;
            // Create the pageIndex if it isn't provided.
            if (!pageIndex) {
                promise = _this.getPages(lesson.id, password, true, false, siteId).then(function (pages) {
                    pageIndex = _this.createPagesIndex(pages);
                });
            }
            else {
                promise = Promise.resolve();
            }
            return promise.then(function () {
                var pageIds = [];
                // Group each try with its page.
                attempts.forEach(function (attempt) {
                    if (!attemptSet[attempt.pageid]) {
                        attemptSet[attempt.pageid] = [];
                        pageIds.push(attempt.pageid);
                    }
                    attemptSet[attempt.pageid].push(attempt);
                });
                // Drop all attempts that go beyond max attempts for the lesson.
                for (var pageId in attemptSet) {
                    // Sort the list by time in ascending order.
                    var attempts_1 = attemptSet[pageId].sort(function (a, b) {
                        return (a.timeseen || a.timemodified) - (b.timeseen || b.timemodified);
                    });
                    attemptSet[pageId] = attempts_1.slice(0, lesson.maxattempts);
                }
                // Get all the answers from the pages the user answered.
                return _this.getPagesAnswers(lesson, pageIds, password, review, siteId);
            }).then(function (answers) {
                // Number of pages answered.
                nQuestions = Object.keys(attemptSet).length;
                for (var pageId in attemptSet) {
                    var attempts_2 = attemptSet[pageId], lastAttempt = attempts_2[attempts_2.length - 1];
                    if (lesson.custom) {
                        // If essay question, handle it, otherwise add to score.
                        if (pageIndex[lastAttempt.pageid].qtype == AddonModLessonProvider_1.LESSON_PAGE_ESSAY) {
                            if (lastAttempt.useranswer && typeof lastAttempt.useranswer.score != 'undefined') {
                                earned += lastAttempt.useranswer.score;
                            }
                            nManual++;
                            manualPoints += answers[lastAttempt.answerid].score;
                        }
                        else if (lastAttempt.answerid) {
                            earned += answers[lastAttempt.answerid].score;
                        }
                    }
                    else {
                        attempts_2.forEach(function (attempt) {
                            earned += attempt.correct ? 1 : 0;
                        });
                        // If essay question, increase numbers.
                        if (pageIndex[lastAttempt.pageid].qtype == AddonModLessonProvider_1.LESSON_PAGE_ESSAY) {
                            nManual++;
                            manualPoints++;
                        }
                    }
                    // Number of times answered.
                    nViewed += attempts_2.length;
                }
                if (lesson.custom) {
                    var bestScores = {};
                    // Find the highest possible score per page to get our total.
                    for (var answerId in answers) {
                        var answer = answers[answerId];
                        if (typeof bestScores[answer.pageid] == 'undefined') {
                            bestScores[answer.pageid] = answer.score;
                        }
                        else if (bestScores[answer.pageid] < answer.score) {
                            bestScores[answer.pageid] = answer.score;
                        }
                    }
                    // Sum all the scores.
                    for (var pageId in bestScores) {
                        total += bestScores[pageId];
                    }
                }
                else {
                    // Check to make sure the student has answered the minimum questions.
                    if (lesson.minquestions && nQuestions < lesson.minquestions) {
                        // Nope, increase number viewed by the amount of unanswered questions.
                        total = nViewed + (lesson.minquestions - nQuestions);
                    }
                    else {
                        total = nViewed;
                    }
                }
            });
        }).then(function () {
            if (total) {
                theGrade = _this.textUtils.roundToDecimals(earned * 100 / total, 5);
            }
            return {
                nquestions: nQuestions,
                attempts: nViewed,
                total: total,
                earned: earned,
                grade: theGrade,
                nmanual: nManual,
                manualpoints: manualPoints
            };
        });
    };
    /**
     * Report a lesson as being viewed.
     *
     * @param {string} id Module ID.
     * @param {string} [password] Lesson password (if any).
     * @param {string} [name] Name of the assign.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModLessonProvider.prototype.logViewLesson = function (id, password, name, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: id
            };
            if (typeof password == 'string') {
                params.password = password;
            }
            return _this.logHelper.logSingle('mod_lesson_view_lesson', params, AddonModLessonProvider_1.COMPONENT, id, name, 'lesson', {}, siteId);
        });
    };
    /**
     * Process a lesson page, saving its data.
     *
     * @param {any} lesson Lesson.
     * @param {number} courseId Course ID the lesson belongs to.
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {any} data Data to save.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {boolean} [offline] Whether it's offline mode.
     * @param {any} [accessInfo] Result of get access info. Required if offline is true.
     * @param {any} [jumps] Result of get pages possible jumps. Required if offline is true.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonProvider.prototype.processPage = function (lesson, courseId, pageData, data, password, review, offline, accessInfo, jumps, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var page = pageData.page, pageId = page.id;
        var result, pageIndex;
        if (offline) {
            // Get the list of pages of the lesson.
            return this.getPages(lesson.id, password, true, false, siteId).then(function (pages) {
                pageIndex = _this.createPagesIndex(pages);
                if (pageData.answers.length) {
                    return _this.recordAttempt(lesson, courseId, pageData, data, review, accessInfo, jumps, pageIndex, siteId);
                }
                else {
                    // The page has no answers so we will just progress to the next page (as set by newpageid).
                    return {
                        nodefaultresponse: true,
                        newpageid: data.newpageid
                    };
                }
            }).then(function (res) {
                result = res;
                result.newpageid = _this.getNewPageId(pageData.page.id, result.newpageid, jumps);
                // Calculate some needed offline data.
                return _this.calculateOfflineData(lesson, accessInfo, password, review, pageIndex, siteId);
            }).then(function (calculatedData) {
                // Add some default data to match the WS response.
                result.warnings = [];
                result.displaymenu = pageData.displaymenu; // Keep the same value since we can't calculate it in offline.
                result.messages = _this.getPageProcessMessages(lesson, accessInfo, result, review, jumps);
                Object.assign(result, calculatedData);
                return result;
            });
        }
        return this.processPageOnline(lesson.id, pageId, data, password, review, siteId).then(function (response) {
            _this.eventsProvider.trigger(AddonModLessonProvider_1.DATA_SENT_EVENT, {
                lessonId: lesson.id,
                type: 'process',
                courseId: courseId,
                pageId: pageId,
                review: review
            }, _this.sitesProvider.getCurrentSiteId());
            return response;
        });
    };
    /**
     * Process a lesson page, saving its data. It will fail if offline or cannot connect.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} pageId Page ID.
     * @param {any} data Data to save.
     * @param {string} [password] Lesson password (if any).
     * @param {boolean} [review] If the user wants to review just after finishing (1 hour margin).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModLessonProvider.prototype.processPageOnline = function (lessonId, pageId, data, password, review, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                lessonid: lessonId,
                pageid: pageId,
                data: _this.utils.objectToArrayOfObjects(data, 'name', 'value', true),
                review: review ? 1 : 0
            };
            if (typeof password == 'string') {
                params.password = password;
            }
            return site.write('mod_lesson_process_page', params);
        });
    };
    /**
     * Records an attempt on a certain page.
     * Based on Moodle's record_attempt.
     *
     * @param {any} lesson Lesson.
     * @param {number} courseId Course ID the lesson belongs to.
     * @param {any} pageData Result of getPageData for the page to process.
     * @param {any} data Data to save.
     * @param {boolean} review If the user wants to review just after finishing (1 hour margin).
     * @param {any} accessInfo Result of get access info.
     * @param {any} jumps Result of get pages possible jumps.
     * @param {any} pageIndex Object containing all the pages indexed by ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<AddonModLessonRecordAttemptResult>} Promise resolved with the result.
     */
    AddonModLessonProvider.prototype.recordAttempt = function (lesson, courseId, pageData, data, review, accessInfo, jumps, pageIndex, siteId) {
        var _this = this;
        // Check the user answer. Each page type has its own implementation.
        var result = this.checkAnswer(lesson, pageData, data, jumps, pageIndex), retake = accessInfo.attemptscount;
        // Processes inmediate jumps.
        if (result.inmediatejump) {
            if (pageData.page.qtype == AddonModLessonProvider_1.LESSON_PAGE_BRANCHTABLE) {
                // Store the content page data. In Moodle this is stored in a separate table, during checkAnswer.
                return this.lessonOfflineProvider.processPage(lesson.id, courseId, retake, pageData.page, data, result.newpageid, result.answerid, false, result.userresponse, siteId).then(function () {
                    return result;
                });
            }
            return Promise.resolve(result);
        }
        var promise = Promise.resolve(), stop = false, nAttempts;
        result.attemptsremaining = 0;
        result.maxattemptsreached = false;
        if (result.noanswer) {
            result.newpageid = pageData.page.id; // Display same page again.
            result.feedback = this.translate.instant('addon.mod_lesson.noanswer');
        }
        else {
            if (!accessInfo.canmanage) {
                // Get the number of attempts that have been made on this question for this student and retake.
                promise = this.getQuestionsAttempts(lesson.id, retake, false, pageData.page.id, siteId).then(function (attempts) {
                    nAttempts = attempts.online.length + attempts.offline.length;
                    // Check if they have reached (or exceeded) the maximum number of attempts allowed.
                    if (nAttempts >= lesson.maxattempts) {
                        result.maxattemptsreached = true;
                        result.feedback = _this.translate.instant('addon.mod_lesson.maximumnumberofattemptsreached');
                        result.newpageid = AddonModLessonProvider_1.LESSON_NEXTPAGE;
                        stop = true; // Set stop to true to prevent further calculations.
                        return;
                    }
                    var subPromise;
                    // Only insert a record if we are not reviewing the lesson.
                    if (!review) {
                        if (lesson.retake || (!lesson.retake && !retake)) {
                            // Store the student's attempt and increase the number of attempts made.
                            // Calculate and store the new page ID to prevent having to recalculate it later.
                            var newPageId = _this.getNewPageId(pageData.page.id, result.newpageid, jumps);
                            subPromise = _this.lessonOfflineProvider.processPage(lesson.id, courseId, retake, pageData.page, data, newPageId, result.answerid, result.correctanswer, result.userresponse, siteId);
                            nAttempts++;
                        }
                    }
                    // Check if "number of attempts remaining" message is needed.
                    if (!result.correctanswer && !result.newpageid) {
                        // Retreive the number of attempts left counter.
                        if (nAttempts >= lesson.maxattempts) {
                            if (lesson.maxattempts > 1) {
                                result.maxattemptsreached = true;
                            }
                            result.newpageid = AddonModLessonProvider_1.LESSON_NEXTPAGE;
                        }
                        else if (lesson.maxattempts > 1) {
                            result.attemptsremaining = lesson.maxattempts - nAttempts;
                        }
                    }
                    return subPromise;
                });
            }
            promise = promise.then(function () {
                if (stop) {
                    return;
                }
                // Determine default feedback if necessary.
                if (!result.response) {
                    if (!lesson.feedback && !result.noanswer &&
                        !(lesson.review && !result.correctanswer && !result.isessayquestion)) {
                        // These conditions have been met:
                        //  1. The lesson manager has not supplied feedback to the student.
                        //  2. Not displaying default feedback.
                        //  3. The user did provide an answer.
                        //  4. We are not reviewing with an incorrect answer (and not reviewing an essay question).
                        result.nodefaultresponse = true;
                    }
                    else if (result.isessayquestion) {
                        result.response = _this.translate.instant('addon.mod_lesson.defaultessayresponse');
                    }
                    else if (result.correctanswer) {
                        result.response = _this.translate.instant('addon.mod_lesson.thatsthecorrectanswer');
                    }
                    else {
                        result.response = _this.translate.instant('addon.mod_lesson.thatsthewronganswer');
                    }
                }
                if (result.response) {
                    var subPromise = void 0;
                    if (lesson.review && !result.correctanswer && !result.isessayquestion) {
                        // Calculate the number of question attempt in the page if it isn't calculated already.
                        if (typeof nAttempts == 'undefined') {
                            subPromise = _this.getQuestionsAttempts(lesson.id, retake, false, pageData.page.id, siteId)
                                .then(function (result) {
                                nAttempts = result.online.length + result.offline.length;
                            });
                        }
                        else {
                            subPromise = Promise.resolve();
                        }
                        subPromise.then(function () {
                            var messageId = nAttempts == 1 ? 'firstwrong' : 'secondpluswrong';
                            result.feedback = '<div class="box feedback">' +
                                _this.translate.instant('addon.mod_lesson.' + messageId) + '</div>';
                        });
                    }
                    else {
                        result.feedback = '';
                        subPromise = Promise.resolve();
                    }
                    var className_1 = 'response';
                    if (result.correctanswer) {
                        className_1 += ' correct';
                    }
                    else if (!result.isessayquestion) {
                        className_1 += ' incorrect';
                    }
                    return subPromise.then(function () {
                        result.feedback += '<div class="box generalbox boxaligncenter p-y-1">' + pageData.page.contents + '</div>';
                        result.feedback += '<div class="correctanswer generalbox"><em>' +
                            _this.translate.instant('addon.mod_lesson.youranswer') + '</em> : ' +
                            '<div class="studentanswer m-t-2 m-b-2"><table class="generaltable"><tbody>';
                        // Create a table containing the answers and responses.
                        if (pageData.page.qoption) {
                            // Multianswer allowed.
                            var studentAnswerArray = result.studentanswer ?
                                result.studentanswer.split(AddonModLessonProvider_1.MULTIANSWER_DELIMITER) : [], responseArray = result.response ?
                                result.response.split(AddonModLessonProvider_1.MULTIANSWER_DELIMITER) : [];
                            // Add answers and responses to the table.
                            for (var i = 0; i < studentAnswerArray.length; i++) {
                                result.feedback = _this.addAnswerAndResponseToFeedback(result.feedback, studentAnswerArray[i], result.studentanswerformat, responseArray[i], className_1);
                            }
                        }
                        else {
                            // Only 1 answer, add it to the table.
                            result.feedback = _this.addAnswerAndResponseToFeedback(result.feedback, result.studentanswer, result.studentanswerformat, result.response, className_1);
                        }
                        result.feedback += '</tbody></table></div></div>';
                    });
                }
            });
        }
        return promise.then(function () {
            return result;
        });
    };
    /**
     * Remove a password stored in DB.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when removed.
     */
    AddonModLessonProvider.prototype.removeStoredPassword = function (lessonId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(AddonModLessonProvider_1.PASSWORD_TABLE, { lessonid: lessonId });
        });
    };
    /**
     * Store a password in DB.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} password Password to store.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when stored.
     */
    AddonModLessonProvider.prototype.storePassword = function (lessonId, password, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var entry = {
                lessonid: lessonId,
                password: password,
                timemodified: Date.now()
            };
            return site.getDb().insertRecord(AddonModLessonProvider_1.PASSWORD_TABLE, entry);
        });
    };
    /**
     * Function to determine if a page is a valid page. It will add the page to validPages if valid. It can also
     * modify the list of viewedPagesIds for cluster pages.
     * Based on Moodle's valid_page_and_view.
     *
     * @param {any} pages Index of lesson pages, indexed by page ID. See createPagesIndex.
     * @param {any} page Page to check.
     * @param {any} validPages Valid pages, indexed by page ID.
     * @param {number[]} viewedPagesIds List of viewed pages IDs.
     * @return {number} Next page ID.
     */
    AddonModLessonProvider.prototype.validPageAndView = function (pages, page, validPages, viewedPagesIds) {
        if (page.qtype != AddonModLessonProvider_1.LESSON_PAGE_ENDOFCLUSTER &&
            page.qtype != AddonModLessonProvider_1.LESSON_PAGE_ENDOFBRANCH) {
            // Add this page as a valid page.
            validPages[page.id] = 1;
        }
        if (page.qtype == AddonModLessonProvider_1.LESSON_PAGE_CLUSTER) {
            // Get list of pages in the cluster.
            var subPages = this.getSubpagesOf(pages, page.id, [AddonModLessonProvider_1.LESSON_PAGE_ENDOFCLUSTER]);
            subPages.forEach(function (subPage) {
                var position = viewedPagesIds.indexOf(subPage.id);
                if (position != -1) {
                    delete viewedPagesIds[position]; // Remove it.
                    // Since the user did see one page in the cluster, add the cluster pageid to the viewedPagesIds.
                    if (viewedPagesIds.indexOf(page.id) == -1) {
                        viewedPagesIds.push(page.id);
                    }
                }
            });
        }
        return page.nextpageid;
    };
    AddonModLessonProvider.COMPONENT = 'mmaModLesson';
    AddonModLessonProvider.DATA_SENT_EVENT = 'addon_mod_lesson_data_sent';
    // This page.
    AddonModLessonProvider.LESSON_THISPAGE = 0;
    // Next page -> any page not seen before.
    AddonModLessonProvider.LESSON_UNSEENPAGE = 1;
    // Next page -> any page not answered correctly.
    AddonModLessonProvider.LESSON_UNANSWEREDPAGE = 2;
    // Jump to Next Page.
    AddonModLessonProvider.LESSON_NEXTPAGE = -1;
    // End of Lesson.
    AddonModLessonProvider.LESSON_EOL = -9;
    // Jump to an unseen page within a branch and end of branch or end of lesson.
    AddonModLessonProvider.LESSON_UNSEENBRANCHPAGE = -50;
    // Jump to a random page within a branch and end of branch or end of lesson.
    AddonModLessonProvider.LESSON_RANDOMPAGE = -60;
    // Jump to a random Branch.
    AddonModLessonProvider.LESSON_RANDOMBRANCH = -70;
    // Cluster Jump.
    AddonModLessonProvider.LESSON_CLUSTERJUMP = -80;
    // Type of page: question or structure (content).
    AddonModLessonProvider.TYPE_QUESTION = 0;
    AddonModLessonProvider.TYPE_STRUCTURE = 1;
    // Type of question pages.
    AddonModLessonProvider.LESSON_PAGE_SHORTANSWER = 1;
    AddonModLessonProvider.LESSON_PAGE_TRUEFALSE = 2;
    AddonModLessonProvider.LESSON_PAGE_MULTICHOICE = 3;
    AddonModLessonProvider.LESSON_PAGE_MATCHING = 5;
    AddonModLessonProvider.LESSON_PAGE_NUMERICAL = 8;
    AddonModLessonProvider.LESSON_PAGE_ESSAY = 10;
    AddonModLessonProvider.LESSON_PAGE_BRANCHTABLE = 20; // Content page.
    AddonModLessonProvider.LESSON_PAGE_ENDOFBRANCH = 21;
    AddonModLessonProvider.LESSON_PAGE_CLUSTER = 30;
    AddonModLessonProvider.LESSON_PAGE_ENDOFCLUSTER = 31;
    /**
     * Constant used as a delimiter when parsing multianswer questions
     */
    AddonModLessonProvider.MULTIANSWER_DELIMITER = '@^#|';
    AddonModLessonProvider.LESSON_OTHER_ANSWERS = '@#wronganswer#@';
    // Variables for database.
    AddonModLessonProvider.PASSWORD_TABLE = 'addon_mod_lesson_password';
    AddonModLessonProvider = AddonModLessonProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__lesson_offline__["a" /* AddonModLessonOfflineProvider */], __WEBPACK_IMPORTED_MODULE_9__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */]])
    ], AddonModLessonProvider);
    return AddonModLessonProvider;
    var AddonModLessonProvider_1;
}());

//# sourceMappingURL=lesson.js.map

/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCourseCompletionProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_courses_providers_courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to handle course completion.
 */
var AddonCourseCompletionProvider = /** @class */ (function () {
    function AddonCourseCompletionProvider(logger, sitesProvider, coursesProvider, utils) {
        this.sitesProvider = sitesProvider;
        this.coursesProvider = coursesProvider;
        this.utils = utils;
        this.ROOT_CACHE_KEY = 'mmaCourseCompletion:';
        this.logger = logger.getInstance('AddonCourseCompletionProvider');
    }
    /**
     * Returns whether or not the user can mark a course as self completed.
     * It can if it's configured in the course and it hasn't been completed yet.
     *
     * @param {number} userId     User ID.
     * @param {any}    completion Course completion.
     * @return {boolean} True if user can mark course as self completed, false otherwise.
     */
    AddonCourseCompletionProvider.prototype.canMarkSelfCompleted = function (userId, completion) {
        var selfCompletionActive = false, alreadyMarked = false;
        if (this.sitesProvider.getCurrentSiteUserId() != userId) {
            return false;
        }
        completion.completions.forEach(function (criteria) {
            if (criteria.type === 1) {
                // Self completion criteria found.
                selfCompletionActive = true;
                alreadyMarked = criteria.complete;
            }
        });
        return selfCompletionActive && !alreadyMarked;
    };
    /**
     * Get completed status text. The language code returned is meant to be translated.
     *
     * @param {any} completion Course completion.
     * @return {string} Language code of the text to show.
     */
    AddonCourseCompletionProvider.prototype.getCompletedStatusText = function (completion) {
        if (completion.completed) {
            return 'addon.coursecompletion.completed';
        }
        else {
            // Let's calculate status.
            var hasStarted_1 = false;
            completion.completions.forEach(function (criteria) {
                if (criteria.timecompleted || criteria.complete) {
                    hasStarted_1 = true;
                }
            });
            if (hasStarted_1) {
                return 'addon.coursecompletion.inprogress';
            }
            else {
                return 'addon.coursecompletion.notyetstarted';
            }
        }
    };
    /**
     * Get course completion status for a certain course and user.
     *
     * @param {number} courseId  Course ID.
     * @param {number} [userId]  User ID. If not defined, use current user.
     * @param {any}    [preSets] Presets to use when calling the WebService.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise to be resolved when the completion is retrieved.
     */
    AddonCourseCompletionProvider.prototype.getCompletion = function (courseId, userId, preSets, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            preSets = preSets || {};
            _this.logger.debug('Get completion for course ' + courseId + ' and user ' + userId);
            var data = {
                courseid: courseId,
                userid: userId
            };
            preSets.cacheKey = _this.getCompletionCacheKey(courseId, userId);
            preSets.updateFrequency = preSets.updateFrequency || __WEBPACK_IMPORTED_MODULE_5__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES;
            return site.read('core_completion_get_course_completion_status', data, preSets).then(function (data) {
                if (data.completionstatus) {
                    return data.completionstatus;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get completion WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} useIid   User ID.
     * @return {string} Cache key.
     */
    AddonCourseCompletionProvider.prototype.getCompletionCacheKey = function (courseId, userId) {
        return this.ROOT_CACHE_KEY + 'view:' + courseId + ':' + userId;
    };
    /**
     * Invalidates view course completion WS call.
     *
     * @param {number} courseId Course ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @return {Promise<any>} Promise resolved when the list is invalidated.
     */
    AddonCourseCompletionProvider.prototype.invalidateCourseCompletion = function (courseId, userId) {
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        return this.sitesProvider.getCurrentSite().invalidateWsCacheForKey(this.getCompletionCacheKey(courseId, userId));
    };
    /**
     * Returns whether or not the view course completion plugin is enabled for the current site.
     *
     * @return {boolean} True if plugin enabled, false otherwise.
     */
    AddonCourseCompletionProvider.prototype.isPluginViewEnabled = function () {
        return this.sitesProvider.isLoggedIn();
    };
    /**
     * Returns whether or not the view course completion plugin is enabled for a certain course.
     *
     * @param {number}  courseId           Course ID.
     * @param {boolean} [preferCache=true] True if shouldn't call WS if data is cached, false otherwise.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonCourseCompletionProvider.prototype.isPluginViewEnabledForCourse = function (courseId, preferCache) {
        if (preferCache === void 0) { preferCache = true; }
        if (!courseId) {
            return Promise.reject(null);
        }
        return this.coursesProvider.getUserCourse(courseId, preferCache).then(function (course) {
            if (course) {
                if (typeof course.enablecompletion != 'undefined' && course.enablecompletion == 0) {
                    // Completion not enabled for the course.
                    return false;
                }
                if (typeof course.completionhascriteria != 'undefined' && course.completionhascriteria == 0) {
                    // No criteria, cannot view completion.
                    return false;
                }
            }
            return true;
        });
    };
    /**
     * Returns whether or not the view course completion plugin is enabled for a certain user.
     *
     * @param {number} courseId Course ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonCourseCompletionProvider.prototype.isPluginViewEnabledForUser = function (courseId, userId) {
        var _this = this;
        // Check if user wants to view his own completion.
        var currentUserId = this.sitesProvider.getCurrentSiteUserId();
        var promise;
        if (!userId || userId == currentUserId) {
            // Viewing own completion. Get the course to check if it has completion criteria.
            promise = this.coursesProvider.getUserCourse(courseId, true).then(function (course) {
                // If the site is returning the completionhascriteria then the user can view his own completion.
                // We already checked the value in isPluginViewEnabledForCourse.
                if (course && typeof course.completionhascriteria != 'undefined') {
                    return true;
                }
                return Promise.reject(null);
            });
        }
        else {
            promise = Promise.reject(null);
        }
        return promise.catch(function () {
            // User not viewing own completion or the site doesn't tell us if the course has criteria.
            // The only way to know if completion can be viewed is to call the WS.
            // Disable emergency cache to be able to detect that the plugin has been disabled (WS will fail).
            var preSets = {
                emergencyCache: 0
            };
            return _this.getCompletion(courseId, userId, preSets).then(function () {
                return true;
            }).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WS returned an error, plugin is not enabled.
                    return false;
                }
                else {
                    // Not a WS error. Check if we have a cached value.
                    preSets.omitExpires = true;
                    return _this.getCompletion(courseId, userId, preSets).then(function () {
                        return true;
                    }).catch(function () {
                        return false;
                    });
                }
            });
        });
    };
    /**
     * Mark a course as self completed.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Resolved on success.
     */
    AddonCourseCompletionProvider.prototype.markCourseAsSelfCompleted = function (courseId) {
        var params = {
            courseid: courseId
        };
        return this.sitesProvider.getCurrentSite().write('core_completion_mark_course_self_completed', params).then(function (response) {
            if (!response.status) {
                return Promise.reject(null);
            }
        });
    };
    AddonCourseCompletionProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__core_courses_providers_courses__["a" /* CoreCoursesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonCourseCompletionProvider);
    return AddonCourseCompletionProvider;
}());

//# sourceMappingURL=coursecompletion.js.map

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSyncBaseProvider; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Base class to create sync providers. It provides some common functions.
 */
var CoreSyncBaseProvider = /** @class */ (function () {
    function CoreSyncBaseProvider(component, loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils) {
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        this.syncProvider = syncProvider;
        this.textUtils = textUtils;
        this.translate = translate;
        this.timeUtils = timeUtils;
        /**
         * Component of the sync provider.
         * @type {string}
         */
        this.component = 'core';
        /**
         * Sync provider's interval.
         * @type {number}
         */
        this.syncInterval = 300000;
        // Store sync promises.
        this.syncPromises = {};
        this.logger = loggerProvider.getInstance(component);
        this.component = component;
    }
    /**
     * Add an ongoing sync to the syncPromises list. On finish the promise will be removed.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {Promise<any>} promise The promise of the sync to add.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} The sync promise.
     */
    CoreSyncBaseProvider.prototype.addOngoingSync = function (id, promise, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncId(id);
        if (!this.syncPromises[siteId]) {
            this.syncPromises[siteId] = {};
        }
        this.syncPromises[siteId][uniqueId] = promise;
        // Promise will be deleted when finish.
        return promise.finally(function () {
            delete _this.syncPromises[siteId][uniqueId];
        });
    };
    /**
     * If there's an ongoing sync for a certain identifier return it.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise of the current sync or undefined if there isn't any.
     */
    CoreSyncBaseProvider.prototype.getOngoingSync = function (id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.isSyncing(id, siteId)) {
            // There's already a sync ongoing for this discussion, return the promise.
            var uniqueId = this.getUniqueSyncId(id);
            return this.syncPromises[siteId][uniqueId];
        }
    };
    /**
     * Get the synchronization time in a human readable format.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the readable time.
     */
    CoreSyncBaseProvider.prototype.getReadableSyncTime = function (id, siteId) {
        var _this = this;
        return this.getSyncTime(id, siteId).then(function (time) {
            return _this.getReadableTimeFromTimestamp(time);
        });
    };
    /**
     * Given a timestamp return it in a human readable format.
     *
     * @param {number} timestamp Timestamp
     * @return {string} Human readable time.
     */
    CoreSyncBaseProvider.prototype.getReadableTimeFromTimestamp = function (timestamp) {
        if (!timestamp) {
            return this.translate.instant('core.never');
        }
        else {
            return this.timeUtils.userDate(timestamp);
        }
    };
    /**
     * Get the synchronization time. Returns 0 if no time stored.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the time.
     */
    CoreSyncBaseProvider.prototype.getSyncTime = function (id, siteId) {
        return this.syncProvider.getSyncRecord(this.component, id, siteId).then(function (entry) {
            return entry.time;
        }).catch(function () {
            return 0;
        });
    };
    /**
     * Get the synchronization warnings of an instance.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string[]>} Promise resolved with the warnings.
     */
    CoreSyncBaseProvider.prototype.getSyncWarnings = function (id, siteId) {
        var _this = this;
        return this.syncProvider.getSyncRecord(this.component, id, siteId).then(function (entry) {
            return _this.textUtils.parseJSON(entry.warnings, []);
        }).catch(function () {
            return [];
        });
    };
    /**
     * Create a unique identifier from component and id.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @return {string} Unique identifier from component and id.
     */
    CoreSyncBaseProvider.prototype.getUniqueSyncId = function (id) {
        return this.component + '#' + id;
    };
    /**
     * Check if a there's an ongoing syncronization for the given id.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {boolean} Whether it's synchronizing.
     */
    CoreSyncBaseProvider.prototype.isSyncing = function (id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncId(id);
        return !!(this.syncPromises[siteId] && this.syncPromises[siteId][uniqueId]);
    };
    /**
     * Check if a sync is needed: if a certain time has passed since the last time.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether sync is needed.
     */
    CoreSyncBaseProvider.prototype.isSyncNeeded = function (id, siteId) {
        var _this = this;
        return this.getSyncTime(id, siteId).then(function (time) {
            return Date.now() - _this.syncInterval >= time;
        });
    };
    /**
     * Set the synchronization time.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [time] Time to set. If not defined, current time.
     * @return {Promise<any>} Promise resolved when the time is set.
     */
    CoreSyncBaseProvider.prototype.setSyncTime = function (id, siteId, time) {
        time = typeof time != 'undefined' ? time : Date.now();
        return this.syncProvider.insertOrUpdateSyncRecord(this.component, id, { time: time }, siteId);
    };
    /**
     * Set the synchronization warnings.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string[]} warnings Warnings to set.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSyncBaseProvider.prototype.setSyncWarnings = function (id, warnings, siteId) {
        var warningsText = JSON.stringify(warnings || []);
        return this.syncProvider.insertOrUpdateSyncRecord(this.component, id, { warnings: warningsText }, siteId);
    };
    /**
     * Execute a sync function on selected sites.
     *
     * @param  {string} syncFunctionLog Log message to explain the sync function purpose.
     * @param  {Function} syncFunction  Sync function to execute.
     * @param  {any[]}    [params]      Array that defines the params that admit the funcion.
     * @param  {string} [siteId]        Site ID to sync. If not defined, sync all sites.
     * @return {Promise<any>}           Resolved with siteIds selected. Rejected if offline.
     */
    CoreSyncBaseProvider.prototype.syncOnSites = function (syncFunctionLog, syncFunction, params, siteId) {
        if (!this.appProvider.isOnline()) {
            this.logger.debug("Cannot sync '" + syncFunctionLog + "' because device is offline.");
            return Promise.reject(null);
        }
        var promise;
        if (!siteId) {
            // No site ID defined, sync all sites.
            this.logger.debug("Try to sync '" + syncFunctionLog + "' in all sites.");
            promise = this.sitesProvider.getLoggedInSitesIds();
        }
        else {
            this.logger.debug("Try to sync '" + syncFunctionLog + "' in site '" + siteId + "'.");
            promise = Promise.resolve([siteId]);
        }
        params = params || [];
        return promise.then(function (siteIds) {
            var sitePromises = [];
            siteIds.forEach(function (siteId) {
                // Execute function for every site selected.
                sitePromises.push(syncFunction.apply(syncFunction, [siteId].concat(params)));
            });
            return Promise.all(sitePromises);
        });
    };
    /**
     * If there's an ongoing sync for a certain identifier, wait for it to end.
     * If there's no sync ongoing the promise will be resolved right away.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when there's no sync going on for the identifier.
     */
    CoreSyncBaseProvider.prototype.waitForSync = function (id, siteId) {
        var promise = this.getOngoingSync(id, siteId);
        if (promise) {
            return promise.catch(function () {
                // Ignore errors.
            });
        }
        return Promise.resolve();
    };
    return CoreSyncBaseProvider;
}());

//# sourceMappingURL=base-sync.js.map

/***/ }),
/* 161 */,
/* 162 */,
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__grades__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_contentlinks_providers_helper__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_login_providers_helper__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_helper__ = __webpack_require__(36);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * Service that provides some features regarding grades information.
 */
var CoreGradesHelperProvider = /** @class */ (function () {
    function CoreGradesHelperProvider(logger, coursesProvider, gradesProvider, sitesProvider, textUtils, courseProvider, domUtils, urlUtils, utils, linkHelper, loginHelper, courseHelper) {
        this.coursesProvider = coursesProvider;
        this.gradesProvider = gradesProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.courseProvider = courseProvider;
        this.domUtils = domUtils;
        this.urlUtils = urlUtils;
        this.utils = utils;
        this.linkHelper = linkHelper;
        this.loginHelper = loginHelper;
        this.courseHelper = courseHelper;
        this.logger = logger.getInstance('CoreGradesHelperProvider');
    }
    /**
     * Formats a row from the grades table te be rendered in a page.
     *
     * @param  {any}  tableRow JSON object representing row of grades table data.
     * @return {any}           Formatted row object.
     */
    CoreGradesHelperProvider.prototype.formatGradeRow = function (tableRow) {
        var row = {};
        for (var name_1 in tableRow) {
            if (typeof tableRow[name_1].content != 'undefined' && tableRow[name_1].content !== null) {
                var content = String(tableRow[name_1].content);
                if (name_1 == 'itemname') {
                    this.setRowIcon(row, content);
                    row['link'] = this.getModuleLink(content);
                    row['rowclass'] += tableRow[name_1].class.indexOf('hidden') >= 0 ? ' hidden' : '';
                    row['rowclass'] += tableRow[name_1].class.indexOf('dimmed_text') >= 0 ? ' dimmed_text' : '';
                    content = content.replace(/<\/span>/gi, '\n');
                    content = this.textUtils.cleanTags(content);
                }
                else {
                    content = this.textUtils.replaceNewLines(content, '<br>');
                }
                if (content == '&nbsp;') {
                    content = '';
                }
                row[name_1] = content.trim();
            }
        }
        return row;
    };
    /**
     * Formats a row from the grades table to be rendered in one table.
     *
     * @param  {any}  tableRow JSON object representing row of grades table data.
     * @return {any}           Formatted row object.
     */
    CoreGradesHelperProvider.prototype.formatGradeRowForTable = function (tableRow) {
        var row = {};
        for (var name_2 in tableRow) {
            if (typeof tableRow[name_2].content != 'undefined' && tableRow[name_2].content !== null) {
                var content = String(tableRow[name_2].content);
                if (name_2 == 'itemname') {
                    row['id'] = parseInt(tableRow[name_2].id.split('_')[1], 10);
                    row['colspan'] = tableRow[name_2].colspan;
                    row['rowspan'] = (tableRow['leader'] && tableRow['leader'].rowspan) || 1;
                    this.setRowIcon(row, content);
                    row['rowclass'] = tableRow[name_2].class.indexOf('leveleven') < 0 ? 'odd' : 'even';
                    row['rowclass'] += tableRow[name_2].class.indexOf('hidden') >= 0 ? ' hidden' : '';
                    row['rowclass'] += tableRow[name_2].class.indexOf('dimmed_text') >= 0 ? ' dimmed_text' : '';
                    content = content.replace(/<\/span>/gi, '\n');
                    content = this.textUtils.cleanTags(content);
                    name_2 = 'gradeitem';
                }
                else {
                    content = this.textUtils.replaceNewLines(content, '<br>');
                }
                if (content == '&nbsp;') {
                    content = '';
                }
                row[name_2] = content.trim();
            }
        }
        return row;
    };
    /**
     * Removes suffix formatted to compatibilize data from table and items.
     *
     * @param  {any} item Grade item to format.
     * @return {any}      Grade item formatted.
     */
    CoreGradesHelperProvider.prototype.formatGradeItem = function (item) {
        for (var name_3 in item) {
            var index = name_3.indexOf('formatted');
            if (index > 0) {
                item[name_3.substr(0, index)] = item[name_3];
            }
        }
        return item;
    };
    /**
     * Formats the response of gradereport_user_get_grades_table to be rendered.
     *
     * @param  {any}  table          JSON object representing a table with data.
     * @return {any}             Formatted HTML table.
     */
    CoreGradesHelperProvider.prototype.formatGradesTable = function (table) {
        var _this = this;
        var maxDepth = table.maxdepth, formatted = {
            columns: [],
            rows: []
        }, 
        // Columns, in order.
        columns = {
            gradeitem: true,
            weight: false,
            grade: false,
            range: false,
            percentage: false,
            lettergrade: false,
            rank: false,
            average: false,
            feedback: false,
            contributiontocoursetotal: false
        };
        formatted.rows = table.tabledata.map(function (row) {
            return _this.formatGradeRowForTable(row);
        });
        // Get a row with some info.
        var normalRow = formatted.rows.find(function (e) {
            return e.itemtype != 'leader' && (typeof e.grade != 'undefined' || typeof e.percentage != 'undefined');
        });
        // Decide if grades or percentage is being shown on phones.
        if (normalRow && typeof normalRow.grade != 'undefined') {
            columns.grade = true;
        }
        else if (normalRow && typeof normalRow.percentage != 'undefined') {
            columns.percentage = true;
        }
        else {
            normalRow = formatted.rows.find(function (e) {
                return e.itemtype != 'leader';
            });
            columns.grade = true;
        }
        for (var colName in columns) {
            if (typeof normalRow[colName] != 'undefined') {
                formatted.columns.push({
                    name: colName,
                    colspan: colName == 'gradeitem' ? maxDepth : 1,
                    hiddenPhone: !columns[colName]
                });
            }
        }
        return formatted;
    };
    /**
     * Get course data for grades since they only have courseid.
     *
     * @param  {any} grades    Grades to get the data for.
     * @return {Promise<any>}  Promise always resolved. Resolve param is the formatted grades.
     */
    CoreGradesHelperProvider.prototype.getGradesCourseData = function (grades) {
        // Using cache for performance reasons.
        return this.coursesProvider.getUserCourses(true).then(function (courses) {
            var indexedCourses = {};
            courses.forEach(function (course) {
                indexedCourses[course.id] = course;
            });
            grades.forEach(function (grade) {
                if (typeof indexedCourses[grade.courseid] != 'undefined') {
                    grade.courseFullName = indexedCourses[grade.courseid].fullname;
                }
            });
            return grades;
        });
    };
    /**
     * Get an specific grade item.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  gradeId              Grade ID.
     * @param  {number}  [userId]             ID of the user to get the grades from. If not defined use site's current user.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                Promise to be resolved when the grades are retrieved.
     */
    CoreGradesHelperProvider.prototype.getGradeItem = function (courseId, gradeId, userId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.gradesProvider.getCourseGradesTable(courseId, userId, siteId, ignoreCache).then(function (grades) {
            if (grades) {
                return _this.getGradesTableRow(grades, gradeId);
            }
            return Promise.reject(null);
        });
    };
    /**
     * Returns the label of the selected grade.
     *
     * @param {any[]} grades Array with objects with value and label.
     * @param {number} selectedGrade Selected grade value.
     * @return {string} Selected grade label.
     */
    CoreGradesHelperProvider.prototype.getGradeLabelFromValue = function (grades, selectedGrade) {
        selectedGrade = Number(selectedGrade);
        if (!grades || !selectedGrade || selectedGrade <= 0) {
            return '';
        }
        for (var x in grades) {
            if (grades[x].value == selectedGrade) {
                return grades[x].label;
            }
        }
        return '';
    };
    /**
     * Get the grade items for a certain module. Keep in mind that may have more than one item to include outcomes and scales.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  moduleId             Module ID.
     * @param  {number}  [userId]             ID of the user to get the grades from. If not defined use site's current user.
     * @param  {number}  [groupId]            ID of the group to get the grades from. Not used for old gradebook table.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                Promise to be resolved when the grades are retrieved.
     */
    CoreGradesHelperProvider.prototype.getGradeModuleItems = function (courseId, moduleId, userId, groupId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.gradesProvider.getGradeItems(courseId, userId, groupId, siteId, ignoreCache).then(function (grades) {
            if (grades) {
                if (typeof grades.tabledata != 'undefined') {
                    // Table format.
                    return _this.getModuleGradesTableRows(grades, moduleId);
                }
                else {
                    return grades.filter(function (item) {
                        return item.cmid == moduleId;
                    }).map(function (item) {
                        return _this.formatGradeItem(item);
                    });
                }
            }
            return Promise.reject(null);
        });
    };
    /**
     * Returns the value of the selected grade.
     *
     * @param {any[]} grades Array with objects with value and label.
     * @param {string} selectedGrade Selected grade label.
     * @return {number} Selected grade value.
     */
    CoreGradesHelperProvider.prototype.getGradeValueFromLabel = function (grades, selectedGrade) {
        if (!grades || !selectedGrade) {
            return 0;
        }
        for (var x in grades) {
            if (grades[x].label == selectedGrade) {
                return grades[x].value < 0 ? 0 : grades[x].value;
            }
        }
        return 0;
    };
    /**
     * Gets the link to the module for the selected grade.
     *
     * @param  {string} text HTML where the link is present.
     * @return {string | false}      URL linking to the module.
     */
    CoreGradesHelperProvider.prototype.getModuleLink = function (text) {
        var el = this.domUtils.toDom(text)[0], link = el.attributes['href'] ? el.attributes['href'].value : false;
        if (!link || link.indexOf('/mod/') < 0) {
            return false;
        }
        return link;
    };
    /**
     * Get a row from the grades table.
     *
     * @param  {any}   table    JSON object representing a table with data.
     * @param  {number} gradeId Grade Object identifier.
     * @return {any}            Formatted HTML table.
     */
    CoreGradesHelperProvider.prototype.getGradesTableRow = function (table, gradeId) {
        if (table.tabledata) {
            var selectedRow = table.tabledata.find(function (row) {
                return row.itemname && row.itemname.id && row.itemname.id.substr(0, 3) == 'row' &&
                    parseInt(row.itemname.id.split('_')[1], 10) == gradeId;
            });
            if (selectedRow) {
                return this.formatGradeRow(selectedRow);
            }
        }
        return '';
    };
    /**
     * Get the rows related to a module from the grades table.
     *
     * @param  {any}   table     JSON object representing a table with data.
     * @param  {number} moduleId Grade Object identifier.
     * @return {any}             Formatted HTML table.
     */
    CoreGradesHelperProvider.prototype.getModuleGradesTableRows = function (table, moduleId) {
        var _this = this;
        if (table.tabledata) {
            // Find href containing "/mod/xxx/xxx.php".
            var regex_1 = /href="([^"]*\/mod\/[^"|^\/]*\/[^"|^\.]*\.php[^"]*)/;
            return table.tabledata.filter(function (row) {
                if (row.itemname && row.itemname.content) {
                    var matches = row.itemname.content.match(regex_1);
                    if (matches && matches.length) {
                        var hrefParams = _this.urlUtils.extractUrlParams(matches[1]);
                        return hrefParams && hrefParams.id == moduleId;
                    }
                }
                return false;
            }).map(function (row) {
                return _this.formatGradeRow(row);
            });
        }
        return [];
    };
    /**
     * Go to view grades.
     *
     * @param {number} courseId Course ID t oview.
     * @param {number} [userId] User to view. If not defined, current user.
     * @param {number} [moduleId] Module to view. If not defined, view all course grades.
     * @param {NavController} [navCtrl] NavController to use.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreGradesHelperProvider.prototype.goToGrades = function (courseId, userId, moduleId, navCtrl, siteId) {
        var _this = this;
        var modal = this.domUtils.showModalLoading();
        var currentUserId;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            siteId = site.id;
            currentUserId = site.getUserId();
            if (moduleId) {
                // Try to open the module grade directly. Check if it's possible.
                return _this.gradesProvider.isGradeItemsAvalaible(siteId).then(function (getGrades) {
                    if (!getGrades) {
                        return Promise.reject(null);
                    }
                });
            }
            else {
                return Promise.reject(null);
            }
        }).then(function () {
            // Can get grades. Do it.
            return _this.gradesProvider.getGradeItems(courseId, userId, undefined, siteId).then(function (items) {
                // Find the item of the module.
                var item = items.find(function (item) {
                    return moduleId == item.cmid;
                });
                if (item) {
                    // Open the item directly.
                    var pageParams = {
                        courseId: courseId,
                        userId: userId,
                        gradeId: item.id
                    };
                    return _this.linkHelper.goInSite(navCtrl, 'CoreGradesGradePage', pageParams, siteId).catch(function () {
                        // Ignore errors.
                    });
                }
                return Promise.reject(null);
            });
        }).catch(function () {
            // Cannot get grade items or there's no need to.
            if (userId && userId != currentUserId) {
                // View another user grades. Open the grades page directly.
                var pageParams = {
                    course: { id: courseId },
                    userId: userId
                };
                return _this.linkHelper.goInSite(navCtrl, 'CoreGradesCoursePage', pageParams, siteId).catch(function () {
                    // Ignore errors.
                });
            }
            // View own grades. Open the course with the grades tab selected.
            return _this.courseHelper.getCourse(courseId, siteId).then(function (result) {
                var pageParams = {
                    course: result.course,
                    selectedTab: 'CoreGrades'
                };
                return _this.loginHelper.redirect('CoreCourseSectionPage', pageParams, siteId).catch(function () {
                    // Ignore errors.
                });
            });
        }).catch(function () {
            // Cannot get course for some reason, just open the grades page.
            return _this.linkHelper.goInSite(navCtrl, 'CoreGradesCoursePage', { course: { id: courseId } }, siteId);
        }).finally(function () {
            modal.dismiss();
        });
    };
    /**
     * Invalidate the grade items for a certain module.
     *
     * @param  {number}  courseId     ID of the course to invalidate the grades.
     * @param  {number}  [userId]     ID of the user to invalidate. If not defined use site's current user.
     * @param  {number}  [groupId]    ID of the group to invalidate. Not used for old gradebook table.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise}              Promise to be resolved when the grades are invalidated.
     */
    CoreGradesHelperProvider.prototype.invalidateGradeModuleItems = function (courseId, userId, groupId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return _this.gradesProvider.isGradeItemsAvalaible(siteId).then(function (enabled) {
                if (enabled) {
                    return _this.gradesProvider.invalidateCourseGradesItemsData(courseId, userId, groupId, siteId);
                }
                else {
                    return _this.gradesProvider.invalidateCourseGradesData(courseId, userId, siteId);
                }
            });
        });
    };
    /**
     * Parses the image and sets it to the row.
     *
     * @param  {any} row  Formatted grade row object.
     * @param  {string} text HTML where the image will be rendered.
     * @return {any}      Row object with the image.
     */
    CoreGradesHelperProvider.prototype.setRowIcon = function (row, text) {
        text = text.replace('%2F', '/').replace('%2f', '/');
        if (text.indexOf('/agg_mean') > -1) {
            row['itemtype'] = 'agg_mean';
            row['image'] = 'assets/img/grades/agg_mean.png';
        }
        else if (text.indexOf('/agg_sum') > -1) {
            row['itemtype'] = 'agg_sum';
            row['image'] = 'assets/img/grades/agg_sum.png';
        }
        else if (text.indexOf('/outcomes') > -1 || text.indexOf('fa-tasks') > -1) {
            row['itemtype'] = 'outcome';
            row['icon'] = 'fa-tasks';
        }
        else if (text.indexOf('i/folder') > -1 || text.indexOf('fa-folder') > -1) {
            row['itemtype'] = 'category';
            row['icon'] = 'fa-folder';
        }
        else if (text.indexOf('/manual_item') > -1 || text.indexOf('fa-square-o') > -1) {
            row['itemtype'] = 'manual';
            row['icon'] = 'fa-square-o';
        }
        else if (text.indexOf('/mod/') > -1) {
            var module_1 = text.match(/mod\/([^\/]*)\//);
            if (typeof module_1[1] != 'undefined') {
                row['itemtype'] = 'mod';
                row['itemmodule'] = module_1[1];
                row['image'] = this.courseProvider.getModuleIconSrc(module_1[1], this.domUtils.convertToElement(text).querySelector('img').getAttribute('src'));
            }
        }
        else {
            if (row['rowspan'] && row['rowspan'] > 1) {
                row['itemtype'] = 'category';
                row['icon'] = 'fa-folder';
            }
            else if (text.indexOf('src=') > -1) {
                row['itemtype'] = 'unknown';
                var src = text.match(/src="([^"]*)"/);
                row['image'] = src[1];
            }
            else if (text.indexOf('<i ') > -1) {
                row['itemtype'] = 'unknown';
                var src = text.match(/<i class="(?:[^"]*?\s)?(fa-[a-z0-9-]+)/);
                row['icon'] = src ? src[1] : '';
            }
        }
        return row;
    };
    /**
     * Creates an array that represents all the current grades that can be chosen using the given grading type.
     * Negative numbers are scales, zero is no grade, and positive numbers are maximum grades.
     *
     * Taken from make_grades_menu on moodlelib.php
     *
     * @param  {number} gradingType     If positive, max grade you can provide. If negative, scale Id.
     * @param  {number} [moduleId]      Module ID. Used to retrieve the scale items when they are not passed as parameter.
     *                                  If the user does not have permision to manage the activity an empty list is returned.
     * @param  {string} [defaultLabel]  Element that will become default option, if not defined, it won't be added.
     * @param  {any}    [defaultValue]  Element that will become default option value. Default ''.
     * @param  {string} [scale]         Scale csv list String. If not provided, it will take it from the module grade info.
     * @return {Promise<any[]>}         Array with objects with value and label to create a propper HTML select.
     */
    CoreGradesHelperProvider.prototype.makeGradesMenu = function (gradingType, moduleId, defaultLabel, defaultValue, scale) {
        var _this = this;
        if (defaultLabel === void 0) { defaultLabel = ''; }
        if (defaultValue === void 0) { defaultValue = ''; }
        if (gradingType < 0) {
            if (scale) {
                return Promise.resolve(this.utils.makeMenuFromList(scale, defaultLabel, undefined, defaultValue));
            }
            else if (moduleId) {
                return this.courseProvider.getModuleBasicGradeInfo(moduleId).then(function (gradeInfo) {
                    if (gradeInfo.scale) {
                        return _this.utils.makeMenuFromList(gradeInfo.scale, defaultLabel, undefined, defaultValue);
                    }
                    return [];
                });
            }
            else {
                return Promise.resolve([]);
            }
        }
        if (gradingType > 0) {
            var grades = [];
            if (defaultLabel) {
                // Key as string to avoid resorting of the object.
                grades.push({
                    label: defaultLabel,
                    value: defaultValue
                });
            }
            for (var i = gradingType; i >= 0; i--) {
                grades.push({
                    label: i + ' / ' + gradingType,
                    value: i
                });
            }
            return Promise.resolve(grades);
        }
        return Promise.resolve([]);
    };
    CoreGradesHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__["a" /* CoreCoursesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__grades__["a" /* CoreGradesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_11__core_login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_12__core_course_providers_helper__["a" /* CoreCourseHelperProvider */]])
    ], CoreGradesHelperProvider);
    return CoreGradesHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLangProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_globalization__ = __webpack_require__(405);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__configconstants__ = __webpack_require__(121);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/*
 * Service to handle language features, like changing the current language.
*/
var CoreLangProvider = /** @class */ (function () {
    function CoreLangProvider(translate, configProvider, platform, globalization) {
        var _this = this;
        this.translate = translate;
        this.configProvider = configProvider;
        this.globalization = globalization;
        this.fallbackLanguage = 'en'; // Always use English as fallback language since it contains all strings.
        this.defaultLanguage = __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].default_lang || 'en'; // Lang to use if device lang not valid or is forced.
        this.customStrings = {}; // Strings defined using the admin tool.
        this.sitePluginsStrings = {}; // Strings defined by site plugins.
        // Set fallback language and language to use until the app determines the right language to use.
        translate.setDefaultLang(this.fallbackLanguage);
        translate.use(this.defaultLanguage);
        platform.ready().then(function () {
            _this.getCurrentLanguage().then(function (language) {
                _this.changeCurrentLanguage(language);
            });
        });
        translate.onLangChange.subscribe(function (event) {
            platform.setLang(event.lang, true);
            platform.setDir(_this.translate.instant('core.thisdirection'), true);
        });
    }
    /**
     * Add a set of site plugins strings for a certain language.
     *
     * @param {string} lang The language where to add the strings.
     * @param {any} strings Object with the strings to add.
     * @param {string} [prefix] A prefix to add to all keys.
     */
    CoreLangProvider.prototype.addSitePluginsStrings = function (lang, strings, prefix) {
        lang = lang.replace(/_/g, '-'); // Use the app format instead of Moodle format.
        // Initialize structure if it doesn't exist.
        if (!this.sitePluginsStrings[lang]) {
            this.sitePluginsStrings[lang] = {};
        }
        for (var key in strings) {
            var prefixedKey = prefix + key;
            var value = strings[key];
            if (this.customStrings[lang] && this.customStrings[lang][prefixedKey]) {
                // This string is overridden by a custom string, ignore it.
                continue;
            }
            // Replace the way to access subproperties.
            value = value.replace(/\$a->/gm, '$a.');
            // Add another curly bracket to string params ({$a} -> {{$a}}).
            value = value.replace(/{([^ ]+)}/gm, '{{$1}}');
            // Make sure we didn't add to many brackets in some case.
            value = value.replace(/{{{([^ ]+)}}}/gm, '{{$1}}');
            // Load the string.
            this.loadString(this.sitePluginsStrings, lang, prefixedKey, value);
        }
    };
    /**
     * Change current language.
     *
     * @param {string} language New language to use.
     * @return {Promise<any>} Promise resolved when the change is finished.
     */
    CoreLangProvider.prototype.changeCurrentLanguage = function (language) {
        var _this = this;
        var promises = [];
        // Change the language, resolving the promise when we receive the first value.
        promises.push(new Promise(function (resolve, reject) {
            var subscription = _this.translate.use(language).subscribe(function (data) {
                // It's a language override, load the original one first.
                var fallbackLang = _this.translate.instant('core.parentlanguage');
                if (fallbackLang != '' && fallbackLang != 'core.parentlanguage' && fallbackLang != language) {
                    var fallbackSubs_1 = _this.translate.use(fallbackLang).subscribe(function (fallbackData) {
                        data = Object.assign(fallbackData, data);
                        resolve(data);
                        // Data received, unsubscribe. Use a timeout because we can receive a value immediately.
                        setTimeout(function () {
                            fallbackSubs_1.unsubscribe();
                        });
                    }, function (error) {
                        // Resolve with the original language.
                        resolve(data);
                        // Error received, unsubscribe. Use a timeout because we can receive a value immediately.
                        setTimeout(function () {
                            fallbackSubs_1.unsubscribe();
                        });
                    });
                }
                else {
                    resolve(data);
                }
                // Data received, unsubscribe. Use a timeout because we can receive a value immediately.
                setTimeout(function () {
                    subscription.unsubscribe();
                });
            }, function (error) {
                reject(error);
                // Error received, unsubscribe. Use a timeout because we can receive a value immediately.
                setTimeout(function () {
                    subscription.unsubscribe();
                });
            });
        }));
        // Change the config.
        promises.push(this.configProvider.set('current_language', language));
        // Use british english when parent english is loaded.
        __WEBPACK_IMPORTED_MODULE_2_moment__["locale"](language == 'en' ? 'en-gb' : language);
        this.currentLanguage = language;
        return Promise.all(promises).finally(function () {
            // Load the custom and site plugins strings for the language.
            if (_this.loadLangStrings(_this.customStrings, language) || _this.loadLangStrings(_this.sitePluginsStrings, language)) {
                // Some lang strings have changed, emit an event to update the pipes.
                _this.translate.onLangChange.emit({ lang: language, translations: _this.translate.translations[language] });
            }
        });
    };
    /**
     * Clear current custom strings.
     */
    CoreLangProvider.prototype.clearCustomStrings = function () {
        this.unloadStrings(this.customStrings);
        this.customStrings = {};
        this.customStringsRaw = '';
    };
    /**
     * Clear current site plugins strings.
     */
    CoreLangProvider.prototype.clearSitePluginsStrings = function () {
        this.unloadStrings(this.sitePluginsStrings);
        this.sitePluginsStrings = {};
    };
    /**
     * Get all current custom strings.
     *
     * @return {any} Custom strings.
     */
    CoreLangProvider.prototype.getAllCustomStrings = function () {
        return this.customStrings;
    };
    /**
     * Get all current site plugins strings.
     *
     * @return {any} Site plugins strings.
     */
    CoreLangProvider.prototype.getAllSitePluginsStrings = function () {
        return this.sitePluginsStrings;
    };
    /**
     * Get current language.
     *
     * @return {Promise<string>} Promise resolved with the current language.
     */
    CoreLangProvider.prototype.getCurrentLanguage = function () {
        var _this = this;
        if (typeof this.currentLanguage != 'undefined') {
            return Promise.resolve(this.currentLanguage);
        }
        // Get current language from config (user might have changed it).
        return this.configProvider.get('current_language').then(function (language) {
            return language;
        }).catch(function () {
            // User hasn't defined a language. If default language is forced, use it.
            if (__WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].default_lang && __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].forcedefaultlanguage) {
                return __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].default_lang;
            }
            try {
                // No forced language, try to get current language from cordova globalization.
                return _this.globalization.getPreferredLanguage().then(function (result) {
                    var language = result.value.toLowerCase();
                    if (language.indexOf('-') > -1) {
                        // Language code defined by locale has a dash, like en-US or es-ES. Check if it's supported.
                        if (__WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].languages && typeof __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].languages[language] == 'undefined') {
                            // Code is NOT supported. Fallback to language without dash. E.g. 'en-US' would fallback to 'en'.
                            language = language.substr(0, language.indexOf('-'));
                        }
                    }
                    if (typeof __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].languages[language] == 'undefined') {
                        // Language not supported, use default language.
                        return _this.defaultLanguage;
                    }
                    return language;
                }).catch(function () {
                    // Error getting locale. Use default language.
                    return _this.defaultLanguage;
                });
            }
            catch (err) {
                // Error getting locale. Use default language.
                return Promise.resolve(_this.defaultLanguage);
            }
        }).then(function (language) {
            _this.currentLanguage = language; // Save it for later.
            return language;
        });
    };
    /**
     * Get the default language.
     *
     * @return {string} Default language.
     */
    CoreLangProvider.prototype.getDefaultLanguage = function () {
        return this.defaultLanguage;
    };
    /**
     * Get the fallback language.
     *
     * @return {string} Fallback language.
     */
    CoreLangProvider.prototype.getFallbackLanguage = function () {
        return this.fallbackLanguage;
    };
    /**
     * Get the full list of translations for a certain language.
     *
     * @param {string} lang The language to check.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLangProvider.prototype.getTranslationTable = function (lang) {
        var _this = this;
        // Create a promise to convert the observable into a promise.
        return new Promise(function (resolve, reject) {
            var observer = _this.translate.getTranslation(lang).subscribe(function (table) {
                resolve(table);
                observer.unsubscribe();
            }, function (err) {
                reject(err);
                observer.unsubscribe();
            });
        });
    };
    /**
     * Load certain custom strings.
     *
     * @param {string} strings Custom strings to load (tool_mobile_customlangstrings).
     */
    CoreLangProvider.prototype.loadCustomStrings = function (strings) {
        var _this = this;
        if (strings == this.customStringsRaw) {
            // Strings haven't changed, stop.
            return;
        }
        // Reset current values.
        this.clearCustomStrings();
        if (!strings) {
            return;
        }
        var list = strings.split(/(?:\r\n|\r|\n)/);
        list.forEach(function (entry) {
            var values = entry.split('|');
            var lang;
            if (values.length < 3) {
                // Not enough data, ignore the entry.
                return;
            }
            lang = values[2].replace(/_/g, '-'); // Use the app format instead of Moodle format.
            if (!_this.customStrings[lang]) {
                _this.customStrings[lang] = {};
            }
            // Convert old keys format to new one.
            var key = values[0].replace(/^mm\.core/, 'core').replace(/^mm\./, 'core.').replace(/^mma\./, 'addon.')
                .replace(/^core\.sidemenu/, 'core.mainmenu').replace(/^addon\.grades/, 'core.grades')
                .replace(/^addon\.participants/, 'core.user');
            _this.loadString(_this.customStrings, lang, key, values[1]);
        });
        this.customStringsRaw = strings;
    };
    /**
     * Load custom strings for a certain language that weren't loaded because the language wasn't active.
     *
     * @param {any} langObject The object with the strings to load.
     * @param {string} lang Language to load.
     * @return {boolean} Whether the translation table was modified.
     */
    CoreLangProvider.prototype.loadLangStrings = function (langObject, lang) {
        var langApplied = false;
        if (langObject[lang]) {
            for (var key in langObject[lang]) {
                var entry = langObject[lang][key];
                if (!entry.applied) {
                    // Store the original value of the string.
                    entry.original = this.translate.translations[lang][key];
                    // Store the string in the translations table.
                    this.translate.translations[lang][key] = entry.value;
                    entry.applied = true;
                    langApplied = true;
                }
            }
        }
        return langApplied;
    };
    /**
     * Load a string in a certain lang object and in the translate table if the lang is loaded.
     *
     * @param {any} langObject The object where to store the lang.
     * @param {string} lang Language code.
     * @param {string} key String key.
     * @param {string} value String value.
     */
    CoreLangProvider.prototype.loadString = function (langObject, lang, key, value) {
        lang = lang.replace(/_/g, '-'); // Use the app format instead of Moodle format.
        if (this.translate.translations[lang]) {
            // The language is loaded.
            // Store the original value of the string.
            langObject[lang][key] = {
                original: this.translate.translations[lang][key],
                value: value,
                applied: true
            };
            // Store the string in the translations table.
            this.translate.translations[lang][key] = value;
        }
        else {
            // The language isn't loaded.
            // Save it in our object but not in the translations table, it will be loaded when the lang is loaded.
            langObject[lang][key] = {
                value: value,
                applied: false
            };
        }
    };
    /**
     * Unload custom or site plugin strings, removing them from the translations table.
     *
     * @param {any} strings Strings to unload.
     */
    CoreLangProvider.prototype.unloadStrings = function (strings) {
        // Iterate over all languages and strings.
        for (var lang in strings) {
            if (!this.translate.translations[lang]) {
                // Language isn't loaded, nothing to unload.
                continue;
            }
            var langStrings = strings[lang];
            for (var key in langStrings) {
                var entry = langStrings[key];
                if (entry.original) {
                    // The string had a value, restore it.
                    this.translate.translations[lang][key] = entry.original;
                }
                else {
                    // The string didn't exist, delete it.
                    delete this.translate.translations[lang][key];
                }
            }
        }
    };
    CoreLangProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["v" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_3__ionic_native_globalization__["a" /* Globalization */]])
    ], CoreLangProvider);
    return CoreLangProvider;
}());

//# sourceMappingURL=lang.js.map

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTabsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * This component displays some tabs that usually share data between them.
 *
 * If your tabs don't share any data then you should probably use ion-tabs. This component doesn't use different ion-nav
 * for each tab, so it will not load pages.
 *
 * Example usage:
 *
 * <core-tabs selectedIndex="1">
 *     <core-tab [title]="'core.courses.timeline' | translate" (ionSelect)="switchTab('timeline')">
 *         <ng-template> <!-- This ng-template is required, @see CoreTabComponent. -->
 *             <!-- Tab contents. -->
 *         </ng-template>
 *     </core-tab>
 * </core-tabs>
 *
 * Obviously, the tab contents will only be shown if that tab is selected.
 */
var CoreTabsComponent = /** @class */ (function () {
    function CoreTabsComponent(element, content, domUtils, appProvider, platform, translate) {
        var _this = this;
        this.content = content;
        this.domUtils = domUtils;
        this.appProvider = appProvider;
        this.selectedIndex = 0; // Index of the tab to select.
        this.hideUntil = true; // Determine when should the contents be shown.
        this.parentScrollable = false; // Determine if the scroll should be in the parent content or the tab itself.
        this.ionChange = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */](); // Emitted when the tab changes.
        this.tabs = []; // List of tabs.
        this.maxSlides = 3;
        this.slidesShown = this.maxSlides;
        this.numTabsShown = 0;
        this.direction = 'ltr';
        this.description = '';
        this.lastScroll = 0;
        this.initialized = false;
        this.afterViewInitTriggered = false;
        this.tabsShown = true;
        this.isDestroyed = false;
        this.isCurrentView = true;
        this.shouldSlideToInitial = false; // Whether we need to slide to the initial slide because it's out of view.
        this.hasSliddenToInitial = false; // Whether we've already slidden to the initial slide or there was no need.
        this.selectHistory = [];
        this.tabBarElement = element.nativeElement;
        this.direction = platform.isRTL ? 'rtl' : 'ltr';
        // Change the side when the language changes.
        this.languageChangedSubscription = translate.onLangChange.subscribe(function (event) {
            setTimeout(function () {
                _this.direction = platform.isRTL ? 'rtl' : 'ltr';
            });
        });
    }
    /**
     * Component being initialized.
     */
    CoreTabsComponent.prototype.ngOnInit = function () {
        this.originalTabsContainer = this.originalTabsRef.nativeElement;
        this.topTabsElement = this.topTabs.nativeElement;
    };
    /**
     * View has been initialized.
     */
    CoreTabsComponent.prototype.ngAfterViewInit = function () {
        if (this.isDestroyed) {
            return;
        }
        this.afterViewInitTriggered = true;
        if (!this.initialized && this.hideUntil) {
            // Tabs should be shown, initialize them.
            this.initializeTabs();
        }
        this.resizeFunction = this.calculateSlides.bind(this);
        window.addEventListener('resize', this.resizeFunction);
    };
    /**
     * Detect changes on input properties.
     */
    CoreTabsComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        // We need to wait for ngAfterViewInit because we need core-tab components to be executed.
        if (!this.initialized && this.hideUntil && this.afterViewInitTriggered) {
            // Tabs should be shown, initialize them.
            // Use a setTimeout so child core-tab update their inputs before initializing the tabs.
            setTimeout(function () {
                _this.initializeTabs();
            });
        }
    };
    /**
     * User entered the page that contains the component.
     */
    CoreTabsComponent.prototype.ionViewDidEnter = function () {
        this.isCurrentView = true;
        this.calculateSlides();
        this.registerBackButtonAction();
    };
    /**
     * Register back button action.
     */
    CoreTabsComponent.prototype.registerBackButtonAction = function () {
        var _this = this;
        this.unregisterBackButtonAction = this.appProvider.registerBackButtonAction(function () {
            // The previous page in history is not the last one, we need the previous one.
            if (_this.selectHistory.length > 1) {
                var tab_1 = _this.selectHistory[_this.selectHistory.length - 2];
                // Remove curent and previous tabs from history.
                _this.selectHistory = _this.selectHistory.filter(function (tabId) {
                    return _this.selected != tabId && tab_1 != tabId;
                });
                _this.selectTab(tab_1);
                return true;
            }
            else if (_this.selected != _this.firstSelectedTab) {
                // All history is gone but we are not in the first selected tab.
                _this.selectHistory = [];
                _this.selectTab(_this.firstSelectedTab);
                return true;
            }
            return false;
        }, 750);
    };
    /**
     * User left the page that contains the component.
     */
    CoreTabsComponent.prototype.ionViewDidLeave = function () {
        // Unregister the custom back button action for this page
        this.unregisterBackButtonAction && this.unregisterBackButtonAction();
        this.isCurrentView = false;
    };
    /**
     * Add a new tab if it isn't already in the list of tabs.
     *
     * @param {CoreTabComponent} tab The tab to add.
     */
    CoreTabsComponent.prototype.addTab = function (tab) {
        var _this = this;
        // Check if tab is already in the list.
        if (this.getIndex(tab) == -1) {
            this.tabs.push(tab);
            this.sortTabs();
            this.calculateSlides();
            if (this.initialized && this.tabs.length > 1 && this.tabBarHeight == 0) {
                // Calculate the tabBarHeight again now that there is more than 1 tab and the bar will be seen.
                // Use timeout to wait for the view to be rendered. 0 ms should be enough, use 50 to be sure.
                setTimeout(function () {
                    _this.calculateTabBarHeight();
                }, 50);
            }
        }
    };
    /**
     * Calculate slides.
     */
    CoreTabsComponent.prototype.calculateSlides = function () {
        var _this = this;
        if (!this.isCurrentView || !this.tabsShown || !this.initialized) {
            // Don't calculate if component isn't in current view, the calculations are wrong.
            return;
        }
        setTimeout(function () {
            _this.calculateMaxSlides();
            _this.updateSlides();
        });
    };
    /**
     * Calculate the tab bar height.
     */
    CoreTabsComponent.prototype.calculateTabBarHeight = function () {
        this.tabBarHeight = this.topTabsElement.offsetHeight;
        this.originalTabsContainer.style.paddingBottom = this.tabBarHeight + 'px';
    };
    /**
     * Get the index of tab.
     *
     * @param  {any}    tab Tab object to check.
     * @return {number}     Index number on the tabs array or -1 if not found.
     */
    CoreTabsComponent.prototype.getIndex = function (tab) {
        for (var i = 0; i < this.tabs.length; i++) {
            var t = this.tabs[i];
            if (t === tab || (typeof t.id != 'undefined' && t.id === tab.id)) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Get the current selected tab.
     *
     * @return {CoreTabComponent} Selected tab.
     */
    CoreTabsComponent.prototype.getSelected = function () {
        return this.tabs[this.selected];
    };
    /**
     * Initialize the tabs, determining the first tab to be shown.
     */
    CoreTabsComponent.prototype.initializeTabs = function () {
        var selectedIndex = this.selectedIndex || 0, selectedTab = this.tabs[selectedIndex];
        if (!selectedTab || !selectedTab.enabled || !selectedTab.show) {
            // The tab is not enabled or not shown. Get the first tab that is enabled.
            selectedTab = this.tabs.find(function (tab, index) {
                if (tab.enabled && tab.show) {
                    selectedIndex = index;
                    return true;
                }
                return false;
            });
        }
        if (selectedTab) {
            this.firstSelectedTab = selectedIndex;
            this.selectTab(selectedIndex);
        }
        // Setup tab scrolling.
        this.calculateTabBarHeight();
        if (this.content) {
            if (!this.parentScrollable) {
                // Parent scroll element (if core-tabs is inside a ion-content).
                var scroll_1 = this.content.getScrollElement();
                if (scroll_1) {
                    scroll_1.classList.add('no-scroll');
                }
            }
            else {
                this.originalTabsContainer.classList.add('no-scroll');
            }
        }
        this.initialized = true;
        // Check which arrows should be shown.
        this.calculateSlides();
    };
    /**
     * Method executed when the slides are changed.
     */
    CoreTabsComponent.prototype.slideChanged = function () {
        var currentIndex = this.slides.getActiveIndex();
        if (this.slidesShown >= this.numTabsShown) {
            this.showPrevButton = false;
            this.showNextButton = false;
        }
        else if (typeof currentIndex !== 'undefined') {
            this.showPrevButton = currentIndex > 0;
            this.showNextButton = currentIndex < this.numTabsShown - this.slidesShown;
        }
        else {
            this.showPrevButton = false;
            this.showNextButton = this.numTabsShown > this.slidesShown;
        }
        if (this.shouldSlideToInitial && currentIndex != this.selected) {
            // Current tab has changed, don't slide to initial anymore.
            this.shouldSlideToInitial = false;
        }
        this.updateAriaHidden(); // Sliding resets the aria-hidden, update it.
    };
    /**
     * Update slides.
     */
    CoreTabsComponent.prototype.updateSlides = function () {
        var _this = this;
        this.numTabsShown = this.tabs.reduce(function (prev, current) {
            return current.show ? prev + 1 : prev;
        }, 0);
        this.slidesShown = Math.min(this.maxSlides, this.numTabsShown);
        this.slideChanged();
        setTimeout(function () {
            _this.calculateTabBarHeight();
            _this.slides.update();
            _this.slides.resize();
            if (!_this.hasSliddenToInitial && _this.selected && _this.selected >= _this.slidesShown) {
                _this.hasSliddenToInitial = true;
                _this.shouldSlideToInitial = true;
                setTimeout(function () {
                    if (_this.shouldSlideToInitial) {
                        _this.slides.slideTo(_this.selected, 0);
                        _this.shouldSlideToInitial = false;
                        _this.updateAriaHidden(); // Slide's slideTo() sets aria-hidden to true, update it.
                    }
                }, 400);
                return;
            }
            else if (_this.selected) {
                _this.hasSliddenToInitial = true;
            }
            setTimeout(function () {
                _this.updateAriaHidden(); // Slide's update() sets aria-hidden to true, update it.
            }, 400);
        });
    };
    CoreTabsComponent.prototype.calculateMaxSlides = function () {
        if (this.slides) {
            var width = this.domUtils.getElementWidth(this.slides.getNativeElement()) || this.slides.renderedWidth;
            if (width) {
                this.maxSlides = Math.floor(width / 100);
                return;
            }
        }
        this.maxSlides = 3;
    };
    /**
     * Method that shows the next slide.
     */
    CoreTabsComponent.prototype.slideNext = function () {
        if (this.showNextButton) {
            this.slides.slideNext();
        }
    };
    /**
     * Method that shows the previous slide.
     */
    CoreTabsComponent.prototype.slidePrev = function () {
        if (this.showPrevButton) {
            this.slides.slidePrev();
        }
    };
    /**
     * Show or hide the tabs. This is used when the user is scrolling inside a tab.
     *
     * @param {any} scrollElement Scroll element to check scroll position.
     */
    CoreTabsComponent.prototype.showHideTabs = function (scrollElement) {
        if (!this.tabBarHeight) {
            // We don't have the tab bar height, this means the tab bar isn't shown.
            return;
        }
        var scroll = parseInt(scrollElement.scrollTop, 10);
        if (scroll == this.lastScroll) {
            // Ensure scroll has been modified to avoid flicks.
            return;
        }
        if (this.tabsShown && scroll > this.tabBarHeight) {
            this.tabsShown = false;
            // Hide tabs.
            this.tabBarElement.classList.add('tabs-hidden');
        }
        else if (!this.tabsShown && scroll <= this.tabBarHeight) {
            this.tabsShown = true;
            this.tabBarElement.classList.remove('tabs-hidden');
            this.calculateSlides();
        }
        if (this.tabsShown) {
            // Smooth translation.
            this.topTabsElement.style.transform = 'translateY(-' + scroll + 'px)';
            this.originalTabsContainer.style.transform = 'translateY(-' + scroll + 'px)';
            this.originalTabsContainer.style.paddingBottom = this.tabBarHeight - scroll + 'px';
        }
        this.lastScroll = scroll;
    };
    /**
     * Remove a tab from the list of tabs.
     *
     * @param {CoreTabComponent} tab The tab to remove.
     */
    CoreTabsComponent.prototype.removeTab = function (tab) {
        var index = this.getIndex(tab);
        this.tabs.splice(index, 1);
        this.calculateSlides();
    };
    /**
     * Select a certain tab.
     *
     * @param {number} index The index of the tab to select.
     */
    CoreTabsComponent.prototype.selectTab = function (index) {
        if (index == this.selected) {
            // Already selected.
            return;
        }
        if (index < 0 || index >= this.tabs.length) {
            // Index isn't valid, select the first one.
            index = 0;
        }
        var currentTab = this.getSelected(), newTab = this.tabs[index];
        if (!newTab.enabled || !newTab.show) {
            // The tab isn't enabled or shown, stop.
            return;
        }
        if (currentTab) {
            // Unselect previous selected tab.
            currentTab.unselectTab();
        }
        if (this.selected) {
            this.slides.slideTo(index);
            this.updateAriaHidden(); // Slide's slideTo() sets aria-hidden to true, update it.
        }
        this.selectHistory.push(index);
        this.selected = index;
        newTab.selectTab();
        this.ionChange.emit(newTab);
    };
    /**
     * Sort the tabs, keeping the same order as in the original list.
     */
    CoreTabsComponent.prototype.sortTabs = function () {
        var _this = this;
        if (this.originalTabsContainer) {
            var newTabs_1 = [];
            this.tabs.forEach(function (tab, index) {
                var originalIndex = Array.prototype.indexOf.call(_this.originalTabsContainer.children, tab.element);
                if (originalIndex != -1) {
                    newTabs_1[originalIndex] = tab;
                }
            });
            this.tabs = newTabs_1;
        }
    };
    /**
     * Function to call when the visibility of a tab has changed.
     */
    CoreTabsComponent.prototype.tabVisibilityChanged = function () {
        this.calculateSlides();
    };
    /**
     * Update aria-hidden of all tabs.
     */
    CoreTabsComponent.prototype.updateAriaHidden = function () {
        this.tabs.forEach(function (tab, index) {
            tab.updateAriaHidden();
        });
    };
    /**
     * Component destroyed.
     */
    CoreTabsComponent.prototype.ngOnDestroy = function () {
        this.isDestroyed = true;
        if (this.resizeFunction) {
            window.removeEventListener('resize', this.resizeFunction);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabsComponent.prototype, "selectedIndex", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabsComponent.prototype, "hideUntil", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabsComponent.prototype, "parentScrollable", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreTabsComponent.prototype, "ionChange", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('originalTabs'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreTabsComponent.prototype, "originalTabsRef", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('topTabs'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreTabsComponent.prototype, "topTabs", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["z" /* Slides */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["z" /* Slides */])
    ], CoreTabsComponent.prototype, "slides", void 0);
    CoreTabsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-tabs',
            templateUrl: 'core-tabs.html'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["f" /* Content */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreTabsComponent);
    return CoreTabsComponent;
}());

//# sourceMappingURL=tabs.js.map

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModWorkshopProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__offline__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service that provides some features for workshops.
 */
var AddonModWorkshopProvider = /** @class */ (function () {
    function AddonModWorkshopProvider(appProvider, filepoolProvider, sitesProvider, utils, workshopOffline, logHelper) {
        this.appProvider = appProvider;
        this.filepoolProvider = filepoolProvider;
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.workshopOffline = workshopOffline;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModWorkshop:';
    }
    AddonModWorkshopProvider_1 = AddonModWorkshopProvider;
    /**
     * Get cache key for workshop data WS calls.
     *
     * @param  {number} courseId Course ID.
     * @return {string}          Cache key.
     */
    AddonModWorkshopProvider.prototype.getWorkshopDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'workshop:' + courseId;
    };
    /**
     * Get prefix cache key for all workshop activity data WS calls.
     *
     * @param  {number} workshopId Workshop ID.
     * @return {string}            Cache key.
     */
    AddonModWorkshopProvider.prototype.getWorkshopDataPrefixCacheKey = function (workshopId) {
        return this.ROOT_CACHE_KEY + workshopId;
    };
    /**
     * Get cache key for workshop access information data WS calls.
     *
     * @param  {number} workshopId Workshop ID.
     * @return {string}            Cache key.
     */
    AddonModWorkshopProvider.prototype.getWorkshopAccessInformationDataCacheKey = function (workshopId) {
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':access';
    };
    /**
     * Get cache key for workshop user plan data WS calls.
     *
     * @param  {number} workshopId Workshop ID.
     * @return {string}            Cache key.
     */
    AddonModWorkshopProvider.prototype.getUserPlanDataCacheKey = function (workshopId) {
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':userplan';
    };
    /**
     * Get cache key for workshop submissions data WS calls.
     *
     * @param  {number} workshopId  Workshop ID.
     * @param  {number} [userId=0]  User ID.
     * @param  {number} [groupId=0] Group ID.
     * @return {string}             Cache key.
     */
    AddonModWorkshopProvider.prototype.getSubmissionsDataCacheKey = function (workshopId, userId, groupId) {
        if (userId === void 0) { userId = 0; }
        if (groupId === void 0) { groupId = 0; }
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':submissions:' + userId + ':' + groupId;
    };
    /**
     * Get cache key for a workshop submission data WS calls.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @return {string}              Cache key.
     */
    AddonModWorkshopProvider.prototype.getSubmissionDataCacheKey = function (workshopId, submissionId) {
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':submission:' + submissionId;
    };
    /**
     * Get cache key for workshop grades data WS calls.
     *
     * @param  {number} workshopId Workshop ID.
     * @return {string}            Cache key.
     */
    AddonModWorkshopProvider.prototype.getGradesDataCacheKey = function (workshopId) {
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':grades';
    };
    /**
     * Get cache key for workshop grade report data WS calls.
     *
     * @param  {number} workshopId  Workshop ID.
     * @param  {number} [groupId=0] Group ID.
     * @return {string}             Cache key.
     */
    AddonModWorkshopProvider.prototype.getGradesReportDataCacheKey = function (workshopId, groupId) {
        if (groupId === void 0) { groupId = 0; }
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':report:' + groupId;
    };
    /**
     * Get cache key for workshop submission assessments data WS calls.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @return {string}              Cache key.
     */
    AddonModWorkshopProvider.prototype.getSubmissionAssessmentsDataCacheKey = function (workshopId, submissionId) {
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':assessments:' + submissionId;
    };
    /**
     * Get cache key for workshop reviewer assessments data WS calls.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {number} [userId=0] User ID or current user.
     * @return {string}            Cache key.
     */
    AddonModWorkshopProvider.prototype.getReviewerAssessmentsDataCacheKey = function (workshopId, userId) {
        if (userId === void 0) { userId = 0; }
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':reviewerassessments:' + userId;
    };
    /**
     * Get cache key for a workshop assessment data WS calls.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @return {string}              Cache key.
     */
    AddonModWorkshopProvider.prototype.getAssessmentDataCacheKey = function (workshopId, assessmentId) {
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':assessment:' + assessmentId;
    };
    /**
     * Get cache key for workshop assessment form data WS calls.
     *
     * @param  {number} workshopId          Workshop ID.
     * @param  {number} assessmentId        Assessment ID.
     * @param  {string} [mode='assessment'] Mode assessment (default) or preview.
     * @return {string}                     Cache key.
     */
    AddonModWorkshopProvider.prototype.getAssessmentFormDataCacheKey = function (workshopId, assessmentId, mode) {
        if (mode === void 0) { mode = 'assessment'; }
        return this.getWorkshopDataPrefixCacheKey(workshopId) + ':assessmentsform:' + assessmentId + ':' + mode;
    };
    /**
     * Return whether or not the plugin is enabled in a certain site. Plugin is enabled if the workshop WS are available.
     *
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonModWorkshopProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('mod_workshop_get_workshops_by_courses') &&
                site.wsAvailable('mod_workshop_get_workshop_access_information');
        });
    };
    /**
     * Get a workshop with key=value. If more than one is found, only the first will be returned.
     *
     * @param  {number}  courseId           Course ID.
     * @param  {string}  key                Name of the property to check.
     * @param  {any}     value              Value to search.
     * @param  {string}  [siteId]           Site ID. If not defined, current site.
     * @param  {boolean} [forceCache=false] True to always get the value from cache, false otherwise. Default false.
     * @return {Promise<any>}               Promise resolved when the workshop is retrieved.
     */
    AddonModWorkshopProvider.prototype.getWorkshopByKey = function (courseId, key, value, siteId, forceCache) {
        var _this = this;
        if (forceCache === void 0) { forceCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            };
            var preSets = {
                cacheKey: _this.getWorkshopDataCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_7__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_workshop_get_workshops_by_courses', params, preSets).then(function (response) {
                if (response && response.workshops) {
                    var workshopFound = response.workshops.find(function (workshop) { return workshop[key] == value; });
                    if (workshopFound) {
                        return workshopFound;
                    }
                }
                return Promise.reject(null);
            }).then(function (workshop) {
                // Set submission types for Moodle 3.5 and older.
                if (typeof workshop.submissiontypetext == 'undefined') {
                    if (workshop.nattachments > 0) {
                        workshop.submissiontypetext = AddonModWorkshopProvider_1.SUBMISSION_TYPE_AVAILABLE;
                        workshop.submissiontypefile = AddonModWorkshopProvider_1.SUBMISSION_TYPE_AVAILABLE;
                    }
                    else {
                        workshop.submissiontypetext = AddonModWorkshopProvider_1.SUBMISSION_TYPE_REQUIRED;
                        workshop.submissiontypefile = AddonModWorkshopProvider_1.SUBMISSION_TYPE_DISABLED;
                    }
                }
                return workshop;
            });
        });
    };
    /**
     * Get a workshop by course module ID.
     *
     * @param  {number}  courseId           Course ID.
     * @param  {number}  cmId               Course module ID.
     * @param  {string}  [siteId]           Site ID. If not defined, current site.
     * @param  {boolean} [forceCache=false] True to always get the value from cache, false otherwise. Default false.
     * @return {Promise<any>}               Promise resolved when the workshop is retrieved.
     */
    AddonModWorkshopProvider.prototype.getWorkshop = function (courseId, cmId, siteId, forceCache) {
        if (forceCache === void 0) { forceCache = false; }
        return this.getWorkshopByKey(courseId, 'coursemodule', cmId, siteId, forceCache);
    };
    /**
     * Get a workshop by ID.
     *
     * @param  {number}  courseId           Course ID.
     * @param  {number}  id                 Workshop ID.
     * @param  {string}  [siteId]           Site ID. If not defined, current site.
     * @param  {boolean} [forceCache=false] True to always get the value from cache, false otherwise. Default false.
     * @return {Promise<any>}               Promise resolved when the workshop is retrieved.
     */
    AddonModWorkshopProvider.prototype.getWorkshopById = function (courseId, id, siteId, forceCache) {
        if (forceCache === void 0) { forceCache = false; }
        return this.getWorkshopByKey(courseId, 'id', id, siteId, forceCache);
    };
    /**
     * Invalidates workshop data.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the workshop is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateWorkshopData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getWorkshopDataCacheKey(courseId));
        });
    };
    /**
     * Invalidates workshop data except files and module info.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when the workshop is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateWorkshopWSData = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getWorkshopDataPrefixCacheKey(workshopId));
        });
    };
    /**
     * Get access information for a given workshop.
     *
     * @param  {number}  workshopId          Workshop ID.
     * @param  {boolean} [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @return {Promise<any>}                 Promise resolved when the workshop is retrieved.
     */
    AddonModWorkshopProvider.prototype.getWorkshopAccessInformation = function (workshopId, offline, ignoreCache, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                workshopid: workshopId
            };
            var preSets = {
                cacheKey: _this.getWorkshopAccessInformationDataCacheKey(workshopId)
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_workshop_get_workshop_access_information', params, preSets);
        });
    };
    /**
     * Invalidates workshop access information data.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateWorkshopAccessInformationData = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getWorkshopAccessInformationDataCacheKey(workshopId));
        });
    };
    /**
     * Return the planner information for the given user.
     *
     * @param  {number}  workshopId          Workshop ID.
     * @param  {boolean} [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}  [siteId]            Site ID. If not defined, current site.
     * @return {Promise<any>}                Promise resolved when the workshop data is retrieved.
     */
    AddonModWorkshopProvider.prototype.getUserPlanPhases = function (workshopId, offline, ignoreCache, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                workshopid: workshopId
            };
            var preSets = {
                cacheKey: _this.getUserPlanDataCacheKey(workshopId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_7__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_workshop_get_user_plan', params, preSets).then(function (response) {
                if (response && response.userplan && response.userplan.phases) {
                    return _this.utils.arrayToObject(response.userplan.phases, 'code');
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidates workshop user plan data.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateUserPlanPhasesData = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserPlanDataCacheKey(workshopId));
        });
    };
    /**
     * Retrieves all the workshop submissions visible by the current user or the one done by the given user.
     *
     * @param  {number}  workshopId          Workshop ID.
     * @param  {number}  [userId=0]          User ID, 0 means the current user.
     * @param  {number}  [groupId=0]         Group id, 0 means that the function will determine the user group.
     * @param  {boolean} [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}  [siteId]            Site ID. If not defined, current site.
     * @return {Promise<any[]>}              Promise resolved when the workshop submissions are retrieved.
     */
    AddonModWorkshopProvider.prototype.getSubmissions = function (workshopId, userId, groupId, offline, ignoreCache, siteId) {
        var _this = this;
        if (userId === void 0) { userId = 0; }
        if (groupId === void 0) { groupId = 0; }
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                workshopid: workshopId,
                userid: userId,
                groupid: groupId
            };
            var preSets = {
                cacheKey: _this.getSubmissionsDataCacheKey(workshopId, userId, groupId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_7__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_workshop_get_submissions', params, preSets).then(function (response) {
                if (response && response.submissions) {
                    return response.submissions;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidates workshop submissions data.
     *
     * @param  {number} workshopId  Workshop ID.
     * @param  {number} [userId=0]  User ID.
     * @param  {number} [groupId=0] Group ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}       Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateSubmissionsData = function (workshopId, userId, groupId, siteId) {
        var _this = this;
        if (userId === void 0) { userId = 0; }
        if (groupId === void 0) { groupId = 0; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getSubmissionsDataCacheKey(workshopId, userId, groupId));
        });
    };
    /**
     * Retrieves the given submission.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the workshop submission data is retrieved.
     */
    AddonModWorkshopProvider.prototype.getSubmission = function (workshopId, submissionId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                submissionid: submissionId
            };
            var preSets = {
                cacheKey: _this.getSubmissionDataCacheKey(workshopId, submissionId)
            };
            return site.read('mod_workshop_get_submission', params, preSets).then(function (response) {
                if (response && response.submission) {
                    return response.submission;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidates workshop submission data.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateSubmissionData = function (workshopId, submissionId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getSubmissionDataCacheKey(workshopId, submissionId));
        });
    };
    /**
     * Returns the grades information for the given workshop and user.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when the workshop grades data is retrieved.
     */
    AddonModWorkshopProvider.prototype.getGrades = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                workshopid: workshopId
            };
            var preSets = {
                cacheKey: _this.getGradesDataCacheKey(workshopId)
            };
            return site.read('mod_workshop_get_grades', params, preSets);
        });
    };
    /**
     * Invalidates workshop grades data.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateGradesData = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getGradesDataCacheKey(workshopId));
        });
    };
    /**
     * Retrieves the assessment grades report.
     *
     * @param  {number}  workshopId          Workshop ID.
     * @param  {number}  [groupId]           Group id, 0 means that the function will determine the user group.
     * @param  {number}  [page=0]            Page of records to return. Default 0.
     * @param  {number}  [perPage=0]         Records per page to return. Default AddonModWorkshopProvider.PER_PAGE.
     * @param  {boolean} [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}  [siteId]            Site ID. If not defined, current site.
     * @return {Promise<any>}                Promise resolved when the workshop data is retrieved.
     */
    AddonModWorkshopProvider.prototype.getGradesReport = function (workshopId, groupId, page, perPage, offline, ignoreCache, siteId) {
        var _this = this;
        if (groupId === void 0) { groupId = 0; }
        if (page === void 0) { page = 0; }
        if (perPage === void 0) { perPage = 0; }
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                workshopid: workshopId,
                groupid: groupId,
                page: page,
                perpage: perPage || AddonModWorkshopProvider_1.PER_PAGE
            };
            var preSets = {
                cacheKey: _this.getGradesReportDataCacheKey(workshopId, groupId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_7__classes_site__["a" /* CoreSite */].FREQUENCY_OFTEN
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_workshop_get_grades_report', params, preSets).then(function (response) {
                if (response && response.report) {
                    return response.report;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Performs the whole fetch of the grade reports in the workshop.
     *
     * @param  {number}  workshopId          Workshop ID.
     * @param  {number}  [groupId=0]         Group ID.
     * @param  {number}  [perPage=0]         Records per page to fetch. It has to match with the prefetch.
     *                                       Default on AddonModWorkshopProvider.PER_PAGE.
     * @param  {boolean} [forceCache=false]  True to always get the value from cache, false otherwise. Default false.
     * @param  {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}  [siteId]            Site ID. If not defined, current site.
     * @return {Promise<any[]>}              Promise resolved when done.
     */
    AddonModWorkshopProvider.prototype.fetchAllGradeReports = function (workshopId, groupId, perPage, forceCache, ignoreCache, siteId) {
        if (groupId === void 0) { groupId = 0; }
        if (perPage === void 0) { perPage = 0; }
        if (forceCache === void 0) { forceCache = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        perPage = perPage || AddonModWorkshopProvider_1.PER_PAGE;
        return this.fetchGradeReportsRecursive(workshopId, groupId, perPage, forceCache, ignoreCache, [], 0, siteId);
    };
    /**
     * Recursive call on fetch all grade reports.
     *
     * @param  {number}  workshopId  Workshop ID.
     * @param  {number}  groupId     Group ID.
     * @param  {number}  perPage     Records per page to fetch. It has to match with the prefetch.
     * @param  {boolean} forceCache  True to always get the value from cache, false otherwise. Default false.
     * @param  {boolean} ignoreCache True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {any[]}   grades      Grades already fetched (just to concatenate them).
     * @param  {number}  page        Page of records to return.
     * @param  {string}  siteId      Site ID.
     * @return {Promise<any[]>}      Promise resolved when done.
     */
    AddonModWorkshopProvider.prototype.fetchGradeReportsRecursive = function (workshopId, groupId, perPage, forceCache, ignoreCache, grades, page, siteId) {
        var _this = this;
        return this.getGradesReport(workshopId, groupId, page, perPage, forceCache, ignoreCache, siteId).then(function (report) {
            Array.prototype.push.apply(grades, report.grades);
            var canLoadMore = ((page + 1) * perPage) < report.totalcount;
            if (canLoadMore) {
                return _this.fetchGradeReportsRecursive(workshopId, groupId, perPage, forceCache, ignoreCache, grades, page + 1, siteId);
            }
            return grades;
        });
    };
    /**
     * Invalidates workshop grade report data.
     *
     * @param  {number} workshopId  Workshop ID.
     * @param  {number} [groupId=0] Group ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}       Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateGradeReportData = function (workshopId, groupId, siteId) {
        var _this = this;
        if (groupId === void 0) { groupId = 0; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getGradesReportDataCacheKey(workshopId, groupId));
        });
    };
    /**
     * Retrieves the given submission assessment.
     *
     * @param  {number}  workshopId          Workshop ID.
     * @param  {number}  submissionId        Submission ID.
     * @param  {boolean} [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}  [siteId]            Site ID. If not defined, current site.
     * @return {Promise<any[]>}              Promise resolved when the workshop data is retrieved.
     */
    AddonModWorkshopProvider.prototype.getSubmissionAssessments = function (workshopId, submissionId, offline, ignoreCache, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                submissionid: submissionId
            };
            var preSets = {
                cacheKey: _this.getSubmissionAssessmentsDataCacheKey(workshopId, submissionId)
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_workshop_get_submission_assessments', params, preSets).then(function (response) {
                if (response && response.assessments) {
                    return response.assessments;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidates workshop submission assessments data.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateSubmissionAssesmentsData = function (workshopId, submissionId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getSubmissionAssessmentsDataCacheKey(workshopId, submissionId));
        });
    };
    /**
     * Add a new submission to a given workshop.
     *
     * @param  {number}  workshopId           Workshop ID.
     * @param  {number}  courseId             Course ID the workshop belongs to.
     * @param  {string}  title                The submission title.
     * @param  {string}  content              The submission text content.
     * @param  {number}  [attachmentsId]      The draft file area id for attachments.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {number}  [timecreated]        The time the submission was created. Only used when editing an offline discussion.
     * @param  {boolean} [allowOffline=false] True if it can be stored in offline, false otherwise.
     * @return {Promise<any>}                 Promise resolved with submission ID if sent online or false if stored offline.
     */
    AddonModWorkshopProvider.prototype.addSubmission = function (workshopId, courseId, title, content, attachmentsId, siteId, timecreated, allowOffline) {
        var _this = this;
        if (allowOffline === void 0) { allowOffline = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.workshopOffline.saveSubmission(workshopId, courseId, title, content, {}, timecreated, 'add', siteId).then(function () {
                return false;
            });
        };
        // If we are editing an offline discussion, discard previous first.
        var discardPromise = timecreated ? this.workshopOffline.deleteSubmissionAction(workshopId, timecreated, 'add', siteId) : Promise.resolve();
        return discardPromise.then(function () {
            if (!_this.appProvider.isOnline() && allowOffline) {
                // App is offline, store the action.
                return storeOffline();
            }
            return _this.addSubmissionOnline(workshopId, title, content, attachmentsId, siteId).catch(function (error) {
                if (allowOffline && !_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Add a new submission to a given workshop. It will fail if offline or cannot connect.
     *
     * @param  {number} workshopId      Workshop ID.
     * @param  {string} title           The submission title.
     * @param  {string} content         The submission text content.
     * @param  {number} [attachmentsId] The draft file area id for attachments.
     * @param  {string} [siteId]        Site ID. If not defined, current site.
     * @return {Promise<any>}           Promise resolved when the submission is created.
     */
    AddonModWorkshopProvider.prototype.addSubmissionOnline = function (workshopId, title, content, attachmentsId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                workshopid: workshopId,
                title: title,
                content: content,
                attachmentsid: attachmentsId || 0
            };
            return site.write('mod_workshop_add_submission', params).then(function (response) {
                // Other errors ocurring.
                if (!response || !response.submissionid) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                return response.submissionid;
            });
        });
    };
    /**
     * Updates the given submission.
     *
     * @param  {number}  workshopId           Workshop ID.
     * @param  {number}  submissionId         Submission ID.
     * @param  {number}  courseId             Course ID the workshop belongs to.
     * @param  {string}  title                The submission title.
     * @param  {string}  content              The submission text content.
     * @param  {number}  [attachmentsId]      The draft file area id for attachments.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [allowOffline=false] True if it can be stored in offline, false otherwise.
     * @return {Promise<any>}                 Promise resolved with submission ID if sent online or false if stored offline.
     */
    AddonModWorkshopProvider.prototype.updateSubmission = function (workshopId, submissionId, courseId, title, content, attachmentsId, siteId, allowOffline) {
        var _this = this;
        if (allowOffline === void 0) { allowOffline = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.workshopOffline.saveSubmission(workshopId, courseId, title, content, attachmentsId, submissionId, 'update', siteId).then(function () {
                return false;
            });
        };
        // If we are editing an offline discussion, discard previous first.
        return this.workshopOffline.deleteSubmissionAction(workshopId, submissionId, 'update', siteId).then(function () {
            if (!_this.appProvider.isOnline() && allowOffline) {
                // App is offline, store the action.
                return storeOffline();
            }
            return _this.updateSubmissionOnline(submissionId, title, content, attachmentsId, siteId).catch(function (error) {
                if (allowOffline && !_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Updates the given submission. It will fail if offline or cannot connect.
     *
     * @param  {number} submissionId    Submission ID.
     * @param  {string} title           The submission title.
     * @param  {string} content         The submission text content.
     * @param  {number} [attachmentsId] The draft file area id for attachments.
     * @param  {string} [siteId]        Site ID. If not defined, current site.
     * @return {Promise<any>}           Promise resolved when the submission is updated.
     */
    AddonModWorkshopProvider.prototype.updateSubmissionOnline = function (submissionId, title, content, attachmentsId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                submissionid: submissionId,
                title: title,
                content: content,
                attachmentsid: attachmentsId || 0
            };
            return site.write('mod_workshop_update_submission', params).then(function (response) {
                // Other errors ocurring.
                if (!response || !response.status) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                // Return submissionId to be consistent with addSubmission.
                return Promise.resolve(submissionId);
            });
        });
    };
    /**
     * Deletes the given submission.
     *
     * @param  {number}  workshopId  Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @param  {number} courseId     Course ID the workshop belongs to.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with submission ID if sent online, resolved with false if stored offline.
     */
    AddonModWorkshopProvider.prototype.deleteSubmission = function (workshopId, submissionId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.workshopOffline.saveSubmission(workshopId, courseId, '', '', 0, submissionId, 'delete', siteId).then(function () {
                return false;
            });
        };
        // If we are editing an offline discussion, discard previous first.
        return this.workshopOffline.deleteSubmissionAction(workshopId, submissionId, 'delete', siteId).then(function () {
            if (!_this.appProvider.isOnline()) {
                // App is offline, store the action.
                return storeOffline();
            }
            return _this.deleteSubmissionOnline(submissionId, siteId).catch(function (error) {
                if (!_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Deletes the given submission. It will fail if offline or cannot connect.
     *
     * @param  {number} submissionId Submission ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the submission is deleted.
     */
    AddonModWorkshopProvider.prototype.deleteSubmissionOnline = function (submissionId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                submissionid: submissionId
            };
            return site.write('mod_workshop_delete_submission', params).then(function (response) {
                // Other errors ocurring.
                if (!response || !response.status) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                // Return submissionId to be consistent with addSubmission.
                return Promise.resolve(submissionId);
            });
        });
    };
    /**
     * Retrieves all the assessments reviewed by the given user.
     *
     * @param  {number}  workshopId          Workshop ID.
     * @param  {number}  [userId]            User ID. If not defined, current user.
     * @param  {boolean} [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}  [siteId]            Site ID. If not defined, current site.
     * @return {Promise<any[]>}              Promise resolved when the workshop data is retrieved.
     */
    AddonModWorkshopProvider.prototype.getReviewerAssessments = function (workshopId, userId, offline, ignoreCache, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                workshopid: workshopId
            };
            var preSets = {
                cacheKey: _this.getReviewerAssessmentsDataCacheKey(workshopId, userId)
            };
            if (userId) {
                params.userid = userId;
            }
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_workshop_get_reviewer_assessments', params, preSets).then(function (response) {
                if (response && response.assessments) {
                    return response.assessments;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidates workshop user assessments data.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {number} [userId]   User ID. If not defined, current user.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateReviewerAssesmentsData = function (workshopId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getReviewerAssessmentsDataCacheKey(workshopId, userId));
        });
    };
    /**
     * Retrieves the given assessment.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the workshop data is retrieved.
     */
    AddonModWorkshopProvider.prototype.getAssessment = function (workshopId, assessmentId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assessmentid: assessmentId
            };
            var preSets = {
                cacheKey: _this.getAssessmentDataCacheKey(workshopId, assessmentId)
            };
            return site.read('mod_workshop_get_assessment', params, preSets).then(function (response) {
                if (response && response.assessment) {
                    return response.assessment;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidates workshop assessment data.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateAssessmentData = function (workshopId, assessmentId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAssessmentDataCacheKey(workshopId, assessmentId));
        });
    };
    /**
     * Retrieves the assessment form definition (data required to be able to display the assessment form).
     *
     * @param  {number}    workshopId          Workshop ID.
     * @param  {number}    assessmentId        Assessment ID.
     * @param  {string}    [mode='assessment'] Mode assessment (default) or preview.
     * @param  {boolean}   [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean}   [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}    [siteId]            Site ID. If not defined, current site.
     * @return {Promise<any>}                  Promise resolved when the workshop data is retrieved.
     */
    AddonModWorkshopProvider.prototype.getAssessmentForm = function (workshopId, assessmentId, mode, offline, ignoreCache, siteId) {
        var _this = this;
        if (mode === void 0) { mode = 'assessment'; }
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assessmentid: assessmentId,
                mode: mode || 'assessment'
            };
            var preSets = {
                cacheKey: _this.getAssessmentFormDataCacheKey(workshopId, assessmentId, mode),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_7__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_workshop_get_assessment_form_definition', params, preSets).then(function (response) {
                if (response) {
                    response.fields = _this.parseFields(response.fields);
                    response.options = _this.utils.objectToKeyValueMap(response.options, 'name', 'value');
                    response.current = _this.parseFields(response.current);
                    return response;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Parse fieldes into a more handful format.
     *
     * @param  {any[]} fields Fields to parse
     * @return {any[]}        Parsed fields
     */
    AddonModWorkshopProvider.prototype.parseFields = function (fields) {
        var parsedFields = [];
        fields.forEach(function (field) {
            var args = field.name.split('_');
            var name = args[0];
            var idx = args[3];
            var idy = args[6] || false;
            if (parseInt(idx, 10) == idx) {
                if (!parsedFields[idx]) {
                    parsedFields[idx] = {
                        number: parseInt(idx, 10) + 1
                    };
                }
                if (idy && parseInt(idy, 10) == idy) {
                    if (!parsedFields[idx].fields) {
                        parsedFields[idx].fields = [];
                    }
                    if (!parsedFields[idx].fields[idy]) {
                        parsedFields[idx].fields[idy] = {
                            number: parseInt(idy, 10) + 1
                        };
                    }
                    parsedFields[idx].fields[idy][name] = field.value;
                }
                else {
                    parsedFields[idx][name] = field.value;
                }
            }
        });
        return parsedFields;
    };
    /**
     * Invalidates workshop assessments form data.
     *
     * @param  {number} workshopId          Workshop ID.
     * @param  {number} assessmentId        Assessment ID.
     * @param  {string} [mode='assessment'] Mode assessment (default) or preview.
     * @param  {string} [siteId]            Site ID. If not defined, current site.
     * @return {Promise<any>}               Promise resolved when the data is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateAssessmentFormData = function (workshopId, assessmentId, mode, siteId) {
        var _this = this;
        if (mode === void 0) { mode = 'assessment'; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAssessmentFormDataCacheKey(workshopId, assessmentId, mode));
        });
    };
    /**
     * Updates the given assessment.
     *
     * @param {number}  workshopId           Workshop ID.
     * @param {number}  assessmentId         Assessment ID.
     * @param {number}  courseId             Course ID the workshop belongs to.
     * @param {any}     inputData            Assessment data.
     * @param {string}  [siteId]             Site ID. If not defined, current site.
     * @param {boolean} [allowOffline=false] True if it can be stored in offline, false otherwise.
     * @return {Promise<any>}                Promise resolved with the grade of the submission if sent online,
     *                                       resolved with false if stored offline.
     */
    AddonModWorkshopProvider.prototype.updateAssessment = function (workshopId, assessmentId, courseId, inputData, siteId, allowOffline) {
        var _this = this;
        if (allowOffline === void 0) { allowOffline = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.workshopOffline.saveAssessment(workshopId, assessmentId, courseId, inputData, siteId).then(function () {
                return false;
            });
        };
        // If we are editing an offline discussion, discard previous first.
        return this.workshopOffline.deleteAssessment(workshopId, assessmentId, siteId).then(function () {
            if (!_this.appProvider.isOnline() && allowOffline) {
                // App is offline, store the action.
                return storeOffline();
            }
            return _this.updateAssessmentOnline(assessmentId, inputData, siteId).catch(function (error) {
                if (allowOffline && !_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Updates the given assessment. It will fail if offline or cannot connect.
     *
     * @param  {number} assessmentId Assessment ID.
     * @param  {any}    inputData    Assessment data.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with the grade of the submission.
     */
    AddonModWorkshopProvider.prototype.updateAssessmentOnline = function (assessmentId, inputData, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assessmentid: assessmentId,
                data: _this.utils.objectToArrayOfObjects(inputData, 'name', 'value')
            };
            return site.write('mod_workshop_update_assessment', params).then(function (response) {
                // Other errors ocurring.
                if (!response || !response.status) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                // Return rawgrade for submission
                return response.rawgrade;
            });
        });
    };
    /**
     * Evaluates a submission (used by teachers for provide feedback or override the submission grade).
     *
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  submissionId The submission id.
     * @param  {number}  courseId     Course ID the workshop belongs to.
     * @param  {string}  feedbackText The feedback for the author.
     * @param  {boolean} published    Whether to publish the submission for other users.
     * @param  {any}     gradeOver    The new submission grade (empty for no overriding the grade).
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when submission is evaluated if sent online,
     *                                resolved with false if stored offline.
     */
    AddonModWorkshopProvider.prototype.evaluateSubmission = function (workshopId, submissionId, courseId, feedbackText, published, gradeOver, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.workshopOffline.saveEvaluateSubmission(workshopId, submissionId, courseId, feedbackText, published, gradeOver, siteId).then(function () {
                return false;
            });
        };
        // If we are editing an offline discussion, discard previous first.
        return this.workshopOffline.deleteEvaluateSubmission(workshopId, submissionId, siteId).then(function () {
            if (!_this.appProvider.isOnline()) {
                // App is offline, store the action.
                return storeOffline();
            }
            return _this.evaluateSubmissionOnline(submissionId, feedbackText, published, gradeOver, siteId).catch(function (error) {
                if (!_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Evaluates a submission (used by teachers for provide feedback or override the submission grade).
     * It will fail if offline or cannot connect.
     *
     * @param  {number}  submissionId The submission id.
     * @param  {string}  feedbackText The feedback for the author.
     * @param  {boolean} published    Whether to publish the submission for other users.
     * @param  {any}     gradeOver    The new submission grade (empty for no overriding the grade).
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when the submission is evaluated.
     */
    AddonModWorkshopProvider.prototype.evaluateSubmissionOnline = function (submissionId, feedbackText, published, gradeOver, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                submissionid: submissionId,
                feedbacktext: feedbackText || '',
                feedbackformat: 1,
                published: published ? 1 : 0,
                gradeover: gradeOver
            };
            return site.write('mod_workshop_evaluate_submission', params).then(function (response) {
                // Other errors ocurring.
                if (!response || !response.status) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                // Return if worked.
                return Promise.resolve(true);
            });
        });
    };
    /**
     * Evaluates an assessment (used by teachers for provide feedback to the reviewer).
     *
     * @param  {number}  workshopId       Workshop ID.
     * @param  {number}  assessmentId     The assessment id.
     * @param  {number}  courseId         Course ID the workshop belongs to.
     * @param  {string}  feedbackText     The feedback for the reviewer.
     * @param  {boolean} weight           The new weight for the assessment.
     * @param  {any}     gradingGradeOver The new grading grade (empty for no overriding the grade).
     * @param  {string}  [siteId]         Site ID. If not defined, current site.
     * @return {Promise<any>}             Promise resolved when assessment is evaluated if sent online,
     *                                    resolved with false if stored offline.
     */
    AddonModWorkshopProvider.prototype.evaluateAssessment = function (workshopId, assessmentId, courseId, feedbackText, weight, gradingGradeOver, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.workshopOffline.saveEvaluateAssessment(workshopId, assessmentId, courseId, feedbackText, weight, gradingGradeOver, siteId).then(function () {
                return false;
            });
        };
        // If we are editing an offline discussion, discard previous first.
        return this.workshopOffline.deleteEvaluateAssessment(workshopId, assessmentId, siteId).then(function () {
            if (!_this.appProvider.isOnline()) {
                // App is offline, store the action.
                return storeOffline();
            }
            return _this.evaluateAssessmentOnline(assessmentId, feedbackText, weight, gradingGradeOver, siteId).catch(function (error) {
                if (!_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Evaluates an assessment (used by teachers for provide feedback to the reviewer). It will fail if offline or cannot connect.
     *
     * @param  {number}  assessmentId     The assessment id.
     * @param  {string}  feedbackText     The feedback for the reviewer.
     * @param  {number}  weight           The new weight for the assessment.
     * @param  {any}     gradingGradeOver The new grading grade (empty for no overriding the grade).
     * @param  {string}  [siteId]         Site ID. If not defined, current site.
     * @return {Promise<any>}             Promise resolved when the assessment is evaluated.
     */
    AddonModWorkshopProvider.prototype.evaluateAssessmentOnline = function (assessmentId, feedbackText, weight, gradingGradeOver, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                assessmentid: assessmentId,
                feedbacktext: feedbackText || '',
                feedbackformat: 1,
                weight: weight,
                gradinggradeover: gradingGradeOver
            };
            return site.write('mod_workshop_evaluate_assessment', params).then(function (response) {
                // Other errors ocurring.
                if (!response || !response.status) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                // Return if worked.
                return Promise.resolve(true);
            });
        });
    };
    /**
     * Invalidate the prefetched content except files.
     * To invalidate files, use AddonModWorkshopProvider#invalidateFiles.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promised resolved when content is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getWorkshop(courseId, moduleId, siteId, true).then(function (workshop) {
            return _this.invalidateContentById(workshop.id, courseId, siteId);
        });
    };
    /**
     * Invalidate the prefetched content except files using the activityId.
     * To invalidate files, use AdddonModWorkshop#invalidateFiles.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {number} courseId   Course ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when content is invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateContentById = function (workshopId, courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [
            // Do not invalidate workshop data before getting workshop info, we need it!
            this.invalidateWorkshopData(courseId, siteId),
            this.invalidateWorkshopWSData(workshopId, siteId),
        ];
        return Promise.all(promises);
    };
    /**
     * Invalidate the prefetched files.
     *
     * @param  {number} moduleId The module ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the files are invalidated.
     */
    AddonModWorkshopProvider.prototype.invalidateFiles = function (moduleId, siteId) {
        return this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModWorkshopProvider_1.COMPONENT, moduleId);
    };
    /**
     * Report the workshop as being viewed.
     *
     * @param  {number} id       Workshop ID.
     * @param {string} [name] Name of the workshop.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the WS call is successful.
     */
    AddonModWorkshopProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            workshopid: id
        };
        return this.logHelper.logSingle('mod_workshop_view_workshop', params, AddonModWorkshopProvider_1.COMPONENT, id, name, 'workshop', siteId);
    };
    /**
     * Report the workshop submission as being viewed.
     *
     * @param  {number} id          Submission ID.
     * @param  {number} workshopId  Workshop ID.
     * @param {string} [name] Name of the workshop.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the WS call is successful.
     */
    AddonModWorkshopProvider.prototype.logViewSubmission = function (id, workshopId, name, siteId) {
        var params = {
            submissionid: id
        };
        return this.logHelper.logSingle('mod_workshop_view_submission', params, AddonModWorkshopProvider_1.COMPONENT, workshopId, name, 'workshop', params, siteId);
    };
    AddonModWorkshopProvider.COMPONENT = 'mmaModWorkshop';
    AddonModWorkshopProvider.PER_PAGE = 10;
    AddonModWorkshopProvider.PHASE_SETUP = 10;
    AddonModWorkshopProvider.PHASE_SUBMISSION = 20;
    AddonModWorkshopProvider.PHASE_ASSESSMENT = 30;
    AddonModWorkshopProvider.PHASE_EVALUATION = 40;
    AddonModWorkshopProvider.PHASE_CLOSED = 50;
    AddonModWorkshopProvider.SUBMISSION_TYPE_DISABLED = 0;
    AddonModWorkshopProvider.SUBMISSION_TYPE_AVAILABLE = 1;
    AddonModWorkshopProvider.SUBMISSION_TYPE_REQUIRED = 2;
    AddonModWorkshopProvider.SUBMISSION_CHANGED = 'addon_mod_workshop_submission_changed';
    AddonModWorkshopProvider.ASSESSMENT_SAVED = 'addon_mod_workshop_assessment_saved';
    AddonModWorkshopProvider.ASSESSMENT_INVALIDATED = 'addon_mod_workshop_assessment_invalidated';
    AddonModWorkshopProvider = AddonModWorkshopProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__offline__["a" /* AddonModWorkshopOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModWorkshopProvider);
    return AddonModWorkshopProvider;
    var AddonModWorkshopProvider_1;
}());

//# sourceMappingURL=workshop.js.map

/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileSessionProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sites__ = __webpack_require__(1);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Helper to store some temporary data for file submission.
 *
 * It uses siteId and component name to index the files.
 * Every component can provide a File area identifier to indentify every file list on the session.
 * This value can be the activity id or a mix of name and numbers.
 */
var CoreFileSessionProvider = /** @class */ (function () {
    function CoreFileSessionProvider(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.files = {};
    }
    /**
     * Add a file to the session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {any} file File to add.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.addFile = function (component, id, file, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.initFileArea(component, id, siteId);
        this.files[siteId][component][id].push(file);
    };
    /**
     * Clear files stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.clearFiles = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id]) {
            this.files[siteId][component][id] = [];
        }
    };
    /**
     * Get files stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {any[]} Array of files in session.
     */
    CoreFileSessionProvider.prototype.getFiles = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id]) {
            return this.files[siteId][component][id];
        }
        return [];
    };
    /**
     * Initializes the filearea to store the file.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.initFileArea = function (component, id, siteId) {
        if (!this.files[siteId]) {
            this.files[siteId] = {};
        }
        if (!this.files[siteId][component]) {
            this.files[siteId][component] = {};
        }
        if (!this.files[siteId][component][id]) {
            this.files[siteId][component][id] = [];
        }
    };
    /**
     * Remove a file stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {any} file File to remove. The instance should be exactly the same as the one stored in session.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.removeFile = function (component, id, file, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id]) {
            var position = this.files[siteId][component][id].indexOf(file);
            if (position != -1) {
                this.files[siteId][component][id].splice(position, 1);
            }
        }
    };
    /**
     * Remove a file stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {number} index Position of the file to remove.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.removeFileByIndex = function (component, id, index, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id] && index >= 0 &&
            index < this.files[siteId][component][id].length) {
            this.files[siteId][component][id].splice(index, 1);
        }
    };
    /**
     * Set a group of files in the session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {any[]} newFiles Files to set.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.setFiles = function (component, id, newFiles, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.initFileArea(component, id, siteId);
        this.files[siteId][component][id] = newFiles;
    };
    CoreFileSessionProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__sites__["a" /* CoreSitesProvider */]])
    ], CoreFileSessionProvider);
    return CoreFileSessionProvider;
}());

//# sourceMappingURL=file-session.js.map

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__default_format__ = __webpack_require__(540);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_delegate__ = __webpack_require__(111);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to interact with course formats. Provides the functions to register and interact with the addons.
 */
var CoreCourseFormatDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseFormatDelegate, _super);
    function CoreCourseFormatDelegate(loggerProvider, sitesProvider, eventsProvider, defaultHandler) {
        var _this = _super.call(this, 'CoreCoursesCourseFormatDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.defaultHandler = defaultHandler;
        _this.featurePrefix = 'CoreCourseFormatDelegate_';
        _this.handlerNameProperty = 'format';
        return _this;
    }
    /**
     * Whether it allows seeing all sections at the same time. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether it allows seeing all sections at the same time.
     */
    CoreCourseFormatDelegate.prototype.canViewAllSections = function (course) {
        return this.executeFunctionOnEnabled(course.format, 'canViewAllSections', [course]);
    };
    /**
     * Whether the option to enable section/module download should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether the option to enable section/module download should be displayed
     */
    CoreCourseFormatDelegate.prototype.displayEnableDownload = function (course) {
        return this.executeFunctionOnEnabled(course.format, 'displayEnableDownload', [course]);
    };
    /**
     * Whether the course refresher should be displayed. If it returns false, a refresher must be included in the course format,
     * and the doRefresh method of CoreCourseSectionPage must be called on refresh. Defaults to true.
     *
     * @param {any} course The course to check.
     * @param {any[]} sections List of course sections.
     * @return {boolean} Whether the refresher should be displayed.
     */
    CoreCourseFormatDelegate.prototype.displayRefresher = function (course, sections) {
        return this.executeFunctionOnEnabled(course.format, 'displayRefresher', [course, sections]);
    };
    /**
     * Whether the default section selector should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether the section selector should be displayed.
     */
    CoreCourseFormatDelegate.prototype.displaySectionSelector = function (course) {
        return this.executeFunctionOnEnabled(course.format, 'displaySectionSelector', [course]);
    };
    /**
     * Get the component to use to display all sections in a course.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getAllSectionsComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunctionOnEnabled(course.format, 'getAllSectionsComponent', [injector, course]))
            .catch(function (e) {
            _this.logger.error('Error getting all sections component', e);
        });
    };
    /**
     * Get the component to use to display a course format.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getCourseFormatComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunctionOnEnabled(course.format, 'getCourseFormatComponent', [injector, course]))
            .catch(function (e) {
            _this.logger.error('Error getting course format component', e);
        });
    };
    /**
     * Get the component to use to display the course summary in the default course format.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getCourseSummaryComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunctionOnEnabled(course.format, 'getCourseSummaryComponent', [injector, course]))
            .catch(function (e) {
            _this.logger.error('Error getting course summary component', e);
        });
    };
    /**
     * Given a course, return the title to use in the course page.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} [sections] List of sections.
     * @return {string} Course title.
     */
    CoreCourseFormatDelegate.prototype.getCourseTitle = function (course, sections) {
        return this.executeFunctionOnEnabled(course.format, 'getCourseTitle', [course, sections]);
    };
    /**
     * Given a course and a list of sections, return the current section that should be displayed first.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {Promise<any>} Promise resolved with current section.
     */
    CoreCourseFormatDelegate.prototype.getCurrentSection = function (course, sections) {
        // Convert the result to a Promise if it isn't.
        return Promise.resolve(this.executeFunctionOnEnabled(course.format, 'getCurrentSection', [course, sections])).catch(function () {
            // This function should never fail. Just return all the sections.
            return sections[0];
        });
    };
    /**
     * Get the component to use to display the section selector inside the default course format.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getSectionSelectorComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunctionOnEnabled(course.format, 'getSectionSelectorComponent', [injector, course]))
            .catch(function (e) {
            _this.logger.error('Error getting section selector component', e);
        });
    };
    /**
     * Get the component to use to display a single section. This component will only be used if the user is viewing
     * a single section. If all the sections are displayed at once then it won't be used.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getSingleSectionComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunctionOnEnabled(course.format, 'getSingleSectionComponent', [injector, course]))
            .catch(function (e) {
            _this.logger.error('Error getting single section component', e);
        });
    };
    /**
     * Invalidate the data required to load the course format.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseFormatDelegate.prototype.invalidateData = function (course, sections) {
        return this.executeFunctionOnEnabled(course.format, 'invalidateData', [course, sections]);
    };
    /**
     * Open a course.
     *
     * @param {NavController} navCtrl The NavController instance to use.
     * @param {any} course The course to open. It should contain a "format" attribute.
     * @param {any} [params] Params to pass to the course page.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseFormatDelegate.prototype.openCourse = function (navCtrl, course, params) {
        return this.executeFunctionOnEnabled(course.format, 'openCourse', [navCtrl, course, params]);
    };
    /**
     * Whether the view should be refreshed when completion changes. If your course format doesn't display
     * activity completion then you should return false.
     *
     * @param {any} course The course.
     * @return {Promise<boolean>} Whether course view should be refreshed when an activity completion changes.
     */
    CoreCourseFormatDelegate.prototype.shouldRefreshWhenCompletionChanges = function (course) {
        return Promise.resolve(this.executeFunctionOnEnabled(course.format, 'shouldRefreshWhenCompletionChanges', [course]));
    };
    CoreCourseFormatDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__default_format__["a" /* CoreCourseFormatDefaultHandler */]])
    ], CoreCourseFormatDelegate);
    return CoreCourseFormatDelegate;
}(__WEBPACK_IMPORTED_MODULE_5__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=format-delegate.js.map

/***/ }),
/* 169 */,
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModDataFieldPluginComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(22);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * Base class for component to render a field.
 */
var AddonModDataFieldPluginComponent = /** @class */ (function () {
    function AddonModDataFieldPluginComponent(fb) {
        this.fb = fb;
        this.gotoEntry = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Add the form control for the search mode.
     *
     * @param {string} fieldName Control field name.
     * @param {any}    value     Initial set value.
     */
    AddonModDataFieldPluginComponent.prototype.addControl = function (fieldName, value) {
        if (!this.form) {
            return;
        }
        if (this.mode == 'search') {
            this.form.addControl(fieldName, this.fb.control(this.search[fieldName] || null));
        }
        if (this.mode == 'edit') {
            this.form.addControl(fieldName, this.fb.control(value, this.field.required ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["u" /* Validators */].required : null));
        }
    };
    /**
     * Component being initialized.
     */
    AddonModDataFieldPluginComponent.prototype.ngOnInit = function () {
        this.init();
    };
    /**
     * Initialize field.
     */
    AddonModDataFieldPluginComponent.prototype.init = function () {
        return;
    };
    /**
     * Return if is shown or list mode.
     *
     * @return {boolean} True if mode is show or list.
     */
    AddonModDataFieldPluginComponent.prototype.isShowOrListMode = function () {
        return this.mode == 'list' || this.mode == 'show';
    };
    /**
     * Component being changed.
     */
    AddonModDataFieldPluginComponent.prototype.ngOnChanges = function (changes) {
        if (this.isShowOrListMode() && changes.value) {
            this.updateValue(changes.value.currentValue);
        }
    };
    /**
     * Update value being shown.
     */
    AddonModDataFieldPluginComponent.prototype.updateValue = function (value) {
        this.value = value;
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], AddonModDataFieldPluginComponent.prototype, "mode", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonModDataFieldPluginComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonModDataFieldPluginComponent.prototype, "value", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonModDataFieldPluginComponent.prototype, "database", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], AddonModDataFieldPluginComponent.prototype, "error", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], AddonModDataFieldPluginComponent.prototype, "gotoEntry", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* FormGroup */])
    ], AddonModDataFieldPluginComponent.prototype, "form", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonModDataFieldPluginComponent.prototype, "search", void 0);
    return AddonModDataFieldPluginComponent;
}());

//# sourceMappingURL=field-plugin-component.js.map

/***/ }),
/* 171 */,
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModAssignHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_groups__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_fileuploader_providers_fileuploader__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__feedback_delegate__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__submission_delegate__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__assign__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__assign_offline__ = __webpack_require__(127);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service that provides some helper functions for assign.
 */
var AddonModAssignHelperProvider = /** @class */ (function () {
    function AddonModAssignHelperProvider(logger, sitesProvider, fileProvider, assignProvider, utils, assignOffline, feedbackDelegate, submissionDelegate, fileUploaderProvider, groupsProvider) {
        this.sitesProvider = sitesProvider;
        this.fileProvider = fileProvider;
        this.assignProvider = assignProvider;
        this.utils = utils;
        this.assignOffline = assignOffline;
        this.feedbackDelegate = feedbackDelegate;
        this.submissionDelegate = submissionDelegate;
        this.fileUploaderProvider = fileUploaderProvider;
        this.groupsProvider = groupsProvider;
        this.logger = logger.getInstance('AddonModAssignHelperProvider');
    }
    /**
     * Check if a submission can be edited in offline.
     *
     * @param {any} assign Assignment.
     * @param {any} submission Submission.
     * @return {boolean} Whether it can be edited offline.
     */
    AddonModAssignHelperProvider.prototype.canEditSubmissionOffline = function (assign, submission) {
        if (!submission) {
            return Promise.resolve(false);
        }
        if (submission.status == __WEBPACK_IMPORTED_MODULE_9__assign__["a" /* AddonModAssignProvider */].SUBMISSION_STATUS_NEW ||
            submission.status == __WEBPACK_IMPORTED_MODULE_9__assign__["a" /* AddonModAssignProvider */].SUBMISSION_STATUS_REOPENED) {
            // It's a new submission, allow creating it in offline.
            return Promise.resolve(true);
        }
        var promises = [];
        var canEdit = true;
        for (var i = 0; i < submission.plugins.length; i++) {
            var plugin = submission.plugins[i];
            promises.push(this.submissionDelegate.canPluginEditOffline(assign, submission, plugin).then(function (canEditPlugin) {
                if (!canEditPlugin) {
                    canEdit = false;
                }
            }));
        }
        return Promise.all(promises).then(function () {
            return canEdit;
        });
    };
    /**
     * Clear plugins temporary data because a submission was cancelled.
     *
     * @param {any} assign Assignment.
     * @param {any} submission Submission to clear the data for.
     * @param {any} inputData Data entered in the submission form.
     */
    AddonModAssignHelperProvider.prototype.clearSubmissionPluginTmpData = function (assign, submission, inputData) {
        var _this = this;
        submission.plugins.forEach(function (plugin) {
            _this.submissionDelegate.clearTmpData(assign, submission, plugin, inputData);
        });
    };
    /**
     * Copy the data from last submitted attempt to the current submission.
     * Since we don't have any WS for that we'll have to re-submit everything manually.
     *
     * @param {any} assign Assignment.
     * @param {any} previousSubmission Submission to copy.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModAssignHelperProvider.prototype.copyPreviousAttempt = function (assign, previousSubmission) {
        var _this = this;
        var pluginData = {}, promises = [];
        previousSubmission.plugins.forEach(function (plugin) {
            promises.push(_this.submissionDelegate.copyPluginSubmissionData(assign, plugin, pluginData));
        });
        return Promise.all(promises).then(function () {
            // We got the plugin data. Now we need to submit it.
            if (Object.keys(pluginData).length) {
                // There's something to save.
                return _this.assignProvider.saveSubmissionOnline(assign.id, pluginData);
            }
        });
    };
    /**
     * Delete stored submission files for a plugin. See storeSubmissionFiles.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModAssignHelperProvider.prototype.deleteStoredSubmissionFiles = function (assignId, folderName, userId, siteId) {
        var _this = this;
        return this.assignOffline.getSubmissionPluginFolder(assignId, folderName, userId, siteId).then(function (folderPath) {
            return _this.fileProvider.removeDir(folderPath);
        });
    };
    /**
     * Delete all drafts of the feedback plugin data.
     *
     * @param {number} assignId Assignment Id.
     * @param {number} userId User Id.
     * @param {any} feedback  Feedback data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModAssignHelperProvider.prototype.discardFeedbackPluginData = function (assignId, userId, feedback, siteId) {
        var _this = this;
        var promises = [];
        feedback.plugins.forEach(function (plugin) {
            promises.push(_this.feedbackDelegate.discardPluginFeedbackData(assignId, userId, plugin, siteId));
        });
        return Promise.all(promises);
    };
    /**
     * List the participants for a single assignment, with some summary info about their submissions.
     *
     * @param {any} assign Assignment object.
     * @param {number} [groupId] Group Id.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of participants and summary of submissions.
     */
    AddonModAssignHelperProvider.prototype.getParticipants = function (assign, groupId, ignoreCache, siteId) {
        var _this = this;
        groupId = groupId || 0;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.assignProvider.listParticipants(assign.id, groupId, ignoreCache, siteId).then(function (participants) {
            if (groupId || participants && participants.length > 0) {
                return participants;
            }
            // If no participants returned and all groups specified, get participants by groups.
            return _this.groupsProvider.getActivityAllowedGroupsIfEnabled(assign.cmid, undefined, siteId).then(function (userGroups) {
                var promises = [], participants = {};
                userGroups.forEach(function (userGroup) {
                    promises.push(_this.assignProvider.listParticipants(assign.id, userGroup.id, ignoreCache, siteId)
                        .then(function (parts) {
                        // Do not get repeated users.
                        parts.forEach(function (participant) {
                            participants[participant.id] = participant;
                        });
                    }));
                });
                return Promise.all(promises).then(function () {
                    return _this.utils.objectToArray(participants);
                });
            });
        });
    };
    /**
     * Get plugin config from assignment config.
     *
     * @param {any} assign Assignment object including all config.
     * @param {string} subtype Subtype name (assignsubmission or assignfeedback)
     * @param {string} type Name of the subplugin.
     * @return {any} Object containing all configurations of the subplugin selected.
     */
    AddonModAssignHelperProvider.prototype.getPluginConfig = function (assign, subtype, type) {
        var configs = {};
        assign.configs.forEach(function (config) {
            if (config.subtype == subtype && config.plugin == type) {
                configs[config.name] = config.value;
            }
        });
        return configs;
    };
    /**
     * Get enabled subplugins.
     *
     * @param {any} assign Assignment object including all config.
     * @param {string} subtype  Subtype name (assignsubmission or assignfeedback)
     * @return {any} List of enabled plugins for the assign.
     */
    AddonModAssignHelperProvider.prototype.getPluginsEnabled = function (assign, subtype) {
        var enabled = [];
        assign.configs.forEach(function (config) {
            if (config.subtype == subtype && config.name == 'enabled' && parseInt(config.value, 10) === 1) {
                // Format the plugin objects.
                enabled.push({
                    type: config.plugin
                });
            }
        });
        return enabled;
    };
    /**
     * Get a list of stored submission files. See storeSubmissionFiles.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    AddonModAssignHelperProvider.prototype.getStoredSubmissionFiles = function (assignId, folderName, userId, siteId) {
        var _this = this;
        return this.assignOffline.getSubmissionPluginFolder(assignId, folderName, userId, siteId).then(function (folderPath) {
            return _this.fileProvider.getDirectoryContents(folderPath);
        });
    };
    /**
     * Get the size that will be uploaded to perform an attempt copy.
     *
     * @param {any} assign Assignment.
     * @param {any} previousSubmission Submission to copy.
     * @return {Promise<number>} Promise resolved with the size.
     */
    AddonModAssignHelperProvider.prototype.getSubmissionSizeForCopy = function (assign, previousSubmission) {
        var _this = this;
        var promises = [];
        var totalSize = 0;
        previousSubmission.plugins.forEach(function (plugin) {
            promises.push(_this.submissionDelegate.getPluginSizeForCopy(assign, plugin).then(function (size) {
                totalSize += size;
            }));
        });
        return Promise.all(promises).then(function () {
            return totalSize;
        });
    };
    /**
     * Get the size that will be uploaded to save a submission.
     *
     * @param {any} assign Assignment.
     * @param {any} submission Submission to check data.
     * @param {any} inputData Data entered in the submission form.
     * @return {Promise<number>} Promise resolved with the size.
     */
    AddonModAssignHelperProvider.prototype.getSubmissionSizeForEdit = function (assign, submission, inputData) {
        var _this = this;
        var promises = [];
        var totalSize = 0;
        submission.plugins.forEach(function (plugin) {
            promises.push(_this.submissionDelegate.getPluginSizeForEdit(assign, submission, plugin, inputData).then(function (size) {
                totalSize += size;
            }));
        });
        return Promise.all(promises).then(function () {
            return totalSize;
        });
    };
    /**
     * Get user data for submissions since they only have userid.
     *
     * @param {any} assign Assignment object.
     * @param {any[]} submissions Submissions to get the data for.
     * @param {number} [groupId] Group Id.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site id (empty for current site).
     * @return {Promise<any[]>} Promise always resolved. Resolve param is the formatted submissions.
     */
    AddonModAssignHelperProvider.prototype.getSubmissionsUserData = function (assign, submissions, groupId, ignoreCache, siteId) {
        var _this = this;
        return this.getParticipants(assign, groupId).then(function (participants) {
            var blind = assign.blindmarking && !assign.revealidentities;
            var promises = [];
            var result = [];
            participants = _this.utils.arrayToObject(participants, 'id');
            submissions.forEach(function (submission) {
                submission.submitid = submission.userid > 0 ? submission.userid : submission.blindid;
                if (submission.submitid <= 0) {
                    return;
                }
                var participant = participants[submission.submitid];
                if (participant) {
                    delete participants[submission.submitid];
                }
                else {
                    // Avoid permission denied error. Participant not found on list.
                    return;
                }
                if (!blind) {
                    submission.userfullname = participant.fullname;
                    submission.userprofileimageurl = participant.profileimageurl;
                }
                submission.manyGroups = !!participant.groups && participant.groups.length > 1;
                submission.noGroups = !!participant.groups && participant.groups.length == 0;
                if (participant.groupname) {
                    submission.groupid = participant.groupid;
                    submission.groupname = participant.groupname;
                }
                var promise;
                if (submission.userid > 0 && blind) {
                    // Blind but not blinded! (Moodle < 3.1.1, 3.2).
                    delete submission.userid;
                    promise = _this.assignProvider.getAssignmentUserMappings(assign.id, submission.submitid, ignoreCache, siteId).
                        then(function (blindId) {
                        submission.blindid = blindId;
                    });
                }
                promise = promise || Promise.resolve();
                promises.push(promise.then(function () {
                    // Add to the list.
                    if (submission.userfullname || submission.blindid) {
                        result.push(submission);
                    }
                }));
            });
            return Promise.all(promises).then(function () {
                // Create a submission for each participant left in the list (the participants already treated were removed).
                _this.utils.objectToArray(participants).forEach(function (participant) {
                    var submission = {
                        submitid: participant.id
                    };
                    if (!blind) {
                        submission.userid = participant.id;
                        submission.userfullname = participant.fullname;
                        submission.userprofileimageurl = participant.profileimageurl;
                    }
                    else {
                        submission.blindid = participant.id;
                    }
                    submission.manyGroups = !!participant.groups && participant.groups.length > 1;
                    submission.noGroups = !!participant.groups && participant.groups.length == 0;
                    if (participant.groupname) {
                        submission.groupid = participant.groupid;
                        submission.groupname = participant.groupname;
                    }
                    submission.status = participant.submitted ? __WEBPACK_IMPORTED_MODULE_9__assign__["a" /* AddonModAssignProvider */].SUBMISSION_STATUS_SUBMITTED :
                        __WEBPACK_IMPORTED_MODULE_9__assign__["a" /* AddonModAssignProvider */].SUBMISSION_STATUS_NEW;
                    result.push(submission);
                });
                return result;
            });
        });
    };
    /**
     * Check if the feedback data has changed for a certain submission and assign.
     *
     * @param {any} assign Assignment.
     * @param {number} userId User Id.
     * @param {any} feedback Feedback data.
     * @return {Promise<boolean>} Promise resolved with true if data has changed, resolved with false otherwise.
     */
    AddonModAssignHelperProvider.prototype.hasFeedbackDataChanged = function (assign, userId, feedback) {
        var _this = this;
        var promises = [];
        var hasChanged = false;
        feedback.plugins.forEach(function (plugin) {
            promises.push(_this.prepareFeedbackPluginData(assign.id, userId, feedback).then(function (inputData) {
                return _this.feedbackDelegate.hasPluginDataChanged(assign, userId, plugin, inputData, userId).then(function (changed) {
                    if (changed) {
                        hasChanged = true;
                    }
                });
            }).catch(function () {
                // Ignore errors.
            }));
        });
        return this.utils.allPromises(promises).then(function () {
            return hasChanged;
        });
    };
    /**
     * Check if the submission data has changed for a certain submission and assign.
     *
     * @param {any} assign Assignment.
     * @param {any} submission Submission to check data.
     * @param {any} inputData Data entered in the submission form.
     * @return {Promise<boolean>} Promise resolved with true if data has changed, resolved with false otherwise.
     */
    AddonModAssignHelperProvider.prototype.hasSubmissionDataChanged = function (assign, submission, inputData) {
        var _this = this;
        var promises = [];
        var hasChanged = false;
        submission.plugins.forEach(function (plugin) {
            promises.push(_this.submissionDelegate.hasPluginDataChanged(assign, submission, plugin, inputData).then(function (changed) {
                if (changed) {
                    hasChanged = true;
                }
            }).catch(function () {
                // Ignore errors.
            }));
        });
        return this.utils.allPromises(promises).then(function () {
            return hasChanged;
        });
    };
    /**
     * Prepare and return the plugin data to send for a certain feedback and assign.
     *
     * @param {number} assignId Assignment Id.
     * @param {number} userId User Id.
     * @param {any} feedback Feedback data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with plugin data to send to server.
     */
    AddonModAssignHelperProvider.prototype.prepareFeedbackPluginData = function (assignId, userId, feedback, siteId) {
        var _this = this;
        var pluginData = {}, promises = [];
        feedback.plugins.forEach(function (plugin) {
            promises.push(_this.feedbackDelegate.preparePluginFeedbackData(assignId, userId, plugin, pluginData, siteId));
        });
        return Promise.all(promises).then(function () {
            return pluginData;
        });
    };
    /**
     * Prepare and return the plugin data to send for a certain submission and assign.
     *
     * @param {any} assign Assignment.
     * @param {any} submission Submission to check data.
     * @param {any} inputData  Data entered in the submission form.
     * @param {boolean} [offline] True to prepare the data for an offline submission, false otherwise.
     * @return {Promise<any>} Promise resolved with plugin data to send to server.
     */
    AddonModAssignHelperProvider.prototype.prepareSubmissionPluginData = function (assign, submission, inputData, offline) {
        var _this = this;
        var pluginData = {}, promises = [];
        submission.plugins.forEach(function (plugin) {
            promises.push(_this.submissionDelegate.preparePluginSubmissionData(assign, submission, plugin, inputData, pluginData, offline));
        });
        return Promise.all(promises).then(function () {
            return pluginData;
        });
    };
    /**
     * Given a list of files (either online files or local files), store the local files in a local folder
     * to be submitted later.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).
     * @param {any[]} files List of files.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if success, rejected otherwise.
     */
    AddonModAssignHelperProvider.prototype.storeSubmissionFiles = function (assignId, folderName, files, userId, siteId) {
        var _this = this;
        // Get the folder where to store the files.
        return this.assignOffline.getSubmissionPluginFolder(assignId, folderName, userId, siteId).then(function (folderPath) {
            return _this.fileUploaderProvider.storeFilesToUpload(folderPath, files);
        });
    };
    /**
     * Upload a file to a draft area. If the file is an online file it will be downloaded and then re-uploaded.
     *
     * @param {number} assignId Assignment ID.
     * @param {any} file Online file or local FileEntry.
     * @param {number} [itemId] Draft ID to use. Undefined or 0 to create a new draft ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the itemId.
     */
    AddonModAssignHelperProvider.prototype.uploadFile = function (assignId, file, itemId, siteId) {
        return this.fileUploaderProvider.uploadOrReuploadFile(file, itemId, __WEBPACK_IMPORTED_MODULE_9__assign__["a" /* AddonModAssignProvider */].COMPONENT, assignId, siteId);
    };
    /**
     * Given a list of files (either online files or local files), upload them to a draft area and return the draft ID.
     * Online files will be downloaded and then re-uploaded.
     * If there are no files to upload it will return a fake draft ID (1).
     *
     * @param {number} assignId Assignment ID.
     * @param {any[]} files List of files.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the itemId.
     */
    AddonModAssignHelperProvider.prototype.uploadFiles = function (assignId, files, siteId) {
        return this.fileUploaderProvider.uploadOrReuploadFiles(files, __WEBPACK_IMPORTED_MODULE_9__assign__["a" /* AddonModAssignProvider */].COMPONENT, assignId, siteId);
    };
    /**
     * Upload or store some files, depending if the user is offline or not.
     *
     * @param {number} assignId Assignment ID.
     * @param {string} folderName Name of the plugin folder. Must be unique (both in submission and feedback plugins).
     * @param {any[]} files List of files.
     * @param {boolean} offline True if files sould be stored for offline, false to upload them.
     * @param {number} [userId] User ID. If not defined, site's current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModAssignHelperProvider.prototype.uploadOrStoreFiles = function (assignId, folderName, files, offline, userId, siteId) {
        if (offline) {
            return this.storeSubmissionFiles(assignId, folderName, files, userId, siteId);
        }
        else {
            return this.uploadFiles(assignId, files, siteId);
        }
    };
    AddonModAssignHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_9__assign__["a" /* AddonModAssignProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__assign_offline__["a" /* AddonModAssignOfflineProvider */], __WEBPACK_IMPORTED_MODULE_7__feedback_delegate__["a" /* AddonModAssignFeedbackDelegate */],
            __WEBPACK_IMPORTED_MODULE_8__submission_delegate__["a" /* AddonModAssignSubmissionDelegate */], __WEBPACK_IMPORTED_MODULE_6__core_fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_groups__["a" /* CoreGroupsProvider */]])
    ], AddonModAssignHelperProvider);
    return AddonModAssignHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_file_helper__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_mimetype__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_constants__ = __webpack_require__(39);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Component to handle a remote file. Shows the file name, icon (depending on mimetype) and a button
 * to download/refresh it.
 */
var CoreFileComponent = /** @class */ (function () {
    function CoreFileComponent(sitesProvider, utils, domUtils, filepoolProvider, appProvider, fileHelper, mimeUtils, eventsProvider, textUtils) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.domUtils = domUtils;
        this.filepoolProvider = filepoolProvider;
        this.appProvider = appProvider;
        this.fileHelper = fileHelper;
        this.mimeUtils = mimeUtils;
        this.eventsProvider = eventsProvider;
        this.textUtils = textUtils;
        // Use it for files that you cannot determine if they're outdated or not.
        this.canDownload = true; // Whether file can be downloaded.
        this.showSize = true; // Whether show filesize.
        this.showTime = true; // Whether show file time modified.
        this.onDelete = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreFileComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.canDelete = this.utils.isTrueOrOne(this.canDelete);
        this.alwaysDownload = this.utils.isTrueOrOne(this.alwaysDownload);
        this.canDownload = this.utils.isTrueOrOne(this.canDownload);
        this.fileUrl = this.fileHelper.getFileUrl(this.file);
        this.timemodified = this.fileHelper.getFileTimemodified(this.file);
        this.siteId = this.sitesProvider.getCurrentSiteId();
        this.fileSize = this.file.filesize;
        this.fileName = this.file.filename;
        if (this.utils.isTrueOrOne(this.showSize) && this.fileSize >= 0) {
            this.fileSizeReadable = this.textUtils.bytesToSize(this.fileSize, 2);
        }
        this.showTime = this.utils.isTrueOrOne(this.showTime) && this.timemodified > 0;
        if (this.file.isexternalfile) {
            this.alwaysDownload = true; // Always show the download button in external files.
        }
        this.fileIcon = this.mimeUtils.getFileIcon(this.file.filename);
        if (this.canDownload) {
            this.calculateState();
            // Update state when receiving events about this file.
            this.filepoolProvider.getFileEventNameByUrl(this.siteId, this.fileUrl).then(function (eventName) {
                _this.observer = _this.eventsProvider.on(eventName, function () {
                    _this.calculateState();
                });
            });
        }
    };
    /**
     * Convenience function to get the file state and set variables based on it.
     *
     * @return {Promise<void>} Promise resolved when state has been calculated.
     */
    CoreFileComponent.prototype.calculateState = function () {
        var _this = this;
        return this.filepoolProvider.getFileStateByUrl(this.siteId, this.fileUrl, this.timemodified).then(function (state) {
            _this.canDownload = _this.sitesProvider.getCurrentSite().canDownloadFiles();
            _this.state = state;
            _this.isDownloading = _this.canDownload && state === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].DOWNLOADING;
        });
    };
    /**
     * Convenience function to open a file, downloading it if needed.
     *
     * @return {Promise<string>} Promise resolved when file is opened.
     */
    CoreFileComponent.prototype.openFile = function () {
        var _this = this;
        return this.fileHelper.downloadAndOpenFile(this.file, this.component, this.componentId, this.state, function (event) {
            if (event && event.calculating) {
                // The process is calculating some data required for the download, show the spinner.
                _this.isDownloading = true;
            }
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
        });
    };
    /**
     * Download a file and, optionally, open it afterwards.
     *
     * @param {Event} [e] Click event.
     * @param {boolean} openAfterDownload Whether the file should be opened after download.
     */
    CoreFileComponent.prototype.download = function (e, openAfterDownload) {
        var _this = this;
        if (openAfterDownload === void 0) { openAfterDownload = false; }
        e && e.preventDefault();
        e && e.stopPropagation();
        var promise;
        if (this.isDownloading && !openAfterDownload) {
            return;
        }
        if (!this.canDownload) {
            // File cannot be downloaded, just open it.
            if (this.file.toURL) {
                // Local file.
                this.utils.openFile(this.file.toURL());
            }
            else if (this.fileUrl) {
                if (this.fileUrl.indexOf('http') === 0) {
                    this.utils.openOnlineFile(this.fileUrl);
                }
                else {
                    this.utils.openFile(this.fileUrl);
                }
            }
            return;
        }
        if (!this.appProvider.isOnline() && (!openAfterDownload || (openAfterDownload &&
            !(this.state === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].DOWNLOADED || this.state === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].OUTDATED)))) {
            this.domUtils.showErrorModal('core.networkerrormsg', true);
            return;
        }
        if (openAfterDownload) {
            // File needs to be opened now.
            this.openFile().catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
            });
        }
        else {
            // File doesn't need to be opened (it's a prefetch). Show confirm modal if file size is defined and it's big.
            promise = this.fileSize ? this.domUtils.confirmDownloadSize({ size: this.fileSize, total: true }) : Promise.resolve();
            promise.then(function () {
                // User confirmed, add the file to queue.
                return _this.filepoolProvider.invalidateFileByUrl(_this.siteId, _this.fileUrl).finally(function () {
                    _this.isDownloading = true;
                    _this.filepoolProvider.addToQueueByUrl(_this.siteId, _this.fileUrl, _this.component, _this.componentId, _this.timemodified, undefined, undefined, 0, _this.file).catch(function (error) {
                        _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
                        _this.calculateState();
                    });
                });
            }).catch(function () {
                // Ignore error.
            });
        }
    };
    /**
     * Delete the file.
     *
     * @param {Event} e Click event.
     */
    CoreFileComponent.prototype.delete = function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.canDelete) {
            this.onDelete.emit();
        }
    };
    /**
     * Component destroyed.
     */
    CoreFileComponent.prototype.ngOnDestroy = function () {
        this.observer && this.observer.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "file", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFileComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "canDelete", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "alwaysDownload", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "canDownload", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "showSize", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "showTime", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreFileComponent.prototype, "onDelete", void 0);
    CoreFileComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-file',
            templateUrl: 'core-file.html'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_file_helper__["a" /* CoreFileHelperProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreFileComponent);
    return CoreFileComponent;
}());

//# sourceMappingURL=file.js.map

/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreConfigProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__app__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Factory to provide access to dynamic and permanent config and settings.
 * It should not be abused into a temporary storage.
 */
var CoreConfigProvider = /** @class */ (function () {
    function CoreConfigProvider(appProvider) {
        this.TABLE_NAME = 'core_config';
        this.tableSchema = {
            name: this.TABLE_NAME,
            columns: [
                {
                    name: 'name',
                    type: 'TEXT',
                    unique: true,
                    notNull: true
                },
                {
                    name: 'value'
                }
            ]
        };
        this.appDB = appProvider.getDB();
        this.appDB.createTableFromSchema(this.tableSchema);
    }
    /**
     * Deletes an app setting.
     *
     * @param {string} name The config name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreConfigProvider.prototype.delete = function (name) {
        return this.appDB.deleteRecords(this.TABLE_NAME, { name: name });
    };
    /**
     * Get an app setting.
     *
     * @param {string} name The config name.
     * @param {any} [defaultValue] Default value to use if the entry is not found.
     * @return {Promise<any>} Resolves upon success along with the config data. Reject on failure.
     */
    CoreConfigProvider.prototype.get = function (name, defaultValue) {
        return this.appDB.getRecord(this.TABLE_NAME, { name: name }).then(function (entry) {
            return entry.value;
        }).catch(function (error) {
            if (typeof defaultValue != 'undefined') {
                return defaultValue;
            }
            return Promise.reject(error);
        });
    };
    /**
     * Set an app setting.
     *
     * @param {string} name The config name.
     * @param {number|string} value The config value. Can only store number or strings.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreConfigProvider.prototype.set = function (name, value) {
        return this.appDB.insertRecord(this.TABLE_NAME, { name: name, value: value });
    };
    CoreConfigProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__app__["a" /* CoreAppProvider */]])
    ], CoreConfigProvider);
    return CoreConfigProvider;
}());

//# sourceMappingURL=config.js.map

/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModWorkshopOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__ = __webpack_require__(24);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to handle offline workshop.
 */
var AddonModWorkshopOfflineProvider = /** @class */ (function () {
    function AddonModWorkshopOfflineProvider(fileProvider, sitesProvider, textUtils, timeUtils) {
        this.fileProvider = fileProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.timeUtils = timeUtils;
        this.siteSchema = {
            name: 'AddonModWorkshopOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModWorkshopOfflineProvider_1.SUBMISSIONS_TABLE,
                    columns: [
                        {
                            name: 'workshopid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'submissionid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'action',
                            type: 'TEXT',
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'title',
                            type: 'TEXT',
                        },
                        {
                            name: 'content',
                            type: 'TEXT',
                        },
                        {
                            name: 'attachmentsid',
                            type: 'TEXT',
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER',
                        }
                    ],
                    primaryKeys: ['workshopid', 'submissionid', 'action']
                },
                {
                    name: AddonModWorkshopOfflineProvider_1.ASSESSMENTS_TABLE,
                    columns: [
                        {
                            name: 'workshopid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'assessmentid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'inputdata',
                            type: 'TEXT',
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER',
                        },
                    ],
                    primaryKeys: ['workshopid', 'assessmentid']
                },
                {
                    name: AddonModWorkshopOfflineProvider_1.EVALUATE_SUBMISSIONS_TABLE,
                    columns: [
                        {
                            name: 'workshopid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'submissionid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER',
                        },
                        {
                            name: 'feedbacktext',
                            type: 'TEXT',
                        },
                        {
                            name: 'published',
                            type: 'INTEGER',
                        },
                        {
                            name: 'gradeover',
                            type: 'TEXT',
                        },
                    ],
                    primaryKeys: ['workshopid', 'submissionid']
                },
                {
                    name: AddonModWorkshopOfflineProvider_1.EVALUATE_ASSESSMENTS_TABLE,
                    columns: [
                        {
                            name: 'workshopid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'assessmentid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER',
                        },
                        {
                            name: 'feedbacktext',
                            type: 'TEXT',
                        },
                        {
                            name: 'weight',
                            type: 'INTEGER',
                        },
                        {
                            name: 'gradinggradeover',
                            type: 'TEXT',
                        },
                    ],
                    primaryKeys: ['workshopid', 'assessmentid']
                }
            ]
        };
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModWorkshopOfflineProvider_1 = AddonModWorkshopOfflineProvider;
    /**
     * Get all the workshops ids that have something to be synced.
     *
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<number[]>} Promise resolved with workshops id that have something to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getAllWorkshops = function (siteId) {
        var promises = [
            this.getAllSubmissions(siteId),
            this.getAllAssessments(siteId),
            this.getAllEvaluateSubmissions(siteId),
            this.getAllEvaluateAssessments(siteId)
        ];
        return Promise.all(promises).then(function (promiseResults) {
            var workshopIds = {};
            // Get workshops from any offline object all should have workshopid.
            promiseResults.forEach(function (offlineObjects) {
                offlineObjects.forEach(function (offlineObject) {
                    workshopIds[offlineObject.workshopid] = true;
                });
            });
            return Object.keys(workshopIds).map(function (workshopId) { return parseInt(workshopId, 10); });
        });
    };
    /**
     * Check if there is an offline data to be synced.
     *
     * @param  {number} workshopId Workshop ID to remove.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<boolean>}  Promise resolved with boolean: true if has offline data, false otherwise.
     */
    AddonModWorkshopOfflineProvider.prototype.hasWorkshopOfflineData = function (workshopId, siteId) {
        var promises = [
            this.getSubmissions(workshopId, siteId),
            this.getAssessments(workshopId, siteId),
            this.getEvaluateSubmissions(workshopId, siteId),
            this.getEvaluateAssessments(workshopId, siteId)
        ];
        return Promise.all(promises).then(function (results) {
            return results.some(function (result) { return result && result.length; });
        }).catch(function () {
            // No offline data found.
            return false;
        });
    };
    /**
     * Delete workshop submission action.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @param  {string} action       Action to be done.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved if stored, rejected if failure.
     */
    AddonModWorkshopOfflineProvider.prototype.deleteSubmissionAction = function (workshopId, submissionId, action, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId,
                submissionid: submissionId,
                action: action
            };
            return site.getDb().deleteRecords(AddonModWorkshopOfflineProvider_1.SUBMISSIONS_TABLE, conditions);
        });
    };
    /**
     * Delete all workshop submission actions.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved if stored, rejected if failure.
     */
    AddonModWorkshopOfflineProvider.prototype.deleteAllSubmissionActions = function (workshopId, submissionId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId,
                submissionid: submissionId,
            };
            return site.getDb().deleteRecords(AddonModWorkshopOfflineProvider_1.SUBMISSIONS_TABLE, conditions);
        });
    };
    /**
     * Get the all the submissions to be synced.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Promise resolved with the objects to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getAllSubmissions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModWorkshopOfflineProvider_1.SUBMISSIONS_TABLE).then(function (records) {
                records.forEach(_this.parseSubmissionRecord.bind(_this));
                return records;
            });
        });
    };
    /**
     * Get the submissions of a workshop to be synced.
     *
     * @param  {number} workshopId ID of the workshop.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved with the object to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getSubmissions = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId
            };
            return site.getDb().getRecords(AddonModWorkshopOfflineProvider_1.SUBMISSIONS_TABLE, conditions).then(function (records) {
                records.forEach(_this.parseSubmissionRecord.bind(_this));
                return records;
            });
        });
    };
    /**
     * Get all actions of a submission of a workshop to be synced.
     *
     * @param  {number} workshopId   ID of the workshop.
     * @param  {number} submissionId ID of the submission.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any[]>}      Promise resolved with the object to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getSubmissionActions = function (workshopId, submissionId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId,
                submissionid: submissionId
            };
            return site.getDb().getRecords(AddonModWorkshopOfflineProvider_1.SUBMISSIONS_TABLE, conditions).then(function (records) {
                records.forEach(_this.parseSubmissionRecord.bind(_this));
                return records;
            });
        });
    };
    /**
     * Get an specific action of a submission of a workshop to be synced.
     *
     * @param  {number} workshopId   ID of the workshop.
     * @param  {number} submissionId ID of the submission.
     * @param  {string} action       Action to be done.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with the object to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getSubmissionAction = function (workshopId, submissionId, action, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId,
                submissionid: submissionId,
                action: action
            };
            return site.getDb().getRecord(AddonModWorkshopOfflineProvider_1.SUBMISSIONS_TABLE, conditions).then(function (record) {
                _this.parseSubmissionRecord(record);
                return record;
            });
        });
    };
    /**
     * Offline version for adding a submission action to a workshop.
     *
     * @param  {number} workshopId    Workshop ID.
     * @param  {number} courseId      Course ID the workshop belongs to.
     * @param  {string} title         The submission title.
     * @param  {string} content       The submission text content.
     * @param  {any}    attachmentsId Stored attachments.
     * @param  {number} submissionId  Submission Id, if action is add, the time the submission was created.
     *                                If set to 0, current time is used.
     * @param  {string} action        Action to be done. ['add', 'update', 'delete']
     * @param  {string} [siteId]      Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when submission action is successfully saved.
     */
    AddonModWorkshopOfflineProvider.prototype.saveSubmission = function (workshopId, courseId, title, content, attachmentsId, submissionId, action, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var timemodified = _this.timeUtils.timestamp();
            var assessment = {
                workshopid: workshopId,
                courseid: courseId,
                title: title,
                content: content,
                attachmentsid: JSON.stringify(attachmentsId),
                action: action,
                submissionid: submissionId ? submissionId : -timemodified,
                timemodified: timemodified
            };
            return site.getDb().insertRecord(AddonModWorkshopOfflineProvider_1.SUBMISSIONS_TABLE, assessment);
        });
    };
    /**
     * Parse "attachments" column of a submission record.
     *
     * @param  {any} record Submission record, modified in place.
     */
    AddonModWorkshopOfflineProvider.prototype.parseSubmissionRecord = function (record) {
        record.attachmentsid = this.textUtils.parseJSON(record.attachmentsid);
    };
    /**
     * Delete workshop assessment.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved if stored, rejected if failure.
     */
    AddonModWorkshopOfflineProvider.prototype.deleteAssessment = function (workshopId, assessmentId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId,
                assessmentid: assessmentId
            };
            return site.getDb().deleteRecords(AddonModWorkshopOfflineProvider_1.ASSESSMENTS_TABLE, conditions);
        });
    };
    /**
     * Get the all the assessments to be synced.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Promise resolved with the objects to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getAllAssessments = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModWorkshopOfflineProvider_1.ASSESSMENTS_TABLE).then(function (records) {
                records.forEach(_this.parseAssessmentRecord.bind(_this));
                return records;
            });
        });
    };
    /**
     * Get the assessments of a workshop to be synced.
     *
     * @param  {number} workshopId ID of the workshop.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any[]>}    Promise resolved with the object to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getAssessments = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId
            };
            return site.getDb().getRecords(AddonModWorkshopOfflineProvider_1.ASSESSMENTS_TABLE, conditions).then(function (records) {
                records.forEach(_this.parseAssessmentRecord.bind(_this));
                return records;
            });
        });
    };
    /**
     * Get an specific assessment of a workshop to be synced.
     *
     * @param  {number} workshopId   ID of the workshop.
     * @param  {number} assessmentId Assessment ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with the object to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getAssessment = function (workshopId, assessmentId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId,
                assessmentid: assessmentId
            };
            return site.getDb().getRecord(AddonModWorkshopOfflineProvider_1.ASSESSMENTS_TABLE, conditions).then(function (record) {
                _this.parseAssessmentRecord(record);
                return record;
            });
        });
    };
    /**
     * Offline version for adding an assessment to a workshop.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {number} courseId     Course ID the workshop belongs to.
     * @param  {any}    inputData    Assessment data.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when assessment is successfully saved.
     */
    AddonModWorkshopOfflineProvider.prototype.saveAssessment = function (workshopId, assessmentId, courseId, inputData, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var assessment = {
                workshopid: workshopId,
                courseid: courseId,
                inputdata: JSON.stringify(inputData),
                assessmentid: assessmentId,
                timemodified: _this.timeUtils.timestamp()
            };
            return site.getDb().insertRecord(AddonModWorkshopOfflineProvider_1.ASSESSMENTS_TABLE, assessment);
        });
    };
    /**
     * Parse "inpudata" column of an assessment record.
     *
     * @param {any} record Assessnent record, modified in place.
     */
    AddonModWorkshopOfflineProvider.prototype.parseAssessmentRecord = function (record) {
        record.inputdata = this.textUtils.parseJSON(record.inputdata);
    };
    /**
     * Delete workshop evaluate submission.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved if stored, rejected if failure.
     */
    AddonModWorkshopOfflineProvider.prototype.deleteEvaluateSubmission = function (workshopId, submissionId, siteId) {
        var conditions = {
            workshopid: workshopId,
            submissionid: submissionId
        };
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(AddonModWorkshopOfflineProvider_1.EVALUATE_SUBMISSIONS_TABLE, conditions);
        });
    };
    /**
     * Get the all the evaluate submissions to be synced.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Promise resolved with the objects to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getAllEvaluateSubmissions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModWorkshopOfflineProvider_1.EVALUATE_SUBMISSIONS_TABLE).then(function (records) {
                records.forEach(_this.parseEvaluateSubmissionRecord.bind(_this));
                return records;
            });
        });
    };
    /**
     * Get the evaluate submissions of a workshop to be synced.
     *
     * @param  {number} workshopId ID of the workshop.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any[]>}    Promise resolved with the object to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getEvaluateSubmissions = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId
            };
            return site.getDb().getRecords(AddonModWorkshopOfflineProvider_1.EVALUATE_SUBMISSIONS_TABLE, conditions)
                .then(function (records) {
                records.forEach(_this.parseEvaluateSubmissionRecord.bind(_this));
                return records;
            });
        });
    };
    /**
     * Get an specific evaluate submission of a workshop to be synced.
     *
     * @param  {number} workshopId   ID of the workshop.
     * @param  {number} submissionId Submission ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with the object to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getEvaluateSubmission = function (workshopId, submissionId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId,
                submissionid: submissionId
            };
            return site.getDb().getRecord(AddonModWorkshopOfflineProvider_1.EVALUATE_SUBMISSIONS_TABLE, conditions).then(function (record) {
                _this.parseEvaluateSubmissionRecord(record);
                return record;
            });
        });
    };
    /**
     * Offline version for evaluation a submission to a workshop.
     *
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  submissionId Submission ID.
     * @param  {number}  courseId     Course ID the workshop belongs to.
     * @param  {string}  feedbackText The feedback for the author.
     * @param  {boolean} published    Whether to publish the submission for other users.
     * @param  {any}     gradeOver    The new submission grade (empty for no overriding the grade).
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when submission evaluation is successfully saved.
     */
    AddonModWorkshopOfflineProvider.prototype.saveEvaluateSubmission = function (workshopId, submissionId, courseId, feedbackText, published, gradeOver, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var submission = {
                workshopid: workshopId,
                courseid: courseId,
                submissionid: submissionId,
                timemodified: _this.timeUtils.timestamp(),
                feedbacktext: feedbackText,
                published: Number(published),
                gradeover: JSON.stringify(gradeOver)
            };
            return site.getDb().insertRecord(AddonModWorkshopOfflineProvider_1.EVALUATE_SUBMISSIONS_TABLE, submission);
        });
    };
    /**
     * Parse "published" and "gradeover" columns of an evaluate submission record.
     *
     * @param  {any} record Evaluate submission record, modified in place.
     */
    AddonModWorkshopOfflineProvider.prototype.parseEvaluateSubmissionRecord = function (record) {
        record.published = Boolean(record.published);
        record.gradeover = this.textUtils.parseJSON(record.gradeover);
    };
    /**
     * Delete workshop evaluate assessment.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved if stored, rejected if failure.
     */
    AddonModWorkshopOfflineProvider.prototype.deleteEvaluateAssessment = function (workshopId, assessmentId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId,
                assessmentid: assessmentId
            };
            return site.getDb().deleteRecords(AddonModWorkshopOfflineProvider_1.EVALUATE_ASSESSMENTS_TABLE, conditions);
        });
    };
    /**
     * Get the all the evaluate assessments to be synced.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Promise resolved with the objects to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getAllEvaluateAssessments = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModWorkshopOfflineProvider_1.EVALUATE_ASSESSMENTS_TABLE).then(function (records) {
                records.forEach(_this.parseEvaluateAssessmentRecord.bind(_this));
                return records;
            });
        });
    };
    /**
     * Get the evaluate assessments of a workshop to be synced.
     *
     * @param  {number} workshopId ID of the workshop.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any[]>}    Promise resolved with the object to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getEvaluateAssessments = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId
            };
            return site.getDb().getRecords(AddonModWorkshopOfflineProvider_1.EVALUATE_ASSESSMENTS_TABLE, conditions)
                .then(function (records) {
                records.forEach(_this.parseEvaluateAssessmentRecord.bind(_this));
                return records;
            });
        });
    };
    /**
     * Get an specific evaluate assessment of a workshop to be synced.
     *
     * @param  {number} workshopId   ID of the workshop.
     * @param  {number} assessmentId Assessment ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with the object to be synced.
     */
    AddonModWorkshopOfflineProvider.prototype.getEvaluateAssessment = function (workshopId, assessmentId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                workshopid: workshopId,
                assessmentid: assessmentId
            };
            return site.getDb().getRecord(AddonModWorkshopOfflineProvider_1.EVALUATE_ASSESSMENTS_TABLE, conditions).then(function (record) {
                _this.parseEvaluateAssessmentRecord(record);
                return record;
            });
        });
    };
    /**
     * Offline version for evaluating an assessment to a workshop.
     *
     * @param  {number}  workshopId       Workshop ID.
     * @param  {number}  assessmentId     Assessment ID.
     * @param  {number}  courseId         Course ID the workshop belongs to.
     * @param  {string}  feedbackText     The feedback for the reviewer.
     * @param  {number}  weight           The new weight for the assessment.
     * @param  {any}     gradingGradeOver The new grading grade (empty for no overriding the grade).
     * @param  {string}  [siteId]         Site ID. If not defined, current site.
     * @return {Promise<any>}             Promise resolved when assessment evaluation is successfully saved.
     */
    AddonModWorkshopOfflineProvider.prototype.saveEvaluateAssessment = function (workshopId, assessmentId, courseId, feedbackText, weight, gradingGradeOver, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var assessment = {
                workshopid: workshopId,
                courseid: courseId,
                assessmentid: assessmentId,
                timemodified: _this.timeUtils.timestamp(),
                feedbacktext: feedbackText,
                weight: weight,
                gradinggradeover: JSON.stringify(gradingGradeOver)
            };
            return site.getDb().insertRecord(AddonModWorkshopOfflineProvider_1.EVALUATE_ASSESSMENTS_TABLE, assessment);
        });
    };
    /**
     * Parse "gradinggradeover" column of an evaluate assessment record.
     *
     * @param  {any} record Evaluate assessment record, modified in place.
     */
    AddonModWorkshopOfflineProvider.prototype.parseEvaluateAssessmentRecord = function (record) {
        record.gradinggradeover = this.textUtils.parseJSON(record.gradinggradeover);
    };
    /**
     * Get the path to the folder where to store files for offline attachments in a workshop.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<string>}   Promise resolved with the path.
     */
    AddonModWorkshopOfflineProvider.prototype.getWorkshopFolder = function (workshopId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var siteFolderPath = _this.fileProvider.getSiteFolder(site.getId());
            var workshopFolderPath = 'offlineworkshop/' + workshopId + '/';
            return _this.textUtils.concatenatePaths(siteFolderPath, workshopFolderPath);
        });
    };
    /**
     * Get the path to the folder where to store files for offline submissions.
     *
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  submissionId If not editing, it will refer to timecreated.
     * @param  {boolean} editing      If the submission is being edited or added otherwise.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<string>}      Promise resolved with the path.
     */
    AddonModWorkshopOfflineProvider.prototype.getSubmissionFolder = function (workshopId, submissionId, editing, siteId) {
        var _this = this;
        return this.getWorkshopFolder(workshopId, siteId).then(function (folderPath) {
            folderPath += 'submission/';
            var folder = editing ? 'update_' + submissionId : 'add';
            return _this.textUtils.concatenatePaths(folderPath, folder);
        });
    };
    /**
     * Get the path to the folder where to store files for offline assessment.
     *
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  assessmentId Assessment ID.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<string>}      Promise resolved with the path.
     */
    AddonModWorkshopOfflineProvider.prototype.getAssessmentFolder = function (workshopId, assessmentId, siteId) {
        var _this = this;
        return this.getWorkshopFolder(workshopId, siteId).then(function (folderPath) {
            folderPath += 'assessment/';
            return _this.textUtils.concatenatePaths(folderPath, String(assessmentId));
        });
    };
    // Variables for database.
    AddonModWorkshopOfflineProvider.SUBMISSIONS_TABLE = 'addon_mod_workshop_submissions';
    AddonModWorkshopOfflineProvider.ASSESSMENTS_TABLE = 'addon_mod_workshop_assessments';
    AddonModWorkshopOfflineProvider.EVALUATE_SUBMISSIONS_TABLE = 'addon_mod_workshop_evaluate_submissions';
    AddonModWorkshopOfflineProvider.EVALUATE_ASSESSMENTS_TABLE = 'addon_mod_workshop_evaluate_assessments';
    AddonModWorkshopOfflineProvider = AddonModWorkshopOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__["a" /* CoreTimeUtilsProvider */]])
    ], AddonModWorkshopOfflineProvider);
    return AddonModWorkshopOfflineProvider;
    var AddonModWorkshopOfflineProvider_1;
}());

//# sourceMappingURL=offline.js.map

/***/ }),
/* 176 */,
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProfileFieldDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(11);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to interact with user profile fields. Provides functions to register a plugin.
 */
var CoreUserProfileFieldDelegate = /** @class */ (function (_super) {
    __extends(CoreUserProfileFieldDelegate, _super);
    function CoreUserProfileFieldDelegate(loggerProvider, sitesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreUserProfileFieldDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlerNameProperty = 'type';
        return _this;
    }
    /**
     * Get the component to use to display an user field.
     *
     * @param {Injector} injector Injector.
     * @param  {any} field      User field to get the directive for.
     * @param  {boolean} signup         True if user is in signup page.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreUserProfileFieldDelegate.prototype.getComponent = function (injector, field, signup) {
        var _this = this;
        var type = field.type || field.datatype;
        var result;
        if (signup) {
            result = this.executeFunction(type, 'getComponent', [injector]);
        }
        else {
            result = this.executeFunctionOnEnabled(type, 'getComponent', [injector]);
        }
        return Promise.resolve(result).catch(function (err) {
            _this.logger.error('Error getting component for field', type, err);
        });
    };
    /**
     * Get the data to send for a certain field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  registerAuth   Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form values.
     * @return {Promise<any>}           Data to send for the field.
     */
    CoreUserProfileFieldDelegate.prototype.getDataForField = function (field, signup, registerAuth, formValues) {
        var type = field.type || field.datatype, handler = this.getHandler(type, !signup);
        if (handler) {
            var name_1 = 'profile_field_' + field.shortname;
            if (handler.getData) {
                return Promise.resolve(handler.getData(field, signup, registerAuth, formValues));
            }
            else if (field.shortname && typeof formValues[name_1] != 'undefined') {
                // Handler doesn't implement the function, but the form has data for the field.
                return Promise.resolve({
                    type: type,
                    name: name_1,
                    value: formValues[name_1]
                });
            }
        }
        return Promise.reject(null);
    };
    /**
     * Get the data to send for a list of fields based on the input data.
     *
     * @param  {any[]}   fields           User fields to get the data for.
     * @param  {boolean} [signup]       True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form values.
     * @return {Promise<any>}           Data to send.
     */
    CoreUserProfileFieldDelegate.prototype.getDataForFields = function (fields, signup, registerAuth, formValues) {
        var _this = this;
        if (signup === void 0) { signup = false; }
        if (registerAuth === void 0) { registerAuth = ''; }
        var result = [], promises = [];
        if (!fields) {
            return Promise.resolve([]);
        }
        fields.forEach(function (field) {
            promises.push(_this.getDataForField(field, signup, registerAuth, formValues).then(function (data) {
                if (data) {
                    result.push(data);
                }
            }).catch(function () {
                // Ignore errors.
            }));
        });
        return Promise.all(promises).then(function () {
            return result;
        });
    };
    CoreUserProfileFieldDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreUserProfileFieldDelegate);
    return CoreUserProfileFieldDelegate;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=user-profile-field-delegate.js.map

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__addon_coursecompletion_providers_coursecompletion__ = __webpack_require__(159);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Helper to gather some common courses functions.
 */
var CoreCoursesHelperProvider = /** @class */ (function () {
    function CoreCoursesHelperProvider(coursesProvider, utils, courseCompletionProvider) {
        this.coursesProvider = coursesProvider;
        this.utils = utils;
        this.courseCompletionProvider = courseCompletionProvider;
    }
    /**
     * Given a course object returned by core_enrol_get_users_courses and another one returned by core_course_get_courses_by_field,
     * load some extra data to the first one.
     *
     * @param {any} course Course returned by core_enrol_get_users_courses.
     * @param {any} courseByField Course returned by core_course_get_courses_by_field.
     */
    CoreCoursesHelperProvider.prototype.loadCourseExtraInfo = function (course, courseByField) {
        if (courseByField) {
            course.displayname = courseByField.displayname;
            if (courseByField.overviewfiles && courseByField.overviewfiles[0]) {
                course.courseImage = courseByField.overviewfiles[0].fileurl;
            }
            else {
                course.courseImage = false;
            }
        }
        else {
            delete course.displayname;
            course.courseImage = false;
        }
    };
    /**
     * Given a list of courses returned by core_enrol_get_users_courses, load some extra data using the WebService
     * core_course_get_courses_by_field if available.
     *
     * @param {any[]} courses List of courses.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCoursesHelperProvider.prototype.loadCoursesExtraInfo = function (courses) {
        var _this = this;
        if (courses[0] && typeof courses[0].overviewfiles != 'undefined' && typeof courses[0].displayname != 'undefined') {
            // We already have the extra data. Call loadCourseExtraInfo to load the calculated fields.
            courses.forEach(function (course) {
                _this.loadCourseExtraInfo(course, course);
            });
            return Promise.resolve();
        }
        if (!courses.length || !this.coursesProvider.isGetCoursesByFieldAvailable()) {
            // No courses or cannot get the data, stop.
            return Promise.resolve();
        }
        var courseIds = courses.map(function (course) {
            return course.id;
        }).join(',');
        // Get the extra data for the courses.
        return this.coursesProvider.getCoursesByField('ids', courseIds).then(function (coursesInfo) {
            coursesInfo = _this.utils.arrayToObject(coursesInfo, 'id');
            courses.forEach(function (course) {
                _this.loadCourseExtraInfo(course, coursesInfo[course.id]);
            });
        });
    };
    /**
     * Get user courses with admin and nav options.
     *
     * @param  {string}  [sort=fullname] Sort courses after get them. If sort is not defined it won't be sorted.
     * @param  {number}  [slice=0]    Slice results to get the X first one. If slice > 0 it will be done after sorting.
     * @param  {string}  [filter]    Filter using some field.
     * @return {Promise<any[]>} Courses filled with options.
     */
    CoreCoursesHelperProvider.prototype.getUserCoursesWithOptions = function (sort, slice, filter) {
        var _this = this;
        if (sort === void 0) { sort = 'fullname'; }
        if (slice === void 0) { slice = 0; }
        return this.coursesProvider.getUserCourses().then(function (courses) {
            var promises = [], courseIds = courses.map(function (course) {
                return course.id;
            });
            if (_this.coursesProvider.canGetAdminAndNavOptions()) {
                // Load course options of the course.
                promises.push(_this.coursesProvider.getCoursesAdminAndNavOptions(courseIds).then(function (options) {
                    courses.forEach(function (course) {
                        course.navOptions = options.navOptions[course.id];
                        course.admOptions = options.admOptions[course.id];
                    });
                }));
            }
            promises.push(_this.loadCoursesExtraInfo(courses));
            return Promise.all(promises).then(function () {
                if (courses.length <= 0) {
                    return [];
                }
                switch (filter) {
                    case 'isfavourite':
                        courses = courses.filter(function (course) {
                            return !!course.isfavourite;
                        });
                        break;
                    default:
                }
                switch (sort) {
                    case 'fullname':
                        courses.sort(function (a, b) {
                            var compareA = a.fullname.toLowerCase(), compareB = b.fullname.toLowerCase();
                            return compareA.localeCompare(compareB);
                        });
                        break;
                    case 'lastaccess':
                        courses.sort(function (a, b) {
                            return b.lastaccess - a.lastaccess;
                        });
                        break;
                    case 'timemodified':
                        courses.sort(function (a, b) {
                            return b.timemodified - a.timemodified;
                        });
                        break;
                    default:
                }
                courses = slice > 0 ? courses.slice(0, slice) : courses;
                // Fetch course completion status if needed.
                return Promise.all(courses.map(function (course) {
                    if (typeof course.completed != 'undefined') {
                        // The WebService already returns the completed status, no need to fetch it.
                        return Promise.resolve(course);
                    }
                    if (typeof course.enablecompletion != 'undefined' && course.enablecompletion == 0) {
                        // Completion is disabled for this course, there is no need to fetch the completion status.
                        return Promise.resolve(course);
                    }
                    return _this.courseCompletionProvider.getCompletion(course.id).catch(function () {
                        // Ignore error, maybe course completion is disabled or user has no permission.
                    }).then(function (completion) {
                        course.completed = completion && completion.completed;
                        return course;
                    });
                }));
            });
        });
    };
    CoreCoursesHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__addon_coursecompletion_providers_coursecompletion__["a" /* AddonCourseCompletionProvider */]])
    ], CoreCoursesHelperProvider);
    return CoreCoursesHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMainMenuDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to interact with plugins to be shown in the main menu. Provides functions to register a plugin
 * and notify an update in the data.
 */
var CoreMainMenuDelegate = /** @class */ (function (_super) {
    __extends(CoreMainMenuDelegate, _super);
    function CoreMainMenuDelegate(loggerProvider, sitesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreMainMenuDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.loaded = false;
        _this.siteHandlers = new __WEBPACK_IMPORTED_MODULE_5_rxjs__["BehaviorSubject"]([]);
        _this.featurePrefix = 'CoreMainMenuDelegate_';
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].LOGOUT, _this.clearSiteHandlers.bind(_this));
        return _this;
    }
    /**
     * Check if handlers are loaded.
     *
     * @return {boolean} True if handlers are loaded, false otherwise.
     */
    CoreMainMenuDelegate.prototype.areHandlersLoaded = function () {
        return this.loaded;
    };
    /**
     * Clear current site handlers. Reserved for core use.
     */
    CoreMainMenuDelegate.prototype.clearSiteHandlers = function () {
        this.loaded = false;
        this.siteHandlers.next([]);
    };
    /**
     * Get the handlers for the current site.
     *
     * @return {Subject<CoreMainMenuHandlerToDisplay[]>} An observable that will receive the handlers.
     */
    CoreMainMenuDelegate.prototype.getHandlers = function () {
        return this.siteHandlers;
    };
    /**
     * Update handlers Data.
     */
    CoreMainMenuDelegate.prototype.updateData = function () {
        var handlersData = [];
        for (var name_1 in this.enabledHandlers) {
            var handler = this.enabledHandlers[name_1], data = handler.getDisplayData();
            handlersData.push({
                name: name_1,
                data: data,
                priority: handler.priority
            });
        }
        // Sort them by priority.
        handlersData.sort(function (a, b) {
            return b.priority - a.priority;
        });
        // Return only the display data.
        var displayData = handlersData.map(function (item) {
            // Move the name and the priority to the display data.
            item.data.name = item.name;
            item.data.priority = item.priority;
            return item.data;
        });
        this.loaded = true;
        this.siteHandlers.next(displayData);
    };
    CoreMainMenuDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreMainMenuDelegate);
    return CoreMainMenuDelegate;
}(__WEBPACK_IMPORTED_MODULE_2__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonWorkshopAssessmentStrategyDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Delegate to register workshop assessment strategy handlers.
 * You can use this service to register your own assessment strategy handlers to be used in a workshop.
 */
var AddonWorkshopAssessmentStrategyDelegate = /** @class */ (function (_super) {
    __extends(AddonWorkshopAssessmentStrategyDelegate, _super);
    function AddonWorkshopAssessmentStrategyDelegate(loggerProvider, sitesProvider, eventsProvider) {
        var _this = _super.call(this, 'AddonWorkshopAssessmentStrategyDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlerNameProperty = 'strategyName';
        return _this;
    }
    /**
     * Check if an assessment strategy plugin is supported.
     *
     * @param  {string} workshopStrategy Assessment strategy name.
     * @return {boolean}                 True if supported, false otherwise.
     */
    AddonWorkshopAssessmentStrategyDelegate.prototype.isPluginSupported = function (workshopStrategy) {
        return this.hasHandler(workshopStrategy, true);
    };
    /**
     * Get the directive to use for a certain assessment strategy plugin.
     *
     * @param {Injector} injector Injector.
     * @param  {string} workshopStrategy Assessment strategy name.
     * @return {any}                     The component, undefined if not found.
     */
    AddonWorkshopAssessmentStrategyDelegate.prototype.getComponentForPlugin = function (injector, workshopStrategy) {
        return this.executeFunctionOnEnabled(workshopStrategy, 'getComponent', [injector]);
    };
    /**
     * Prepare original values to be shown and compared depending on the strategy selected.
     *
     * @param  {string} workshopStrategy Workshop strategy.
     * @param  {any}    form             Original data of the form.
     * @param  {number} workshopId       Workshop ID.
     * @return {Promise<any[]>}          Resolved with original values sorted.
     */
    AddonWorkshopAssessmentStrategyDelegate.prototype.getOriginalValues = function (workshopStrategy, form, workshopId) {
        return Promise.resolve(this.executeFunctionOnEnabled(workshopStrategy, 'getOriginalValues', [form, workshopId]) || []);
    };
    /**
     * Check if the assessment data has changed for a certain submission and workshop for a this strategy plugin.
     *
     * @param  {any}   workshop       Workshop.
     * @param  {any[]} originalValues Original values of the form.
     * @param  {any[]} currentValues  Current values of the form.
     * @return {boolean}              True if data has changed, false otherwise.
     */
    AddonWorkshopAssessmentStrategyDelegate.prototype.hasDataChanged = function (workshop, originalValues, currentValues) {
        return this.executeFunctionOnEnabled(workshop.strategy, 'hasDataChanged', [originalValues, currentValues]) || false;
    };
    /**
     * Prepare assessment data to be sent to the server depending on the strategy selected.
     *
     * @param  {string} workshopStrategy Workshop strategy to follow.
     * @param  {any{}}  currentValues    Current values of the form.
     * @param  {any}    form             Assessment form data.
     * @return {Promise<any>}            Promise resolved with the data to be sent. Or rejected with the input errors object.
     */
    AddonWorkshopAssessmentStrategyDelegate.prototype.prepareAssessmentData = function (workshopStrategy, currentValues, form) {
        return Promise.resolve(this.executeFunctionOnEnabled(workshopStrategy, 'prepareAssessmentData', [currentValues, form]));
    };
    AddonWorkshopAssessmentStrategyDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */]])
    ], AddonWorkshopAssessmentStrategyDelegate);
    return AddonWorkshopAssessmentStrategyDelegate;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=assessment-strategy-delegate.js.map

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCompileHtmlComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_compile__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





/**
 * This component has a behaviour similar to $compile for AngularJS. Given an HTML code, it will compile it so all its
 * components and directives are instantiated.
 *
 * IMPORTANT: Use this component only if it is a must. It will create and compile a new component and module everytime this
 * component is used, so it can slow down the app.
 *
 * This component has its own module to prevent circular dependencies. If you want to use it,
 * you need to import CoreCompileHtmlComponentModule.
 *
 * You can provide some Javascript code (as text) to be executed inside the component. The context of the javascript code (this)
 * will be the component instance created to compile the template. This means your javascript code can interact with the template.
 * The component instance will have most of the providers so you can use them in the javascript code. E.g. if you want to use
 * CoreAppProvider, you can do it with "this.CoreAppProvider".
 */
var CoreCompileHtmlComponent = /** @class */ (function () {
    function CoreCompileHtmlComponent(compileProvider, cdr, element, navCtrl, differs, domUtils, utils) {
        this.compileProvider = compileProvider;
        this.cdr = cdr;
        this.navCtrl = navCtrl;
        this.domUtils = domUtils;
        this.utils = utils;
        this.extraImports = []; // Extra import modules.
        this.extraProviders = []; // Extra providers.
        this.created = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */](); // Will emit an event when the component is instantiated.
        this.compiling = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */](); // Event that indicates whether the template is being compiled.
        this.creatingComponent = false;
        this.element = element.nativeElement;
        this.differ = differs.find([]).create();
    }
    /**
     * Detect and act upon changes that Angular can’t or won’t detect on its own (objects and arrays).
     */
    CoreCompileHtmlComponent.prototype.ngDoCheck = function () {
        if (this.componentInstance && !this.creatingComponent) {
            // Check if there's any change in the jsData object.
            var changes = this.differ.diff(this.jsData);
            if (changes) {
                this.setInputData();
                if (this.componentInstance.ngOnChanges) {
                    this.componentInstance.ngOnChanges(this.domUtils.createChangesFromKeyValueDiff(changes));
                }
            }
        }
    };
    /**
     * Detect changes on input properties.
     */
    CoreCompileHtmlComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        // Only compile if text/javascript has changed or the forceCompile flag has been set to true.
        if ((changes.text || changes.javascript || (changes.forceCompile && this.utils.isTrueOrOne(this.forceCompile))) &&
            this.text) {
            // Create a new component and a new module.
            this.creatingComponent = true;
            this.compiling.emit(true);
            this.compileProvider.createAndCompileComponent(this.text, this.getComponentClass(), this.extraImports)
                .then(function (factory) {
                // Destroy previous components.
                _this.componentRef && _this.componentRef.destroy();
                if (factory) {
                    // Create the component.
                    _this.componentRef = _this.container.createComponent(factory);
                    _this.created.emit(_this.componentRef.instance);
                }
                _this.loaded = true;
            }).catch(function (error) {
                _this.domUtils.showErrorModal(error);
                _this.loaded = true;
            }).finally(function () {
                _this.creatingComponent = false;
                _this.compiling.emit(false);
            });
        }
    };
    /**
     * Component destroyed.
     */
    CoreCompileHtmlComponent.prototype.ngOnDestroy = function () {
        this.componentRef && this.componentRef.destroy();
    };
    /**
     * Get a class that defines the dynamic component.
     *
     * @return {any} The component class.
     */
    CoreCompileHtmlComponent.prototype.getComponentClass = function () {
        // tslint:disable: no-this-assignment
        var compileInstance = this;
        // Create the component, using the text as the template.
        return /** @class */ (function () {
            function CoreCompileHtmlFakeComponent() {
                // Store this instance so it can be accessed by the outer component.
                compileInstance.componentInstance = this;
                // Create 2 empty properties that can be used by the template to store data.
                this['dataObject'] = {};
                this['dataArray'] = [];
                // Inject the libraries.
                compileInstance.compileProvider.injectLibraries(this, compileInstance.extraProviders);
                // Always add these elements, they could be needed on component init (componentObservable).
                this['ChangeDetectorRef'] = compileInstance.cdr;
                this['NavController'] = compileInstance.navCtrl;
                this['componentContainer'] = compileInstance.element;
                // Add the data passed to the component.
                compileInstance.setInputData();
            }
            /**
             * Component being initialized.
             */
            CoreCompileHtmlFakeComponent.prototype.ngOnInit = function () {
                // If there is some javascript to run, do it now.
                if (compileInstance.javascript) {
                    compileInstance.compileProvider.executeJavascript(this, compileInstance.javascript);
                }
            };
            /**
             * Content has been initialized.
             */
            CoreCompileHtmlFakeComponent.prototype.ngAfterContentInit = function () {
                // To be overridden.
            };
            /**
             * View has been initialized.
             */
            CoreCompileHtmlFakeComponent.prototype.ngAfterViewInit = function () {
                // To be overridden.
            };
            /**
             * Component destroyed.
             */
            CoreCompileHtmlFakeComponent.prototype.ngOnDestroy = function () {
                // To be overridden.
            };
            return CoreCompileHtmlFakeComponent;
        }());
    };
    /**
     * Set the JS data as input data of the component instance.
     */
    CoreCompileHtmlComponent.prototype.setInputData = function () {
        if (this.componentInstance) {
            for (var name_1 in this.jsData) {
                this.componentInstance[name_1] = this.jsData[name_1];
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCompileHtmlComponent.prototype, "text", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCompileHtmlComponent.prototype, "javascript", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCompileHtmlComponent.prototype, "jsData", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreCompileHtmlComponent.prototype, "extraImports", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreCompileHtmlComponent.prototype, "extraProviders", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCompileHtmlComponent.prototype, "forceCompile", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreCompileHtmlComponent.prototype, "created", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreCompileHtmlComponent.prototype, "compiling", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('dynamicComponent', { read: __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */] }),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */])
    ], CoreCompileHtmlComponent.prototype, "container", void 0);
    CoreCompileHtmlComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-compile-html',
            template: '<core-loading [hideUntil]="loaded"><ng-container #dynamicComponent></ng-container></core-loading>'
        }),
        __param(3, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_compile__["a" /* CoreCompileProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* KeyValueDiffers */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreCompileHtmlComponent);
    return CoreCompileHtmlComponent;
}());

//# sourceMappingURL=compile-html.js.map

/***/ }),
/* 182 */,
/* 183 */,
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreQuestionBaseComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_question_providers_helper__ = __webpack_require__(128);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Base class for components to render a question.
 */
var CoreQuestionBaseComponent = /** @class */ (function () {
    function CoreQuestionBaseComponent(logger, logName, injector) {
        this.injector = injector;
        this.logger = logger.getInstance(logName);
        // Use an injector to get the providers to prevent having to modify all subclasses if a new provider is needed.
        this.questionHelper = injector.get(__WEBPACK_IMPORTED_MODULE_3__core_question_providers_helper__["a" /* CoreQuestionHelperProvider */]);
        this.domUtils = injector.get(__WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__["a" /* CoreDomUtilsProvider */]);
        this.textUtils = injector.get(__WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]);
        this.realElement = injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]).nativeElement;
    }
    /**
     * Initialize a question component of type calculated or calculated simple.
     *
     * @return {void|HTMLElement} Element containing the question HTML, void if the data is not valid.
     */
    CoreQuestionBaseComponent.prototype.initCalculatedComponent = function () {
        // Treat the input text first.
        var questionEl = this.initInputTextComponent();
        if (questionEl) {
            // Check if the question has a select for units.
            var selectModel = {}, select = questionEl.querySelector('select[name*=unit]'), options = select && Array.from(select.querySelectorAll('option'));
            if (select && options && options.length) {
                selectModel.id = select.id;
                selectModel.name = select.name;
                selectModel.disabled = select.disabled;
                selectModel.options = [];
                // Treat each option.
                for (var i in options) {
                    var optionEl = options[i];
                    if (typeof optionEl.value == 'undefined') {
                        this.logger.warn('Aborting because couldn\'t find input.', this.question.name);
                        return this.questionHelper.showComponentError(this.onAbort);
                    }
                    var option = {
                        value: optionEl.value,
                        label: optionEl.innerHTML
                    };
                    if (optionEl.selected) {
                        selectModel.selected = option.value;
                    }
                    selectModel.options.push(option);
                }
                if (!selectModel.selected) {
                    // No selected option, select the first one.
                    selectModel.selected = selectModel.options[0].value;
                }
                // Get the accessibility label.
                var accessibilityLabel = questionEl.querySelector('label[for="' + select.id + '"]');
                selectModel.accessibilityLabel = accessibilityLabel && accessibilityLabel.innerHTML;
                this.question.select = selectModel;
                // Check which one should be displayed first: the select or the input.
                var input_1 = questionEl.querySelector('input[type="text"][name*=answer]');
                this.question.selectFirst =
                    questionEl.innerHTML.indexOf(input_1.outerHTML) > questionEl.innerHTML.indexOf(select.outerHTML);
                return questionEl;
            }
            // Check if the question has radio buttons for units.
            var radios = Array.from(questionEl.querySelectorAll('input[type="radio"]'));
            if (!radios.length) {
                // No select and no radio buttons. The units need to be entered in the input text.
                return questionEl;
            }
            this.question.options = [];
            for (var i in radios) {
                var radioEl = radios[i], option = {
                    id: radioEl.id,
                    name: radioEl.name,
                    value: radioEl.value,
                    checked: radioEl.checked,
                    disabled: radioEl.disabled
                }, 
                // Get the label with the question text.
                label = questionEl.querySelector('label[for="' + option.id + '"]');
                this.question.optionsName = option.name;
                if (label) {
                    option.text = label.innerText;
                    // Check that we were able to successfully extract options required data.
                    if (typeof option.name != 'undefined' && typeof option.value != 'undefined' &&
                        typeof option.text != 'undefined') {
                        if (radioEl.checked) {
                            // If the option is checked we use the model to select the one.
                            this.question.unit = option.value;
                        }
                        this.question.options.push(option);
                        continue;
                    }
                }
                // Something went wrong when extracting the questions data. Abort.
                this.logger.warn('Aborting because of an error parsing options.', this.question.name, option.name);
                return this.questionHelper.showComponentError(this.onAbort);
            }
            // Check which one should be displayed first: the options or the input.
            var input = questionEl.querySelector('input[type="text"][name*=answer]');
            this.question.optionsFirst =
                questionEl.innerHTML.indexOf(input.outerHTML) > questionEl.innerHTML.indexOf(radios[0].outerHTML);
        }
    };
    /**
     * Initialize the component and the question text.
     *
     * @return {void|HTMLElement} Element containing the question HTML, void if the data is not valid.
     */
    CoreQuestionBaseComponent.prototype.initComponent = function () {
        if (!this.question) {
            this.logger.warn('Aborting because of no question received.');
            return this.questionHelper.showComponentError(this.onAbort);
        }
        this.realElement.classList.add('core-question-container');
        var element = this.domUtils.convertToElement(this.question.html);
        // Extract question text.
        this.question.text = this.domUtils.getContentsOfElement(element, '.qtext');
        if (typeof this.question.text == 'undefined') {
            this.logger.warn('Aborting because of an error parsing question.', this.question.name);
            return this.questionHelper.showComponentError(this.onAbort);
        }
        return element;
    };
    /**
     * Initialize a question component of type essay.
     *
     * @return {void|HTMLElement} Element containing the question HTML, void if the data is not valid.
     */
    CoreQuestionBaseComponent.prototype.initEssayComponent = function () {
        var questionEl = this.initComponent();
        if (questionEl) {
            // First search the textarea.
            var textarea = questionEl.querySelector('textarea[name*=_answer]');
            this.question.allowsAttachments = !!questionEl.querySelector('div[id*=filemanager]');
            this.question.isMonospaced = !!questionEl.querySelector('.qtype_essay_monospaced');
            this.question.isPlainText = this.question.isMonospaced || !!questionEl.querySelector('.qtype_essay_plain');
            this.question.hasDraftFiles = this.questionHelper.hasDraftFileUrls(questionEl.innerHTML);
            if (!textarea) {
                // Textarea not found, we might be in review. Search the answer and the attachments.
                this.question.answer = this.domUtils.getContentsOfElement(questionEl, '.qtype_essay_response');
                this.question.attachments = this.questionHelper.getQuestionAttachmentsFromHtml(this.domUtils.getContentsOfElement(questionEl, '.attachments'));
            }
            else {
                // Textarea found.
                var input = questionEl.querySelector('input[type="hidden"][name*=answerformat]'), content = textarea.innerHTML;
                this.question.textarea = {
                    id: textarea.id,
                    name: textarea.name,
                    text: content ? this.textUtils.decodeHTML(content) : ''
                };
                if (input) {
                    this.question.formatInput = {
                        name: input.name,
                        value: input.value
                    };
                }
            }
        }
    };
    /**
     * Initialize a question component that uses the original question text with some basic treatment.
     *
     * @param {string} contentSelector The selector to find the question content (text).
     * @return {void|HTMLElement} Element containing the question HTML, void if the data is not valid.
     */
    CoreQuestionBaseComponent.prototype.initOriginalTextComponent = function (contentSelector) {
        if (!this.question) {
            this.logger.warn('Aborting because of no question received.');
            return this.questionHelper.showComponentError(this.onAbort);
        }
        var element = this.domUtils.convertToElement(this.question.html);
        // Get question content.
        var content = element.querySelector(contentSelector);
        if (!content) {
            this.logger.warn('Aborting because of an error parsing question.', this.question.name);
            return this.questionHelper.showComponentError(this.onAbort);
        }
        // Remove sequencecheck and validation error.
        this.domUtils.removeElement(content, 'input[name*=sequencecheck]');
        this.domUtils.removeElement(content, '.validationerror');
        // Replace Moodle's correct/incorrect and feedback classes with our own.
        this.questionHelper.replaceCorrectnessClasses(element);
        this.questionHelper.replaceFeedbackClasses(element);
        // Treat the correct/incorrect icons.
        this.questionHelper.treatCorrectnessIcons(element);
        // Set the question text.
        this.question.text = content.innerHTML;
    };
    /**
     * Initialize a question component that has an input of type "text".
     *
     * @return {void|HTMLElement} Element containing the question HTML, void if the data is not valid.
     */
    CoreQuestionBaseComponent.prototype.initInputTextComponent = function () {
        var questionEl = this.initComponent();
        if (questionEl) {
            // Get the input element.
            var input = questionEl.querySelector('input[type="text"][name*=answer]');
            if (!input) {
                this.logger.warn('Aborting because couldn\'t find input.', this.question.name);
                return this.questionHelper.showComponentError(this.onAbort);
            }
            this.question.input = {
                id: input.id,
                name: input.name,
                value: input.value,
                readOnly: input.readOnly,
                isInline: !!this.domUtils.closest(input, '.qtext') // The answer can be inside the question text.
            };
            // Check if question is marked as correct.
            if (input.classList.contains('incorrect')) {
                this.question.input.correctClass = 'core-question-incorrect';
                this.question.input.correctIcon = 'fa-remove';
                this.question.input.correctIconColor = 'danger';
            }
            else if (input.classList.contains('correct')) {
                this.question.input.correctClass = 'core-question-correct';
                this.question.input.correctIcon = 'fa-check';
                this.question.input.correctIconColor = 'success';
            }
            else if (input.classList.contains('partiallycorrect')) {
                this.question.input.correctClass = 'core-question-partiallycorrect';
                this.question.input.correctIcon = 'fa-check-square';
                this.question.input.correctIconColor = 'warning';
            }
            else {
                this.question.input.correctClass = '';
                this.question.input.correctIcon = '';
                this.question.input.correctIconColor = '';
            }
            if (this.question.input.isInline) {
                // Handle correct/incorrect classes and icons.
                var content = questionEl.querySelector('.qtext');
                this.questionHelper.replaceCorrectnessClasses(content);
                this.questionHelper.treatCorrectnessIcons(content);
                this.question.text = content.innerHTML;
            }
        }
        return questionEl;
    };
    /**
     * Initialize a question component with a "match" behaviour.
     *
     * @return {void|HTMLElement} Element containing the question HTML, void if the data is not valid.
     */
    CoreQuestionBaseComponent.prototype.initMatchComponent = function () {
        var questionEl = this.initComponent();
        if (questionEl) {
            // Find rows.
            var rows = Array.from(questionEl.querySelectorAll('table.answer tr'));
            if (!rows || !rows.length) {
                this.logger.warn('Aborting because couldn\'t find any row.', this.question.name);
                return this.questionHelper.showComponentError(this.onAbort);
            }
            this.question.rows = [];
            for (var i in rows) {
                var row = rows[i], rowModel = {}, columns = Array.from(row.querySelectorAll('td'));
                if (!columns || columns.length < 2) {
                    this.logger.warn('Aborting because couldn\'t the right columns.', this.question.name);
                    return this.questionHelper.showComponentError(this.onAbort);
                }
                // Get the row's text. It should be in the first column.
                rowModel.text = columns[0].innerHTML;
                // Get the select and the options.
                var select = columns[1].querySelector('select'), options = Array.from(columns[1].querySelectorAll('option'));
                if (!select || !options || !options.length) {
                    this.logger.warn('Aborting because couldn\'t find select or options.', this.question.name);
                    return this.questionHelper.showComponentError(this.onAbort);
                }
                rowModel.id = select.id;
                rowModel.name = select.name;
                rowModel.disabled = select.disabled;
                rowModel.selected = false;
                rowModel.options = [];
                // Check if answer is correct.
                if (columns[1].className.indexOf('incorrect') >= 0) {
                    rowModel.isCorrect = 0;
                }
                else if (columns[1].className.indexOf('correct') >= 0) {
                    rowModel.isCorrect = 1;
                }
                // Treat each option.
                for (var j in options) {
                    var optionEl = options[j];
                    if (typeof optionEl.value == 'undefined') {
                        this.logger.warn('Aborting because couldn\'t find the value of an option.', this.question.name);
                        return this.questionHelper.showComponentError(this.onAbort);
                    }
                    var option = {
                        value: optionEl.value,
                        label: optionEl.innerHTML,
                        selected: optionEl.selected
                    };
                    if (option.selected) {
                        rowModel.selected = option.value;
                    }
                    rowModel.options.push(option);
                }
                // Get the accessibility label.
                var accessibilityLabel = columns[1].querySelector('label.accesshide');
                rowModel.accessibilityLabel = accessibilityLabel && accessibilityLabel.innerHTML;
                this.question.rows.push(rowModel);
            }
            this.question.loaded = true;
        }
        return questionEl;
    };
    /**
     * Initialize a question component with a multiple choice (checkbox) or single choice (radio).
     *
     * @return {void|HTMLElement} Element containing the question HTML, void if the data is not valid.
     */
    CoreQuestionBaseComponent.prototype.initMultichoiceComponent = function () {
        var questionEl = this.initComponent();
        if (questionEl) {
            // Get the prompt.
            this.question.prompt = this.domUtils.getContentsOfElement(questionEl, '.prompt');
            // Search radio buttons first (single choice).
            var options = Array.from(questionEl.querySelectorAll('input[type="radio"]'));
            if (!options || !options.length) {
                // Radio buttons not found, it should be a multi answer. Search for checkbox.
                this.question.multi = true;
                options = Array.from(questionEl.querySelectorAll('input[type="checkbox"]'));
                if (!options || !options.length) {
                    // No checkbox found either. Abort.
                    this.logger.warn('Aborting because of no radio and checkbox found.', this.question.name);
                    return this.questionHelper.showComponentError(this.onAbort);
                }
            }
            this.question.options = [];
            this.question.disabled = true;
            for (var i in options) {
                var element = options[i], option = {
                    id: element.id,
                    name: element.name,
                    value: element.value,
                    checked: element.checked,
                    disabled: element.disabled
                }, parent_1 = element.parentElement;
                if (option.value == '-1') {
                    // It's the clear choice option, ignore it.
                    continue;
                }
                this.question.optionsName = option.name;
                this.question.disabled = this.question.disabled && element.disabled;
                // Get the label with the question text.
                var label = questionEl.querySelector('label[for="' + option.id + '"]');
                if (label) {
                    option.text = label.innerHTML;
                    // Check that we were able to successfully extract options required data.
                    if (typeof option.name != 'undefined' && typeof option.value != 'undefined' &&
                        typeof option.text != 'undefined') {
                        if (element.checked) {
                            // If the option is checked and it's a single choice we use the model to select the one.
                            if (!this.question.multi) {
                                this.question.singleChoiceModel = option.value;
                            }
                            if (parent_1) {
                                // Check if answer is correct.
                                if (parent_1 && parent_1.className.indexOf('incorrect') >= 0) {
                                    option.isCorrect = 0;
                                }
                                else if (parent_1 && parent_1.className.indexOf('correct') >= 0) {
                                    option.isCorrect = 1;
                                }
                                // Search the feedback.
                                var feedback = parent_1.querySelector('.specificfeedback');
                                if (feedback) {
                                    option.feedback = feedback.innerHTML;
                                }
                            }
                        }
                        this.question.options.push(option);
                        continue;
                    }
                }
                // Something went wrong when extracting the questions data. Abort.
                this.logger.warn('Aborting because of an error parsing options.', this.question.name, option.name);
                return this.questionHelper.showComponentError(this.onAbort);
            }
        }
        return questionEl;
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreQuestionBaseComponent.prototype, "question", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreQuestionBaseComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreQuestionBaseComponent.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreQuestionBaseComponent.prototype, "attemptId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreQuestionBaseComponent.prototype, "offlineEnabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreQuestionBaseComponent.prototype, "buttonClicked", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreQuestionBaseComponent.prototype, "onAbort", void 0);
    return CoreQuestionBaseComponent;
}());

//# sourceMappingURL=base-question-component.js.map

/***/ }),
/* 185 */,
/* 186 */,
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserAvatarComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_user_providers_user__ = __webpack_require__(43);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Component to display a "user avatar".
 *
 * Example: <ion-avatar core-user-avatar [user]="participant"></ion-avatar>
 */
var CoreUserAvatarComponent = /** @class */ (function () {
    function CoreUserAvatarComponent(navCtrl, sitesProvider, utils, appProvider, eventsProvider) {
        var _this = this;
        this.navCtrl = navCtrl;
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.appProvider = appProvider;
        this.linkProfile = true; // Avoid linking to the profile if wanted.
        this.checkOnline = false; // If want to check and show online status.
        // Variable to check if we consider this user online or not.
        // @TODO: Use setting when available (see MDL-63972) so we can use site setting.
        this.timetoshowusers = 300000; // Miliseconds default.
        this.currentUserId = this.sitesProvider.getCurrentSiteUserId();
        this.pictureObs = eventsProvider.on(__WEBPACK_IMPORTED_MODULE_6__core_user_providers_user__["a" /* CoreUserProvider */].PROFILE_PICTURE_UPDATED, function (data) {
            if (data.userId == _this.userId) {
                _this.avatarUrl = data.picture;
            }
        }, this.sitesProvider.getCurrentSiteId());
    }
    /**
     * Component being initialized.
     */
    CoreUserAvatarComponent.prototype.ngOnInit = function () {
        this.setFields();
    };
    /**
     * Listen to changes.
     */
    CoreUserAvatarComponent.prototype.ngOnChanges = function (changes) {
        // If something change, update the fields.
        if (changes) {
            this.setFields();
        }
    };
    /**
     * Set fields from user.
     */
    CoreUserAvatarComponent.prototype.setFields = function () {
        var profileUrl = this.profileUrl || (this.user && (this.user.profileimageurl || this.user.userprofileimageurl ||
            this.user.userpictureurl || this.user.profileimageurlsmall));
        if (typeof profileUrl == 'string') {
            this.avatarUrl = profileUrl;
        }
        this.fullname = this.fullname || (this.user && (this.user.fullname || this.user.userfullname));
        this.userId = this.userId || (this.user && (this.user.userid || this.user.id));
        this.courseId = this.courseId || (this.user && this.user.courseid);
    };
    /**
     * Helper function for checking the time meets the 'online' condition.
     *
     * @return boolean
     */
    CoreUserAvatarComponent.prototype.isOnline = function () {
        if (this.utils.isFalseOrZero(this.user.isonline)) {
            return false;
        }
        if (this.user.lastaccess) {
            // If the time has passed, don't show the online status.
            var time = new Date().getTime() - this.timetoshowusers;
            return this.user.lastaccess * 1000 >= time;
        }
        else {
            // You have to have Internet access first.
            return this.user.isonline && this.appProvider.isOnline();
        }
    };
    /**
     * Function executed image clicked.
     */
    CoreUserAvatarComponent.prototype.gotoProfile = function (event) {
        if (this.linkProfile && this.userId) {
            event.preventDefault();
            event.stopPropagation();
            this.navCtrl.push('CoreUserProfilePage', { userId: this.userId, courseId: this.courseId });
        }
    };
    /**
     * Component destroyed.
     */
    CoreUserAvatarComponent.prototype.ngOnDestroy = function () {
        this.pictureObs && this.pictureObs.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserAvatarComponent.prototype, "user", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreUserAvatarComponent.prototype, "profileUrl", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserAvatarComponent.prototype, "linkProfile", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreUserAvatarComponent.prototype, "fullname", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreUserAvatarComponent.prototype, "userId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreUserAvatarComponent.prototype, "courseId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserAvatarComponent.prototype, "checkOnline", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreUserAvatarComponent.prototype, "extraIcon", void 0);
    CoreUserAvatarComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'ion-avatar[core-user-avatar]',
            templateUrl: 'core-user-avatar.html'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreUserAvatarComponent);
    return CoreUserAvatarComponent;
}());

//# sourceMappingURL=user-avatar.js.map

/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLinkDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_contentlinks_providers_helper__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__configconstants__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_split_view_split_view__ = __webpack_require__(34);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};









/**
 * Directive to open a link in external browser.
 */
var CoreLinkDirective = /** @class */ (function () {
    function CoreLinkDirective(element, domUtils, utils, sitesProvider, urlUtils, contentLinksHelper, navCtrl, content, svComponent) {
        this.domUtils = domUtils;
        this.utils = utils;
        this.sitesProvider = sitesProvider;
        this.urlUtils = urlUtils;
        this.contentLinksHelper = contentLinksHelper;
        this.navCtrl = navCtrl;
        this.content = content;
        this.svComponent = svComponent;
        this.autoLogin = 'check'; // If the link should be open with auto-login. Accepts the following values:
        // This directive can be added dynamically. In that case, the first param is the anchor HTMLElement.
        this.element = element.nativeElement || element;
    }
    /**
     * Function executed when the component is initialized.
     */
    CoreLinkDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.inApp = this.utils.isTrueOrOne(this.inApp);
        var navCtrl = this.navCtrl;
        if (this.svComponent && (!this.navCtrl || this.navCtrl === this.svComponent.getDetailsNav())) {
            // The link is in the right side of a split view. Always open them with the left side NavController.
            navCtrl = this.svComponent.getMasterNav();
        }
        this.element.addEventListener('click', function (event) {
            // If the event prevented default action, do nothing.
            if (!event.defaultPrevented) {
                var href_1 = _this.element.getAttribute('href');
                if (href_1) {
                    event.preventDefault();
                    event.stopPropagation();
                    if (_this.utils.isTrueOrOne(_this.capture)) {
                        _this.contentLinksHelper.handleLink(href_1, undefined, navCtrl, true, true).then(function (treated) {
                            if (!treated) {
                                _this.navigate(href_1);
                            }
                        });
                    }
                    else {
                        _this.navigate(href_1);
                    }
                }
            }
        });
    };
    /**
     * Convenience function to correctly navigate, open file or url in the browser.
     *
     * @param {string} href HREF to be opened.
     */
    CoreLinkDirective.prototype.navigate = function (href) {
        var _this = this;
        var contentLinksScheme = __WEBPACK_IMPORTED_MODULE_7__configconstants__["a" /* CoreConfigConstants */].customurlscheme + '://link=';
        if (href.indexOf('cdvfile://') === 0 || href.indexOf('file://') === 0 || href.indexOf('filesystem:') === 0) {
            // We have a local file.
            this.utils.openFile(href).catch(function (error) {
                _this.domUtils.showErrorModal(error);
            });
        }
        else if (href.charAt(0) == '#') {
            href = href.substr(1);
            // In site links
            if (href.charAt(0) == '/') {
                // @todo: This cannot be achieved with push/pop navigation, location.go() doesn't update the state, only the URL.
                // In Ionic 4 the navigation will change, so maybe it can be done by then.
            }
            else {
                // Look for id or name.
                this.domUtils.scrollToElementBySelector(this.content, '#' + href + ', [name=\'' + href + '\']');
            }
        }
        else if (href.indexOf(contentLinksScheme) === 0) {
            // Link should be treated by Custom URL Scheme. Encode the right part, otherwise ':' is removed in iOS.
            href = contentLinksScheme + encodeURIComponent(href.replace(contentLinksScheme, ''));
            this.utils.openInBrowser(href);
        }
        else {
            // It's an external link, we will open with browser. Check if we need to auto-login.
            if (!this.sitesProvider.isLoggedIn()) {
                // Not logged in, cannot auto-login.
                if (this.inApp) {
                    this.utils.openInApp(href);
                }
                else {
                    this.utils.openInBrowser(href);
                }
            }
            else {
                // Check if URL does not have any protocol, so it's a relative URL.
                if (!this.urlUtils.isAbsoluteURL(href)) {
                    // Add the site URL at the begining.
                    if (href.charAt(0) == '/') {
                        href = this.sitesProvider.getCurrentSite().getURL() + href;
                    }
                    else {
                        href = this.sitesProvider.getCurrentSite().getURL() + '/' + href;
                    }
                }
                if (this.autoLogin == 'yes') {
                    if (this.inApp) {
                        this.sitesProvider.getCurrentSite().openInAppWithAutoLogin(href);
                    }
                    else {
                        this.sitesProvider.getCurrentSite().openInBrowserWithAutoLogin(href);
                    }
                }
                else if (this.autoLogin == 'no') {
                    if (this.inApp) {
                        this.utils.openInApp(href);
                    }
                    else {
                        this.utils.openInBrowser(href);
                    }
                }
                else {
                    if (this.inApp) {
                        this.sitesProvider.getCurrentSite().openInAppWithAutoLoginIfSameSite(href);
                    }
                    else {
                        this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(href);
                    }
                }
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLinkDirective.prototype, "capture", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLinkDirective.prototype, "inApp", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLinkDirective.prototype, "autoLogin", void 0);
    CoreLinkDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-link]'
        }),
        __param(6, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __param(7, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()), __param(8, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["f" /* Content */], __WEBPACK_IMPORTED_MODULE_8__components_split_view_split_view__["a" /* CoreSplitViewComponent */]])
    ], CoreLinkDirective);
    return CoreLinkDirective;
}());

//# sourceMappingURL=link.js.map

/***/ }),
/* 189 */,
/* 190 */,
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreRatingOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service to handle offline data for rating.
 */
var CoreRatingOfflineProvider = /** @class */ (function () {
    function CoreRatingOfflineProvider(sitesProvider, utils) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.siteSchema = {
            name: 'CoreRatingOfflineProvider',
            version: 1,
            tables: [
                {
                    name: CoreRatingOfflineProvider_1.RATINGS_TABLE,
                    columns: [
                        {
                            name: 'component',
                            type: 'TEXT'
                        },
                        {
                            name: 'ratingarea',
                            type: 'TEXT'
                        },
                        {
                            name: 'contextlevel',
                            type: 'INTEGER',
                        },
                        {
                            name: 'instanceid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'itemid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'itemsetid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'scaleid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'rating',
                            type: 'INTEGER'
                        },
                        {
                            name: 'rateduserid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'aggregation',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['component', 'ratingarea', 'contextlevel', 'instanceid', 'itemid']
                }
            ]
        };
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    CoreRatingOfflineProvider_1 = CoreRatingOfflineProvider;
    /**
     * Get an offline rating.
     *
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {numnber} instanceId Context instance id.
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating area. Example: "post".
     * @param {number} itemId Item id. Example: forum post id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreRatingOfflineRating>} Promise resolved with the saved rating, rejected if not found.
     */
    CoreRatingOfflineProvider.prototype.getRating = function (contextLevel, instanceId, component, ratingArea, itemId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                contextlevel: contextLevel,
                instanceid: instanceId,
                component: component,
                ratingarea: ratingArea,
                itemid: itemId
            };
            return site.getDb().getRecord(CoreRatingOfflineProvider_1.RATINGS_TABLE, conditions);
        });
    };
    /**
     * Add an offline rating.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating area. Example: "post".
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {numnber} instanceId Context instance id.
     * @param {number} itemId Item id. Example: forum post id.
     * @param {number} itemSetId Item set id. Example: forum discussion id.
     * @param {number} courseId Course id.
     * @param {number} scaleId Scale id.
     * @param {number} rating Rating value. Use CoreRatingProvider.UNSET_RATING to delete rating.
     * @param {number} ratedUserId Rated user id.
     * @param {number} aggregateMethod Aggregate method.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the rating is saved.
     */
    CoreRatingOfflineProvider.prototype.addRating = function (component, ratingArea, contextLevel, instanceId, itemId, itemSetId, courseId, scaleId, rating, ratedUserId, aggregateMethod, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                component: component,
                ratingarea: ratingArea,
                contextlevel: contextLevel,
                instanceid: instanceId,
                itemid: itemId,
                itemsetid: itemSetId,
                courseid: courseId,
                scaleid: scaleId,
                rating: rating,
                rateduserid: ratedUserId,
                aggregation: aggregateMethod
            };
            return site.getDb().insertRecord(CoreRatingOfflineProvider_1.RATINGS_TABLE, data);
        });
    };
    /**
     * Delete offline rating.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating area. Example: "post".
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} itemId Item id. Example: forum post id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the rating is saved.
     */
    CoreRatingOfflineProvider.prototype.deleteRating = function (component, ratingArea, contextLevel, instanceId, itemId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                component: component,
                ratingarea: ratingArea,
                contextlevel: contextLevel,
                instanceid: instanceId,
                itemid: itemId
            };
            return site.getDb().deleteRecords(CoreRatingOfflineProvider_1.RATINGS_TABLE, conditions);
        });
    };
    /**
     * Get the list of item sets in a component or instance.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating Area. Example: "post".
     * @param {string} [contextLevel] Context level: course, module, user, etc.
     * @param {numnber} [instanceId] Context instance id.
     * @param {number} [itemSetId] Item set id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreRatingItemSet[]>} Promise resolved with the list of item set ids.
     */
    CoreRatingOfflineProvider.prototype.getItemSets = function (component, ratingArea, contextLevel, instanceId, itemSetId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var fields = 'DISTINCT contextlevel, instanceid, itemsetid, courseid';
            var conditions = {
                component: component,
                ratingarea: ratingArea
            };
            if (contextLevel != null && instanceId != null) {
                conditions.contextlevel = contextLevel;
                conditions.instanceId = instanceId;
            }
            if (itemSetId != null) {
                conditions.itemSetId = itemSetId;
            }
            return site.getDb().getRecords(CoreRatingOfflineProvider_1.RATINGS_TABLE, conditions, undefined, fields)
                .then(function (records) {
                return records.map(function (record) {
                    return {
                        component: component,
                        ratingArea: ratingArea,
                        contextLevel: record.contextlevel,
                        instanceId: record.instanceid,
                        itemSetId: record.itemsetid,
                        courseId: record.courseid
                    };
                });
            });
        });
    };
    /**
     * Get offline ratings of an item set.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating Area. Example: "post".
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} itemId Item id. Example: forum post id.
     * @param {number} itemSetId Item set id. Example: forum discussion id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreRatingOfflineRating[]>} Promise resolved with the list of ratings.
     */
    CoreRatingOfflineProvider.prototype.getRatings = function (component, ratingArea, contextLevel, instanceId, itemSetId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                component: component,
                ratingarea: ratingArea,
                contextlevel: contextLevel,
                instanceid: instanceId,
                itemsetid: itemSetId
            };
            return site.getDb().getRecords(CoreRatingOfflineProvider_1.RATINGS_TABLE, conditions);
        });
    };
    /**
     * Return whether a component, instance or item set has offline ratings.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating Area. Example: "post".
     * @param {string} [contextLevel] Context level: course, module, user, etc.
     * @param {number} [instanceId] Context instance id.
     * @param {number} [itemSetId] Item set id. Example: forum discussion id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with a boolean.
     */
    CoreRatingOfflineProvider.prototype.hasRatings = function (component, ratingArea, contextLevel, instanceId, itemSetId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                component: component,
                ratingarea: ratingArea
            };
            if (contextLevel != null && instanceId != null) {
                conditions.contextlevel = contextLevel;
                conditions.instanceId = instanceId;
            }
            if (itemSetId != null) {
                conditions.itemsetid = itemSetId;
            }
            return _this.utils.promiseWorks(site.getDb().recordExists(CoreRatingOfflineProvider_1.RATINGS_TABLE, conditions));
        });
    };
    // Variables for database.
    CoreRatingOfflineProvider.RATINGS_TABLE = 'rating_ratings';
    CoreRatingOfflineProvider = CoreRatingOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreRatingOfflineProvider);
    return CoreRatingOfflineProvider;
    var CoreRatingOfflineProvider_1;
}());

//# sourceMappingURL=offline.js.map

/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModWorkshopHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_fileuploader_providers_fileuploader__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__workshop__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__offline__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__assessment_strategy_delegate__ = __webpack_require__(180);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Helper to gather some common functions for workshop.
 */
var AddonModWorkshopHelperProvider = /** @class */ (function () {
    function AddonModWorkshopHelperProvider(translate, fileProvider, uploaderProvider, sitesProvider, textUtils, utils, workshopProvider, workshopOffline, strategyDelegate) {
        this.translate = translate;
        this.fileProvider = fileProvider;
        this.uploaderProvider = uploaderProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.workshopProvider = workshopProvider;
        this.workshopOffline = workshopOffline;
        this.strategyDelegate = strategyDelegate;
    }
    /**
     * Get a task by code.
     *
     * @param  {any[]}  tasks    Array of tasks.
     * @param  {string} taskCode Unique task code.
     * @return {any}             Task requested
     */
    AddonModWorkshopHelperProvider.prototype.getTask = function (tasks, taskCode) {
        for (var x in tasks) {
            if (tasks[x].code == taskCode) {
                return tasks[x];
            }
        }
        return false;
    };
    /**
     * Check is task code is done.
     *
     * @param  {any[]}  tasks    Array of tasks.
     * @param  {string} taskCode Unique task code.
     * @return {boolean}         True if task is completed.
     */
    AddonModWorkshopHelperProvider.prototype.isTaskDone = function (tasks, taskCode) {
        var task = this.getTask(tasks, taskCode);
        if (task) {
            return task.completed;
        }
        // Task not found, assume true.
        return true;
    };
    /**
     * Return if a user can submit a workshop.
     *
     * @param  {any}   workshop Workshop info.
     * @param  {any}   access   Access information.
     * @param  {any[]} tasks    Array of tasks.
     * @return {boolean}        True if the user can submit the workshop.
     */
    AddonModWorkshopHelperProvider.prototype.canSubmit = function (workshop, access, tasks) {
        var examplesMust = workshop.useexamples && workshop.examplesmode == __WEBPACK_IMPORTED_MODULE_7__workshop__["a" /* AddonModWorkshopProvider */].EXAMPLES_BEFORE_SUBMISSION;
        var examplesDone = access.canmanageexamples || workshop.examplesmode == __WEBPACK_IMPORTED_MODULE_7__workshop__["a" /* AddonModWorkshopProvider */].EXAMPLES_VOLUNTARY ||
            this.isTaskDone(tasks, 'examples');
        return workshop.phase > __WEBPACK_IMPORTED_MODULE_7__workshop__["a" /* AddonModWorkshopProvider */].PHASE_SETUP && access.cansubmit && (!examplesMust || examplesDone);
    };
    /**
     * Return if a user can assess a workshop.
     *
     * @param  {any} workshop Workshop info.
     * @param  {any} access   Access information.
     * @return {boolean}      True if the user can assess the workshop.
     */
    AddonModWorkshopHelperProvider.prototype.canAssess = function (workshop, access) {
        var examplesMust = workshop.useexamples && workshop.examplesmode == __WEBPACK_IMPORTED_MODULE_7__workshop__["a" /* AddonModWorkshopProvider */].EXAMPLES_BEFORE_ASSESSMENT;
        var examplesDone = access.canmanageexamples;
        return !examplesMust || examplesDone;
    };
    /**
     * Return a particular user submission from the submission list.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {number} [userId]   User ID. If not defined current user Id.
     * @return {Promise<any>}      Resolved with the submission, resolved with false if not found.
     */
    AddonModWorkshopHelperProvider.prototype.getUserSubmission = function (workshopId, userId) {
        var _this = this;
        if (userId === void 0) { userId = 0; }
        return this.workshopProvider.getSubmissions(workshopId).then(function (submissions) {
            userId = userId || _this.sitesProvider.getCurrentSiteUserId();
            for (var x in submissions) {
                if (submissions[x].authorid == userId) {
                    return submissions[x];
                }
            }
            return false;
        });
    };
    /**
     * Return a particular submission. It will use prefetched data if fetch fails.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} submissionId Submission ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Resolved with the submission, resolved with false if not found.
     */
    AddonModWorkshopHelperProvider.prototype.getSubmissionById = function (workshopId, submissionId, siteId) {
        var _this = this;
        return this.workshopProvider.getSubmission(workshopId, submissionId, siteId).catch(function () {
            return _this.workshopProvider.getSubmissions(workshopId, undefined, undefined, undefined, undefined, siteId)
                .then(function (submissions) {
                for (var x in submissions) {
                    if (submissions[x].id == submissionId) {
                        return submissions[x];
                    }
                }
                return false;
            });
        });
    };
    /**
     * Return a particular assesment. It will use prefetched data if fetch fails. It will add assessment form data.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {number} [userId]     User ID. If not defined, current user.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Resolved with the assessment.
     */
    AddonModWorkshopHelperProvider.prototype.getReviewerAssessmentById = function (workshopId, assessmentId, userId, siteId) {
        var _this = this;
        if (userId === void 0) { userId = 0; }
        return this.workshopProvider.getAssessment(workshopId, assessmentId, siteId).catch(function (error) {
            return _this.workshopProvider.getReviewerAssessments(workshopId, userId, undefined, undefined, siteId)
                .then(function (assessments) {
                for (var x in assessments) {
                    if (assessments[x].id == assessmentId) {
                        return assessments[x];
                    }
                }
                // Not found, return original error.
                return Promise.reject(error);
            });
        }).then(function (assessment) {
            return _this.workshopProvider.getAssessmentForm(workshopId, assessmentId, undefined, undefined, undefined, siteId)
                .then(function (assessmentForm) {
                assessment.form = assessmentForm;
                return assessment;
            });
        });
    };
    /**
     * Retrieves the assessment of the given user and all the related data.
     *
     * @param  {number}  workshopId          Workshop ID.
     * @param  {number}  [userId=0]          User ID. If not defined, current user.
     * @param  {boolean} [offline=false]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string}  [siteId]            Site ID. If not defined, current site.
     * @return {Promise<any[]>}              Promise resolved when the workshop data is retrieved.
     */
    AddonModWorkshopHelperProvider.prototype.getReviewerAssessments = function (workshopId, userId, offline, ignoreCache, siteId) {
        var _this = this;
        if (userId === void 0) { userId = 0; }
        if (offline === void 0) { offline = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.workshopProvider.getReviewerAssessments(workshopId, userId, offline, ignoreCache, siteId)
            .then(function (assessments) {
            var promises = assessments.map(function (assessment) {
                return _this.getSubmissionById(workshopId, assessment.submissionid, siteId).then(function (submission) {
                    assessment.submission = submission;
                });
            });
            return Promise.all(promises).then(function () {
                return assessments;
            });
        });
    };
    /**
     * Delete stored attachment files for a submission.
     *
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  submissionId If not editing, it will refer to timecreated.
     * @param  {boolean} editing      If the submission is being edited or added otherwise.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when deleted.
     */
    AddonModWorkshopHelperProvider.prototype.deleteSubmissionStoredFiles = function (workshopId, submissionId, editing, siteId) {
        var _this = this;
        return this.workshopOffline.getSubmissionFolder(workshopId, submissionId, editing, siteId).then(function (folderPath) {
            return _this.fileProvider.removeDir(folderPath).catch(function () {
                // Ignore any errors, CoreFileProvider.removeDir fails if folder doesn't exists.
            });
        });
    };
    /**
     * Given a list of files (either online files or local files), store the local files in a local folder
     * to be submitted later.
     *
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  submissionId If not editing, it will refer to timecreated.
     * @param  {boolean} editing      If the submission is being edited or added otherwise.
     * @param  {any[]}   files        List of files.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved if success, rejected otherwise.
     */
    AddonModWorkshopHelperProvider.prototype.storeSubmissionFiles = function (workshopId, submissionId, editing, files, siteId) {
        var _this = this;
        // Get the folder where to store the files.
        return this.workshopOffline.getSubmissionFolder(workshopId, submissionId, editing, siteId).then(function (folderPath) {
            return _this.uploaderProvider.storeFilesToUpload(folderPath, files);
        });
    };
    /**
     * Upload or store some files for a submission, depending if the user is offline or not.
     *
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  submissionId If not editing, it will refer to timecreated.
     * @param  {any[]}   files        List of files.
     * @param  {boolean} editing      If the submission is being edited or added otherwise.
     * @param  {boolean} offline      True if files sould be stored for offline, false to upload them.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved if success.
     */
    AddonModWorkshopHelperProvider.prototype.uploadOrStoreSubmissionFiles = function (workshopId, submissionId, files, editing, offline, siteId) {
        if (offline) {
            return this.storeSubmissionFiles(workshopId, submissionId, editing, files, siteId);
        }
        else {
            return this.uploaderProvider.uploadOrReuploadFiles(files, __WEBPACK_IMPORTED_MODULE_7__workshop__["a" /* AddonModWorkshopProvider */].COMPONENT, workshopId, siteId);
        }
    };
    /**
     * Get a list of stored attachment files for a submission. See AddonModWorkshopHelperProvider#storeFiles.
     *
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  submissionId If not editing, it will refer to timecreated.
     * @param  {boolean} editing      If the submission is being edited or added otherwise.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any[]>}       Promise resolved with the files.
     */
    AddonModWorkshopHelperProvider.prototype.getStoredSubmissionFiles = function (workshopId, submissionId, editing, siteId) {
        var _this = this;
        return this.workshopOffline.getSubmissionFolder(workshopId, submissionId, editing, siteId).then(function (folderPath) {
            return _this.uploaderProvider.getStoredFiles(folderPath).catch(function () {
                // Ignore not found files.
                return [];
            });
        });
    };
    /**
     * Get a list of stored attachment files for a submission and online files also. See AddonModWorkshopHelperProvider#storeFiles.
     *
     * @param  {any}     filesObject  Files object combining offline and online information.
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  submissionId If not editing, it will refer to timecreated.
     * @param  {boolean} editing      If the submission is being edited or added otherwise.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any[]>}       Promise resolved with the files.
     */
    AddonModWorkshopHelperProvider.prototype.getSubmissionFilesFromOfflineFilesObject = function (filesObject, workshopId, submissionId, editing, siteId) {
        var _this = this;
        return this.workshopOffline.getSubmissionFolder(workshopId, submissionId, editing, siteId).then(function (folderPath) {
            return _this.uploaderProvider.getStoredFilesFromOfflineFilesObject(filesObject, folderPath);
        });
    };
    /**
     * Delete stored attachment files for an assessment.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when deleted.
     */
    AddonModWorkshopHelperProvider.prototype.deleteAssessmentStoredFiles = function (workshopId, assessmentId, siteId) {
        var _this = this;
        return this.workshopOffline.getAssessmentFolder(workshopId, assessmentId, siteId).then(function (folderPath) {
            return _this.fileProvider.removeDir(folderPath).catch(function () {
                // Ignore any errors, CoreFileProvider.removeDir fails if folder doesn't exists.
            });
        });
    };
    /**
     * Given a list of files (either online files or local files), store the local files in a local folder
     * to be submitted later.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {any[]}  files        List of files.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved if success, rejected otherwise.
     */
    AddonModWorkshopHelperProvider.prototype.storeAssessmentFiles = function (workshopId, assessmentId, files, siteId) {
        var _this = this;
        // Get the folder where to store the files.
        return this.workshopOffline.getAssessmentFolder(workshopId, assessmentId, siteId).then(function (folderPath) {
            return _this.uploaderProvider.storeFilesToUpload(folderPath, files);
        });
    };
    /**
     * Upload or store some files for an assessment, depending if the user is offline or not.
     *
     * @param  {number}  workshopId   Workshop ID.
     * @param  {number}  assessmentId ID.
     * @param  {any[]}   files        List of files.
     * @param  {boolean} offline      True if files sould be stored for offline, false to upload them.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved if success.
     */
    AddonModWorkshopHelperProvider.prototype.uploadOrStoreAssessmentFiles = function (workshopId, assessmentId, files, offline, siteId) {
        if (offline) {
            return this.storeAssessmentFiles(workshopId, assessmentId, files, siteId);
        }
        else {
            return this.uploaderProvider.uploadOrReuploadFiles(files, __WEBPACK_IMPORTED_MODULE_7__workshop__["a" /* AddonModWorkshopProvider */].COMPONENT, workshopId, siteId);
        }
    };
    /**
     * Get a list of stored attachment files for an assessment. See AddonModWorkshopHelperProvider#storeFiles.
     *
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with the files.
     */
    AddonModWorkshopHelperProvider.prototype.getStoredAssessmentFiles = function (workshopId, assessmentId, siteId) {
        var _this = this;
        return this.workshopOffline.getAssessmentFolder(workshopId, assessmentId, siteId).then(function (folderPath) {
            return _this.uploaderProvider.getStoredFiles(folderPath).catch(function () {
                // Ignore not found files.
                return [];
            });
        });
    };
    /**
     * Get a list of stored attachment files for an assessment and online files also. See AddonModWorkshopHelperProvider#storeFiles.
     *
     * @param  {object} filesObject  Files object combining offline and online information.
     * @param  {number} workshopId   Workshop ID.
     * @param  {number} assessmentId Assessment ID.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with the files.
     */
    AddonModWorkshopHelperProvider.prototype.getAssessmentFilesFromOfflineFilesObject = function (filesObject, workshopId, assessmentId, siteId) {
        var _this = this;
        return this.workshopOffline.getAssessmentFolder(workshopId, assessmentId, siteId).then(function (folderPath) {
            return _this.uploaderProvider.getStoredFilesFromOfflineFilesObject(filesObject, folderPath);
        });
    };
    /**
     * Returns the action of a given submission.
     *
     * @param  {any[]}  actions      Offline actions to be applied to the given submission.
     * @param  {number} submissionId ID of the submission to filter by or false.
     * @return {any[]}               Promise resolved with the files.
     */
    AddonModWorkshopHelperProvider.prototype.filterSubmissionActions = function (actions, submissionId) {
        return actions.filter(function (action) {
            if (submissionId) {
                return action.submissionid == submissionId;
            }
            else {
                return action.submissionid < 0;
            }
        });
    };
    /**
     * Applies offline data to submission.
     *
     * @param  {any}   submission Submission object to be modified.
     * @param  {any[]} actions    Offline actions to be applied to the given submission.
     * @return {Promise<any>}     Promise resolved with the files.
     */
    AddonModWorkshopHelperProvider.prototype.applyOfflineData = function (submission, actions) {
        if (actions.length && !submission) {
            submission = {};
        }
        var editing = true, attachmentsid = false, workshopId;
        actions.forEach(function (action) {
            switch (action.action) {
                case 'add':
                    submission.id = action.submissionid;
                    editing = false;
                case 'update':
                    submission.title = action.title;
                    submission.content = action.content;
                    submission.title = action.title;
                    submission.courseid = action.courseid;
                    submission.submissionmodified = parseInt(action.timemodified, 10) / 1000;
                    submission.offline = true;
                    attachmentsid = action.attachmentsid;
                    workshopId = action.workshopid;
                    break;
                case 'delete':
                    submission.deleted = true;
                    submission.submissionmodified = parseInt(action.timemodified, 10) / 1000;
                    break;
                default:
            }
        });
        // Check offline files for latest attachmentsid.
        if (actions.length) {
            if (attachmentsid) {
                return this.getSubmissionFilesFromOfflineFilesObject(attachmentsid, workshopId, submission.id, editing)
                    .then(function (files) {
                    submission.attachmentfiles = files;
                    return submission;
                });
            }
            else {
                submission.attachmentfiles = [];
            }
        }
        return Promise.resolve(submission);
    };
    /**
     * Prepare assessment data to be sent to the server.
     *
     * @param {any}    workshop       Workshop object.
     * @param {any[]}  selectedValues Assessment current values
     * @param {string} feedbackText   Feedback text.
     * @param {any[]}  feedbackFiles  Feedback attachments.
     * @param {any}    form           Assessment form original data.
     * @param {number} attachmentsId  The draft file area id for attachments.
     * @return {Promise<any>}         Promise resolved with the data to be sent. Or rejected with the input errors object.
     */
    AddonModWorkshopHelperProvider.prototype.prepareAssessmentData = function (workshop, selectedValues, feedbackText, feedbackFiles, form, attachmentsId) {
        if (workshop.overallfeedbackmode == 2 && !feedbackText) {
            return Promise.reject({ feedbackauthor: this.translate.instant('core.err_required') });
        }
        return this.strategyDelegate.prepareAssessmentData(workshop.strategy, selectedValues, form).then(function (data) {
            data.feedbackauthor = feedbackText;
            data.feedbackauthorattachmentsid = attachmentsId || 0;
            data.nodims = form.dimenssionscount;
            return data;
        });
    };
    /**
     * Calculates the real value of a grade based on real_grade_value.
     *
     * @param  {number} value    Percentual value from 0 to 100.
     * @param  {number} max      The maximal grade.
     * @param  {number} decimals Decimals to show in the formatted grade.
     * @return {string}          Real grade formatted.
     */
    AddonModWorkshopHelperProvider.prototype.realGradeValueHelper = function (value, max, decimals) {
        if (value == null) {
            return null;
        }
        else if (max == 0) {
            return '0';
        }
        else {
            value = this.textUtils.roundToDecimals(max * value / 100, decimals);
            return this.utils.formatFloat(value);
        }
    };
    /**
     * Calculates the real value of a grades of an assessment.
     *
     * @param  {any} workshop   Workshop object.
     * @param  {any} assessment Assessment data.
     * @return {any}            Assessment with real grades.
     */
    AddonModWorkshopHelperProvider.prototype.realGradeValue = function (workshop, assessment) {
        assessment.grade = this.realGradeValueHelper(assessment.grade, workshop.grade, workshop.gradedecimals);
        assessment.gradinggrade = this.realGradeValueHelper(assessment.gradinggrade, workshop.gradinggrade, workshop.gradedecimals);
        assessment.gradinggradeover = this.realGradeValueHelper(assessment.gradinggradeover, workshop.gradinggrade, workshop.gradedecimals);
        return assessment;
    };
    /**
     * Check grade should be shown
     *
     * @param  {any} grade Grade to be shown
     * @return {boolean}   If grade should be shown or not.
     */
    AddonModWorkshopHelperProvider.prototype.showGrade = function (grade) {
        return typeof grade !== 'undefined' && grade !== null;
    };
    AddonModWorkshopHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__workshop__["a" /* AddonModWorkshopProvider */],
            __WEBPACK_IMPORTED_MODULE_8__offline__["a" /* AddonModWorkshopOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_9__assessment_strategy_delegate__["a" /* AddonWorkshopAssessmentStrategyDelegate */]])
    ], AddonModWorkshopHelperProvider);
    return AddonModWorkshopHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreFileComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreFileComponent_0;
/* unused harmony export View_CoreFileComponent_Host_0 */
/* unused harmony export CoreFileComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_button_button_ngfactory__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular_components_button_button__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core_src_translate_pipe__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core_src_translate_service__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_ionic_angular_components_icon_icon__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pipes_format_date__ = __webpack_require__(235);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__node_modules_ionic_angular_components_item_item_ngfactory__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ionic_angular_components_item_item__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_ionic_angular_util_form__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_ionic_angular_components_item_item_reorder__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_ionic_angular_components_item_item_content__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__download_refresh_download_refresh_ngfactory__ = __webpack_require__(732);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__download_refresh_download_refresh__ = __webpack_require__(374);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__file__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_file_helper__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_utils_mimetype__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_utils_text__ = __webpack_require__(10);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 




























var styles_CoreFileComponent = [];
var RenderType_CoreFileComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreFileComponent, data: {} });

function View_CoreFileComponent_1(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "p", [], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](1, null, ["", ""]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.fileSizeReadable; _ck(_v, 1, 0, currVal_0); }); }
function View_CoreFileComponent_2(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 2, "p", [], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](1, null, ["", ""])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_49" /* ɵppd */](2, 1)], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_56" /* ɵunv */](_v, 1, 0, _ck(_v, 2, 0, __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v.parent, 0), (_co.timemodified * 1000))); _ck(_v, 1, 0, currVal_0); }); }
function View_CoreFileComponent_3(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 6, "button", [["clear", ""], ["color", "danger"], ["icon-only", ""], ["ion-button", ""]], [[1, "aria-label", 0]], [[null, "click"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("click" === en)) {
        var pd_0 = (_co.delete($event) !== false);
        ad = (pd_0 && ad);
    } return ad; }, __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_button_button_ngfactory__["b" /* View_Button_0 */], __WEBPACK_IMPORTED_MODULE_1__node_modules_ionic_angular_components_button_button_ngfactory__["a" /* RenderType_Button */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 1097728, [[2, 4]], 0, __WEBPACK_IMPORTED_MODULE_2_ionic_angular_components_button_button__["a" /* Button */], [[8, ""], __WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */]], { color: [0, "color"], clear: [1, "clear"] }, null), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_47" /* ɵpid */](131072, __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core_src_translate_pipe__["a" /* TranslatePipe */], [__WEBPACK_IMPORTED_MODULE_5__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */]]), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 0, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](4, 0, null, 0, 1, "ion-icon", [["name", "trash"], ["role", "img"]], [[2, "hide", null]], null, null, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](5, 147456, null, 0, __WEBPACK_IMPORTED_MODULE_6_ionic_angular_components_icon_icon__["a" /* Icon */], [__WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 0, ["\n        "]))], function (_ck, _v) { var currVal_1 = "danger"; var currVal_2 = ""; _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_4 = "trash"; _ck(_v, 5, 0, currVal_4); }, function (_ck, _v) { var currVal_0 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_56" /* ɵunv */](_v, 0, 0, __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 2).transform("core.delete")); _ck(_v, 0, 0, currVal_0); var currVal_3 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 5)._hidden; _ck(_v, 4, 0, currVal_3); }); }
function View_CoreFileComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_47" /* ɵpid */](0, __WEBPACK_IMPORTED_MODULE_7__pipes_format_date__["a" /* CoreFormatDatePipe */], [__WEBPACK_IMPORTED_MODULE_8__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__["a" /* CoreTimeUtilsProvider */]]), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](1, 0, null, null, 26, "a", [["class", "item-media item item-block"], ["detail-none", ""], ["ion-item", ""], ["text-wrap", ""]], null, [[null, "click"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("click" === en)) {
        var pd_0 = (_co.download($event, true) !== false);
        ad = (pd_0 && ad);
    } return ad; }, __WEBPACK_IMPORTED_MODULE_10__node_modules_ionic_angular_components_item_item_ngfactory__["b" /* View_Item_0 */], __WEBPACK_IMPORTED_MODULE_10__node_modules_ionic_angular_components_item_item_ngfactory__["a" /* RenderType_Item */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](2, 1097728, null, 3, __WEBPACK_IMPORTED_MODULE_11_ionic_angular_components_item_item__["a" /* Item */], [__WEBPACK_IMPORTED_MODULE_12_ionic_angular_util_form__["a" /* Form */], __WEBPACK_IMPORTED_MODULE_3_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */], [2, __WEBPACK_IMPORTED_MODULE_13_ionic_angular_components_item_item_reorder__["a" /* ItemReorder */]]], null, null), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](335544320, 1, { contentLabel: 0 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](603979776, 2, { _buttons: 1 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](603979776, 3, { _icons: 1 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](6, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_14_ionic_angular_components_item_item_content__["a" /* ItemContent */], [], null, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](8, 0, null, 0, 0, "img", [["alt", ""], ["item-start", ""], ["role", "presentation"]], [[8, "src", 4]], null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](10, 0, null, 2, 1, "h2", [], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](11, null, ["", ""])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, 2, 1, null, View_CoreFileComponent_1)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](14, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_15__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, 2, 1, null, View_CoreFileComponent_2)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](17, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_15__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](19, 0, null, 4, 7, "div", [["class", "buttons"], ["item-end", ""]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](21, 0, null, null, 1, "core-download-refresh", [], null, [[null, "action"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("action" === en)) {
        var pd_0 = (_co.download() !== false);
        ad = (pd_0 && ad);
    } return ad; }, __WEBPACK_IMPORTED_MODULE_16__download_refresh_download_refresh_ngfactory__["b" /* View_CoreDownloadRefreshComponent_0 */], __WEBPACK_IMPORTED_MODULE_16__download_refresh_download_refresh_ngfactory__["a" /* RenderType_CoreDownloadRefreshComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](22, 49152, null, 0, __WEBPACK_IMPORTED_MODULE_17__download_refresh_download_refresh__["a" /* CoreDownloadRefreshComponent */], [], { status: [0, "status"], enabled: [1, "enabled"], loading: [2, "loading"], canTrustDownload: [3, "canTrustDownload"] }, { action: "action" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreFileComponent_3)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](25, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_15__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, 2, ["\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _co.fileSizeReadable; _ck(_v, 14, 0, currVal_2); var currVal_3 = _co.showTime; _ck(_v, 17, 0, currVal_3); var currVal_4 = _co.state; var currVal_5 = _co.canDownload; var currVal_6 = _co.isDownloading; var currVal_7 = !_co.alwaysDownload; _ck(_v, 22, 0, currVal_4, currVal_5, currVal_6, currVal_7); var currVal_8 = (!_co.isDownloading && _co.canDelete); _ck(_v, 25, 0, currVal_8); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.fileIcon; _ck(_v, 8, 0, currVal_0); var currVal_1 = _co.fileName; _ck(_v, 11, 0, currVal_1); }); }
function View_CoreFileComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-file", [], null, null, null, View_CoreFileComponent_0, RenderType_CoreFileComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 245760, null, 0, __WEBPACK_IMPORTED_MODULE_18__file__["a" /* CoreFileComponent */], [__WEBPACK_IMPORTED_MODULE_19__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_20__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_21__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_22__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_23__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_24__providers_file_helper__["a" /* CoreFileHelperProvider */], __WEBPACK_IMPORTED_MODULE_25__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_26__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_27__providers_utils_text__["a" /* CoreTextUtilsProvider */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }
var CoreFileComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-file", __WEBPACK_IMPORTED_MODULE_18__file__["a" /* CoreFileComponent */], View_CoreFileComponent_Host_0, { file: "file", component: "component", componentId: "componentId", canDelete: "canDelete", alwaysDownload: "alwaysDownload", canDownload: "canDownload", showSize: "showSize", showTime: "showTime" }, { onDelete: "onDelete" }, []);

//# sourceMappingURL=file.ngfactory.js.map

/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDynamicComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




/**
 * Component to create another component dynamically.
 *
 * You need to pass the class of the component to this component (the class, not the name), along with the input data.
 *
 * So you should do something like:
 *
 *     import { MyComponent } from './component';
 *
 *     ...
 *
 *         this.component = MyComponent;
 *
 * And in the template:
 *
 *     <core-dynamic-component [component]="component" [data]="data">
 *         <p>Cannot render the data.</p>
 *     </core-dynamic-component>
 *
 * Please notice that the component that you pass needs to be declared in entryComponents of the module to be created dynamically.
 *
 * Alternatively, you can also supply a ComponentRef instead of the class of the component. In this case, the component won't
 * be instantiated because it already is, it will be attached to the view and the right data will be passed to it.
 * Passing ComponentRef is meant for site plugins, so we'll inject a NavController instance to the component.
 *
 * The contents of this component will be displayed if no component is supplied or it cannot be created. In the example above,
 * if no component is supplied then the template will show the message "Cannot render the data.".
 */
var CoreDynamicComponent = /** @class */ (function () {
    function CoreDynamicComponent(logger, factoryResolver, differs, navCtrl, cdr, element, domUtils) {
        this.factoryResolver = factoryResolver;
        this.navCtrl = navCtrl;
        this.cdr = cdr;
        this.element = element;
        this.domUtils = domUtils;
        this.logger = logger.getInstance('CoreDynamicComponent');
        this.differ = differs.find([]).create();
    }
    Object.defineProperty(CoreDynamicComponent.prototype, "dynamicComponent", {
        // Get the container where to put the dynamic component.
        set: function (el) {
            this.container = el;
            this.createComponent();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Component being initialized.
     */
    CoreDynamicComponent.prototype.ngOnInit = function () {
        this.createComponent();
    };
    /**
     * Detect changes on input properties.
     */
    CoreDynamicComponent.prototype.ngOnChanges = function (changes) {
        if (changes.component && !this.component) {
            // Component not set, destroy the instance if any.
            this.lastComponent = undefined;
            this.instance = undefined;
            this.container && this.container.clear();
        }
        else if (changes.component && (!this.instance || this.component != this.lastComponent)) {
            this.createComponent();
        }
    };
    /**
     * Detect and act upon changes that Angular can’t or won’t detect on its own (objects and arrays).
     */
    CoreDynamicComponent.prototype.ngDoCheck = function () {
        if (this.instance) {
            // Check if there's any change in the data object.
            var changes = this.differ.diff(this.data);
            if (changes) {
                this.setInputData();
                if (this.instance.ngOnChanges) {
                    this.instance.ngOnChanges(this.domUtils.createChangesFromKeyValueDiff(changes));
                }
            }
        }
    };
    /**
     * Call a certain function on the component.
     *
     * @param {string} name Name of the function to call.
     * @param {any[]} params List of params to send to the function.
     * @return {any} Result of the call. Undefined if no component instance or the function doesn't exist.
     */
    CoreDynamicComponent.prototype.callComponentFunction = function (name, params) {
        if (this.instance && typeof this.instance[name] == 'function') {
            return this.instance[name].apply(this.instance, params);
        }
    };
    /**
     * Create a component, add it to a container and set the input data.
     *
     * @return {boolean} Whether the component was successfully created.
     */
    CoreDynamicComponent.prototype.createComponent = function () {
        this.lastComponent = this.component;
        if (!this.component || !this.container) {
            // No component to instantiate or container doesn't exist right now.
            return false;
        }
        if (this.instance) {
            // Component already instantiated.
            return true;
        }
        if (this.component instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__["p" /* ComponentRef */]) {
            // A ComponentRef was supplied instead of the component class. Add it to the view.
            this.container.insert(this.component.hostView);
            this.instance = this.component.instance;
            // This feature is usually meant for site plugins. Inject some properties.
            this.instance['ChangeDetectorRef'] = this.cdr;
            this.instance['NavController'] = this.navCtrl;
            this.instance['componentContainer'] = this.element.nativeElement;
        }
        else {
            try {
                // Create the component and add it to the container.
                var factory = this.factoryResolver.resolveComponentFactory(this.component), componentRef = this.container.createComponent(factory);
                this.instance = componentRef.instance;
            }
            catch (ex) {
                this.logger.error('Error creating component', ex);
                return false;
            }
        }
        this.setInputData();
        return true;
    };
    /**
     * Set the input data for the component.
     */
    CoreDynamicComponent.prototype.setInputData = function () {
        for (var name_1 in this.data) {
            this.instance[name_1] = this.data[name_1];
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreDynamicComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreDynamicComponent.prototype, "data", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('dynamicComponent', { read: __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */] }),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */]),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */]])
    ], CoreDynamicComponent.prototype, "dynamicComponent", null);
    CoreDynamicComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-dynamic-component',
            templateUrl: 'core-dynamic-component.html'
        }),
        __param(3, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["o" /* ComponentFactoryResolver */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* KeyValueDiffers */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreDynamicComponent);
    return CoreDynamicComponent;
}());

//# sourceMappingURL=dynamic-component.js.map

/***/ }),
/* 203 */,
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModDataHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_fileuploader_providers_fileuploader__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__fields_delegate__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__offline__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__data__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_rating_providers_offline__ = __webpack_require__(191);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * Service that provides helper functions for datas.
 */
var AddonModDataHelperProvider = /** @class */ (function () {
    function AddonModDataHelperProvider(sitesProvider, dataProvider, translate, fieldsDelegate, dataOffline, fileUploaderProvider, textUtils, eventsProvider, utils, domUtils, courseProvider, ratingOffline) {
        this.sitesProvider = sitesProvider;
        this.dataProvider = dataProvider;
        this.translate = translate;
        this.fieldsDelegate = fieldsDelegate;
        this.dataOffline = dataOffline;
        this.fileUploaderProvider = fileUploaderProvider;
        this.textUtils = textUtils;
        this.eventsProvider = eventsProvider;
        this.utils = utils;
        this.domUtils = domUtils;
        this.courseProvider = courseProvider;
        this.ratingOffline = ratingOffline;
    }
    /**
     * Returns the record with the offline actions applied.
     *
     * @param {AddonModDataEntry} record Entry to modify.
     * @param {AddonModDataOfflineAction[]} offlineActions Offline data with the actions done.
     * @param {any[]} fields Entry defined fields indexed by fieldid.
     * @return {Promise<AddonModDataEntry>} Promise resolved when done.
     */
    AddonModDataHelperProvider.prototype.applyOfflineActions = function (record, offlineActions, fields) {
        var _this = this;
        var promises = [];
        offlineActions.forEach(function (action) {
            record.timemodified = action.timemodified;
            record.hasOffline = true;
            switch (action.action) {
                case 'approve':
                    record.approved = true;
                    break;
                case 'disapprove':
                    record.approved = false;
                    break;
                case 'delete':
                    record.deleted = true;
                    break;
                case 'add':
                case 'edit':
                    record.groupid = action.groupid;
                    var offlineContents_1 = {};
                    action.fields.forEach(function (offlineContent) {
                        if (typeof offlineContents_1[offlineContent.fieldid] == 'undefined') {
                            offlineContents_1[offlineContent.fieldid] = {};
                        }
                        if (offlineContent.subfield) {
                            offlineContents_1[offlineContent.fieldid][offlineContent.subfield] =
                                _this.textUtils.parseJSON(offlineContent.value);
                        }
                        else {
                            offlineContents_1[offlineContent.fieldid][''] = _this.textUtils.parseJSON(offlineContent.value);
                        }
                    });
                    // Override field contents.
                    fields.forEach(function (field) {
                        if (_this.fieldsDelegate.hasFiles(field)) {
                            promises.push(_this.getStoredFiles(record.dataid, record.id, field.id).then(function (offlineFiles) {
                                record.contents[field.id] = _this.fieldsDelegate.overrideData(field, record.contents[field.id], offlineContents_1[field.id], offlineFiles);
                                record.contents[field.id].fieldid = field.id;
                            }));
                        }
                        else {
                            record.contents[field.id] = _this.fieldsDelegate.overrideData(field, record.contents[field.id], offlineContents_1[field.id]);
                            record.contents[field.id].fieldid = field.id;
                        }
                    });
                    break;
                default:
                    break;
            }
        });
        return Promise.all(promises).then(function () {
            return record;
        });
    };
    /**
     * Approve or disapprove a database entry.
     *
     * @param {number} dataId Database ID.
     * @param {number} entryId Entry ID.
     * @param {boolaen} approve True to approve, false to disapprove.
     * @param {number} [courseId] Course ID. It not defined, it will be fetched.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    AddonModDataHelperProvider.prototype.approveOrDisapproveEntry = function (dataId, entryId, approve, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var modal = this.domUtils.showModalLoading('core.sending', true);
        this.getActivityCourseIdIfNotSet(dataId, courseId, siteId).then(function (courseId) {
            // Approve/disapprove entry.
            return _this.dataProvider.approveEntry(dataId, entryId, approve, courseId, siteId).catch(function (message) {
                _this.domUtils.showErrorModalDefault(message, 'addon.mod_data.errorapproving', true);
                return Promise.reject(null);
            });
        }).then(function () {
            var promises = [];
            promises.push(_this.dataProvider.invalidateEntryData(dataId, entryId, siteId));
            promises.push(_this.dataProvider.invalidateEntriesData(dataId, siteId));
            return Promise.all(promises).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_11__data__["a" /* AddonModDataProvider */].ENTRY_CHANGED, { dataId: dataId, entryId: entryId }, siteId);
            _this.domUtils.showToast(approve ? 'addon.mod_data.recordapproved' : 'addon.mod_data.recorddisapproved', true, 3000);
        }).catch(function () {
            // Ignore error, it was already displayed.
        }).finally(function () {
            modal.dismiss();
        });
    };
    /**
     * Displays fields for being shown.
     *
     * @param {string} template Template HMTL.
     * @param {any[]} fields Fields that defines every content in the entry.
     * @param {any} entry Entry.
     * @param {number} offset Entry offset.
     * @param {string} mode Mode list or show.
     * @param {AddonModDataOfflineAction[]} actions Actions that can be performed to the record.
     * @return {string} Generated HTML.
     */
    AddonModDataHelperProvider.prototype.displayShowFields = function (template, fields, entry, offset, mode, actions) {
        if (!template) {
            return '';
        }
        var replace, render;
        // Replace the fields found on template.
        fields.forEach(function (field) {
            replace = '[[' + field.name + ']]';
            replace = replace.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            replace = new RegExp(replace, 'gi');
            // Replace field by a generic directive.
            render = '<addon-mod-data-field-plugin [field]="fields[' + field.id + ']" [value]="entries[' + entry.id +
                '].contents[' + field.id + ']" mode="' + mode + '" [database]="data" (gotoEntry)="gotoEntry(' + entry.id +
                ')"></addon-mod-data-field-plugin>';
            template = template.replace(replace, render);
        });
        for (var action in actions) {
            replace = new RegExp('##' + action + '##', 'gi');
            // Is enabled?
            if (actions[action]) {
                if (action == 'moreurl') {
                    // Render more url directly because it can be part of an HTML attribute.
                    render = this.sitesProvider.getCurrentSite().getURL() + '/mod/data/view.php?d={{data.id}}&rid=' + entry.id;
                }
                else if (action == 'approvalstatus') {
                    render = this.translate.instant('addon.mod_data.' + (entry.approved ? 'approved' : 'notapproved'));
                }
                else {
                    render = '<addon-mod-data-action action="' + action + '" [entry]="entries[' + entry.id + ']" mode="' + mode +
                        '" [database]="data" [module]="module" [offset]="' + offset + '" [group]="group" ></addon-mod-data-action>';
                }
                template = template.replace(replace, render);
            }
            else {
                template = template.replace(replace, '');
            }
        }
        return template;
    };
    /**
     * Get online and offline entries, or search entries.
     *
     * @param   {any}       data               Database object.
     * @param   {any[]}     fields             The fields that define the contents.
     * @param   {number}    [groupId=0]        Group ID.
     * @param   {string}    [search]           Search text. It will be used if advSearch is not defined.
     * @param   {any[]}     [advSearch]        Advanced search data.
     * @param   {string}    [sort=0]           Sort the records by this field id, reserved ids are:
     *                                            0: timeadded
     *                                           -1: firstname
     *                                           -2: lastname
     *                                           -3: approved
     *                                           -4: timemodified.
     *                                          Empty for using the default database setting.
     * @param   {string}    [order=DESC]        The direction of the sorting: 'ASC' or 'DESC'.
     *                                          Empty for using the default database setting.
     * @param   {number}    [page=0]            Page of records to return.
     * @param   {number}    [perPage=PER_PAGE]  Records per page to return. Default on PER_PAGE.
     * @param   {string}    [siteId]            Site ID. If not defined, current site.
     * @return  {Promise<AddonModDataEntries>}  Promise resolved when the database is retrieved.
     */
    AddonModDataHelperProvider.prototype.fetchEntries = function (data, fields, groupId, search, advSearch, sort, order, page, perPage, siteId) {
        var _this = this;
        if (groupId === void 0) { groupId = 0; }
        if (sort === void 0) { sort = '0'; }
        if (order === void 0) { order = 'DESC'; }
        if (page === void 0) { page = 0; }
        if (perPage === void 0) { perPage = __WEBPACK_IMPORTED_MODULE_11__data__["a" /* AddonModDataProvider */].PER_PAGE; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var offlineActions = {};
            var result = {
                entries: [],
                totalcount: 0,
                offlineEntries: []
            };
            var offlinePromise = _this.dataOffline.getDatabaseEntries(data.id, site.id).then(function (actions) {
                result.hasOfflineActions = !!actions.length;
                actions.forEach(function (action) {
                    if (typeof offlineActions[action.entryid] == 'undefined') {
                        offlineActions[action.entryid] = [];
                    }
                    offlineActions[action.entryid].push(action);
                    // We only display new entries in the first page when not searching.
                    if (action.action == 'add' && page == 0 && !search && !advSearch &&
                        (!action.groupid || !groupId || action.groupid == groupId)) {
                        result.offlineEntries.push({
                            id: action.entryid,
                            canmanageentry: true,
                            approved: !data.approval || data.manageapproved,
                            dataid: data.id,
                            groupid: action.groupid,
                            timecreated: -action.entryid,
                            timemodified: -action.entryid,
                            userid: site.getUserId(),
                            fullname: site.getInfo().fullname,
                            contents: {}
                        });
                    }
                });
                // Sort offline entries by creation time.
                result.offlineEntries.sort(function (entry1, entry2) { return entry2.timecreated - entry1.timecreated; });
            });
            var ratingsPromise = _this.ratingOffline.hasRatings('mod_data', 'entry', 'module', data.coursemodule)
                .then(function (hasRatings) {
                result.hasOfflineRatings = hasRatings;
            });
            var fetchPromise;
            if (search || advSearch) {
                fetchPromise = _this.dataProvider.searchEntries(data.id, groupId, search, advSearch, sort, order, page, perPage, site.id).then(function (fetchResult) {
                    result.entries = fetchResult.entries;
                    result.totalcount = fetchResult.totalcount;
                    result.maxcount = fetchResult.maxcount;
                });
            }
            else {
                fetchPromise = _this.dataProvider.getEntries(data.id, groupId, sort, order, page, perPage, false, false, site.id)
                    .then(function (fetchResult) {
                    result.entries = fetchResult.entries;
                    result.totalcount = fetchResult.totalcount;
                });
            }
            return Promise.all([offlinePromise, ratingsPromise, fetchPromise]).then(function () {
                // Apply offline actions to online and offline entries.
                var promises = [];
                result.entries.forEach(function (entry) {
                    promises.push(_this.applyOfflineActions(entry, offlineActions[entry.id] || [], fields));
                });
                result.offlineEntries.forEach(function (entry) {
                    promises.push(_this.applyOfflineActions(entry, offlineActions[entry.id] || [], fields));
                });
                return Promise.all(promises);
            }).then(function () {
                return result;
            });
        });
    };
    /**
     * Fetch an online or offline entry.
     *
     * @param {any} data Database.
     * @param {any[]} fields List of database fields.
     * @param {number} entryId Entry ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{entry: AddonModDataEntry, ratinginfo?: CoreRatingInfo}>} Promise resolved with the entry.
     */
    AddonModDataHelperProvider.prototype.fetchEntry = function (data, fields, entryId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.dataOffline.getEntryActions(data.id, entryId, site.id).then(function (offlineActions) {
                var promise;
                if (entryId > 0) {
                    // Online entry.
                    promise = _this.dataProvider.getEntry(data.id, entryId, false, site.id);
                }
                else {
                    // Offline entry or new entry.
                    promise = Promise.resolve({
                        entry: {
                            id: entryId,
                            userid: site.getUserId(),
                            groupid: 0,
                            dataid: data.id,
                            timecreated: -entryId,
                            timemodified: -entryId,
                            approved: !data.approval || data.manageapproved,
                            canmanageentry: true,
                            fullname: site.getInfo().fullname,
                            contents: [],
                        }
                    });
                }
                return promise.then(function (response) {
                    return _this.applyOfflineActions(response.entry, offlineActions, fields).then(function () {
                        return response;
                    });
                });
            });
        });
    };
    /**
     * Returns an object with all the actions that the user can do over the record.
     *
     * @param {any}  database     Database activity.
     * @param {any}  accessInfo   Access info to the activity.
     * @param {any}  record       Entry or record where the actions will be performed.
     * @return {any}              Keyed with the action names and boolean to evalute if it can or cannot be done.
     */
    AddonModDataHelperProvider.prototype.getActions = function (database, accessInfo, record) {
        return {
            more: true,
            moreurl: true,
            user: true,
            userpicture: true,
            timeadded: true,
            timemodified: true,
            edit: record.canmanageentry && !record.deleted,
            delete: record.canmanageentry,
            approve: database.approval && accessInfo.canapprove && !record.approved && !record.deleted,
            disapprove: database.approval && accessInfo.canapprove && record.approved && !record.deleted,
            approvalstatus: database.approval,
            comments: database.comments,
            // Unsupported actions.
            tags: false,
            delcheck: false,
            export: false
        };
    };
    /**
     * Convenience function to get the course id of the database.
     *
     * @param {number} dataId Database id.
     * @param {number} [courseId] Course id, if known.
     * @param {string} [siteId] Site id, if not set, current site will be used.
     * @return {Promise<number>} Resolved with course Id when done.
     */
    AddonModDataHelperProvider.prototype.getActivityCourseIdIfNotSet = function (dataId, courseId, siteId) {
        if (courseId) {
            return Promise.resolve(courseId);
        }
        return this.courseProvider.getModuleBasicInfoByInstance(dataId, 'data', siteId).then(function (module) {
            return module.course;
        });
    };
    /**
     * Returns the default template of a certain type.
     *
     * Based on Moodle function data_generate_default_template.
     *
     * @param {string} type Type of template.
     * @param {any[]} fields List of database fields.
     * @return {string} Template HTML.
     */
    AddonModDataHelperProvider.prototype.getDefaultTemplate = function (type, fields) {
        var html = [];
        if (type == 'list') {
            html.push('##delcheck##<br />');
        }
        html.push('<div class="defaulttemplate">', '<table class="mod-data-default-template ##approvalstatus##">', '<tbody>');
        fields.forEach(function (field) {
            html.push('<tr class="">', '<td class="template-field cell c0" style="">', field.name, ': </td>', '<td class="template-token cell c1 lastcol" style="">[[', field.name, ']]</td>', '</tr>');
        });
        if (type == 'list') {
            html.push('<tr class="lastrow">', '<td class="controls template-field cell c0 lastcol" style="" colspan="2">', '##edit##  ##more##  ##delete##  ##approve##  ##disapprove##  ##export##', '</td>', '</tr>');
        }
        else if (type == 'single') {
            html.push('<tr class="lastrow">', '<td class="controls template-field cell c0 lastcol" style="" colspan="2">', '##edit##  ##delete##  ##approve##  ##disapprove##  ##export##', '</td>', '</tr>');
        }
        else if (type == 'asearch') {
            html.push('<tr class="searchcontrols">', '<td class="template-field cell c0" style="">Author first name: </td>', '<td class="template-token cell c1 lastcol" style="">##firstname##</td>', '</tr>', '<tr class="searchcontrols lastrow">', '<td class="template-field cell c0" style="">Author surname: </td>', '<td class="template-token cell c1 lastcol" style="">##lastname##</td>', '</tr>');
        }
        html.push('</tbody>', '</table>', '</div>');
        if (type == 'list') {
            html.push('<hr />');
        }
        return html.join('');
    };
    /**
     * Retrieve the entered data in the edit form.
     * We don't use ng-model because it doesn't detect changes done by JavaScript.
     *
     * @param {any} inputData Array with the entered form values.
     * @param {Array} fields Fields that defines every content in the entry.
     * @param {number} [dataId] Database Id. If set, files will be uploaded and itemId set.
     * @param {number} entryId Entry Id.
     * @param {AddonModDataEntryFields} entryContents Original entry contents.
     * @param {boolean} offline True to prepare the data for an offline uploading, false otherwise.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} That contains object with the answers.
     */
    AddonModDataHelperProvider.prototype.getEditDataFromForm = function (inputData, fields, dataId, entryId, entryContents, offline, siteId) {
        var _this = this;
        if (offline === void 0) { offline = false; }
        if (!inputData) {
            return Promise.resolve({});
        }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Filter and translate fields to each field plugin.
        var edit = [], promises = [];
        fields.forEach(function (field) {
            promises.push(Promise.resolve(_this.fieldsDelegate.getFieldEditData(field, inputData, entryContents[field.id]))
                .then(function (fieldData) {
                if (fieldData) {
                    var proms_1 = [];
                    fieldData.forEach(function (data) {
                        var dataProm;
                        // Upload Files if asked.
                        if (dataId && data.files) {
                            dataProm = _this.uploadOrStoreFiles(dataId, 0, entryId, data.fieldid, data.files, offline, siteId)
                                .then(function (filesResult) {
                                delete data.files;
                                data.value = filesResult;
                            });
                        }
                        else {
                            dataProm = Promise.resolve();
                        }
                        proms_1.push(dataProm.then(function () {
                            if (data.value) {
                                data.value = JSON.stringify(data.value);
                            }
                            if (typeof data.subfield == 'undefined') {
                                data.subfield = '';
                            }
                            // WS wants values in Json format.
                            edit.push(data);
                        }));
                    });
                    return Promise.all(proms_1);
                }
            }));
        });
        return Promise.all(promises).then(function () {
            return edit;
        });
    };
    /**
     * Retrieve the temp files to be updated.
     *
     * @param {any} inputData Array with the entered form values.
     * @param {any[]} fields Fields that defines every content in the entry.
     * @param {number} [dataId] Database Id. If set, fils will be uploaded and itemId set.
     * @param {AddonModDataEntryFields} entryContents Original entry contents indexed by field id.
     * @return {Promise<any>} That contains object with the files.
     */
    AddonModDataHelperProvider.prototype.getEditTmpFiles = function (inputData, fields, dataId, entryContents) {
        var _this = this;
        if (!inputData) {
            return Promise.resolve([]);
        }
        // Filter and translate fields to each field plugin.
        var promises = fields.map(function (field) {
            return Promise.resolve(_this.fieldsDelegate.getFieldEditFiles(field, inputData, entryContents[field.id]));
        });
        return Promise.all(promises).then(function (fieldsFiles) {
            return fieldsFiles.reduce(function (files, fieldFiles) { return files.concat(fieldFiles); }, []);
        });
    };
    /**
     * Get a list of stored attachment files for a new entry. See $mmaModDataHelper#storeFiles.
     *
     * @param  {number} dataId     Database ID.
     * @param  {number} entryId    Entry ID or, if creating, timemodified.
     * @param  {number} fieldId    Field ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved with the files.
     */
    AddonModDataHelperProvider.prototype.getStoredFiles = function (dataId, entryId, fieldId, siteId) {
        var _this = this;
        return this.dataOffline.getEntryFieldFolder(dataId, entryId, fieldId, siteId).then(function (folderPath) {
            return _this.fileUploaderProvider.getStoredFiles(folderPath).catch(function () {
                // Ignore not found files.
                return [];
            });
        });
    };
    /**
     * Check if data has been changed by the user.
     *
     * @param {any} inputData Object with the entered form values.
     * @param {any[]} fields Fields that defines every content in the entry.
     * @param {number} [dataId] Database Id. If set, fils will be uploaded and itemId set.
     * @param {AddonModDataEntryFields} entryContents Original entry contents indexed by field id.
     * @return {Promise<boolean>} True if changed, false if not.
     */
    AddonModDataHelperProvider.prototype.hasEditDataChanged = function (inputData, fields, dataId, entryContents) {
        var _this = this;
        var promises = fields.map(function (field) {
            return _this.fieldsDelegate.hasFieldDataChanged(field, inputData, entryContents[field.id]);
        });
        // Will reject on first change detected.
        return Promise.all(promises).then(function () {
            // No changes.
            return false;
        }).catch(function () {
            // Has changes.
            return true;
        });
    };
    /**
     * Displays a confirmation modal for deleting an entry.
     *
     * @param {number} dataId Database ID.
     * @param {number} entryId Entry ID.
     * @param {number} [courseId] Course ID. It not defined, it will be fetched.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    AddonModDataHelperProvider.prototype.showDeleteEntryModal = function (dataId, entryId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.domUtils.showConfirm(this.translate.instant('addon.mod_data.confirmdeleterecord')).then(function () {
            var modal = _this.domUtils.showModalLoading();
            return _this.getActivityCourseIdIfNotSet(dataId, courseId, siteId).then(function (courseId) {
                return _this.dataProvider.deleteEntry(dataId, entryId, courseId, siteId);
            }).catch(function (message) {
                _this.domUtils.showErrorModalDefault(message, 'addon.mod_data.errordeleting', true);
                return Promise.reject(null);
            }).then(function () {
                return _this.utils.allPromises([
                    _this.dataProvider.invalidateEntryData(dataId, entryId, siteId),
                    _this.dataProvider.invalidateEntriesData(dataId, siteId)
                ]).catch(function () {
                    // Ignore errors.
                });
            }).then(function () {
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_11__data__["a" /* AddonModDataProvider */].ENTRY_CHANGED, { dataId: dataId, entryId: entryId, deleted: true }, siteId);
                _this.domUtils.showToast('addon.mod_data.recorddeleted', true, 3000);
            }).finally(function () {
                modal.dismiss();
            });
        }).catch(function () {
            // Ignore error, it was already displayed.
        });
    };
    /**
     * Given a list of files (either online files or local files), store the local files in a local folder
     * to be submitted later.
     *
     * @param  {number}   dataId   Database ID.
     * @param  {number}   entryId  Entry ID or, if creating, timemodified.
     * @param  {number}   fieldId  Field ID.
     * @param  {any[]}    files    List of files.
     * @param  {string}   [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved if success, rejected otherwise.
     */
    AddonModDataHelperProvider.prototype.storeFiles = function (dataId, entryId, fieldId, files, siteId) {
        var _this = this;
        // Get the folder where to store the files.
        return this.dataOffline.getEntryFieldFolder(dataId, entryId, fieldId, siteId).then(function (folderPath) {
            return _this.fileUploaderProvider.storeFilesToUpload(folderPath, files);
        });
    };
    /**
     * Upload or store some files, depending if the user is offline or not.
     *
     * @param  {number}   dataId     Database ID.
     * @param  {number}   [itemId=0] Draft ID to use. Undefined or 0 to create a new draft ID.
     * @param  {number}   entryId    Entry ID or, if creating, timemodified.
     * @param  {number}   fieldId    Field ID.
     * @param  {any[]}    files      List of files.
     * @param  {boolean}  offline    True if files sould be stored for offline, false to upload them.
     * @param  {string}   [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved if success.
     */
    AddonModDataHelperProvider.prototype.uploadOrStoreFiles = function (dataId, itemId, entryId, fieldId, files, offline, siteId) {
        if (itemId === void 0) { itemId = 0; }
        if (files.length) {
            if (offline) {
                return this.storeFiles(dataId, entryId, fieldId, files, siteId);
            }
            return this.fileUploaderProvider.uploadOrReuploadFiles(files, __WEBPACK_IMPORTED_MODULE_11__data__["a" /* AddonModDataProvider */].COMPONENT, itemId, siteId);
        }
        return Promise.resolve(0);
    };
    AddonModDataHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_11__data__["a" /* AddonModDataProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_9__fields_delegate__["a" /* AddonModDataFieldsDelegate */],
            __WEBPACK_IMPORTED_MODULE_10__offline__["a" /* AddonModDataOfflineProvider */], __WEBPACK_IMPORTED_MODULE_8__core_fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_12__core_rating_providers_offline__["a" /* CoreRatingOfflineProvider */]])
    ], AddonModDataHelperProvider);
    return AddonModDataHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModGlossaryProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__offline__ = __webpack_require__(244);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Service that provides some features for glossaries.
 */
var AddonModGlossaryProvider = /** @class */ (function () {
    function AddonModGlossaryProvider(appProvider, sitesProvider, filepoolProvider, translate, textUtils, utils, glossaryOffline, logHelper) {
        this.appProvider = appProvider;
        this.sitesProvider = sitesProvider;
        this.filepoolProvider = filepoolProvider;
        this.translate = translate;
        this.textUtils = textUtils;
        this.utils = utils;
        this.glossaryOffline = glossaryOffline;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModGlossary:';
    }
    AddonModGlossaryProvider_1 = AddonModGlossaryProvider;
    /**
     * Get the course glossary cache key.
     *
     * @param  {number} courseId Course Id.
     * @return {string}          Cache key.
     */
    AddonModGlossaryProvider.prototype.getCourseGlossariesCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'courseGlossaries:' + courseId;
    };
    /**
     * Get all the glossaries in a course.
     *
     * @param  {number} courseId Course Id.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Resolved with the glossaries.
     */
    AddonModGlossaryProvider.prototype.getCourseGlossaries = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            };
            var preSets = {
                cacheKey: _this.getCourseGlossariesCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_glossary_get_glossaries_by_courses', params, preSets).then(function (result) {
                return result.glossaries;
            });
        });
    };
    /**
     * Invalidate all glossaries in a course.
     *
     * @param  {number} courseId Course Id.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateCourseGlossaries = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var key = _this.getCourseGlossariesCacheKey(courseId);
            return site.invalidateWsCacheForKey(key);
        });
    };
    /**
     * Get the entries by author cache key.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} letter     First letter of firstname or lastname, or either keywords: ALL or SPECIAL.
     * @param  {string} field      Search and order using: FIRSTNAME or LASTNAME
     * @param  {string} sort       The direction of the order: ASC or DESC
     * @return {string}            Cache key.
     */
    AddonModGlossaryProvider.prototype.getEntriesByAuthorCacheKey = function (glossaryId, letter, field, sort) {
        return this.ROOT_CACHE_KEY + 'entriesByAuthor:' + glossaryId + ':' + letter + ':' + field + ':' + sort;
    };
    /**
     * Get entries by author.
     *
     * @param  {number}  glossaryId Glossary Id.
     * @param  {string}  letter     First letter of firstname or lastname, or either keywords: ALL or SPECIAL.
     * @param  {string}  field      Search and order using: FIRSTNAME or LASTNAME
     * @param  {string}  sort       The direction of the order: ASC or DESC
     * @param  {number}  from       Start returning records from here.
     * @param  {number}  limit      Number of records to return.
     * @param  {boolean} forceCache True to always get the value from cache, false otherwise. Default false.
     * @param  {string}  [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any[]>}     Resolved with the entries.
     */
    AddonModGlossaryProvider.prototype.getEntriesByAuthor = function (glossaryId, letter, field, sort, from, limit, forceCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                id: glossaryId,
                letter: letter,
                field: field,
                sort: sort,
                from: from,
                limit: limit
            };
            var preSets = {
                cacheKey: _this.getEntriesByAuthorCacheKey(glossaryId, letter, field, sort),
                omitExpires: forceCache,
                updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('mod_glossary_get_entries_by_author', params, preSets);
        });
    };
    /**
     * Invalidate cache of entries by author.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} letter     First letter of firstname or lastname, or either keywords: ALL or SPECIAL.
     * @param  {string} field      Search and order using: FIRSTNAME or LASTNAME
     * @param  {string} sort       The direction of the order: ASC or DESC
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateEntriesByAuthor = function (glossaryId, letter, field, sort, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var key = _this.getEntriesByAuthorCacheKey(glossaryId, letter, field, sort);
            return site.invalidateWsCacheForKey(key);
        });
    };
    /**
     * Get entries by category.
     *
     * @param  {number} glossaryId  Glossary Id.
     * @param  {string} categoryId  The category ID. Use constant SHOW_ALL_CATERGORIES for all categories, or
     *                              constant SHOW_NOT_CATEGORISED for uncategorised entries.
     * @param  {number} from        Start returning records from here.
     * @param  {number} limit       Number of records to return.
     * @param  {boolean} forceCache True to always get the value from cache, false otherwise. Default false.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any[]>}     Resolved with the entries.
     */
    AddonModGlossaryProvider.prototype.getEntriesByCategory = function (glossaryId, categoryId, from, limit, forceCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                id: glossaryId,
                categoryid: categoryId,
                from: from,
                limit: limit
            };
            var preSets = {
                cacheKey: _this.getEntriesByCategoryCacheKey(glossaryId, categoryId),
                omitExpires: forceCache,
                updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('mod_glossary_get_entries_by_category', params, preSets);
        });
    };
    /**
     * Invalidate cache of entries by category.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} categoryId The category ID. Use constant SHOW_ALL_CATERGORIES for all categories, or
     *                             constant SHOW_NOT_CATEGORISED for uncategorised entries.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateEntriesByCategory = function (glossaryId, categoryId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var key = _this.getEntriesByCategoryCacheKey(glossaryId, categoryId);
            return site.invalidateWsCacheForKey(key);
        });
    };
    /**
     * Get the entries by category cache key.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} categoryId The category ID. Use constant SHOW_ALL_CATERGORIES for all categories, or
     *                             constant SHOW_NOT_CATEGORISED for uncategorised entries.
     * @return {string}            Cache key.
     */
    AddonModGlossaryProvider.prototype.getEntriesByCategoryCacheKey = function (glossaryId, categoryId) {
        return this.ROOT_CACHE_KEY + 'entriesByCategory:' + glossaryId + ':' + categoryId;
    };
    /**
     * Get the entries by date cache key.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} order      The way to order the records.
     * @param  {string} sort       The direction of the order.
     * @return {string}            Cache key.
     */
    AddonModGlossaryProvider.prototype.getEntriesByDateCacheKey = function (glossaryId, order, sort) {
        return this.ROOT_CACHE_KEY + 'entriesByDate:' + glossaryId + ':' + order + ':' + sort;
    };
    /**
     * Get entries by date.
     *
     * @param  {number}  glossaryId Glossary Id.
     * @param  {string}  order      The way to order the records.
     * @param  {string}  sort       The direction of the order.
     * @param  {number}  from       Start returning records from here.
     * @param  {number}  limit      Number of records to return.
     * @param  {boolean} forceCache True to always get the value from cache, false otherwise. Default false.
     * @param  {string}  [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any[]>}     Resolved with the entries.
     */
    AddonModGlossaryProvider.prototype.getEntriesByDate = function (glossaryId, order, sort, from, limit, forceCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                id: glossaryId,
                order: order,
                sort: sort,
                from: from,
                limit: limit
            };
            var preSets = {
                cacheKey: _this.getEntriesByDateCacheKey(glossaryId, order, sort),
                omitExpires: forceCache,
                updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('mod_glossary_get_entries_by_date', params, preSets);
        });
    };
    /**
     * Invalidate cache of entries by date.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} order      The way to order the records.
     * @param  {string} sort       The direction of the order.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateEntriesByDate = function (glossaryId, order, sort, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var key = _this.getEntriesByDateCacheKey(glossaryId, order, sort);
            return site.invalidateWsCacheForKey(key);
        });
    };
    /**
     * Get the entries by letter cache key.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} letter     A letter, or a special keyword.
     * @return {string}            Cache key.
     */
    AddonModGlossaryProvider.prototype.getEntriesByLetterCacheKey = function (glossaryId, letter) {
        return this.ROOT_CACHE_KEY + 'entriesByLetter:' + glossaryId + ':' + letter;
    };
    /**
     * Get entries by letter.
     *
     * @param  {number}  glossaryId Glossary Id.
     * @param  {string}  letter     A letter, or a special keyword.
     * @param  {number}  from       Start returning records from here.
     * @param  {number}  limit      Number of records to return.
     * @param  {boolean} forceCache True to always get the value from cache, false otherwise. Default false.
     * @param  {string}  [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any[]>}     Resolved with the entries.
     */
    AddonModGlossaryProvider.prototype.getEntriesByLetter = function (glossaryId, letter, from, limit, forceCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                id: glossaryId,
                letter: letter,
                from: from,
                limit: limit
            };
            var preSets = {
                cacheKey: _this.getEntriesByLetterCacheKey(glossaryId, letter),
                omitExpires: forceCache,
                updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('mod_glossary_get_entries_by_letter', params, preSets);
        });
    };
    /**
     * Invalidate cache of entries by letter.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} letter     A letter, or a special keyword.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateEntriesByLetter = function (glossaryId, letter, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var key = _this.getEntriesByLetterCacheKey(glossaryId, letter);
            return site.invalidateWsCacheForKey(key);
        });
    };
    /**
     * Get the entries by search cache key.
     *
     * @param  {number}  glossaryId Glossary Id.
     * @param  {string}  query      The search query.
     * @param  {boolean} fullSearch Whether or not full search is required.
     * @param  {string}  order      The way to order the results.
     * @param  {string}  sort       The direction of the order.
     * @return {string}             Cache key.
     */
    AddonModGlossaryProvider.prototype.getEntriesBySearchCacheKey = function (glossaryId, query, fullSearch, order, sort) {
        return this.ROOT_CACHE_KEY + 'entriesBySearch:' + glossaryId + ':' + fullSearch + ':' + order + ':' + sort + ':' + query;
    };
    /**
     * Get entries by search.
     *
     * @param  {number}  glossaryId Glossary Id.
     * @param  {string}  query      The search query.
     * @param  {boolean} fullSearch Whether or not full search is required.
     * @param  {string}  order      The way to order the results.
     * @param  {string}  sort       The direction of the order.
     * @param  {number}  from       Start returning records from here.
     * @param  {number}  limit      Number of records to return.
     * @param  {boolean} forceCache True to always get the value from cache, false otherwise. Default false.
     * @param  {string}  [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any[]>}     Resolved with the entries.
     */
    AddonModGlossaryProvider.prototype.getEntriesBySearch = function (glossaryId, query, fullSearch, order, sort, from, limit, forceCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                id: glossaryId,
                query: query,
                fullsearch: fullSearch,
                order: order,
                sort: sort,
                from: from,
                limit: limit
            };
            var preSets = {
                cacheKey: _this.getEntriesBySearchCacheKey(glossaryId, query, fullSearch, order, sort),
                omitExpires: forceCache,
                updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('mod_glossary_get_entries_by_search', params, preSets);
        });
    };
    /**
     * Invalidate cache of entries by search.
     *
     * @param  {number}  glossaryId Glossary Id.
     * @param  {string}  query      The search query.
     * @param  {boolean} fullSearch Whether or not full search is required.
     * @param  {string}  order      The way to order the results.
     * @param  {string}  sort       The direction of the order.
     * @param  {string}  [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}       Resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateEntriesBySearch = function (glossaryId, query, fullSearch, order, sort, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var key = _this.getEntriesBySearchCacheKey(glossaryId, query, fullSearch, order, sort);
            return site.invalidateWsCacheForKey(key);
        });
    };
    /**
     * Get the glossary categories cache key.
     *
     * @param  {number} glossaryId Glossary Id.
     * @return {string}            The cache key.
     */
    AddonModGlossaryProvider.prototype.getCategoriesCacheKey = function (glossaryId) {
        return this.ROOT_CACHE_KEY + 'categories:' + glossaryId;
    };
    /**
     * Get all the categories related to the glossary.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any[]>}    Promise resolved with the categories if supported or empty array if not.
     */
    AddonModGlossaryProvider.prototype.getAllCategories = function (glossaryId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.getCategories(glossaryId, 0, AddonModGlossaryProvider_1.LIMIT_CATEGORIES, [], site);
        });
    };
    /**
     * Get the categories related to the glossary by sections. It's a recursive function see initial call values.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {number} from       Number of categories already fetched, so fetch will be done from this number.  Initial value 0.
     * @param  {number} limit      Number of categories to fetch. Initial value LIMIT_CATEGORIES.
     * @param  {any[]}  categories Already fetched categories where to append the fetch. Initial value [].
     * @param  {any}    site       Site object.
     * @return {Promise<any[]>}    Promise resolved with the categories.
     */
    AddonModGlossaryProvider.prototype.getCategories = function (glossaryId, from, limit, categories, site) {
        var _this = this;
        var params = {
            id: glossaryId,
            from: from,
            limit: limit
        };
        var preSets = {
            cacheKey: this.getCategoriesCacheKey(glossaryId),
            updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
        };
        return site.read('mod_glossary_get_categories', params, preSets).then(function (response) {
            categories = categories.concat(response.categories);
            var canLoadMore = (from + limit) < response.count;
            if (canLoadMore) {
                from += limit;
                return _this.getCategories(glossaryId, from, limit, categories, site);
            }
            return categories;
        });
    };
    /**
     * Invalidate cache of categories by glossary id.
     *
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when categories data has been invalidated,
     */
    AddonModGlossaryProvider.prototype.invalidateCategories = function (glossaryId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCategoriesCacheKey(glossaryId));
        });
    };
    /**
     * Get an entry by ID cache key.
     *
     * @param  {number} entryId Entry Id.
     * @return {string}         Cache key.
     */
    AddonModGlossaryProvider.prototype.getEntryCacheKey = function (entryId) {
        return this.ROOT_CACHE_KEY + 'getEntry:' + entryId;
    };
    /**
     * Get one entry by ID.
     *
     * @param  {number} entryId  Entry ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved with the entry.
     */
    AddonModGlossaryProvider.prototype.getEntry = function (entryId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                id: entryId
            };
            var preSets = {
                cacheKey: _this.getEntryCacheKey(entryId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_2__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_glossary_get_entry_by_id', params, preSets).then(function (response) {
                if (response && response.entry) {
                    return response;
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Performs the fetch of the entries using the propper function and arguments.
     *
     * @param  {Function} fetchFunction      Function to fetch.
     * @param  {any[]}    fetchArguments     Arguments to call the fetching.
     * @param  {number}   [limitFrom=0]      Number of entries already fetched, so fetch will be done from this number.
     * @param  {number}   [limitNum]         Number of records to return. Defaults to LIMIT_ENTRIES.
     * @param  {boolean}  [forceCache=false] True to always get the value from cache, false otherwise. Default false.
     * @param  {string}   [siteId]           Site ID. If not defined, current site.
     * @return {Promise<any>}                Promise resolved with the response.
     */
    AddonModGlossaryProvider.prototype.fetchEntries = function (fetchFunction, fetchArguments, limitFrom, limitNum, forceCache, siteId) {
        if (limitFrom === void 0) { limitFrom = 0; }
        if (forceCache === void 0) { forceCache = false; }
        limitNum = limitNum || AddonModGlossaryProvider_1.LIMIT_ENTRIES;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var args = fetchArguments.slice();
        args.push(limitFrom);
        args.push(limitNum);
        args.push(forceCache);
        args.push(siteId);
        return fetchFunction.apply(this, args);
    };
    /**
     * Performs the whole fetch of the entries using the propper function and arguments.
     *
     * @param  {Function} fetchFunction      Function to fetch.
     * @param  {any[]}    fetchArguments     Arguments to call the fetching.
     * @param  {boolean}  [forceCache=false] True to always get the value from cache, false otherwise. Default false.
     * @param  {string}   [siteId]           Site ID. If not defined, current site.
     * @return {Promise<any[]>}              Promise resolved with all entrries.
     */
    AddonModGlossaryProvider.prototype.fetchAllEntries = function (fetchFunction, fetchArguments, forceCache, siteId) {
        var _this = this;
        if (forceCache === void 0) { forceCache = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var entries = [];
        var limitNum = AddonModGlossaryProvider_1.LIMIT_ENTRIES;
        var fetchMoreEntries = function () {
            return _this.fetchEntries(fetchFunction, fetchArguments, entries.length, limitNum, forceCache, siteId).then(function (result) {
                Array.prototype.push.apply(entries, result.entries);
                return entries.length < result.count ? fetchMoreEntries() : entries;
            });
        };
        return fetchMoreEntries();
    };
    /**
     * Invalidate cache of entry by ID.
     *
     * @param  {number} entryId  Entry Id.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateEntry = function (entryId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getEntryCacheKey(entryId));
        });
    };
    /**
     * Invalidate cache of all entries in the array.
     *
     * @param  {any[]}  entries  Entry objects to invalidate.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateEntries = function (entries, siteId) {
        var _this = this;
        var keys = [];
        entries.forEach(function (entry) {
            keys.push(_this.getEntryCacheKey(entry.id));
        });
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateMultipleWsCacheForKey(keys);
        });
    };
    /**
     * Invalidate the prefetched content except files.
     * To invalidate files, use AddonModGlossary#invalidateFiles.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID.
     * @return {Promise<any>}    Promise resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateContent = function (moduleId, courseId) {
        var _this = this;
        return this.getGlossary(courseId, moduleId).then(function (glossary) {
            return _this.invalidateGlossaryEntries(glossary).finally(function () {
                return _this.utils.allPromises([
                    _this.invalidateCourseGlossaries(courseId),
                    _this.invalidateCategories(glossary.id)
                ]);
            });
        });
    };
    /**
     * Invalidate the prefetched content for a given glossary, except files.
     * To invalidate files, use AddonModGlossaryProvider#invalidateFiles.
     *
     * @param  {any}     glossary          The glossary object.
     * @param  {boolean} [onlyEntriesList] If true, entries won't be invalidated.
     * @param  {string}  [siteId]          Site ID. If not defined, current site.
     * @return {Promise<any>}              Promise resolved when data is invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateGlossaryEntries = function (glossary, onlyEntriesList, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        if (!onlyEntriesList) {
            promises.push(this.fetchAllEntries(this.getEntriesByLetter, [glossary.id, 'ALL'], true, siteId).then(function (entries) {
                return _this.invalidateEntries(entries, siteId);
            }));
        }
        glossary.browsemodes.forEach(function (mode) {
            switch (mode) {
                case 'letter':
                    promises.push(_this.invalidateEntriesByLetter(glossary.id, 'ALL', siteId));
                    break;
                case 'cat':
                    promises.push(_this.invalidateEntriesByCategory(glossary.id, AddonModGlossaryProvider_1.SHOW_ALL_CATERGORIES, siteId));
                    break;
                case 'date':
                    promises.push(_this.invalidateEntriesByDate(glossary.id, 'CREATION', 'DESC', siteId));
                    promises.push(_this.invalidateEntriesByDate(glossary.id, 'UPDATE', 'DESC', siteId));
                    break;
                case 'author':
                    promises.push(_this.invalidateEntriesByAuthor(glossary.id, 'ALL', 'LASTNAME', 'ASC', siteId));
                    break;
                default:
            }
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidate the prefetched files.
     *
     * @param  {number} moduleId The module ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the files are invalidated.
     */
    AddonModGlossaryProvider.prototype.invalidateFiles = function (moduleId, siteId) {
        return this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModGlossaryProvider_1.COMPONENT, moduleId);
    };
    /**
     * Get one glossary by cmid.
     *
     * @param  {number} courseId Course Id.
     * @param  {number} cmId     Course Module Id.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved with the glossary.
     */
    AddonModGlossaryProvider.prototype.getGlossary = function (courseId, cmId, siteId) {
        return this.getCourseGlossaries(courseId, siteId).then(function (glossaries) {
            var glossary = glossaries.find(function (glossary) { return glossary.coursemodule == cmId; });
            if (glossary) {
                return glossary;
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get one glossary by glossary ID.
     *
     * @param  {number} courseId   Course Id.
     * @param  {number} glossaryId Glossary Id.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved with the glossary.
     */
    AddonModGlossaryProvider.prototype.getGlossaryById = function (courseId, glossaryId, siteId) {
        return this.getCourseGlossaries(courseId, siteId).then(function (glossaries) {
            var glossary = glossaries.find(function (glossary) { return glossary.id == glossaryId; });
            if (glossary) {
                return glossary;
            }
            return Promise.reject(null);
        });
    };
    /**
     * Create a new entry on a glossary
     *
     * @param  {number}  glossaryId        Glossary ID.
     * @param  {string}  concept           Glossary entry concept.
     * @param  {string}  definition        Glossary entry concept definition.
     * @param  {number}  courseId          Course ID of the glossary.
     * @param  {any}     [options]         Array of options for the entry.
     * @param  {any}     [attach]          Attachments ID if sending online, result of CoreFileUploaderProvider#storeFilesToUpload
     *                                     otherwise.
     * @param  {number}  [timeCreated]     The time the entry was created. If not defined, current time.
     * @param  {string}  [siteId]          Site ID. If not defined, current site.
     * @param  {any}     [discardEntry]    The entry provided will be discarded if found.
     * @param  {boolean} [allowOffline]    True if it can be stored in offline, false otherwise.
     * @param  {boolean} [checkDuplicates] Check for duplicates before storing offline. Only used if allowOffline is true.
     * @return {Promise<number | false>}   Promise resolved with entry ID if entry was created in server, false if stored in device.
     */
    AddonModGlossaryProvider.prototype.addEntry = function (glossaryId, concept, definition, courseId, options, attach, timeCreated, siteId, discardEntry, allowOffline, checkDuplicates) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a new entry to be synchronized later.
        var storeOffline = function () {
            var discardTime = discardEntry && discardEntry.timecreated;
            var duplicatesPromise;
            if (checkDuplicates) {
                duplicatesPromise = _this.isConceptUsed(glossaryId, concept, discardTime, siteId);
            }
            else {
                duplicatesPromise = Promise.resolve(false);
            }
            // Check if the entry is duplicated in online or offline mode.
            return duplicatesPromise.then(function (used) {
                if (used) {
                    return Promise.reject(_this.translate.instant('addon.mod_glossary.errconceptalreadyexists'));
                }
                return _this.glossaryOffline.addNewEntry(glossaryId, concept, definition, courseId, attach, options, timeCreated, siteId, undefined, discardEntry).then(function () {
                    return false;
                });
            });
        };
        if (!this.appProvider.isOnline() && allowOffline) {
            // App is offline, store the action.
            return storeOffline();
        }
        // If we are editing an offline entry, discard previous first.
        var discardPromise;
        if (discardEntry) {
            discardPromise = this.glossaryOffline.deleteNewEntry(glossaryId, discardEntry.concept, discardEntry.timecreated, siteId);
        }
        else {
            discardPromise = Promise.resolve();
        }
        return discardPromise.then(function () {
            // Try to add it in online.
            return _this.addEntryOnline(glossaryId, concept, definition, options, attach, siteId).then(function (entryId) {
                return entryId;
            }).catch(function (error) {
                if (allowOffline && !_this.utils.isWebServiceError(error)) {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
                else {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
            });
        });
    };
    /**
     * Create a new entry on a glossary. It does not cache calls. It will fail if offline or cannot connect.
     *
     * @param  {number} glossaryId Glossary ID.
     * @param  {string} concept    Glossary entry concept.
     * @param  {string} definition Glossary entry concept definition.
     * @param  {any}    [options]  Array of options for the entry.
     * @param  {number} [attachId] Attachments ID (if any attachment).
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<number>}   Promise resolved with the entry ID if created, rejected otherwise.
     */
    AddonModGlossaryProvider.prototype.addEntryOnline = function (glossaryId, concept, definition, options, attachId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                glossaryid: glossaryId,
                concept: concept,
                definition: definition,
                definitionformat: 1,
                options: _this.utils.objectToArrayOfObjects(options || {}, 'name', 'value')
            };
            if (attachId) {
                params.options.push({
                    name: 'attachmentsid',
                    value: attachId
                });
            }
            // Workaround for bug MDL-57737.
            if (!site.isVersionGreaterEqualThan('3.2.2')) {
                params.definition = _this.textUtils.cleanTags(params.definition);
            }
            return site.write('mod_glossary_add_entry', params).then(function (response) {
                if (response && response.entryid) {
                    return response.entryid;
                }
                return Promise.reject(_this.utils.createFakeWSError(''));
            });
        });
    };
    /**
     * Check if a entry concept is already used.
     *
     * @param  {number} glossaryId    Glossary ID.
     * @param  {string} concept       Concept to check.
     * @param  {number} [timeCreated] Timecreated to check that is not the timecreated we are editing.
     * @param  {string} [siteId]      Site ID. If not defined, current site.
     * @return {Promise<boolean>}     Promise resolved with true if used, resolved with false if not used or error.
     */
    AddonModGlossaryProvider.prototype.isConceptUsed = function (glossaryId, concept, timeCreated, siteId) {
        var _this = this;
        // Check offline first.
        return this.glossaryOffline.isConceptUsed(glossaryId, concept, timeCreated, siteId).then(function (exists) {
            if (exists) {
                return true;
            }
            // If we get here, there's no offline entry with this name, check online.
            // Get entries from the cache.
            return _this.fetchAllEntries(_this.getEntriesByLetter, [glossaryId, 'ALL'], true, siteId).then(function (entries) {
                // Check if there's any entry with the same concept.
                return entries.some(function (entry) { return entry.concept == concept; });
            });
        }).catch(function () {
            // Error, assume not used.
            return false;
        });
    };
    /**
     * Return whether or not the plugin is enabled for editing in the current site. Plugin is enabled if the glossary WS are
     * available.
     *
     * @return {boolean} Whether the glossary editing is available or not.
     */
    AddonModGlossaryProvider.prototype.isPluginEnabledForEditing = function () {
        return this.sitesProvider.getCurrentSite().wsAvailable('mod_glossary_add_entry');
    };
    /**
     * Report a glossary as being viewed.
     *
     * @param  {number} glossaryId Glossary ID.
     * @param  {string} mode       The mode in which the glossary was viewed.
     * @param {string} [name] Name of the glossary.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when the WS call is successful.
     */
    AddonModGlossaryProvider.prototype.logView = function (glossaryId, mode, name, siteId) {
        var params = {
            id: glossaryId,
            mode: mode
        };
        return this.logHelper.logSingle('mod_glossary_view_glossary', params, AddonModGlossaryProvider_1.COMPONENT, glossaryId, name, 'glossary', { mode: mode }, siteId);
    };
    /**
     * Report a glossary entry as being viewed.
     *
     * @param  {number} entryId Entry ID.
     * @param  {number} glossaryId Glossary ID.
     * @param {string} [name] Name of the glossary.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the WS call is successful.
     */
    AddonModGlossaryProvider.prototype.logEntryView = function (entryId, glossaryId, name, siteId) {
        var params = {
            id: entryId
        };
        return this.logHelper.logSingle('mod_glossary_view_entry', params, AddonModGlossaryProvider_1.COMPONENT, glossaryId, name, 'glossary', { entryid: entryId }, siteId);
    };
    AddonModGlossaryProvider.COMPONENT = 'mmaModGlossary';
    AddonModGlossaryProvider.LIMIT_ENTRIES = 25;
    AddonModGlossaryProvider.LIMIT_CATEGORIES = 10;
    AddonModGlossaryProvider.SHOW_ALL_CATERGORIES = 0;
    AddonModGlossaryProvider.SHOW_NOT_CATEGORISED = -1;
    AddonModGlossaryProvider.ADD_ENTRY_EVENT = 'addon_mod_glossary_add_entry';
    AddonModGlossaryProvider = AddonModGlossaryProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__offline__["a" /* AddonModGlossaryOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_8__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModGlossaryProvider);
    return AddonModGlossaryProvider;
    var AddonModGlossaryProvider_1;
}());

//# sourceMappingURL=glossary.js.map

/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreCompileHtmlComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreCompileHtmlComponent_0;
/* unused harmony export View_CoreCompileHtmlComponent_Host_0 */
/* unused harmony export CoreCompileHtmlComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_loading_loading_ngfactory__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_loading_loading__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core_src_translate_service__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__compile_html__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_compile__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ionic_angular_navigation_nav_controller__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_dom__ = __webpack_require__(4);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 










var styles_CoreCompileHtmlComponent = [];
var RenderType_CoreCompileHtmlComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreCompileHtmlComponent, data: {} });

function View_CoreCompileHtmlComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](402653184, 1, { container: 0 }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](1, 0, null, null, 2, "core-loading", [], null, null, null, __WEBPACK_IMPORTED_MODULE_1__components_loading_loading_ngfactory__["b" /* View_CoreLoadingComponent_0 */], __WEBPACK_IMPORTED_MODULE_1__components_loading_loading_ngfactory__["a" /* RenderType_CoreLoadingComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](2, 638976, null, 0, __WEBPACK_IMPORTED_MODULE_2__components_loading_loading__["a" /* CoreLoadingComponent */], [__WEBPACK_IMPORTED_MODULE_3__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */]], { hideUntil: [0, "hideUntil"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](3, 16777216, [[1, 3], ["dynamicComponent", 1]], 0, 0, null, null, null, null, null, null, null))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.loaded; _ck(_v, 2, 0, currVal_0); }, null); }
function View_CoreCompileHtmlComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-compile-html", [], null, null, null, View_CoreCompileHtmlComponent_0, RenderType_CoreCompileHtmlComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 966656, null, 0, __WEBPACK_IMPORTED_MODULE_6__compile_html__["a" /* CoreCompileHtmlComponent */], [__WEBPACK_IMPORTED_MODULE_7__providers_compile__["a" /* CoreCompileProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], [2, __WEBPACK_IMPORTED_MODULE_8_ionic_angular_navigation_nav_controller__["a" /* NavController */]], __WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* KeyValueDiffers */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }
var CoreCompileHtmlComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-compile-html", __WEBPACK_IMPORTED_MODULE_6__compile_html__["a" /* CoreCompileHtmlComponent */], View_CoreCompileHtmlComponent_Host_0, { text: "text", javascript: "javascript", jsData: "jsData", extraImports: "extraImports", extraProviders: "extraProviders", forceCompile: "forceCompile" }, { created: "created", compiling: "compiling" }, []);

//# sourceMappingURL=compile-html.ngfactory.js.map

/***/ }),
/* 207 */,
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreWSProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common_http__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_file_transfer__ = __webpack_require__(418);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_mimetype__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__classes_interceptor__ = __webpack_require__(419);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * This service allows performing WS calls and download/upload files.
 */
var CoreWSProvider = /** @class */ (function () {
    function CoreWSProvider(http, translate, appProvider, textUtils, logger, fileProvider, fileTransfer, commonHttp, mimeUtils) {
        this.http = http;
        this.translate = translate;
        this.appProvider = appProvider;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.fileTransfer = fileTransfer;
        this.commonHttp = commonHttp;
        this.mimeUtils = mimeUtils;
        this.mimeTypeCache = {}; // A "cache" to store file mimetypes to prevent performing too many HEAD requests.
        this.ongoingCalls = {};
        this.retryCalls = [];
        this.retryTimeout = 0;
        this.logger = logger.getInstance('CoreWSProvider');
    }
    /**
     * Adds the call data to an special queue to be processed when retrying.
     *
     * @param {string} method The WebService method to be called.
     * @param {string} siteUrl Complete site url to perform the call.
     * @param {any} ajaxData Arguments to pass to the method.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise<any>} Deferred promise resolved with the response data in success and rejected with the error message
     *                        if it fails.
     */
    CoreWSProvider.prototype.addToRetryQueue = function (method, siteUrl, ajaxData, preSets) {
        var call = {
            method: method,
            siteUrl: siteUrl,
            ajaxData: ajaxData,
            preSets: preSets,
            deferred: {}
        };
        call.deferred.promise = new Promise(function (resolve, reject) {
            call.deferred.resolve = resolve;
            call.deferred.reject = reject;
        });
        this.retryCalls.push(call);
        return call.deferred.promise;
    };
    /**
     * A wrapper function for a moodle WebService call.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method. It's recommended to call convertValuesToString before passing the data.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise<any>} Promise resolved with the response data in success and rejected if it fails.
     */
    CoreWSProvider.prototype.call = function (method, data, preSets) {
        var siteUrl;
        if (!preSets) {
            return Promise.reject(this.createFakeWSError('core.unexpectederror', true));
        }
        else if (!this.appProvider.isOnline()) {
            return Promise.reject(this.createFakeWSError('core.networkerrormsg', true));
        }
        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        data = Object.assign({}, data); // Create a new object so the changes don't affect the original data.
        data.wsfunction = method;
        data.wstoken = preSets.wsToken;
        siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';
        // There are some ongoing retry calls, wait for timeout.
        if (this.retryCalls.length > 0) {
            this.logger.warn('Calls locked, trying later...');
            return this.addToRetryQueue(method, siteUrl, data, preSets);
        }
        else {
            return this.performPost(method, siteUrl, data, preSets);
        }
    };
    /**
     * Call a Moodle WS using the AJAX API. Please use it if the WS layer is not an option.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreWSAjaxPreSets} preSets Extra settings and information. Only some
     * @return {Promise<any>} Promise resolved with the response data in success and rejected with an object containing:
     *                                 - error: Error message.
     *                                 - errorcode: Error code returned by the site (if any).
     *                                 - available: 0 if unknown, 1 if available, -1 if not available.
     */
    CoreWSProvider.prototype.callAjax = function (method, data, preSets) {
        var _this = this;
        var siteUrl, ajaxData;
        if (typeof preSets.siteUrl == 'undefined') {
            return rejectWithError(this.createFakeWSError('core.unexpectederror', true));
        }
        else if (!this.appProvider.isOnline()) {
            return rejectWithError(this.createFakeWSError('core.networkerrormsg', true));
        }
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        ajaxData = [{
                index: 0,
                methodname: method,
                args: this.convertValuesToString(data)
            }];
        // The info= parameter has no function. It is just to help with debugging.
        // We call it info to match the parameter name use by Moodle's AMD ajax module.
        siteUrl = preSets.siteUrl + '/lib/ajax/service.php?info=' + method;
        var promise = this.http.post(siteUrl, JSON.stringify(ajaxData)).timeout(__WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
        return promise.then(function (data) {
            // Some moodle web services return null.
            // If the responseExpected value is set then so long as no data is returned, we create a blank object.
            if (!data && !preSets.responseExpected) {
                data = [{}];
            }
            // Check if error. Ajax layer should always return an object (if error) or an array (if success).
            if (!data || typeof data != 'object') {
                return rejectWithError(_this.createFakeWSError('core.serverconnection', true));
            }
            else if (data.error) {
                return rejectWithError(data);
            }
            // Get the first response since only one request was done.
            data = data[0];
            if (data.error) {
                return rejectWithError(data.exception);
            }
            return data.data;
        }, function (data) {
            var available = data.status == 404 ? -1 : 0;
            return rejectWithError(_this.createFakeWSError('core.serverconnection', true), available);
        });
        // Convenience function to return an error.
        function rejectWithError(exception, available) {
            if (typeof available == 'undefined') {
                if (exception.errorcode) {
                    available = exception.errorcode == 'invalidrecord' ? -1 : 1;
                }
                else {
                    available = 0;
                }
            }
            exception.available = available;
            return Promise.reject(exception);
        }
    };
    /**
     * Converts an objects values to strings where appropriate.
     * Arrays (associative or otherwise) will be maintained, null values will be removed.
     *
     * @param {object} data The data that needs all the non-object values set to strings.
     * @param {boolean} [stripUnicode] If Unicode long chars need to be stripped.
     * @return {object} The cleaned object or null if some strings becomes empty after stripping Unicode.
     */
    CoreWSProvider.prototype.convertValuesToString = function (data, stripUnicode) {
        var result = Array.isArray(data) ? [] : {};
        for (var key in data) {
            var value = data[key];
            if (value == null) {
                // Skip null or undefined value.
                continue;
            }
            else if (typeof value == 'object') {
                // Object or array.
                value = this.convertValuesToString(value, stripUnicode);
                if (value == null) {
                    return null;
                }
            }
            else if (typeof value == 'string') {
                if (stripUnicode) {
                    var stripped = this.textUtils.stripUnicode(value);
                    if (stripped != value && stripped.trim().length == 0) {
                        return null;
                    }
                    value = stripped;
                }
            }
            else if (typeof value == 'boolean') {
                /* Moodle does not allow "true" or "false" in WS parameters, only in POST parameters.
                   We've been using "true" and "false" for WS settings "filter" and "fileurl",
                   we keep it this way to avoid changing cache keys. */
                if (key == 'moodlewssettingfilter' || key == 'moodlewssettingfileurl') {
                    value = value ? 'true' : 'false';
                }
                else {
                    value = value ? '1' : '0';
                }
            }
            else if (typeof value == 'number') {
                value = String(value);
            }
            else {
                // Unknown type.
                continue;
            }
            if (Array.isArray(result)) {
                result.push(value);
            }
            else {
                result[key] = value;
            }
        }
        return result;
    };
    /**
     * Create a "fake" WS error for local errors.
     *
     * @param {string} message The message to include in the error.
     * @param {boolean} [needsTranslate] If the message needs to be translated.
     * @return {CoreWSError} Fake WS error.
     */
    CoreWSProvider.prototype.createFakeWSError = function (message, needsTranslate) {
        if (needsTranslate) {
            message = this.translate.instant(message);
        }
        return {
            message: message
        };
    };
    /**
     * Downloads a file from Moodle using Cordova File API.
     *
     * @param {string} url Download url.
     * @param {string} path Local path to store the file.
     * @param {boolean} [addExtension] True if extension need to be added to the final path.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved with the downloaded file.
     */
    CoreWSProvider.prototype.downloadFile = function (url, path, addExtension, onProgress) {
        var _this = this;
        this.logger.debug('Downloading file', url, path, addExtension);
        if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        // Use a tmp path to download the file and then move it to final location.
        // This is because if the download fails, the local file is deleted.
        var tmpPath = path + '.tmp';
        // Create the tmp file as an empty file.
        return this.fileProvider.createFile(tmpPath).then(function (fileEntry) {
            var transfer = _this.fileTransfer.create();
            transfer.onProgress(onProgress);
            return transfer.download(url, fileEntry.toURL(), true).then(function () {
                var promise;
                if (addExtension) {
                    var ext_1 = _this.mimeUtils.getFileExtension(path);
                    // Google Drive extensions will be considered invalid since Moodle usually converts them.
                    if (!ext_1 || ext_1 == 'gdoc' || ext_1 == 'gsheet' || ext_1 == 'gslides' || ext_1 == 'gdraw' || ext_1 == 'php') {
                        // Not valid, get the file's mimetype.
                        promise = _this.getRemoteFileMimeType(url).then(function (mime) {
                            if (mime) {
                                var remoteExt = _this.mimeUtils.getExtension(mime, url);
                                // If the file is from Google Drive, ignore mimetype application/json.
                                if (remoteExt && (!ext_1 || mime != 'application/json')) {
                                    if (ext_1) {
                                        // Remove existing extension since we will use another one.
                                        path = _this.mimeUtils.removeExtension(path);
                                    }
                                    path += '.' + remoteExt;
                                    return remoteExt;
                                }
                            }
                            return ext_1;
                        });
                    }
                    else {
                        promise = Promise.resolve(ext_1);
                    }
                }
                else {
                    promise = Promise.resolve('');
                }
                return promise.then(function (extension) {
                    return _this.fileProvider.moveFile(tmpPath, path).then(function (movedEntry) {
                        // Save the extension.
                        movedEntry.extension = extension;
                        movedEntry.path = path;
                        _this.logger.debug("Success downloading file " + url + " to " + path + " with extension " + extension);
                        return movedEntry;
                    });
                });
            });
        }).catch(function (err) {
            _this.logger.error("Error downloading " + url + " to " + path, err);
            return Promise.reject(err);
        });
    };
    /**
     * Get a promise from the cache.
     *
     * @param {string} method Method of the HTTP request.
     * @param {string} url Base URL of the HTTP request.
     * @param {any} [params] Params of the HTTP request.
     */
    CoreWSProvider.prototype.getPromiseHttp = function (method, url, params) {
        var queueItemId = this.getQueueItemId(method, url, params);
        if (typeof this.ongoingCalls[queueItemId] != 'undefined') {
            return this.ongoingCalls[queueItemId];
        }
        return false;
    };
    /**
     * Perform a HEAD request to get the mimetype of a remote file.
     *
     * @param {string} url File URL.
     * @param {boolean} [ignoreCache] True to ignore cache, false otherwise.
     * @return {Promise<string>} Promise resolved with the mimetype or '' if failure.
     */
    CoreWSProvider.prototype.getRemoteFileMimeType = function (url, ignoreCache) {
        var _this = this;
        if (this.mimeTypeCache[url] && !ignoreCache) {
            return Promise.resolve(this.mimeTypeCache[url]);
        }
        return this.performHead(url).then(function (data) {
            var mimeType = data.headers.get('Content-Type');
            if (mimeType) {
                // Remove "parameters" like charset.
                mimeType = mimeType.split(';')[0];
            }
            _this.mimeTypeCache[url] = mimeType;
            return mimeType || '';
        }).catch(function () {
            // Error, resolve with empty mimetype.
            return '';
        });
    };
    /**
     * Perform a HEAD request to get the size of a remote file.
     *
     * @param {string} url File URL.
     * @return {Promise<number>} Promise resolved with the size or -1 if failure.
     */
    CoreWSProvider.prototype.getRemoteFileSize = function (url) {
        return this.performHead(url).then(function (data) {
            var size = parseInt(data.headers.get('Content-Length'), 10);
            if (size) {
                return size;
            }
            return -1;
        }).catch(function () {
            // Error, return -1.
            return -1;
        });
    };
    /**
     * Get the unique queue item id of the cache for a HTTP request.
     *
     * @param {string} method Method of the HTTP request.
     * @param {string} url Base URL of the HTTP request.
     * @param {object} [params] Params of the HTTP request.
     * @return {string} Queue item ID.
     */
    CoreWSProvider.prototype.getQueueItemId = function (method, url, params) {
        if (params) {
            url += '###' + __WEBPACK_IMPORTED_MODULE_12__classes_interceptor__["a" /* CoreInterceptor */].serialize(params);
        }
        return method + '#' + __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__["Md5"].hashAsciiStr(url);
    };
    /**
     * Perform a HEAD request and save the promise while waiting to be resolved.
     *
     * @param {string} url URL to perform the request.
     * @return {Promise<any>} Promise resolved with the response.
     */
    CoreWSProvider.prototype.performHead = function (url) {
        var promise = this.getPromiseHttp('head', url);
        if (!promise) {
            promise = this.commonHttp.head(url).timeout(__WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
            promise = this.setPromiseHttp(promise, 'head', url);
        }
        return promise;
    };
    /**
     * Perform the post call and save the promise while waiting to be resolved.
     *
     * @param {string} method The WebService method to be called.
     * @param {string} siteUrl Complete site url to perform the call.
     * @param {any} ajaxData Arguments to pass to the method.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise<any>} Promise resolved with the response data in success and rejected with CoreWSError if it fails.
     */
    CoreWSProvider.prototype.performPost = function (method, siteUrl, ajaxData, preSets) {
        var _this = this;
        var options = {};
        // This is done because some returned values like 0 are treated as null if responseType is json.
        if (preSets.typeExpected == 'number' || preSets.typeExpected == 'boolean' || preSets.typeExpected == 'string') {
            // Avalaible values are: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
            options['responseType'] = 'text';
        }
        // We add the method name to the URL purely to help with debugging.
        // This duplicates what is in the ajaxData, but that does no harm.
        // POST variables take precedence over GET.
        var requestUrl = siteUrl + '&wsfunction=' + method;
        // Perform the post request.
        var promise = this.http.post(requestUrl, ajaxData, options).timeout(__WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
        return promise.then(function (data) {
            // Some moodle web services return null.
            // If the responseExpected value is set to false, we create a blank object if the response is null.
            if (!data && !preSets.responseExpected) {
                data = {};
            }
            if (!data) {
                return Promise.reject(_this.createFakeWSError('core.serverconnection', true));
            }
            else if (typeof data != preSets.typeExpected) {
                // If responseType is text an string will be returned, parse before returning.
                if (typeof data == 'string') {
                    if (preSets.typeExpected == 'number') {
                        data = Number(data);
                        if (isNaN(data)) {
                            _this.logger.warn("Response expected type \"" + preSets.typeExpected + "\" cannot be parsed to number");
                            return Promise.reject(_this.createFakeWSError('core.errorinvalidresponse', true));
                        }
                    }
                    else if (preSets.typeExpected == 'boolean') {
                        if (data === 'true') {
                            data = true;
                        }
                        else if (data === 'false') {
                            data = false;
                        }
                        else {
                            _this.logger.warn("Response expected type \"" + preSets.typeExpected + "\" is not true or false");
                            return Promise.reject(_this.createFakeWSError('core.errorinvalidresponse', true));
                        }
                    }
                    else {
                        _this.logger.warn('Response of type "' + typeof data + ("\" received, expecting \"" + preSets.typeExpected + "\""));
                        return Promise.reject(_this.createFakeWSError('core.errorinvalidresponse', true));
                    }
                }
                else {
                    _this.logger.warn('Response of type "' + typeof data + ("\" received, expecting \"" + preSets.typeExpected + "\""));
                    return Promise.reject(_this.createFakeWSError('core.errorinvalidresponse', true));
                }
            }
            if (typeof data.exception !== 'undefined') {
                // Special debugging for site plugins, otherwise it's hard to debug errors if the data is cached.
                if (method == 'tool_mobile_get_content') {
                    _this.logger.error('Error calling WS', method, data);
                }
                return Promise.reject(data);
            }
            if (typeof data.debuginfo != 'undefined') {
                return Promise.reject(_this.createFakeWSError('Error. ' + data.message));
            }
            return data;
        }, function (error) {
            // If server has heavy load, retry after some seconds.
            if (error.status == 429) {
                var retryPromise = _this.addToRetryQueue(method, siteUrl, ajaxData, preSets);
                // Only process the queue one time.
                if (_this.retryTimeout == 0) {
                    _this.retryTimeout = parseInt(error.headers.get('Retry-After'), 10) || 5;
                    _this.logger.warn(error.statusText + ". Retrying in " + _this.retryTimeout + " seconds. " +
                        (_this.retryCalls.length + " calls left."));
                    setTimeout(function () {
                        _this.logger.warn("Retrying now with " + _this.retryCalls.length + " calls to process.");
                        // Finish timeout.
                        _this.retryTimeout = 0;
                        _this.processRetryQueue();
                    }, _this.retryTimeout * 1000);
                }
                else {
                    _this.logger.warn('Calls locked, trying later...');
                }
                return retryPromise;
            }
            return Promise.reject(_this.createFakeWSError('core.serverconnection', true));
        });
    };
    /**
     * Retry all requests in the queue.
     * This function uses recursion in order to add a delay between requests to reduce stress.
     */
    CoreWSProvider.prototype.processRetryQueue = function () {
        var _this = this;
        if (this.retryCalls.length > 0 && this.retryTimeout == 0) {
            var call_1 = this.retryCalls.shift();
            // Add a delay between calls.
            setTimeout(function () {
                call_1.deferred.resolve(_this.performPost(call_1.method, call_1.siteUrl, call_1.ajaxData, call_1.preSets));
                _this.processRetryQueue();
            }, 200);
        }
        else {
            this.logger.warn("Retry queue has stopped with " + this.retryCalls.length + " calls and " + this.retryTimeout + " timeout secs.");
        }
    };
    /**
     * Save promise on the cache.
     *
     * @param {Promise<any>} promise Promise to be saved.
     * @param {string} method Method of the HTTP request.
     * @param {string} url Base URL of the HTTP request.
     * @param {any} [params] Params of the HTTP request.
     * @return {Promise<any>} The promise saved.
     */
    CoreWSProvider.prototype.setPromiseHttp = function (promise, method, url, params) {
        var _this = this;
        var queueItemId = this.getQueueItemId(method, url, params);
        var timeout;
        this.ongoingCalls[queueItemId] = promise;
        // HTTP not finished, but we should delete the promise after timeout.
        timeout = setTimeout(function () {
            delete _this.ongoingCalls[queueItemId];
        }, __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].WS_TIMEOUT);
        // HTTP finished, delete from ongoing.
        return promise.finally(function () {
            delete _this.ongoingCalls[queueItemId];
            clearTimeout(timeout);
        });
    };
    /**
     * A wrapper function for a synchronous Moodle WebService call.
     * Warning: This function should only be used if synchronous is a must. It's recommended to use call.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise} Promise resolved with the response data in success and rejected with the error message if it fails.
     * @return {any} Request response. If the request fails, returns an object with 'error'=true and 'message' properties.
     */
    CoreWSProvider.prototype.syncCall = function (method, data, preSets) {
        var errorResponse = {
            error: true,
            message: ''
        };
        var siteUrl, xhr;
        if (!preSets) {
            errorResponse.message = this.translate.instant('core.unexpectederror');
            return errorResponse;
        }
        else if (!this.appProvider.isOnline()) {
            errorResponse.message = this.translate.instant('core.networkerrormsg');
            return errorResponse;
        }
        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        data = this.convertValuesToString(data || {}, preSets.cleanUnicode);
        if (data == null) {
            // Empty cleaned text found.
            errorResponse.message = this.translate.instant('core.unicodenotsupportedcleanerror');
            return errorResponse;
        }
        data.wsfunction = method;
        data.wstoken = preSets.wsToken;
        siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';
        // Serialize data.
        data = __WEBPACK_IMPORTED_MODULE_12__classes_interceptor__["a" /* CoreInterceptor */].serialize(data);
        // Perform sync request using XMLHttpRequest.
        xhr = new window.XMLHttpRequest();
        xhr.open('post', siteUrl, false);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');
        xhr.send(data);
        // Get response.
        data = ('response' in xhr) ? xhr.response : xhr.responseText;
        // Check status.
        var status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);
        if (status < 200 || status >= 300) {
            // Request failed.
            errorResponse.message = data;
            return errorResponse;
        }
        // Treat response.
        data = this.textUtils.parseJSON(data);
        // Some moodle web services return null.
        // If the responseExpected value is set then so long as no data is returned, we create a blank object.
        if ((!data || !data.data) && !preSets.responseExpected) {
            data = {};
        }
        if (!data) {
            errorResponse.message = this.translate.instant('core.serverconnection');
        }
        else if (typeof data != preSets.typeExpected) {
            this.logger.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
            errorResponse.message = this.translate.instant('core.errorinvalidresponse');
        }
        if (typeof data.exception != 'undefined' || typeof data.debuginfo != 'undefined') {
            errorResponse.message = data.message;
        }
        if (errorResponse.message !== '') {
            return errorResponse;
        }
        return data;
    };
    /*
     * Uploads a file.
     *
     * @param {string} filePath File path.
     * @param {CoreWSFileUploadOptions} options File upload options.
     * @param {CoreWSPreSets} preSets Must contain siteUrl and wsToken.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when uploaded.
     */
    CoreWSProvider.prototype.uploadFile = function (filePath, options, preSets, onProgress) {
        var _this = this;
        this.logger.debug("Trying to upload file: " + filePath);
        if (!filePath || !options || !preSets) {
            return Promise.reject(null);
        }
        if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        var uploadUrl = preSets.siteUrl + '/webservice/upload.php', transfer = this.fileTransfer.create();
        transfer.onProgress(onProgress);
        options.httpMethod = 'POST';
        options.params = {
            token: preSets.wsToken,
            filearea: options.fileArea || 'draft',
            itemid: options.itemId || 0
        };
        options.chunkedMode = false;
        options.headers = {
            Connection: 'close'
        };
        return transfer.upload(filePath, uploadUrl, options, true).then(function (success) {
            var data = _this.textUtils.parseJSON(success.response, null, _this.logger.error.bind(_this.logger, 'Error parsing response from upload'));
            if (data === null) {
                return Promise.reject(_this.translate.instant('core.errorinvalidresponse'));
            }
            if (!data) {
                return Promise.reject(_this.translate.instant('core.serverconnection'));
            }
            else if (typeof data != 'object') {
                _this.logger.warn('Upload file: Response of type "' + typeof data + '" received, expecting "object"');
                return Promise.reject(_this.translate.instant('core.errorinvalidresponse'));
            }
            if (typeof data.exception !== 'undefined') {
                return Promise.reject(data.message);
            }
            else if (data && typeof data.error !== 'undefined') {
                return Promise.reject(data.error);
            }
            else if (data[0] && typeof data[0].error !== 'undefined') {
                return Promise.reject(data[0].error);
            }
            // We uploaded only 1 file, so we only return the first file returned.
            _this.logger.debug('Successfully uploaded file', filePath);
            return data[0];
        }).catch(function (error) {
            _this.logger.error('Error while uploading file', filePath, error);
            return Promise.reject(_this.translate.instant('core.errorinvalidresponse'));
        });
    };
    CoreWSProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__angular_common_http__["c" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_9__utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_6__file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_file_transfer__["a" /* FileTransfer */], __WEBPACK_IMPORTED_MODULE_1__angular_http__["d" /* Http */],
            __WEBPACK_IMPORTED_MODULE_8__utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], CoreWSProvider);
    return CoreWSProvider;
}());

//# sourceMappingURL=ws.js.map

/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBlogProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_pushnotifications_providers_pushnotifications__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to handle blog entries.
 */
var AddonBlogProvider = /** @class */ (function () {
    function AddonBlogProvider(logger, sitesProvider, utils, pushNotificationsProvider) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.ROOT_CACHE_KEY = 'addonBlog:';
        this.logger = logger.getInstance('AddonBlogProvider');
    }
    AddonBlogProvider_1 = AddonBlogProvider;
    /**
     * Returns whether or not the blog plugin is enabled for a certain site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if enabled, resolved with false or rejected otherwise.
     */
    AddonBlogProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('core_blog_get_entries') &&
                site.canUseAdvancedFeature('enableblogs');
        });
    };
    /**
     * Get the cache key for the blog entries.
     *
     * @param  {any}     [filter]     Filter to apply on search.
     * @return {string}          Cache key.
     */
    AddonBlogProvider.prototype.getEntriesCacheKey = function (filter) {
        if (filter === void 0) { filter = {}; }
        return this.ROOT_CACHE_KEY + this.utils.sortAndStringify(filter);
    };
    /**
     * Get blog entries.
     *
     * @param  {any}     [filter]     Filter to apply on search.
     * @param  {any}     [page=0]     Page of the blog entries to fetch.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise to be resolved when the entries are retrieved.
     */
    AddonBlogProvider.prototype.getEntries = function (filter, page, siteId) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        if (page === void 0) { page = 0; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                filters: _this.utils.objectToArrayOfObjects(filter, 'name', 'value'),
                page: page,
                perpage: AddonBlogProvider_1.ENTRIES_PER_PAGE
            };
            var preSets = {
                cacheKey: _this.getEntriesCacheKey(filter),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_5__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('core_blog_get_entries', data, preSets);
        });
    };
    /**
     * Invalidate blog entries WS call.
     *
     * @param  {any}     [filter]     Filter to apply on search
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when data is invalidated.
     */
    AddonBlogProvider.prototype.invalidateEntries = function (filter, siteId) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getEntriesCacheKey(filter));
        });
    };
    /**
     * Trigger the blog_entries_viewed event.
     *
     * @param  {any}     [filter]     Filter to apply on search.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise to be resolved when done.
     */
    AddonBlogProvider.prototype.logView = function (filter, siteId) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        this.pushNotificationsProvider.logViewListEvent('blog', 'core_blog_view_entries', filter, siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                filters: _this.utils.objectToArrayOfObjects(filter, 'name', 'value')
            };
            return site.write('core_blog_view_entries', data);
        });
    };
    AddonBlogProvider.ENTRIES_PER_PAGE = 10;
    AddonBlogProvider.COMPONENT = 'blog';
    AddonBlogProvider = AddonBlogProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__core_pushnotifications_providers_pushnotifications__["a" /* CorePushNotificationsProvider */]])
    ], AddonBlogProvider);
    return AddonBlogProvider;
    var AddonBlogProvider_1;
}());

//# sourceMappingURL=blog.js.map

/***/ }),
/* 210 */,
/* 211 */,
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreUserAvatarComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreUserAvatarComponent_0;
/* unused harmony export View_CoreUserAvatarComponent_Host_0 */
/* unused harmony export CoreUserAvatarComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__directives_external_content__ = __webpack_require__(236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular_platform_platform__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core_src_translate_pipe__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ngx_translate_core_src_translate_service__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__user_avatar__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_ionic_angular_navigation_nav_controller__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_events__ = __webpack_require__(11);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 
















var styles_CoreUserAvatarComponent = [];
var RenderType_CoreUserAvatarComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreUserAvatarComponent, data: {} });

function View_CoreUserAvatarComponent_1(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 3, "img", [["core-external-content", ""], ["onError", "this.src='assets/img/user-avatar.png'"], ["role", "presentation"]], [[8, "alt", 0]], [[null, "click"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("click" === en)) {
        var pd_0 = (_co.gotoProfile($event) !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 4734976, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_external_content__["a" /* CoreExternalContentDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_platform_platform__["a" /* Platform */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */]], { siteId: [0, "siteId"], src: [1, "src"] }, null), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_48" /* ɵpod */](2, { $a: 0 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_47" /* ɵpid */](131072, __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core_src_translate_pipe__["a" /* TranslatePipe */], [__WEBPACK_IMPORTED_MODULE_11__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */]])], function (_ck, _v) { var _co = _v.component; var currVal_1 = (_co.siteId || null); var currVal_2 = _co.avatarUrl; _ck(_v, 1, 0, currVal_1, currVal_2); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_56" /* ɵunv */](_v, 0, 0, __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 3).transform("core.pictureof", _ck(_v, 2, 0, _co.fullname))); _ck(_v, 0, 0, currVal_0); }); }
function View_CoreUserAvatarComponent_2(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 2, "img", [["role", "presentation"], ["src", "assets/img/user-avatar.png"]], [[8, "alt", 0]], [[null, "click"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("click" === en)) {
        var pd_0 = (_co.gotoProfile($event) !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_48" /* ɵpod */](1, { $a: 0 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_47" /* ɵpid */](131072, __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core_src_translate_pipe__["a" /* TranslatePipe */], [__WEBPACK_IMPORTED_MODULE_11__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */]])], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_56" /* ɵunv */](_v, 0, 0, __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 2).transform("core.pictureof", _ck(_v, 1, 0, _co.fullname))); _ck(_v, 0, 0, currVal_0); }); }
function View_CoreUserAvatarComponent_3(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 0, "span", [["class", "contact-status online"]], null, null, null, null, null))], null, null); }
function View_CoreUserAvatarComponent_4(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 0, "img", [["alt", ""], ["class", "core-avatar-extra-icon"], ["role", "presentation"]], [[8, "src", 4]], null, null, null, null))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.extraIcon; _ck(_v, 0, 0, currVal_0); }); }
function View_CoreUserAvatarComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreUserAvatarComponent_1)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_12__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreUserAvatarComponent_2)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](4, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_12__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreUserAvatarComponent_3)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](7, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_12__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_26" /* ɵand */](16777216, null, null, 1, null, View_CoreUserAvatarComponent_4)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](10, 16384, null, 0, __WEBPACK_IMPORTED_MODULE_12__angular_common__["k" /* NgIf */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]], { ngIf: [0, "ngIf"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_43" /* ɵncd */](null, 0)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.avatarUrl; _ck(_v, 1, 0, currVal_0); var currVal_1 = !_co.avatarUrl; _ck(_v, 4, 0, currVal_1); var currVal_2 = (_co.checkOnline && _co.isOnline()); _ck(_v, 7, 0, currVal_2); var currVal_3 = _co.extraIcon; _ck(_v, 10, 0, currVal_3); }, null); }
function View_CoreUserAvatarComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "ion-avatar", [["core-user-avatar", ""]], null, null, null, View_CoreUserAvatarComponent_0, RenderType_CoreUserAvatarComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 770048, null, 0, __WEBPACK_IMPORTED_MODULE_13__user_avatar__["a" /* CoreUserAvatarComponent */], [__WEBPACK_IMPORTED_MODULE_14_ionic_angular_navigation_nav_controller__["a" /* NavController */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_15__providers_events__["a" /* CoreEventsProvider */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }
var CoreUserAvatarComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("ion-avatar[core-user-avatar]", __WEBPACK_IMPORTED_MODULE_13__user_avatar__["a" /* CoreUserAvatarComponent */], View_CoreUserAvatarComponent_Host_0, { user: "user", profileUrl: "profileUrl", linkProfile: "linkProfile", fullname: "fullname", userId: "userId", courseId: "courseId", checkOnline: "checkOnline", extraIcon: "extraIcon" }, {}, ["*"]);

//# sourceMappingURL=user-avatar.ngfactory.js.map

/***/ }),
/* 213 */,
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreRatingProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__offline__ = __webpack_require__(191);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service to handle ratings.
 */
var CoreRatingProvider = /** @class */ (function () {
    function CoreRatingProvider(appProvider, eventsProvider, sitesProvider, userProvider, utils, ratingOffline) {
        this.appProvider = appProvider;
        this.eventsProvider = eventsProvider;
        this.sitesProvider = sitesProvider;
        this.userProvider = userProvider;
        this.utils = utils;
        this.ratingOffline = ratingOffline;
        this.ROOT_CACHE_KEY = 'CoreRating:';
    }
    CoreRatingProvider_1 = CoreRatingProvider;
    /**
     * Returns whether the web serivce to add ratings is available.
     *
     * @return {boolean} If WS is abalaible.
     * @since 3.2
     */
    CoreRatingProvider.prototype.isAddRatingWSAvailable = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_rating_add_rating');
    };
    /**
     * Add a rating to an item.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating area. Example: "post".
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} instanceId Context instance id.
     * @param {number} itemId Item id. Example: forum post id.
     * @param {number} itemSetId Item set id. Example: forum discussion id.
     * @param {number} courseId Course id.
     * @param {number} scaleId Scale id.
     * @param {number} rating Rating value. Use CoreRatingProvider.UNSET_RATING to delete rating.
     * @param {number} ratedUserId Rated user id.
     * @param {number} aggregateMethod Aggregate method.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreRatingItemRating|null>} Promise resolved with the aggregated rating or null if stored offline.
     * @since 3.2
     */
    CoreRatingProvider.prototype.addRating = function (component, ratingArea, contextLevel, instanceId, itemId, itemSetId, courseId, scaleId, rating, ratedUserId, aggregateMethod, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a rating to be synchronized later.
        var storeOffline = function () {
            return _this.ratingOffline.addRating(component, ratingArea, contextLevel, instanceId, itemId, itemSetId, courseId, scaleId, rating, ratedUserId, aggregateMethod, siteId).then(function () {
                _this.eventsProvider.trigger(CoreRatingProvider_1.RATING_SAVED_EVENT, {
                    component: component,
                    ratingArea: ratingArea,
                    contextLevel: contextLevel,
                    instanceId: instanceId,
                    itemSetId: itemSetId,
                    itemId: itemId
                }, siteId);
                return null;
            });
        };
        if (!this.appProvider.isOnline()) {
            // App is offline, store the action.
            return storeOffline();
        }
        return this.ratingOffline.deleteRating(component, ratingArea, contextLevel, instanceId, itemId, siteId).then(function () {
            return _this.addRatingOnline(component, ratingArea, contextLevel, instanceId, itemId, scaleId, rating, ratedUserId, aggregateMethod, siteId).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error or offline not supported, reject.
                    return Promise.reject(error);
                }
                // Couldn't connect to server, store offline.
                return storeOffline();
            });
        });
    };
    /**
     * Add a rating to an item. It will fail if offline or cannot connect.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating area. Example: "post".
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} instanceId Context instance id.
     * @param {number} itemId Item id. Example: forum post id.
     * @param {number} scaleId Scale id.
     * @param {number} rating Rating value. Use CoreRatingProvider.UNSET_RATING to delete rating.
     * @param {number} ratedUserId Rated user id.
     * @param {number} aggregateMethod Aggregate method.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreRatingItemRating>} Promise resolved with the aggregated rating.
     * @since 3.2
     */
    CoreRatingProvider.prototype.addRatingOnline = function (component, ratingArea, contextLevel, instanceId, itemId, scaleId, rating, ratedUserId, aggregateMethod, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                contextlevel: contextLevel,
                instanceid: instanceId,
                component: component,
                ratingarea: ratingArea,
                itemid: itemId,
                scaleid: scaleId,
                rating: rating,
                rateduserid: ratedUserId,
                aggregation: aggregateMethod
            };
            return site.write('core_rating_add_rating', params).then(function (response) {
                return _this.invalidateRatingItems(contextLevel, instanceId, component, ratingArea, itemId, scaleId).then(function () {
                    _this.eventsProvider.trigger(CoreRatingProvider_1.AGGREGATE_CHANGED_EVENT, {
                        contextLevel: contextLevel,
                        instanceId: instanceId,
                        component: component,
                        ratingArea: ratingArea,
                        itemId: itemId,
                        aggregate: response.aggregate,
                        count: response.count
                    });
                    return response;
                });
            });
        });
    };
    /**
     * Get item ratings.
     *
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} instanceId Context instance id.
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating area. Example: "post".
     * @param {number} itemId Item id. Example: forum post id.
     * @param {number} scaleId Scale id.
     * @param {string} [sort="timemodified"] Sort field.
     * @param {number} [courseId] Course id. Used for fetching user profiles.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<CoreRatingItemRating[]>} Promise resolved with the list of ratings.
     */
    CoreRatingProvider.prototype.getItemRatings = function (contextLevel, instanceId, component, ratingArea, itemId, scaleId, sort, courseId, siteId, ignoreCache) {
        var _this = this;
        if (sort === void 0) { sort = 'timemodified'; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                contextlevel: contextLevel,
                instanceid: instanceId,
                component: component,
                ratingarea: ratingArea,
                itemid: itemId,
                scaleid: scaleId,
                sort: sort
            };
            var preSets = {
                cacheKey: _this.getItemRatingsCacheKey(contextLevel, instanceId, component, ratingArea, itemId, scaleId, sort),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_1__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('core_rating_get_item_ratings', params, preSets).then(function (response) {
                if (!response || !response.ratings) {
                    return Promise.reject(null);
                }
                // We need to fetch profiles because the returned profile pictures are incorrect.
                var promises = response.ratings.map(function (rating) {
                    return _this.userProvider.getProfile(rating.userid, courseId, true, site.id).then(function (user) {
                        rating.userpictureurl = user.profileimageurl;
                    }).catch(function () {
                        // Ignore error.
                        rating.userpictureurl = null;
                    });
                });
                return Promise.all(promises).then(function () {
                    return response.ratings;
                });
            });
        });
    };
    /**
     * Invalidate item ratings.
     *
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} instanceId Context instance id.
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating area. Example: "post".
     * @param {number} itemId Item id. Example: forum post id.
     * @param {number} scaleId Scale id.
     * @param {string} [sort="timemodified"] Sort field.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreRatingProvider.prototype.invalidateRatingItems = function (contextLevel, instanceId, component, ratingArea, itemId, scaleId, sort, siteId) {
        var _this = this;
        if (sort === void 0) { sort = 'timemodified'; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var key = _this.getItemRatingsCacheKey(contextLevel, instanceId, component, ratingArea, itemId, scaleId, sort);
            return site.invalidateWsCacheForKey(key);
        });
    };
    /**
     * Check if rating is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreRatingProvider.prototype.isRatingDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('NoDelegate_CoreRating');
    };
    /**
     * Check if rating is disabled in a certain site.
     *
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreRatingProvider.prototype.isRatingDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isRatingDisabledInSite(site);
        });
    };
    /**
     * Convenience function to merge two or more rating infos of the same instance.
     *
     * @param {CoreRatingInfo[]} ratingInfos Array of rating infos.
     * @return {CoreRatingInfo} Merged rating info or null.
     */
    CoreRatingProvider.prototype.mergeRatingInfos = function (ratingInfos) {
        var result = null;
        var scales = {};
        var ratings = {};
        ratingInfos.forEach(function (ratingInfo) {
            if (!ratingInfo) {
                // Skip null rating infos.
                return;
            }
            if (!result) {
                result = Object.assign({}, ratingInfo);
            }
            (ratingInfo.scales || []).forEach(function (scale) {
                scales[scale.id] = scale;
            });
            (ratingInfo.ratings || []).forEach(function (rating) {
                ratings[rating.itemid] = rating;
            });
        });
        if (result) {
            result.scales = this.utils.objectToArray(scales);
            result.ratings = this.utils.objectToArray(ratings);
        }
        return result;
    };
    /**
     * Prefetch individual ratings.
     *
     * This function should be called from the prefetch handler of activities with ratings.
     *
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} instanceId Instance id.
     * @param {string} [siteId] Site id. If not defined, current site.
     * @param {number} [courseId] Course id. Used for prefetching user profiles.
     * @param {CoreRatingInfo} [ratingInfo] Rating info returned by web services.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreRatingProvider.prototype.prefetchRatings = function (contextLevel, instanceId, scaleId, courseId, ratingInfo, siteId) {
        var _this = this;
        if (!ratingInfo || !ratingInfo.ratings) {
            return Promise.resolve();
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = ratingInfo.ratings.map(function (item) {
                return _this.getItemRatings(contextLevel, instanceId, ratingInfo.component, ratingInfo.ratingarea, item.itemid, scaleId, undefined, courseId, site.id, true).then(function (ratings) {
                    var userIds = ratings.map(function (rating) { return rating.userid; });
                    return _this.userProvider.prefetchProfiles(userIds, courseId, site.id);
                });
            });
            return Promise.all(promises);
        });
    };
    /**
     * Get cache key for rating items WS calls.
     *
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating area. Example: "post".
     * @param {number} itemId Item id. Example: forum post id.
     * @param {number} scaleId Scale id.
     * @param {string} sort Sort field.
     * @return {string} Cache key.
     */
    CoreRatingProvider.prototype.getItemRatingsCacheKey = function (contextLevel, instanceId, component, ratingArea, itemId, scaleId, sort) {
        return "" + this.ROOT_CACHE_KEY + contextLevel + ":" + instanceId + ":" + component + ":" + ratingArea + ":" + itemId + ":" + scaleId + ":" + sort;
    };
    CoreRatingProvider.AGGREGATE_NONE = 0; // No ratings.
    CoreRatingProvider.AGGREGATE_AVERAGE = 1;
    CoreRatingProvider.AGGREGATE_COUNT = 2;
    CoreRatingProvider.AGGREGATE_MAXIMUM = 3;
    CoreRatingProvider.AGGREGATE_MINIMUM = 4;
    CoreRatingProvider.AGGREGATE_SUM = 5;
    CoreRatingProvider.UNSET_RATING = -999;
    CoreRatingProvider.AGGREGATE_CHANGED_EVENT = 'core_rating_aggregate_changed';
    CoreRatingProvider.RATING_SAVED_EVENT = 'core_rating_rating_saved';
    CoreRatingProvider = CoreRatingProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__core_user_providers_user__["a" /* CoreUserProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__offline__["a" /* CoreRatingOfflineProvider */]])
    ], CoreRatingProvider);
    return CoreRatingProvider;
    var CoreRatingProvider_1;
}());

//# sourceMappingURL=rating.js.map

/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__addon_mod_forum_providers_forum__ = __webpack_require__(156);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service that provides some features regarding site home.
 */
var CoreSiteHomeProvider = /** @class */ (function () {
    function CoreSiteHomeProvider(logger, sitesProvider, courseProvider, forumProvider) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.forumProvider = forumProvider;
        this.logger = logger.getInstance('CoreSiteHomeProvider');
    }
    /**
     * Get the news forum for the Site Home.
     *
     * @param {number} siteHomeId Site Home ID.
     * @return {Promise<any>} Promise resolved with the forum if found, rejected otherwise.
     */
    CoreSiteHomeProvider.prototype.getNewsForum = function (siteHomeId) {
        return this.forumProvider.getCourseForums(siteHomeId).then(function (forums) {
            for (var i = 0; i < forums.length; i++) {
                if (forums[i].type == 'news') {
                    return forums[i];
                }
            }
            return Promise.reject(null);
        });
    };
    /**
     * Invalidate the WS call to get the news forum for the Site Home.
     *
     * @param {number} siteHomeId Site Home ID.
     * @return {Promise<any>} Promise resolved when invalidated.
     */
    CoreSiteHomeProvider.prototype.invalidateNewsForum = function (siteHomeId) {
        return this.forumProvider.invalidateForumData(siteHomeId);
    };
    /**
     * Returns whether or not the frontpage is available for the current site.
     *
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether it's available.
     */
    CoreSiteHomeProvider.prototype.isAvailable = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // First check if it's disabled.
            if (_this.isDisabledInSite(site)) {
                return false;
            }
            // Use a WS call to check if there's content in the site home.
            var siteHomeId = site.getSiteHomeId(), preSets = { emergencyCache: false };
            _this.logger.debug('Using WS call to check if site home is available.');
            return _this.courseProvider.getSections(siteHomeId, false, true, preSets, site.id).then(function (sections) {
                if (!sections || !sections.length) {
                    return Promise.reject(null);
                }
                for (var i = 0; i < sections.length; i++) {
                    var section = sections[i];
                    if (section.summary || (section.modules && section.modules.length)) {
                        // It has content, return true.
                        return true;
                    }
                }
                return Promise.reject(null);
            }).catch(function () {
                var config = site.getStoredConfig();
                if (config && config.frontpageloggedin) {
                    var items = config.frontpageloggedin.split(',');
                    if (items.length > 0) {
                        // It's enabled.
                        return true;
                    }
                }
                return false;
            });
        }).catch(function () {
            return false;
        });
    };
    /**
     * Check if Site Home is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreSiteHomeProvider.prototype.isDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isDisabledInSite(site);
        });
    };
    /**
     * Check if Site Home is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreSiteHomeProvider.prototype.isDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('CoreMainMenuDelegate_CoreSiteHome');
    };
    CoreSiteHomeProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_4__addon_mod_forum_providers_forum__["a" /* AddonModForumProvider */]])
    ], CoreSiteHomeProvider);
    return CoreSiteHomeProvider;
}());

//# sourceMappingURL=sitehome.js.map

/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModForumOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__forum__ = __webpack_require__(156);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to handle offline forum.
 */
var AddonModForumOfflineProvider = /** @class */ (function () {
    function AddonModForumOfflineProvider(fileProvider, sitesProvider, textUtils) {
        this.fileProvider = fileProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.siteSchema = {
            name: 'AddonModForumOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModForumOfflineProvider_1.DISCUSSIONS_TABLE,
                    columns: [
                        {
                            name: 'forumid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'name',
                            type: 'TEXT',
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'subject',
                            type: 'TEXT',
                        },
                        {
                            name: 'message',
                            type: 'TEXT',
                        },
                        {
                            name: 'options',
                            type: 'TEXT',
                        },
                        {
                            name: 'groupid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER',
                        }
                    ],
                    primaryKeys: ['forumid', 'userid', 'timecreated']
                },
                {
                    name: AddonModForumOfflineProvider_1.REPLIES_TABLE,
                    columns: [
                        {
                            name: 'postid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'discussionid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'forumid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'name',
                            type: 'TEXT',
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'subject',
                            type: 'TEXT',
                        },
                        {
                            name: 'message',
                            type: 'TEXT',
                        },
                        {
                            name: 'options',
                            type: 'TEXT',
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER',
                        }
                    ],
                    primaryKeys: ['postid', 'userid']
                }
            ]
        };
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModForumOfflineProvider_1 = AddonModForumOfflineProvider;
    /**
     * Delete a forum offline discussion.
     *
     * @param  {number} forumId     Forum ID.
     * @param  {number} timeCreated The time the discussion was created.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @param  {number} [userId]    User the discussion belongs to. If not defined, current user in site.
     * @return {Promise<any>}       Promise resolved if stored, rejected if failure.
     */
    AddonModForumOfflineProvider.prototype.deleteNewDiscussion = function (forumId, timeCreated, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                forumid: forumId,
                userid: userId || site.getUserId(),
                timecreated: timeCreated,
            };
            return site.getDb().deleteRecords(AddonModForumOfflineProvider_1.DISCUSSIONS_TABLE, conditions);
        });
    };
    /**
     * Get a forum offline discussion.
     *
     * @param  {number} forumId     Forum ID.
     * @param  {number} timeCreated The time the discussion was created.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @param  {number} [userId]    User the discussion belongs to. If not defined, current user in site.
     * @return {Promise<any>}       Promise resolved if stored, rejected if failure.
     */
    AddonModForumOfflineProvider.prototype.getNewDiscussion = function (forumId, timeCreated, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                forumid: forumId,
                userid: userId || site.getUserId(),
                timecreated: timeCreated,
            };
            return site.getDb().getRecord(AddonModForumOfflineProvider_1.DISCUSSIONS_TABLE, conditions).then(function (record) {
                record.options = _this.textUtils.parseJSON(record.options);
                return record;
            });
        });
    };
    /**
     * Get all offline new discussions.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Promise resolved with discussions.
     */
    AddonModForumOfflineProvider.prototype.getAllNewDiscussions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModForumOfflineProvider_1.DISCUSSIONS_TABLE).then(_this.parseRecordOptions.bind(_this));
        });
    };
    /**
     * Check if there are offline new discussions to send.
     *
     * @param  {number} forumId   Forum ID.
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @param  {number} [userId]  User the discussions belong to. If not defined, current user in site.
     * @return {Promise<boolean>} Promise resolved with boolean: true if has offline answers, false otherwise.
     */
    AddonModForumOfflineProvider.prototype.hasNewDiscussions = function (forumId, siteId, userId) {
        return this.getNewDiscussions(forumId, siteId, userId).then(function (discussions) {
            return !!discussions.length;
        }).catch(function () {
            // No offline data found, return false.
            return false;
        });
    };
    /**
     * Get new discussions to be synced.
     *
     * @param  {number} forumId  Forum ID to get.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the discussions belong to. If not defined, current user in site.
     * @return {Promise<any[]>}  Promise resolved with the object to be synced.
     */
    AddonModForumOfflineProvider.prototype.getNewDiscussions = function (forumId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                forumid: forumId,
                userid: userId || site.getUserId(),
            };
            return site.getDb().getRecords(AddonModForumOfflineProvider_1.DISCUSSIONS_TABLE, conditions)
                .then(_this.parseRecordOptions.bind(_this));
        });
    };
    /**
     * Offline version for adding a new discussion to a forum.
     *
     * @param  {number} forumId       Forum ID.
     * @param  {string} name          Forum name.
     * @param  {number} courseId      Course ID the forum belongs to.
     * @param  {string} subject       New discussion's subject.
     * @param  {string} message       New discussion's message.
     * @param  {any}    [options]     Options (subscribe, pin, ...).
     * @param  {string} [groupId]     Group this discussion belongs to.
     * @param  {number} [timeCreated] The time the discussion was created. If not defined, current time.
     * @param  {string} [siteId]      Site ID. If not defined, current site.
     * @param  {number} [userId]      User the discussion belong to. If not defined, current user in site.
     * @return {Promise<any>}         Promise resolved when new discussion is successfully saved.
     */
    AddonModForumOfflineProvider.prototype.addNewDiscussion = function (forumId, name, courseId, subject, message, options, groupId, timeCreated, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                forumid: forumId,
                name: name,
                courseid: courseId,
                subject: subject,
                message: message,
                options: JSON.stringify(options || {}),
                groupid: groupId || __WEBPACK_IMPORTED_MODULE_4__forum__["a" /* AddonModForumProvider */].ALL_PARTICIPANTS,
                userid: userId || site.getUserId(),
                timecreated: timeCreated || new Date().getTime()
            };
            return site.getDb().insertRecord(AddonModForumOfflineProvider_1.DISCUSSIONS_TABLE, data);
        });
    };
    /**
     * Delete forum offline replies.
     *
     * @param  {number} postId   ID of the post being replied.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the reply belongs to. If not defined, current user in site.
     * @return {Promise<any>}    Promise resolved if stored, rejected if failure.
     */
    AddonModForumOfflineProvider.prototype.deleteReply = function (postId, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                postid: postId,
                userid: userId || site.getUserId(),
            };
            return site.getDb().deleteRecords(AddonModForumOfflineProvider_1.REPLIES_TABLE, conditions);
        });
    };
    /**
     * Get all offline replies.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Promise resolved with replies.
     */
    AddonModForumOfflineProvider.prototype.getAllReplies = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModForumOfflineProvider_1.REPLIES_TABLE).then(_this.parseRecordOptions.bind(_this));
        });
    };
    /**
     * Check if there is an offline reply for a forum to be synced.
     *
     * @param  {number} forumId   ID of the forum being replied.
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @param  {number} [userId]  User the replies belong to. If not defined, current user in site.
     * @return {Promise<boolean>} Promise resolved with boolean: true if has offline answers, false otherwise.
     */
    AddonModForumOfflineProvider.prototype.hasForumReplies = function (forumId, siteId, userId) {
        return this.getForumReplies(forumId, siteId, userId).then(function (replies) {
            return !!replies.length;
        }).catch(function () {
            // No offline data found, return false.
            return false;
        });
    };
    /**
     * Get the replies of a forum to be synced.
     *
     * @param  {number} forumId  ID of the forum being replied.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the replies belong to. If not defined, current user in site.
     * @return {Promise<any[]>}  Promise resolved with replies.
     */
    AddonModForumOfflineProvider.prototype.getForumReplies = function (forumId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                forumid: forumId,
                userid: userId || site.getUserId(),
            };
            return site.getDb().getRecords(AddonModForumOfflineProvider_1.REPLIES_TABLE, conditions)
                .then(_this.parseRecordOptions.bind(_this));
        });
    };
    /**
     * Check if there is an offline reply to be synced.
     *
     * @param  {number} discussionId ID of the discussion the user is replying to.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @param  {number} [userId]     User the replies belong to. If not defined, current user in site.
     * @return {Promise<boolean>}    Promise resolved with boolean: true if has offline answers, false otherwise.
     */
    AddonModForumOfflineProvider.prototype.hasDiscussionReplies = function (discussionId, siteId, userId) {
        return this.getDiscussionReplies(discussionId, siteId, userId).then(function (replies) {
            return !!replies.length;
        }).catch(function () {
            // No offline data found, return false.
            return false;
        });
    };
    /**
     * Get the replies of a discussion to be synced.
     *
     * @param  {number} discussionId ID of the discussion the user is replying to.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @param  {number} [userId]     User the replies belong to. If not defined, current user in site.
     * @return {Promise<any[]>}      Promise resolved with discussions.
     */
    AddonModForumOfflineProvider.prototype.getDiscussionReplies = function (discussionId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                discussionid: discussionId,
                userid: userId || site.getUserId(),
            };
            return site.getDb().getRecords(AddonModForumOfflineProvider_1.REPLIES_TABLE, conditions)
                .then(_this.parseRecordOptions.bind(_this));
        });
    };
    /**
     * Offline version for replying to a certain post.
     *
     * @param  {number}  postId       ID of the post being replied.
     * @param  {number}  discussionId ID of the discussion the user is replying to.
     * @param  {number}  forumId      ID of the forum the user is replying to.
     * @param  {string}  name         Forum name.
     * @param  {number}  courseId     Course ID the forum belongs to.
     * @param  {string}  subject      New post's subject.
     * @param  {string}  message      New post's message.
     * @param  {any}     [options]    Options (subscribe, attachments, ...).
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @param  {number}  [userId]     User the post belong to. If not defined, current user in site.
     * @return {Promise<any>}         Promise resolved when the post is created.
     */
    AddonModForumOfflineProvider.prototype.replyPost = function (postId, discussionId, forumId, name, courseId, subject, message, options, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                postid: postId,
                discussionid: discussionId,
                forumid: forumId,
                name: name,
                courseid: courseId,
                subject: subject,
                message: message,
                options: JSON.stringify(options || {}),
                userid: userId || site.getUserId(),
                timecreated: new Date().getTime()
            };
            return site.getDb().insertRecord(AddonModForumOfflineProvider_1.REPLIES_TABLE, data);
        });
    };
    /**
     * Get the path to the folder where to store files for offline attachments in a forum.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the path.
     */
    AddonModForumOfflineProvider.prototype.getForumFolder = function (forumId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var siteFolderPath = _this.fileProvider.getSiteFolder(site.getId());
            return _this.textUtils.concatenatePaths(siteFolderPath, 'offlineforum/' + forumId);
        });
    };
    /**
     * Get the path to the folder where to store files for a new offline discussion.
     *
     * @param  {number} forumId     Forum ID.
     * @param  {number} timeCreated The time the discussion was created.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<string>}    Promise resolved with the path.
     */
    AddonModForumOfflineProvider.prototype.getNewDiscussionFolder = function (forumId, timeCreated, siteId) {
        var _this = this;
        return this.getForumFolder(forumId, siteId).then(function (folderPath) {
            return _this.textUtils.concatenatePaths(folderPath, 'newdisc_' + timeCreated);
        });
    };
    /**
     * Get the path to the folder where to store files for a new offline reply.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {number} postId   ID of the post being replied.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the replies belong to. If not defined, current user in site.
     * @return {Promise<string>} Promise resolved with the path.
     */
    AddonModForumOfflineProvider.prototype.getReplyFolder = function (forumId, postId, siteId, userId) {
        var _this = this;
        return this.getForumFolder(forumId, siteId).then(function (folderPath) {
            return _this.sitesProvider.getSite(siteId).then(function (site) {
                userId = userId || site.getUserId();
                return _this.textUtils.concatenatePaths(folderPath, 'reply_' + postId + '_' + userId);
            });
        });
    };
    /**
     * Parse "options" column of fetched records.
     *
     * @param  {any[]} records List of records.
     * @return {any[]}         List of records with options parsed.
     */
    AddonModForumOfflineProvider.prototype.parseRecordOptions = function (records) {
        var _this = this;
        records.forEach(function (record) {
            record.options = _this.textUtils.parseJSON(record.options);
        });
        return records;
    };
    // Variables for database.
    AddonModForumOfflineProvider.DISCUSSIONS_TABLE = 'addon_mod_forum_discussions';
    AddonModForumOfflineProvider.REPLIES_TABLE = 'addon_mod_forum_replies';
    AddonModForumOfflineProvider = AddonModForumOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], AddonModForumOfflineProvider);
    return AddonModForumOfflineProvider;
    var AddonModForumOfflineProvider_1;
}());

//# sourceMappingURL=offline.js.map

/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModScormProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_ws__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__scorm_offline__ = __webpack_require__(251);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_constants__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_course_providers_log_helper__ = __webpack_require__(59);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};















/**
 * Service that provides some features for SCORM.
 */
var AddonModScormProvider = /** @class */ (function () {
    function AddonModScormProvider(logger, translate, sitesProvider, wsProvider, textUtils, utils, filepoolProvider, scormOfflineProvider, timeUtils, syncProvider, eventsProvider, logHelper) {
        this.translate = translate;
        this.sitesProvider = sitesProvider;
        this.wsProvider = wsProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.filepoolProvider = filepoolProvider;
        this.scormOfflineProvider = scormOfflineProvider;
        this.timeUtils = timeUtils;
        this.syncProvider = syncProvider;
        this.eventsProvider = eventsProvider;
        this.logHelper = logHelper;
        // Protected constants.
        this.VALID_STATUSES = ['notattempted', 'passed', 'completed', 'failed', 'incomplete', 'browsed', 'suspend'];
        this.STATUSES = {
            'passed': 'passed',
            'completed': 'completed',
            'failed': 'failed',
            'incomplete': 'incomplete',
            'browsed': 'browsed',
            'not attempted': 'notattempted',
            'p': 'passed',
            'c': 'completed',
            'f': 'failed',
            'i': 'incomplete',
            'b': 'browsed',
            'n': 'notattempted'
        };
        this.ROOT_CACHE_KEY = 'mmaModScorm:';
        this.logger = logger.getInstance('AddonModScormProvider');
    }
    AddonModScormProvider_1 = AddonModScormProvider;
    /**
     * Calculates the SCORM grade based on the grading method and the list of attempts scores.
     * We only treat online attempts to calculate a SCORM grade.
     *
     * @param {any} scorm SCORM.
     * @param {any} onlineAttempts Object with the online attempts. Each attempt must have a property called "grade".
     * @return {number} Grade. -1 if no grade.
     */
    AddonModScormProvider.prototype.calculateScormGrade = function (scorm, onlineAttempts) {
        if (!onlineAttempts || !Object.keys(onlineAttempts).length) {
            return -1;
        }
        switch (scorm.whatgrade) {
            case AddonModScormProvider_1.FIRSTATTEMPT:
                return onlineAttempts[1] ? onlineAttempts[1].grade : -1;
            case AddonModScormProvider_1.LASTATTEMPT:
                // Search the last attempt number.
                var max_1 = 0;
                Object.keys(onlineAttempts).forEach(function (attemptNumber) {
                    max_1 = Math.max(Number(attemptNumber), max_1);
                });
                if (max_1 > 0) {
                    return onlineAttempts[max_1].grade;
                }
                return -1;
            case AddonModScormProvider_1.HIGHESTATTEMPT:
                // Search the highest grade.
                var grade = 0;
                for (var attemptNumber in onlineAttempts) {
                    grade = Math.max(onlineAttempts[attemptNumber].grade, grade);
                }
                return grade;
            case AddonModScormProvider_1.AVERAGEATTEMPT:
                // Calculate the average.
                var sumGrades = 0, total = 0;
                for (var attemptNumber in onlineAttempts) {
                    sumGrades += onlineAttempts[attemptNumber].grade;
                    total++;
                }
                return Math.round(sumGrades / total);
            default:
                return -1;
        }
    };
    /**
     * Calculates the size of a SCORM.
     *
     * @param {any} scorm SCORM.
     * @return {Promise<number>} Promise resolved with the SCORM size.
     */
    AddonModScormProvider.prototype.calculateScormSize = function (scorm) {
        if (scorm.packagesize) {
            return Promise.resolve(scorm.packagesize);
        }
        return this.wsProvider.getRemoteFileSize(this.getPackageUrl(scorm));
    };
    /**
     * Count the attempts left for the given scorm.
     *
     * @param {any} scorm SCORM.
     * @param {number} attemptsCount Number of attempts performed.
     * @return {number} Number of attempts left.
     */
    AddonModScormProvider.prototype.countAttemptsLeft = function (scorm, attemptsCount) {
        if (scorm.maxattempt == 0) {
            return Number.MAX_VALUE; // Unlimited attempts.
        }
        attemptsCount = Number(attemptsCount); // Make sure it's a number.
        if (isNaN(attemptsCount)) {
            return -1;
        }
        return scorm.maxattempt - attemptsCount;
    };
    /**
     * Returns the mode and attempt number to use based on mode selected and SCORM data.
     * This function is based on Moodle's scorm_check_mode.
     *
     * @param {any} scorm SCORM.
     * @param {string} mode Selected mode.
     * @param {number} attempt Current attempt.
     * @param {boolean} [newAttempt] Whether it should start a new attempt.
     * @param {boolean} [incomplete] Whether current attempt is incomplete.
     * @return {{mode: string, attempt: number, newAttempt: boolean}} Mode, attempt number and whether to start a new attempt.
     */
    AddonModScormProvider.prototype.determineAttemptAndMode = function (scorm, mode, attempt, newAttempt, incomplete) {
        if (mode == AddonModScormProvider_1.MODEBROWSE) {
            if (scorm.hidebrowse) {
                // Prevent Browse mode if hidebrowse is set.
                mode = AddonModScormProvider_1.MODENORMAL;
            }
            else {
                // We don't need to check attempts as browse mode is set.
                if (attempt == 0) {
                    attempt = 1;
                    newAttempt = true;
                }
                return {
                    mode: mode,
                    attempt: attempt,
                    newAttempt: newAttempt
                };
            }
        }
        if (scorm.forcenewattempt == AddonModScormProvider_1.SCORM_FORCEATTEMPT_ALWAYS) {
            // This SCORM is configured to force a new attempt on every re-entry.
            return {
                mode: AddonModScormProvider_1.MODENORMAL,
                attempt: attempt + 1,
                newAttempt: true
            };
        }
        // Validate user request to start a new attempt.
        if (attempt == 0) {
            newAttempt = true;
        }
        else if (incomplete) {
            // The option to start a new attempt should never have been presented. Force false.
            newAttempt = false;
        }
        else if (scorm.forcenewattempt) {
            // A new attempt should be forced for already completed attempts.
            newAttempt = true;
        }
        if (newAttempt && (scorm.maxattempt == 0 || attempt < scorm.maxattempt)) {
            // Create a new attempt. Force mode normal.
            attempt++;
            mode = AddonModScormProvider_1.MODENORMAL;
        }
        else {
            if (incomplete) {
                // We can't review an incomplete attempt.
                mode = AddonModScormProvider_1.MODENORMAL;
            }
            else {
                // We aren't starting a new attempt and the current one is complete, force review mode.
                mode = AddonModScormProvider_1.MODEREVIEW;
            }
        }
        return {
            mode: mode,
            attempt: attempt,
            newAttempt: newAttempt
        };
    };
    /**
     * Check if TOC should be displayed in the player.
     *
     * @param {any} scorm SCORM.
     * @return {boolean} Whether it should display TOC.
     */
    AddonModScormProvider.prototype.displayTocInPlayer = function (scorm) {
        return scorm.hidetoc !== 3;
    };
    /**
     * This is a little language parser for AICC_SCRIPT.
     * Evaluates the expression and returns a boolean answer.
     * See 2.3.2.5.1. Sequencing/Navigation Today - from the SCORM 1.2 spec (CAM).
     *
     * @param {string} prerequisites The AICC_SCRIPT prerequisites expression.
     * @param {any} trackData The tracked user data of each SCO.
     * @return {boolean} Whether the prerequisites are fulfilled.
     */
    AddonModScormProvider.prototype.evalPrerequisites = function (prerequisites, trackData) {
        var _this = this;
        var stack = []; // List of prerequisites.
        // Expand the amp entities.
        prerequisites = prerequisites.replace(/&amp;/gi, '&');
        // Find all my parsable tokens.
        prerequisites = prerequisites.replace(/(&|\||\(|\)|\~)/gi, '\t$1\t');
        // Expand operators.
        prerequisites = prerequisites.replace(/&/gi, '&&');
        prerequisites = prerequisites.replace(/\|/gi, '||');
        // Now - grab all the tokens.
        var elements = prerequisites.trim().split('\t');
        // Process each token to build an expression to be evaluated.
        elements.forEach(function (element) {
            element = element.trim();
            if (!element) {
                return;
            }
            if (!element.match(/^(&&|\|\||\(|\))$/gi)) {
                // Create each individual expression.
                // Search for ~ = <> X*{} .
                var re = /^(\d+)\*\{(.+)\}$/, // Sets like 3*{S34, S36, S37, S39}.
                reOther = /^(.+)(\=|\<\>)(.+)$/; // Other symbols.
                var matches = void 0;
                if (re.test(element)) {
                    matches = element.match(re);
                    var repeat = matches[1], set = matches[2].split(',');
                    var count_1 = 0;
                    set.forEach(function (setElement) {
                        setElement = setElement.trim();
                        if (typeof trackData[setElement] != 'undefined' &&
                            (trackData[setElement].status == 'completed' || trackData[setElement].status == 'passed')) {
                            count_1++;
                        }
                    });
                    if (count_1 >= repeat) {
                        element = 'true';
                    }
                    else {
                        element = 'false';
                    }
                }
                else if (element == '~') {
                    // Not maps ~.
                    element = '!';
                }
                else if (reOther.test(element)) {
                    // Other symbols = | <> .
                    matches = element.match(reOther);
                    element = matches[1].trim();
                    if (typeof trackData[element] != 'undefined') {
                        var value = matches[3].trim().replace(/(\'|\")/gi), oper = void 0;
                        if (typeof _this.STATUSES[value] != 'undefined') {
                            value = _this.STATUSES[value];
                        }
                        if (matches[2] == '<>') {
                            oper = '!=';
                        }
                        else {
                            oper = '==';
                        }
                        element = '(\'' + trackData[element].status + '\' ' + oper + ' \'' + value + '\')';
                    }
                    else {
                        element = 'false';
                    }
                }
                else {
                    // Everything else must be an element defined like S45 ...
                    if (typeof trackData[element] != 'undefined' &&
                        (trackData[element].status == 'completed' || trackData[element].status == 'passed')) {
                        element = 'true';
                    }
                    else {
                        element = 'false';
                    }
                }
            }
            // Add the element to the list of prerequisites.
            stack.push(' ' + element + ' ');
        });
        // tslint:disable: no-eval
        return eval(stack.join('') + ';');
    };
    /**
     * Formats a grade to be displayed.
     *
     * @param {any} scorm SCORM.
     * @param {number} grade Grade.
     * @return {string} Grade to display.
     */
    AddonModScormProvider.prototype.formatGrade = function (scorm, grade) {
        if (typeof grade == 'undefined' || grade == -1) {
            return this.translate.instant('core.none');
        }
        if (scorm.grademethod !== AddonModScormProvider_1.GRADESCOES && scorm.maxgrade > 0) {
            grade = (grade / scorm.maxgrade) * 100;
            return this.translate.instant('core.percentagenumber', { $a: this.textUtils.roundToDecimals(grade, 2) });
        }
        return String(grade);
    };
    /**
     * Formats a tree-like TOC into an array.
     *
     * @param {any[]} toc SCORM's TOC (tree format).
     * @param {number} [level=0] The level of the TOC we're right now. 0 by default.
     * @return {any[]} SCORM's TOC (array format).
     */
    AddonModScormProvider.prototype.formatTocToArray = function (toc, level) {
        var _this = this;
        if (level === void 0) { level = 0; }
        if (!toc || !toc.length) {
            return [];
        }
        var formatted = [];
        toc.forEach(function (node) {
            node.level = level;
            formatted.push(node);
            formatted = formatted.concat(_this.formatTocToArray(node.children, level + 1));
        });
        return formatted;
    };
    /**
     * Get access information for a given SCORM.
     *
     * @param  {number}  scormId      SCORM ID.
     * @param  {boolean} [forceCache] True to always get the value from cache. false otherwise.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>} Object with access information.
     * @since 3.7
     */
    AddonModScormProvider.prototype.getAccessInformation = function (scormId, forceCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.wsAvailable('mod_scorm_get_scorm_access_information')) {
                // Access information not available for 3.6 or older sites.
                return Promise.resolve({});
            }
            var params = {
                scormid: scormId
            };
            var preSets = {
                cacheKey: _this.getAccessInformationCacheKey(scormId),
                omitExpires: forceCache
            };
            return site.read('mod_scorm_get_scorm_access_information', params, preSets);
        });
    };
    /**
     * Get cache key for access information WS calls.
     *
     * @param {number} scormId SCORM ID.
     * @return {string} Cache key.
     */
    AddonModScormProvider.prototype.getAccessInformationCacheKey = function (scormId) {
        return this.ROOT_CACHE_KEY + 'accessInfo:' + scormId;
    };
    /**
     * Get the number of attempts done by a user in the given SCORM.
     *
     * @param {number} scormId SCORM ID.
     * @param {boolean} [ignoreMissing] Whether it should ignore attempts without grade/completion. Only for online attempts.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data for online attempts.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<AddonModScormAttemptCountResult>} Promise resolved when done.
     */
    AddonModScormProvider.prototype.getAttemptCount = function (scormId, ignoreMissing, ignoreCache, siteId, userId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var result = {
                lastAttempt: {
                    number: 0,
                    offline: false
                }
            }, promises = [];
            promises.push(_this.getAttemptCountOnline(scormId, ignoreMissing, ignoreCache, siteId, userId).then(function (count) {
                // Calculate numbers of online attempts.
                result.online = [];
                for (var i = 1; i <= count; i++) {
                    result.online.push(i);
                }
                // Calculate last attempt.
                if (count > result.lastAttempt.number) {
                    result.lastAttempt.number = count;
                    result.lastAttempt.offline = false;
                }
            }));
            promises.push(_this.scormOfflineProvider.getAttempts(scormId, siteId, userId).then(function (attempts) {
                // Get only attempt numbers.
                result.offline = attempts.map(function (entry) {
                    // Calculate last attempt. We use >= to prioritize offline events if an attempt is both online and offline.
                    if (entry.attempt >= result.lastAttempt.number) {
                        result.lastAttempt.number = entry.attempt;
                        result.lastAttempt.offline = true;
                    }
                    return entry.attempt;
                });
            }));
            return Promise.all(promises).then(function () {
                var total = result.online.length;
                result.offline.forEach(function (attempt) {
                    // Check if this attempt also exists in online, it might have been copied to local.
                    if (result.online.indexOf(attempt) == -1) {
                        total++;
                    }
                });
                result.total = total;
                return result;
            });
        });
    };
    /**
     * Get cache key for SCORM attempt count WS calls.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} [userId] User ID. If not defined, current user.
     * @return {string} Cache key.
     */
    AddonModScormProvider.prototype.getAttemptCountCacheKey = function (scormId, userId) {
        return this.ROOT_CACHE_KEY + 'attemptcount:' + scormId + ':' + userId;
    };
    /**
     * Get the number of attempts done by a user in the given SCORM in online.
     *
     * @param {number} scormId SCORM ID.
     * @param {boolean} [ignoreMissing] Whether it should ignore attempts that haven't reported a grade/completion.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<number>} Promise resolved when the attempt count is retrieved.
     */
    AddonModScormProvider.prototype.getAttemptCountOnline = function (scormId, ignoreMissing, ignoreCache, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                scormid: scormId,
                userid: userId,
                ignoremissingcompletion: ignoreMissing ? 1 : 0
            }, preSets = {
                cacheKey: _this.getAttemptCountCacheKey(scormId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_12__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_scorm_get_scorm_attempt_count', params, preSets).then(function (response) {
                if (response && typeof response.attemptscount != 'undefined') {
                    return response.attemptscount;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get the grade for a certain SCORM and attempt.
     * Based on Moodle's scorm_grade_user_attempt.
     *
     * @param {any} scorm SCORM.
     * @param {number} attempt Attempt number.
     * @param {boolean} [offline] Whether the attempt is offline.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the grade. If the attempt hasn't reported grade/completion, it will be -1.
     */
    AddonModScormProvider.prototype.getAttemptGrade = function (scorm, attempt, offline, siteId) {
        var attemptScore = {
            scos: 0,
            values: 0,
            max: 0,
            sum: 0
        };
        // Get the user data and use it to calculate the grade.
        return this.getScormUserData(scorm.id, attempt, undefined, offline, false, siteId).then(function (data) {
            for (var scoId in data) {
                var sco = data[scoId], userData = sco.userdata;
                if (userData.status == 'completed' || userData.status == 'passed') {
                    attemptScore.scos++;
                }
                if (userData.score_raw || (typeof scorm.scormtype != 'undefined' &&
                    scorm.scormtype == 'sco' && typeof userData.score_raw != 'undefined')) {
                    var scoreRaw = parseFloat(userData.score_raw);
                    attemptScore.values++;
                    attemptScore.sum += scoreRaw;
                    attemptScore.max = Math.max(scoreRaw, attemptScore.max);
                }
            }
            var score = 0;
            switch (scorm.grademethod) {
                case AddonModScormProvider_1.GRADEHIGHEST:
                    score = attemptScore.max;
                    break;
                case AddonModScormProvider_1.GRADEAVERAGE:
                    if (attemptScore.values > 0) {
                        score = attemptScore.sum / attemptScore.values;
                    }
                    else {
                        score = 0;
                    }
                    break;
                case AddonModScormProvider_1.GRADESUM:
                    score = attemptScore.sum;
                    break;
                case AddonModScormProvider_1.GRADESCOES:
                    score = attemptScore.scos;
                    break;
                default:
                    score = attemptScore.max; // Remote Learner GRADEHIGHEST is default.
            }
            return score;
        });
    };
    /**
     * Get the list of a organizations defined in a SCORM package.
     *
     * @param {number} scormId SCORM ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of organizations.
     */
    AddonModScormProvider.prototype.getOrganizations = function (scormId, siteId) {
        return this.getScos(scormId, undefined, false, siteId).then(function (scos) {
            var organizations = [];
            scos.forEach(function (sco) {
                // Is an organization entry?
                if (sco.organization == '' && sco.parent == '/' && sco.scormtype == '') {
                    organizations.push({
                        identifier: sco.identifier,
                        title: sco.title,
                        sortorder: sco.sortorder
                    });
                }
            });
            return organizations;
        });
    };
    /**
     * Get the organization Toc any
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt The attempt number (to populate SCO track data).
     * @param {string} [organization] Organization identifier.
     * @param {boolean} [offline] Whether the attempt is offline.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the toc object.
     */
    AddonModScormProvider.prototype.getOrganizationToc = function (scormId, attempt, organization, offline, siteId) {
        return this.getScosWithData(scormId, attempt, organization, offline, false, siteId).then(function (scos) {
            var map = {}, rootScos = [];
            scos.forEach(function (sco, index) {
                sco.children = [];
                map[sco.identifier] = index;
                if (sco.parent !== '/') {
                    if (sco.parent == organization) {
                        // It's a root SCO, add it to the root array.
                        rootScos.push(sco);
                    }
                    else {
                        // Add this sco to the parent.
                        scos[map[sco.parent]].children.push(sco);
                    }
                }
            });
            return rootScos;
        });
    };
    /**
     * Get the package URL of a given SCORM.
     *
     * @param {any} scorm SCORM.
     * @return {string} Package URL.
     */
    AddonModScormProvider.prototype.getPackageUrl = function (scorm) {
        if (scorm.packageurl) {
            return scorm.packageurl;
        }
        if (scorm.reference) {
            return scorm.reference;
        }
        return '';
    };
    /**
     * Get the user data for a certain SCORM and attempt.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {any[]} [scos] SCOs returned by getScos. Recommended if offline=true.
     * @param {boolean} [offline] Whether the attempt is offline.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data for online attempts.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the user data is retrieved.
     */
    AddonModScormProvider.prototype.getScormUserData = function (scormId, attempt, scos, offline, ignoreCache, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (offline) {
            // Get SCOs if not provided.
            var promise = scos ? Promise.resolve(scos) : this.getScos(scormId, undefined, undefined, siteId);
            return promise.then(function (scos) {
                return _this.scormOfflineProvider.getScormUserData(scormId, attempt, scos, siteId);
            });
        }
        else {
            return this.getScormUserDataOnline(scormId, attempt, ignoreCache, siteId);
        }
    };
    /**
     * Get cache key for SCORM user data WS calls.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @return {string} Cache key.
     */
    AddonModScormProvider.prototype.getScormUserDataCacheKey = function (scormId, attempt) {
        return this.getScormUserDataCommonCacheKey(scormId) + ':' + attempt;
    };
    /**
     * Get common cache key for SCORM user data WS calls.
     *
     * @param {number} scormId SCORM ID.
     * @return {string} Cache key.
     */
    AddonModScormProvider.prototype.getScormUserDataCommonCacheKey = function (scormId) {
        return this.ROOT_CACHE_KEY + 'userdata:' + scormId;
    };
    /**
     * Get the user data for a certain SCORM and attempt in online.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the user data is retrieved.
     */
    AddonModScormProvider.prototype.getScormUserDataOnline = function (scormId, attempt, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                scormid: scormId,
                attempt: attempt
            }, preSets = {
                cacheKey: _this.getScormUserDataCacheKey(scormId, attempt)
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_scorm_get_scorm_user_data', params, preSets).then(function (response) {
                if (response && response.data) {
                    // Format the response.
                    var data_1 = {};
                    response.data.forEach(function (sco) {
                        sco.defaultdata = _this.utils.objectToKeyValueMap(sco.defaultdata, 'element', 'value');
                        sco.userdata = _this.utils.objectToKeyValueMap(sco.userdata, 'element', 'value');
                        data_1[sco.scoid] = sco;
                    });
                    return data_1;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get SCORM scos WS calls.
     *
     * @param {number} scormId SCORM ID.
     * @return {string} Cache key.
     */
    AddonModScormProvider.prototype.getScosCacheKey = function (scormId) {
        return this.ROOT_CACHE_KEY + 'scos:' + scormId;
    };
    /**
     * Retrieves the list of SCO objects for a given SCORM and organization.
     *
     * @param {number} scormId SCORM ID.
     * @param {string} [organization] Organization.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail if offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]} Promise resolved with a list of SCO.
     */
    AddonModScormProvider.prototype.getScos = function (scormId, organization, ignoreCache, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Don't send the organization to the WS, we'll filter them locally.
            var params = {
                scormid: scormId
            }, preSets = {
                cacheKey: _this.getScosCacheKey(scormId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_12__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_scorm_get_scorm_scoes', params, preSets).then(function (response) {
                if (response && response.scoes) {
                    if (organization) {
                        // Filter SCOs by organization.
                        return response.scoes.filter(function (sco) {
                            return sco.organization == organization;
                        });
                    }
                    else {
                        return response.scoes;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Retrieves the list of SCO objects for a given SCORM and organization, including data about
     * a certain attempt (status, isvisible, ...).
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {string} [organization] Organization ID.
     * @param {boolean} [offline] Whether the attempt is offline.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data for online attempts.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with a list of SCO objects.
     */
    AddonModScormProvider.prototype.getScosWithData = function (scormId, attempt, organization, offline, ignoreCache, siteId) {
        var _this = this;
        // Get organization SCOs.
        return this.getScos(scormId, organization, ignoreCache, siteId).then(function (scos) {
            // Get the track data for all the SCOs in the organization for the given attempt.
            // We'll use this data to set SCO data like isvisible, status and so.
            return _this.getScormUserData(scormId, attempt, scos, offline, ignoreCache, siteId).then(function (data) {
                var trackDataBySCO = {};
                // First populate trackDataBySCO to index by SCO identifier.
                // We want the full list first because it's needed by evalPrerequisites.
                scos.forEach(function (sco) {
                    trackDataBySCO[sco.identifier] = data[sco.id].userdata;
                });
                scos.forEach(function (sco) {
                    // Add specific SCO information (related to tracked data).
                    var scoData = data[sco.id].userdata;
                    if (!scoData) {
                        return;
                    }
                    // Check isvisible attribute.
                    sco.isvisible = typeof scoData.isvisible == 'undefined' || (scoData.isvisible && scoData.isvisible !== 'false');
                    // Check pre-requisites status.
                    sco.prereq = typeof scoData.prerequisites == 'undefined' ||
                        _this.evalPrerequisites(scoData.prerequisites, trackDataBySCO);
                    // Add status.
                    sco.status = (typeof scoData.status == 'undefined' || scoData.status === '') ?
                        'notattempted' : scoData.status;
                    // Exit var.
                    sco.exitvar = typeof scoData.exitvar == 'undefined' ? 'cmi.core.exit' : scoData.exitvar;
                    sco.exitvalue = scoData[sco.exitvar];
                });
                return scos;
            });
        });
    };
    /**
     * Given a SCORM and a SCO, returns the full launch URL for the SCO.
     *
     * @param {any} scorm SCORM.
     * @param {any} sco SCO.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the URL.
     */
    AddonModScormProvider.prototype.getScoSrc = function (scorm, sco, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Build the launch URL. Moodle web checks SCORM version, we don't need to, it's always SCORM 1.2.
        var launchUrl = sco.launch, parameters;
        if (sco.extradata && sco.extradata.length) {
            for (var i = 0; i < sco.extradata.length; i++) {
                var entry = sco.extradata[i];
                if (entry.element == 'parameters') {
                    parameters = entry.value;
                    break;
                }
            }
        }
        if (parameters) {
            var connector = launchUrl.indexOf('?') > -1 ? '&' : '?';
            if (parameters.charAt(0) == '?') {
                parameters = parameters.substr(1);
            }
            launchUrl += connector + parameters;
        }
        if (this.isExternalLink(launchUrl)) {
            // It's an online URL.
            return Promise.resolve(launchUrl);
        }
        return this.filepoolProvider.getPackageDirUrlByUrl(siteId, scorm.moduleurl).then(function (dirPath) {
            return _this.textUtils.concatenatePaths(dirPath, launchUrl);
        });
    };
    /**
     * Get the path to the folder where a SCORM is downloaded.
     *
     * @param {string} moduleUrl Module URL (returned by get_course_contents).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the folder path.
     */
    AddonModScormProvider.prototype.getScormFolder = function (moduleUrl, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.getPackageDirPathByUrl(siteId, moduleUrl);
    };
    /**
     * Gets a list of files to downlaod for a SCORM, using a format similar to module.contents from get_course_contents.
     * It will only return one file: the ZIP package.
     *
     * @param {any} scorm SCORM.
     * @return {any[]} File list.
     */
    AddonModScormProvider.prototype.getScormFileList = function (scorm) {
        var files = [];
        if (!this.isScormUnsupported(scorm) && !scorm.warningMessage) {
            files.push({
                fileurl: this.getPackageUrl(scorm),
                filepath: '/',
                filename: scorm.reference,
                filesize: scorm.packagesize,
                type: 'file',
                timemodified: 0
            });
        }
        return files;
    };
    /**
     * Get the URL and description of the status icon.
     *
     * @param {any} sco SCO.
     * @param {boolean} [incomplete] Whether the SCORM is incomplete.
     * @return {{url: string, description: string}} Image URL and description.
     */
    AddonModScormProvider.prototype.getScoStatusIcon = function (sco, incomplete) {
        var imageName = '', descName = '', status;
        if (sco.scormtype == 'sco') {
            // Not an asset, calculate image using status.
            status = sco.status;
            if (this.VALID_STATUSES.indexOf(status) < 0) {
                // Status empty or not valid, use 'notattempted'.
                status = 'notattempted';
            }
            if (!incomplete) {
                // Check if SCO is completed or not. If SCORM is incomplete there's no need to check SCO.
                incomplete = this.isStatusIncomplete(status);
            }
            if (incomplete && sco.exitvalue == 'suspend') {
                imageName = 'suspend';
                descName = 'suspended';
            }
            else {
                imageName = sco.status;
                descName = sco.status;
            }
        }
        else {
            imageName = 'asset';
            descName = (!sco.status || sco.status == 'notattempted') ? 'asset' : 'assetlaunched';
        }
        return {
            url: 'assets/img/scorm/' + imageName + '.gif',
            description: this.translate.instant('addon.mod_scorm.' + descName)
        };
    };
    /**
     * Get cache key for SCORM data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModScormProvider.prototype.getScormDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'scorm:' + courseId;
    };
    /**
     * Get a SCORM with key=value. If more than one is found, only the first will be returned.
     *
     * @param {number} courseId Course ID.
     * @param {string} key Name of the property to check.
     * @param {any} value Value to search.
     * @param {string} [moduleUrl] Module URL.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the SCORM is retrieved.
     */
    AddonModScormProvider.prototype.getScormByField = function (courseId, key, value, moduleUrl, forceCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getScormDataCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_12__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_scorm_get_scorms_by_courses', params, preSets).then(function (response) {
                if (response && response.scorms) {
                    var currentScorm = response.scorms.find(function (scorm) {
                        return scorm[key] == value;
                    });
                    if (currentScorm) {
                        // If the SCORM isn't available the WS returns a warning and it doesn't return timeopen and timeclosed.
                        if (typeof currentScorm.timeopen == 'undefined') {
                            for (var i in response.warnings) {
                                var warning = response.warnings[i];
                                if (warning.itemid === currentScorm.id) {
                                    currentScorm.warningMessage = warning.message;
                                    break;
                                }
                            }
                        }
                        currentScorm.moduleurl = moduleUrl;
                        return currentScorm;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a SCORM by module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId Course module ID.
     * @param {string} [moduleUrl] Module URL.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the SCORM is retrieved.
     */
    AddonModScormProvider.prototype.getScorm = function (courseId, cmId, moduleUrl, forceCache, siteId) {
        return this.getScormByField(courseId, 'coursemodule', cmId, moduleUrl, forceCache, siteId);
    };
    /**
     * Get a SCORM by SCORM ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} id SCORM ID.
     * @param {string} [moduleUrl] Module URL.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the SCORM is retrieved.
     */
    AddonModScormProvider.prototype.getScormById = function (courseId, id, moduleUrl, forceCache, siteId) {
        return this.getScormByField(courseId, 'id', id, moduleUrl, forceCache, siteId);
    };
    /**
     * Get a readable SCORM grade method.
     *
     * @param {any} scorm SCORM.
     * @return {string} Grading method.
     */
    AddonModScormProvider.prototype.getScormGradeMethod = function (scorm) {
        if (scorm.maxattempt == 1) {
            switch (parseInt(scorm.grademethod, 10)) {
                case AddonModScormProvider_1.GRADEHIGHEST:
                    return this.translate.instant('addon.mod_scorm.gradehighest');
                case AddonModScormProvider_1.GRADEAVERAGE:
                    return this.translate.instant('addon.mod_scorm.gradeaverage');
                case AddonModScormProvider_1.GRADESUM:
                    return this.translate.instant('addon.mod_scorm.gradesum');
                case AddonModScormProvider_1.GRADESCOES:
                    return this.translate.instant('addon.mod_scorm.gradescoes');
                default:
                    return '';
            }
        }
        else {
            switch (parseInt(scorm.whatgrade, 10)) {
                case AddonModScormProvider_1.HIGHESTATTEMPT:
                    return this.translate.instant('addon.mod_scorm.highestattempt');
                case AddonModScormProvider_1.AVERAGEATTEMPT:
                    return this.translate.instant('addon.mod_scorm.averageattempt');
                case AddonModScormProvider_1.FIRSTATTEMPT:
                    return this.translate.instant('addon.mod_scorm.firstattempt');
                case AddonModScormProvider_1.LASTATTEMPT:
                    return this.translate.instant('addon.mod_scorm.lastattempt');
                default:
                    return '';
            }
        }
    };
    /**
     * Invalidates access information.
     *
     * @param  {number} forumId  SCORM ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModScormProvider.prototype.invalidateAccessInformation = function (scormId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getAccessInformationCacheKey(scormId));
        });
    };
    /**
     * Invalidates all the data related to a certain SCORM.
     *
     * @param {number} scormId SCORM ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModScormProvider.prototype.invalidateAllScormData = function (scormId, siteId, userId) {
        var promises = [];
        promises.push(this.invalidateAttemptCount(scormId, siteId, userId));
        promises.push(this.invalidateScos(scormId, siteId));
        promises.push(this.invalidateScormUserData(scormId, siteId));
        promises.push(this.invalidateAccessInformation(scormId, siteId));
        return Promise.all(promises);
    };
    /**
     * Invalidates attempt count.
     *
     * @param {number} scormId SCORM ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModScormProvider.prototype.invalidateAttemptCount = function (scormId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getAttemptCountCacheKey(scormId, userId));
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID of the module.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModScormProvider.prototype.invalidateContent = function (moduleId, courseId, siteId, userId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getScorm(courseId, moduleId, undefined, false, siteId).then(function (scorm) {
            var promises = [];
            promises.push(_this.invalidateAllScormData(scorm.id, siteId, userId));
            promises.push(_this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModScormProvider_1.COMPONENT, moduleId, true));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates SCORM data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModScormProvider.prototype.invalidateScormData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getScormDataCacheKey(courseId));
        });
    };
    /**
     * Invalidates SCORM user data for all attempts.
     *
     * @param {number} scormId SCORM ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModScormProvider.prototype.invalidateScormUserData = function (scormId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getScormUserDataCommonCacheKey(scormId));
        });
    };
    /**
     * Invalidates SCORM scos for all organizations.
     *
     * @param {number} scormId SCORM ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModScormProvider.prototype.invalidateScos = function (scormId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getScosCacheKey(scormId));
        });
    };
    /**
     * Check if a SCORM's attempt is incomplete.
     *
     * @param {any} scormId SCORM ID.
     * @param {number} attempt Attempt.
     * @param {boolean} offline Whether the attempt is offline.
     * @param {boolean} ignoreCache Whether it should ignore cached data for online attempts.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with a boolean: true if incomplete, false otherwise.
     */
    AddonModScormProvider.prototype.isAttemptIncomplete = function (scormId, attempt, offline, ignoreCache, siteId) {
        var _this = this;
        return this.getScosWithData(scormId, attempt, undefined, offline, ignoreCache, siteId).then(function (scos) {
            for (var i in scos) {
                var sco = scos[i];
                // Ignore SCOs not visible or without launch URL.
                if (sco.isvisible && sco.launch) {
                    if (_this.isStatusIncomplete(sco.status)) {
                        return true;
                    }
                }
            }
            return false;
        });
    };
    /**
     * Given a launch URL, check if it's a external link.
     * Based on Moodle's scorm_external_link.
     *
     * @param {string} link Link to check.
     * @return {boolean} Whether it's an external link.
     */
    AddonModScormProvider.prototype.isExternalLink = function (link) {
        link = link.toLowerCase();
        if (link.match(/https?:\/\//)) {
            return true;
        }
        else if (link.substr(0, 4) == 'www.') {
            return true;
        }
        return false;
    };
    /**
     * Check if the given SCORM is closed.
     *
     * @param {any} scorm SCORM to check.
     * @return {boolean} Whether the SCORM is closed.
     */
    AddonModScormProvider.prototype.isScormClosed = function (scorm) {
        var timeNow = this.timeUtils.timestamp();
        if (scorm.timeclose > 0 && timeNow > scorm.timeclose) {
            return true;
        }
        return false;
    };
    /**
     * Check if the given SCORM is downloadable.
     *
     * @param {any} scorm SCORM to check.
     * @return {boolean} Whether the SCORM is downloadable.
     */
    AddonModScormProvider.prototype.isScormDownloadable = function (scorm) {
        return typeof scorm.protectpackagedownloads != 'undefined' && scorm.protectpackagedownloads === false;
    };
    /**
     * Check if the given SCORM is open.
     *
     * @param {any} scorm SCORM to check.
     * @return {boolean} Whether the SCORM is open.
     */
    AddonModScormProvider.prototype.isScormOpen = function (scorm) {
        var timeNow = this.timeUtils.timestamp();
        if (scorm.timeopen > 0 && scorm.timeopen > timeNow) {
            return false;
        }
        return true;
    };
    /**
     * Check if a SCORM is unsupported in the app. If it's not, returns the error code to show.
     *
     * @param {any} scorm SCORM to check.
     * @return {string} String with error code if unsupported, undefined if supported.
     */
    AddonModScormProvider.prototype.isScormUnsupported = function (scorm) {
        if (!this.isScormValidVersion(scorm)) {
            return 'addon.mod_scorm.errorinvalidversion';
        }
        else if (!this.isScormDownloadable(scorm)) {
            return 'addon.mod_scorm.errornotdownloadable';
        }
        else if (!this.isValidPackageUrl(this.getPackageUrl(scorm))) {
            return 'addon.mod_scorm.errorpackagefile';
        }
    };
    /**
     * Check if it's a valid SCORM 1.2.
     *
     * @param {any} scorm SCORM to check.
     * @return {boolean} Whether the SCORM is valid.
     */
    AddonModScormProvider.prototype.isScormValidVersion = function (scorm) {
        return scorm.version == 'SCORM_1.2';
    };
    /**
     * Check if a SCO status is incomplete.
     *
     * @param {string} status SCO status.
     * @return {boolean} Whether it's incomplete.
     */
    AddonModScormProvider.prototype.isStatusIncomplete = function (status) {
        return !status || status == 'notattempted' || status == 'incomplete' || status == 'browsed';
    };
    /**
     * Check if a package URL is valid.
     *
     * @param {string} packageUrl Package URL.
     * @return {boolean} Whether it's valid.
     */
    AddonModScormProvider.prototype.isValidPackageUrl = function (packageUrl) {
        if (!packageUrl) {
            return false;
        }
        if (packageUrl.indexOf('imsmanifest.xml') > -1) {
            return false;
        }
        return true;
    };
    /**
     * Report a SCO as being launched.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} scoId SCO ID.
     * @param {string} [name] Name of the SCORM.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModScormProvider.prototype.logLaunchSco = function (scormId, scoId, name, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                scormid: scormId,
                scoid: scoId
            };
            return _this.logHelper.logSingle('mod_scorm_launch_sco', params, AddonModScormProvider_1.COMPONENT, scormId, name, 'scorm', { scoid: scoId }, siteId);
        });
    };
    /**
     * Report a SCORM as being viewed.
     *
     * @param {string} id Module ID.
     * @param {string} [name] Name of the SCORM.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModScormProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            scormid: id
        };
        return this.logHelper.logSingle('mod_scorm_view_scorm', params, AddonModScormProvider_1.COMPONENT, id, name, 'scorm', {}, siteId);
    };
    /**
     * Saves a SCORM tracking record.
     *
     * @param {number} scoId Sco ID.
     * @param {number} attempt Attempt number.
     * @param {any[]} tracks Tracking data to store.
     * @param {any} scorm SCORM.
     * @param {boolean} offline Whether the attempt is offline.
     * @param {any} [userData] User data for this attempt and SCO. If not defined, it will be retrieved from DB. Recommended.
     * @return {Promise<any>} Promise resolved when data is saved.
     */
    AddonModScormProvider.prototype.saveTracks = function (scoId, attempt, tracks, scorm, offline, userData, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (offline) {
            var promise = userData ? Promise.resolve(userData) : this.getScormUserData(scorm.id, attempt, undefined, offline, false, siteId);
            return promise.then(function (userData) {
                return _this.scormOfflineProvider.saveTracks(scorm, scoId, attempt, tracks, userData, siteId);
            });
        }
        else {
            return this.saveTracksOnline(scorm.id, scoId, attempt, tracks, siteId).then(function () {
                // Tracks have been saved, update cached user data.
                _this.updateUserDataAfterSave(scorm.id, attempt, tracks, siteId);
                _this.eventsProvider.trigger(AddonModScormProvider_1.DATA_SENT_EVENT, {
                    scormId: scorm.id,
                    scoId: scoId,
                    attempt: attempt
                }, _this.sitesProvider.getCurrentSiteId());
            });
        }
    };
    /**
     * Saves a SCORM tracking record.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} scoId Sco ID.
     * @param {number} attempt Attempt number.
     * @param {any[]} tracks Tracking data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data is saved.
     */
    AddonModScormProvider.prototype.saveTracksOnline = function (scormId, scoId, attempt, tracks, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!tracks || !tracks.length) {
                return Promise.resolve(); // Nothing to save.
            }
            var params = {
                scoid: scoId,
                attempt: attempt,
                tracks: tracks
            };
            _this.syncProvider.blockOperation(AddonModScormProvider_1.COMPONENT, scormId, 'saveTracksOnline', site.id);
            return site.write('mod_scorm_insert_scorm_tracks', params).then(function (response) {
                if (response && response.trackids) {
                    return response.trackids;
                }
                return Promise.reject(null);
            }).finally(function () {
                _this.syncProvider.unblockOperation(AddonModScormProvider_1.COMPONENT, scormId, 'saveTracksOnline', site.id);
            });
        });
    };
    /**
     * Saves a SCORM tracking record using a synchronous call.
     * Please use this function only if synchronous is a must. It's recommended to use saveTracks.
     *
     * @param {number} scoId Sco ID.
     * @param {number} attempt Attempt number.
     * @param {any[]} tracks Tracking data to store.
     * @param {any} scorm SCORM.
     * @param {boolean} [offline] Whether the attempt is offline.
     * @param {any} [userData] User data for this attempt and SCO. Required if offline=true.
     * @return {boolean} In online returns true if data is inserted, false otherwise.
     *                   In offline returns true if data to insert is valid, false otherwise. True doesn't mean that the
     *                   data has been stored, this function can return true but the insertion can still fail somehow.
     */
    AddonModScormProvider.prototype.saveTracksSync = function (scoId, attempt, tracks, scorm, offline, userData) {
        if (offline) {
            return this.scormOfflineProvider.saveTracksSync(scorm, scoId, attempt, tracks, userData);
        }
        else {
            var success = this.saveTracksSyncOnline(scoId, attempt, tracks);
            if (success) {
                // Tracks have been saved, update cached user data.
                this.updateUserDataAfterSave(scorm.id, attempt, tracks);
                this.eventsProvider.trigger(AddonModScormProvider_1.DATA_SENT_EVENT, {
                    scormId: scorm.id,
                    scoId: scoId,
                    attempt: attempt
                }, this.sitesProvider.getCurrentSiteId());
            }
            return success;
        }
    };
    /**
     * Saves a SCORM tracking record using a synchronous call.
     * Please use this function only if synchronous is a must. It's recommended to use saveTracksOnline.
     *
     * @param {number} scoId Sco ID.
     * @param {number} attempt Attempt number.
     * @param {any[]} tracks Tracking data.
     * @return {boolean} True if success, false otherwise.
     */
    AddonModScormProvider.prototype.saveTracksSyncOnline = function (scoId, attempt, tracks) {
        var params = {
            scoid: scoId,
            attempt: attempt,
            tracks: tracks
        }, currentSite = this.sitesProvider.getCurrentSite(), preSets = {
            siteUrl: currentSite.getURL(),
            wsToken: currentSite.getToken()
        };
        var wsFunction = 'mod_scorm_insert_scorm_tracks', response;
        if (!tracks || !tracks.length) {
            return true; // Nothing to save.
        }
        // Check if the method is available, use a prefixed version if possible.
        if (!currentSite.wsAvailable(wsFunction, false)) {
            if (currentSite.wsAvailable(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX + wsFunction, false)) {
                wsFunction = __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX + wsFunction;
            }
            else {
                this.logger.error('WS function "' + wsFunction + '" is not available, even in compatibility mode.');
                return false;
            }
        }
        response = this.wsProvider.syncCall(wsFunction, params, preSets);
        if (response && !response.error && response.trackids) {
            return true;
        }
        return false;
    };
    /**
     * Check if the SCORM main file should be downloaded.
     * This function should only be called if the SCORM can be downloaded (not downloaded or outdated).
     *
     * @param {any} scorm SCORM to check.
     * @param {boolean} [isOutdated] True if package outdated, false if not downloaded, undefined to calculate it.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>}  Promise resolved with true if it should be downloaded, false otherwise.
     */
    AddonModScormProvider.prototype.shouldDownloadMainFile = function (scorm, isOutdated, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var component = AddonModScormProvider_1.COMPONENT;
        if (typeof isOutdated == 'undefined') {
            // Calculate if it's outdated.
            return this.filepoolProvider.getPackageData(siteId, component, scorm.coursemodule).then(function (data) {
                var isOutdated = data.status == __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].OUTDATED ||
                    (data.status == __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].DOWNLOADING && data.previous == __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].OUTDATED);
                // Package needs to be downloaded if it's not outdated (not downloaded) or if the hash has changed.
                return !isOutdated || data.extra != scorm.sha1hash;
            }).catch(function () {
                // Package not found, not downloaded.
                return true;
            });
        }
        else if (isOutdated) {
            // The package is outdated, but maybe the file hasn't changed.
            return this.filepoolProvider.getPackageExtra(siteId, component, scorm.coursemodule).then(function (extra) {
                return scorm.sha1hash != extra;
            }).catch(function () {
                // Package not found, not downloaded.
                return true;
            });
        }
        else {
            // Package is not outdated and not downloaded, download the main file.
            return Promise.resolve(true);
        }
    };
    /**
     * If needed, updates cached user data after saving tracks in online.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {any[]} tracks Tracking data saved.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when updated.
     */
    AddonModScormProvider.prototype.updateUserDataAfterSave = function (scormId, attempt, tracks, siteId) {
        if (!tracks || !tracks.length) {
            return Promise.resolve();
        }
        // Check if we need to update. We only update if we sent some track with a dot notation.
        var needsUpdate = false;
        for (var i = 0, len = tracks.length; i < len; i++) {
            var track = tracks[i];
            if (track.element && track.element.indexOf('.') > -1) {
                needsUpdate = true;
                break;
            }
        }
        if (needsUpdate) {
            return this.getScormUserDataOnline(scormId, attempt, true, siteId);
        }
        return Promise.resolve();
    };
    AddonModScormProvider.COMPONENT = 'mmaModScorm';
    // Public constants.
    AddonModScormProvider.GRADESCOES = 0;
    AddonModScormProvider.GRADEHIGHEST = 1;
    AddonModScormProvider.GRADEAVERAGE = 2;
    AddonModScormProvider.GRADESUM = 3;
    AddonModScormProvider.HIGHESTATTEMPT = 0;
    AddonModScormProvider.AVERAGEATTEMPT = 1;
    AddonModScormProvider.FIRSTATTEMPT = 2;
    AddonModScormProvider.LASTATTEMPT = 3;
    AddonModScormProvider.MODEBROWSE = 'browse';
    AddonModScormProvider.MODENORMAL = 'normal';
    AddonModScormProvider.MODEREVIEW = 'review';
    AddonModScormProvider.SCORM_FORCEATTEMPT_NO = 0;
    AddonModScormProvider.SCORM_FORCEATTEMPT_ONCOMPLETE = 1;
    AddonModScormProvider.SCORM_FORCEATTEMPT_ALWAYS = 2;
    AddonModScormProvider.SKIPVIEW_NEVER = 0;
    AddonModScormProvider.SKIPVIEW_FIRST = 1;
    AddonModScormProvider.SKIPVIEW_ALWAYS = 2;
    // Events.
    AddonModScormProvider.LAUNCH_NEXT_SCO_EVENT = 'addon_mod_scorm_launch_next_sco';
    AddonModScormProvider.LAUNCH_PREV_SCO_EVENT = 'addon_mod_scorm_launch_prev_sco';
    AddonModScormProvider.UPDATE_TOC_EVENT = 'addon_mod_scorm_update_toc';
    AddonModScormProvider.GO_OFFLINE_EVENT = 'addon_mod_scorm_go_offline';
    AddonModScormProvider.DATA_SENT_EVENT = 'addon_mod_scorm_data_sent';
    AddonModScormProvider = AddonModScormProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_ws__["a" /* CoreWSProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_11__scorm_offline__["a" /* AddonModScormOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_sync__["a" /* CoreSyncProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_14__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModScormProvider);
    return AddonModScormProvider;
    var AddonModScormProvider_1;
}());

//# sourceMappingURL=scorm.js.map

/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModWikiProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__wiki_offline__ = __webpack_require__(273);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service that provides some features for wikis.
 */
var AddonModWikiProvider = /** @class */ (function () {
    function AddonModWikiProvider(logger, sitesProvider, appProvider, filepoolProvider, utils, translate, wikiOffline, eventsProvider, logHelper) {
        var _this = this;
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        this.filepoolProvider = filepoolProvider;
        this.utils = utils;
        this.translate = translate;
        this.wikiOffline = wikiOffline;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModWiki:';
        this.subwikiListsCache = {};
        this.logger = logger.getInstance('AddonModWikiProvider');
        // Clear subwiki lists cache on logout.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGIN, function () {
            _this.clearSubwikiList();
        });
    }
    AddonModWikiProvider_1 = AddonModWikiProvider;
    /**
     * Clear subwiki list cache for a certain wiki or all of them.
     *
     * @param {number} [wikiId] wiki Id, if not provided all will be cleared.
     */
    AddonModWikiProvider.prototype.clearSubwikiList = function (wikiId) {
        if (typeof wikiId == 'undefined') {
            this.subwikiListsCache = {};
        }
        else {
            delete this.subwikiListsCache[wikiId];
        }
    };
    /**
     * Save wiki contents on a page or section.
     *
     * @param {number} pageId Page ID.
     * @param {string} content content to be saved.
     * @param {string} [section] section to get.
     * @return {Promise<number>} Promise resolved with the page ID.
     */
    AddonModWikiProvider.prototype.editPage = function (pageId, content, section, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                pageid: pageId,
                content: content
            };
            if (section) {
                params.section = section;
            }
            return site.write('mod_wiki_edit_page', params).then(function (response) {
                return response.pageid || Promise.reject(null);
            });
        });
    };
    /**
     * Get a wiki page contents.
     *
     * @param {number} pageId Page ID.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the page data.
     */
    AddonModWikiProvider.prototype.getPageContents = function (pageId, offline, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                pageid: pageId
            }, preSets = {
                cacheKey: _this.getPageContentsCacheKey(pageId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_wiki_get_page_contents', params, preSets).then(function (response) {
                return response.page || Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for wiki Pages Contents WS calls.
     *
     * @param {number} pageId Wiki Page ID.
     * @return {string} Cache key.
     */
    AddonModWikiProvider.prototype.getPageContentsCacheKey = function (pageId) {
        return this.ROOT_CACHE_KEY + 'page:' + pageId;
    };
    /**
     * Get a wiki page contents for editing. It does not cache calls.
     *
     * @param {number} pageId Page ID.
     * @param {string} [section] Section to get.
     * @param {boolean} [lockOnly] Just renew lock and not return content.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with page contents.
     */
    AddonModWikiProvider.prototype.getPageForEditing = function (pageId, section, lockOnly, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                pageid: pageId
            };
            if (section) {
                params.section = section;
            }
            // This parameter requires Moodle 3.2. It saves network usage.
            if (lockOnly && site.isVersionGreaterEqualThan('3.2')) {
                params.lockonly = 1;
            }
            return site.write('mod_wiki_get_page_for_editing', params).then(function (response) {
                return response.pagesection || Promise.reject(null);
            });
        });
    };
    /**
     * Gets the list of files from a specific subwiki.
     *
     * @param {number} wikiId Wiki ID.
     * @param {number} [groupId] Group to get files from.
     * @param {number} [userId] User to get files from.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with subwiki files.
     */
    AddonModWikiProvider.prototype.getSubwikiFiles = function (wikiId, groupId, userId, offline, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            groupId = groupId || -1;
            userId = userId || 0;
            var params = {
                wikiid: wikiId,
                groupid: groupId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getSubwikiFilesCacheKey(wikiId, groupId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_wiki_get_subwiki_files', params, preSets).then(function (response) {
                return response.files || Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for wiki Subwiki Files WS calls.
     *
     * @param {number} wikiId Wiki ID.
     * @param {number} groupId Group ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonModWikiProvider.prototype.getSubwikiFilesCacheKey = function (wikiId, groupId, userId) {
        return this.getSubwikiFilesCacheKeyPrefix(wikiId) + ':' + groupId + ':' + userId;
    };
    /**
     * Get cache key for all wiki Subwiki Files WS calls.
     *
     * @param {number} wikiId Wiki ID.
     * @return {string} Cache key.
     */
    AddonModWikiProvider.prototype.getSubwikiFilesCacheKeyPrefix = function (wikiId) {
        return this.ROOT_CACHE_KEY + 'subwikifiles:' + wikiId;
    };
    /**
     * Get a list of subwikis and related data for a certain wiki from the cache.
     *
     * @param {number} wikiId wiki Id
     * @return {AddonModWikiSubwikiListData} Subwiki list and related data.
     */
    AddonModWikiProvider.prototype.getSubwikiList = function (wikiId) {
        return this.subwikiListsCache[wikiId];
    };
    /**
     * Get the list of Pages of a SubWiki.
     *
     * @param {number} wikiId Wiki ID.
     * @param {number} [groupId] Group to get pages from.
     * @param {number} [userId] User to get pages from.
     * @param {string} [sortBy=title] The attribute to sort the returned list.
     * @param {string} [sortDirection=ASC] Direction to sort the returned list (ASC | DESC).
     * @param {boolean} [includeContent] Whether the pages have to include its content. Default: false.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with wiki subwiki pages.
     */
    AddonModWikiProvider.prototype.getSubwikiPages = function (wikiId, groupId, userId, sortBy, sortDirection, includeContent, offline, ignoreCache, siteId) {
        var _this = this;
        if (sortBy === void 0) { sortBy = 'title'; }
        if (sortDirection === void 0) { sortDirection = 'ASC'; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            groupId = groupId || -1;
            userId = userId || 0;
            sortBy = sortBy || 'title';
            sortDirection = sortDirection || 'ASC';
            includeContent = includeContent || false;
            var params = {
                wikiid: wikiId,
                groupid: groupId,
                userid: userId,
                options: {
                    sortby: sortBy,
                    sortdirection: sortDirection,
                    includecontent: includeContent ? 1 : 0
                }
            }, preSets = {
                cacheKey: _this.getSubwikiPagesCacheKey(wikiId, groupId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_wiki_get_subwiki_pages', params, preSets).then(function (response) {
                return response.pages || Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for wiki Subwiki Pages WS calls.
     *
     * @param {number} wikiId Wiki ID.
     * @param {number} groupId Group ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonModWikiProvider.prototype.getSubwikiPagesCacheKey = function (wikiId, groupId, userId) {
        return this.getSubwikiPagesCacheKeyPrefix(wikiId) + ':' + groupId + ':' + userId;
    };
    /**
     * Get cache key for all wiki Subwiki Pages WS calls.
     *
     * @param {number} wikiId Wiki ID.
     * @return {string} Cache key.
     */
    AddonModWikiProvider.prototype.getSubwikiPagesCacheKeyPrefix = function (wikiId) {
        return this.ROOT_CACHE_KEY + 'subwikipages:' + wikiId;
    };
    /**
     * Get all the subwikis of a wiki.
     *
     * @param {number} wikiId Wiki ID.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with subwikis.
     */
    AddonModWikiProvider.prototype.getSubwikis = function (wikiId, offline, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                wikiid: wikiId
            }, preSets = {
                cacheKey: _this.getSubwikisCacheKey(wikiId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (offline) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_wiki_get_subwikis', params, preSets).then(function (response) {
                return response.subwikis || Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get wiki subWikis WS calls.
     *
     * @param {number} wikiId Wiki ID.
     * @return {string} Cache key.
     */
    AddonModWikiProvider.prototype.getSubwikisCacheKey = function (wikiId) {
        return this.ROOT_CACHE_KEY + 'subwikis:' + wikiId;
    };
    /**
     * Get a wiki by module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId Course module ID.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the wiki is retrieved.
     */
    AddonModWikiProvider.prototype.getWiki = function (courseId, cmId, forceCache, siteId) {
        return this.getWikiByField(courseId, 'coursemodule', cmId, forceCache, siteId);
    };
    /**
     * Get a wiki with key=value. If more than one is found, only the first will be returned.
     *
     * @param {number} courseId Course ID.
     * @param {string} key Name of the property to check.
     * @param {any} value Value to search.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the wiki is retrieved.
     */
    AddonModWikiProvider.prototype.getWikiByField = function (courseId, key, value, forceCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getWikiDataCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_10__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_wiki_get_wikis_by_courses', params, preSets).then(function (response) {
                if (response.wikis) {
                    var currentWiki = response.wikis.find(function (wiki) {
                        return wiki[key] == value;
                    });
                    if (currentWiki) {
                        return currentWiki;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a wiki by wiki ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} id Wiki ID.
     * @param {boolean} [forceCache] Whether it should always return cached data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the wiki is retrieved.
     */
    AddonModWikiProvider.prototype.getWikiById = function (courseId, id, forceCache, siteId) {
        return this.getWikiByField(courseId, 'id', id, forceCache, siteId);
    };
    /**
     * Get cache key for wiki data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModWikiProvider.prototype.getWikiDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'wiki:' + courseId;
    };
    /**
     * Gets a list of files to download for a wiki, using a format similar to module.contents from get_course_contents.
     *
     * @param {any} wiki Wiki.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    AddonModWikiProvider.prototype.getWikiFileList = function (wiki, offline, ignoreCache, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var files = [];
        return this.getSubwikis(wiki.id, offline, ignoreCache, siteId).then(function (subwikis) {
            var promises = [];
            subwikis.forEach(function (subwiki) {
                promises.push(_this.getSubwikiFiles(subwiki.wikiid, subwiki.groupid, subwiki.userid, offline, ignoreCache, siteId)
                    .then(function (swFiles) {
                    files = files.concat(swFiles);
                }));
            });
            return Promise.all(promises).then(function () {
                return files;
            });
        });
    };
    /**
     * Gets a list of all pages for a Wiki.
     *
     * @param {any} wiki Wiki.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Page list.
     */
    AddonModWikiProvider.prototype.getWikiPageList = function (wiki, offline, ignoreCache, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var pages = [];
        return this.getSubwikis(wiki.id, offline, ignoreCache, siteId).then(function (subwikis) {
            var promises = [];
            subwikis.forEach(function (subwiki) {
                promises.push(_this.getSubwikiPages(subwiki.wikiid, subwiki.groupid, subwiki.userid, undefined, undefined, undefined, offline, ignoreCache, siteId).then(function (subwikiPages) {
                    pages = pages.concat(subwikiPages);
                }));
            });
            return Promise.all(promises).then(function () {
                return pages;
            });
        });
    };
    /**
     * Invalidate the prefetched content except files.
     * To invalidate files, use invalidateFiles.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModWikiProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getWiki(courseId, moduleId, false, siteId).then(function (wiki) {
            var promises = [];
            promises.push(_this.invalidateWikiData(courseId, siteId));
            promises.push(_this.invalidateSubwikis(wiki.id, siteId));
            promises.push(_this.invalidateSubwikiPages(wiki.id, siteId));
            promises.push(_this.invalidateSubwikiFiles(wiki.id, siteId));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidate the prefetched files.
     *
     * @param {number} moduleId The module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the files are invalidated.
     */
    AddonModWikiProvider.prototype.invalidateFiles = function (moduleId, siteId) {
        return this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModWikiProvider_1.COMPONENT, moduleId);
    };
    /**
     * Invalidates page content WS call for a certain page.
     *
     * @param {number} pageId Wiki Page ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModWikiProvider.prototype.invalidatePage = function (pageId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getPageContentsCacheKey(pageId));
        });
    };
    /**
     * Invalidates all the subwiki files WS calls for a certain wiki.
     *
     * @param {number} wikiId Wiki ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModWikiProvider.prototype.invalidateSubwikiFiles = function (wikiId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getSubwikiFilesCacheKeyPrefix(wikiId));
        });
    };
    /**
     * Invalidates all the subwiki pages WS calls for a certain wiki.
     *
     * @param {Number} wikiId Wiki ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModWikiProvider.prototype.invalidateSubwikiPages = function (wikiId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getSubwikiPagesCacheKeyPrefix(wikiId));
        });
    };
    /**
     * Invalidates all the get subwikis WS calls for a certain wiki.
     *
     * @param {number} wikiId Wiki ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModWikiProvider.prototype.invalidateSubwikis = function (wikiId, siteId) {
        var _this = this;
        this.clearSubwikiList(wikiId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getSubwikisCacheKey(wikiId));
        });
    };
    /**
     * Invalidates wiki data.
     *
     * @param {Number} courseId Course ID.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise}        Promise resolved when the data is invalidated.
     */
    AddonModWikiProvider.prototype.invalidateWikiData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getWikiDataCacheKey(courseId));
        });
    };
    /**
     * Check if a page title is already used.
     *
     * @param {number} wikiId Wiki ID.
     * @param {number} subwikiId Subwiki ID.
     * @param {string} title Page title.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if used, resolved with false if not used or cannot determine.
     */
    AddonModWikiProvider.prototype.isTitleUsed = function (wikiId, subwikiId, title, offline, ignoreCache, siteId) {
        var _this = this;
        // First get the subwiki.
        return this.getSubwikis(wikiId, offline, ignoreCache, siteId).then(function (subwikis) {
            // Search the subwiki.
            var subwiki = subwikis.find(function (subwiki) {
                return subwiki.id == subwikiId;
            });
            return subwiki || Promise.reject(null);
        }).then(function (subwiki) {
            // Now get all the pages of the subwiki.
            return _this.getSubwikiPages(wikiId, subwiki.groupid, subwiki.userid, undefined, undefined, false, offline, ignoreCache, siteId);
        }).then(function (pages) {
            // Check if there's any page with the same title.
            var page = pages.find(function (page) {
                return page.title == title;
            });
            return !!page;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Report a wiki page as being viewed.
     *
     * @param {number} id Page ID.
     * @param {number} wikiId Wiki ID.
     * @param {string} [name] Name of the wiki.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModWikiProvider.prototype.logPageView = function (id, wikiId, name, siteId) {
        var params = {
            pageid: id
        };
        return this.logHelper.logSingle('mod_wiki_view_page', params, AddonModWikiProvider_1.COMPONENT, wikiId, name, 'wiki', params, siteId);
    };
    /**
     * Report the wiki as being viewed.
     *
     * @param {number} id Wiki ID.
     * @param {string} [name] Name of the wiki.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModWikiProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            wikiid: id
        };
        return this.logHelper.logSingle('mod_wiki_view_wiki', params, AddonModWikiProvider_1.COMPONENT, id, name, 'wiki', {}, siteId);
    };
    /**
     * Create a new page on a subwiki.
     *
     * @param {string} title Title to create the page.
     * @param {string} content Content to save on the page.
     * @param {number} [subwikiId] Subwiki ID. If not defined, wikiId, userId and groupId should be defined.
     * @param {number} [wikiId] Wiki ID. Optional, will be used to create a new subwiki if subwikiId not supplied.
     * @param {number} [userId] User ID. Optional, will be used to create a new subwiki if subwikiId not supplied.
     * @param {number} [groupId] Group ID. Optional, will be used to create a new subwiki if subwikiId not supplied.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with page ID if page was created in server, -1 if stored in device.
     */
    AddonModWikiProvider.prototype.newPage = function (title, content, subwikiId, wikiId, userId, groupId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a new page to be synchronized later.
        var storeOffline = function () {
            var promise;
            if (wikiId) {
                // We have wiki ID, check if there's already an online page with this title and subwiki.
                promise = _this.isTitleUsed(wikiId, subwikiId, title, true, false, siteId).catch(function () {
                    // Error, assume not used.
                    return false;
                }).then(function (used) {
                    if (used) {
                        return Promise.reject(_this.translate.instant('addon.mod_wiki.pageexists'));
                    }
                });
            }
            else {
                promise = Promise.resolve();
            }
            return promise.then(function () {
                return _this.wikiOffline.saveNewPage(title, content, subwikiId, wikiId, userId, groupId, siteId).then(function () {
                    return -1;
                });
            });
        };
        if (!this.appProvider.isOnline()) {
            // App is offline, store the action.
            return storeOffline();
        }
        // Discard stored content for this page. If it exists it means the user is editing it.
        return this.wikiOffline.deleteNewPage(title, subwikiId, wikiId, userId, groupId, siteId).then(function () {
            // Try to create it in online.
            return _this.newPageOnline(title, content, subwikiId, wikiId, userId, groupId, siteId).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means that the page cannot be added.
                    return Promise.reject(error);
                }
                else {
                    // Couldn't connect to server, store in offline.
                    return storeOffline();
                }
            });
        });
    };
    /**
     * Create a new page on a subwiki. It will fail if offline or cannot connect.
     *
     * @param {string} title Title to create the page.
     * @param {string} content Content to save on the page.
     * @param {number} [subwikiId] Subwiki ID. If not defined, wikiId, userId and groupId should be defined.
     * @param {number} [wikiId] Wiki ID. Optional, will be used create subwiki if not informed.
     * @param {number} [userId] User ID. Optional, will be used create subwiki if not informed.
     * @param {number} [groupId] Group ID. Optional, will be used create subwiki if not informed.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the page ID if created, rejected otherwise.
     */
    AddonModWikiProvider.prototype.newPageOnline = function (title, content, subwikiId, wikiId, userId, groupId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                title: title,
                content: content,
                contentformat: 'html'
            };
            subwikiId = _this.wikiOffline.convertToPositiveNumber(subwikiId);
            wikiId = _this.wikiOffline.convertToPositiveNumber(wikiId);
            if (subwikiId && subwikiId > 0) {
                params.subwikiid = subwikiId;
            }
            else if (wikiId) {
                params.wikiid = wikiId;
                params.userid = _this.wikiOffline.convertToPositiveNumber(userId);
                params.groupid = _this.wikiOffline.convertToPositiveNumber(groupId);
            }
            return site.write('mod_wiki_new_page', params).then(function (response) {
                return response.pageid || Promise.reject(null);
            });
        });
    };
    /**
     * Save subwiki list for a wiki to the cache.
     *
     * @param {number} wikiId Wiki Id.
     * @param {any[]} subwikis List of subwikis.
     * @param {number} count Number of subwikis in the subwikis list.
     * @param {number} subwikiId Subwiki Id currently selected.
     * @param {number} userId User Id currently selected.
     * @param {number} groupId Group Id currently selected.
     */
    AddonModWikiProvider.prototype.setSubwikiList = function (wikiId, subwikis, count, subwikiId, userId, groupId) {
        this.subwikiListsCache[wikiId] = {
            count: count,
            subwikiSelected: subwikiId,
            userSelected: userId,
            groupSelected: groupId,
            subwikis: subwikis
        };
    };
    /**
     * Sort an array of wiki pages by title.
     *
     * @param {any[]} pages Pages to sort.
     * @param {boolean} [desc] True to sort in descendent order, false to sort in ascendent order. Defaults to false.
     * @return {any[]} Sorted pages.
     */
    AddonModWikiProvider.prototype.sortPagesByTitle = function (pages, desc) {
        return pages.sort(function (a, b) {
            var result = a.title >= b.title ? 1 : -1;
            if (desc) {
                result = -result;
            }
            return result;
        });
    };
    /**
     * Check if a wiki has a certain subwiki.
     *
     * @param {number} wikiId Wiki ID.
     * @param {number} subwikiId Subwiki ID to search.
     * @param {boolean} [offline] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if it has subwiki, resolved with false otherwise.
     */
    AddonModWikiProvider.prototype.wikiHasSubwiki = function (wikiId, subwikiId, offline, ignoreCache, siteId) {
        // Get the subwikis to check if any of them matches the one passed as param.
        return this.getSubwikis(wikiId, offline, ignoreCache, siteId).then(function (subwikis) {
            var subwiki = subwikis.find(function (subwiki) {
                return subwiki.id == subwikiId;
            });
            return !!subwiki;
        }).catch(function () {
            // Not found, return false.
            return false;
        });
    };
    AddonModWikiProvider.COMPONENT = 'mmaModWiki';
    AddonModWikiProvider.PAGE_CREATED_EVENT = 'addon_mod_wiki_page_created';
    AddonModWikiProvider.RENEW_LOCK_TIME = 30000; // Milliseconds.
    AddonModWikiProvider = AddonModWikiProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_9__wiki_offline__["a" /* AddonModWikiOfflineProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModWikiProvider);
    return AddonModWikiProvider;
    var AddonModWikiProvider_1;
}());

//# sourceMappingURL=wiki.js.map

/***/ }),
/* 219 */,
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreRatingSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_base_sync__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__rating__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__offline__ = __webpack_require__(191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_events__ = __webpack_require__(11);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * Service to sync ratings.
 */
var CoreRatingSyncProvider = /** @class */ (function (_super) {
    __extends(CoreRatingSyncProvider, _super);
    function CoreRatingSyncProvider(translate, appProvider, eventsProvider, loggerProvider, sitesProvider, syncProvider, textUtils, timeUtils, utils, ratingProvider, ratingOffline) {
        var _this = _super.call(this, 'CoreRatingSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils) || this;
        _this.eventsProvider = eventsProvider;
        _this.utils = utils;
        _this.ratingProvider = ratingProvider;
        _this.ratingOffline = ratingOffline;
        return _this;
    }
    CoreRatingSyncProvider_1 = CoreRatingSyncProvider;
    /**
     * Try to synchronize all the ratings of a certain component, instance or item set.
     *
     * This function should be called from the sync provider of activities with ratings.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating Area. Example: "post".
     * @param {string} [contextLevel] Context level: course, module, user, etc.
     * @param {numnber} [instanceId] Context instance id.
     * @param {number} [itemSetId] Item set id.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    CoreRatingSyncProvider.prototype.syncRatings = function (component, ratingArea, contextLevel, instanceId, itemSetId, force, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.ratingOffline.getItemSets(component, ratingArea, contextLevel, instanceId, itemSetId, siteId)
            .then(function (itemSets) {
            var results = [];
            var promises = itemSets.map(function (itemSet) {
                var promise = force ? _this.syncItemSet(component, ratingArea, itemSet.contextLevel, itemSet.instanceId, itemSet.itemSetId, siteId) : _this.syncItemSetIfNeeded(component, ratingArea, itemSet.contextLevel, itemSet.instanceId, itemSet.itemSetId, siteId);
                return promise.then(function (result) {
                    if (result.updated) {
                        // Sync successful, send event.
                        _this.eventsProvider.trigger(CoreRatingSyncProvider_1.SYNCED_EVENT, __assign({}, itemSet, { warnings: result.warnings }), siteId);
                    }
                    results.push(__assign({ itemSet: itemSet }, result));
                });
            });
            return Promise.all(promises).then(function () {
                return results;
            });
        });
    };
    /**
     * Sync ratings of an item set only if a certain time has passed since the last time.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating Area. Example: "post".
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} instanceId Context instance id.
     * @param {number} itemSetId Item set id. Example: forum discussion id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when ratings are synced or if it doesn't need to be synced.
     */
    CoreRatingSyncProvider.prototype.syncItemSetIfNeeded = function (component, ratingArea, contextLevel, instanceId, itemSetId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var syncId = this.getItemSetSyncId(component, ratingArea, contextLevel, instanceId, itemSetId);
        return this.isSyncNeeded(syncId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncItemSet(component, ratingArea, contextLevel, instanceId, itemSetId, siteId);
            }
        });
    };
    /**
     * Synchronize all offline ratings of an item set.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating Area. Example: "post".
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} instanceId Context instance id.
     * @param {number} itemSetId Item set id. Example: forum discussion id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected otherwise.
     */
    CoreRatingSyncProvider.prototype.syncItemSet = function (component, ratingArea, contextLevel, instanceId, itemSetId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var syncId = this.getItemSetSyncId(component, ratingArea, contextLevel, instanceId, itemSetId);
        if (this.isSyncing(syncId, siteId)) {
            // There's already a sync ongoing for this item set, return the promise.
            return this.getOngoingSync(syncId, siteId);
        }
        this.logger.debug("Try to sync ratings of component '" + component + "' rating area '" + ratingArea + "'" +
            (" context level '" + contextLevel + "' instance " + instanceId + " item set " + itemSetId));
        var updated = [];
        var warnings = [];
        return this.ratingOffline.getRatings(component, ratingArea, contextLevel, instanceId, itemSetId, siteId).then(function (ratings) {
            if (!ratings.length) {
                // Nothing to sync.
                return;
            }
            else if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(null);
            }
            var promises = ratings.map(function (rating) {
                return _this.ratingProvider.addRatingOnline(component, ratingArea, rating.contextlevel, rating.instanceid, rating.itemid, rating.scaleid, rating.rating, rating.rateduserid, rating.aggregation, siteId)
                    .catch(function (error) {
                    if (_this.utils.isWebServiceError(error)) {
                        warnings.push(_this.textUtils.getErrorMessageFromError(error));
                    }
                    else {
                        // Couldn't connect to server, reject.
                        return Promise.reject(error);
                    }
                }).then(function () {
                    updated.push(rating.itemid);
                    return _this.ratingOffline.deleteRating(component, ratingArea, rating.contextlevel, rating.instanceid, rating.itemid, siteId).finally(function () {
                        return _this.ratingProvider.invalidateRatingItems(rating.contextlevel, rating.instanceid, component, ratingArea, rating.itemid, rating.scaleid, undefined, siteId);
                    });
                });
            });
            return Promise.all(promises).then(function () {
                // All done, return the warnings.
                return { updated: updated, warnings: warnings };
            });
        });
    };
    /**
     * Get the sync id of an item set.
     *
     * @param {string} component Component. Example: "mod_forum".
     * @param {string} ratingArea Rating Area. Example: "post".
     * @param {string} contextLevel Context level: course, module, user, etc.
     * @param {number} instanceId Context instance id.
     * @param {number} itemSetId Item set id. Example: forum discussion id.
     * @return {string} Sync id.
     */
    CoreRatingSyncProvider.prototype.getItemSetSyncId = function (component, ratingArea, contextLevel, instanceId, itemSetId) {
        return "itemSet#" + component + "#" + ratingArea + "#" + contextLevel + "#" + instanceId + "#" + itemSetId;
    };
    CoreRatingSyncProvider.SYNCED_EVENT = 'core_rating_synced';
    CoreRatingSyncProvider = CoreRatingSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_12__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_sync__["a" /* CoreSyncProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__rating__["a" /* CoreRatingProvider */],
            __WEBPACK_IMPORTED_MODULE_11__offline__["a" /* CoreRatingOfflineProvider */]])
    ], CoreRatingSyncProvider);
    return CoreRatingSyncProvider;
    var CoreRatingSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_2__classes_base_sync__["a" /* CoreSyncBaseProvider */]));

//# sourceMappingURL=sync.js.map

/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPageProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service that provides some features for page.
 */
var AddonModPageProvider = /** @class */ (function () {
    function AddonModPageProvider(logger, sitesProvider, courseProvider, utils, filepoolProvider, logHelper) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.utils = utils;
        this.filepoolProvider = filepoolProvider;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModPage:';
        this.logger = logger.getInstance('AddonModPageProvider');
    }
    AddonModPageProvider_1 = AddonModPageProvider;
    /**
     * Get a page by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId     Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the book is retrieved.
     */
    AddonModPageProvider.prototype.getPageData = function (courseId, cmId, siteId) {
        return this.getPageByKey(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Get a page.
     *
     * @param {number} courseId  Course ID.
     * @param {string} key       Name of the property to check.
     * @param {any}  value     Value to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}          Promise resolved when the book is retrieved.
     */
    AddonModPageProvider.prototype.getPageByKey = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getPageCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_7__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_page_get_pages_by_courses', params, preSets).then(function (response) {
                if (response && response.pages) {
                    var currentPage = response.pages.find(function (page) {
                        return page[key] == value;
                    });
                    if (currentPage) {
                        return currentPage;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for page data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModPageProvider.prototype.getPageCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'page:' + courseId;
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}
     */
    AddonModPageProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var promises = [];
        promises.push(this.invalidatePageData(courseId, siteId));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModPageProvider_1.COMPONENT, moduleId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates page data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModPageProvider.prototype.invalidatePageData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getPageCacheKey(courseId));
        });
    };
    /**
     * Returns whether or not getPage WS available or not.
     *
     * @return {boolean} If WS is avalaible.
     * @since 3.3
     */
    AddonModPageProvider.prototype.isGetPageWSAvailable = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('mod_page_get_pages_by_courses');
    };
    /**
     * Return whether or not the plugin is enabled.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonModPageProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canDownloadFiles();
        });
    };
    /**
     * Report a page as being viewed.
     *
     * @param {number} id Module ID.
     * @param {string} [name] Name of the page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModPageProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            pageid: id
        };
        return this.logHelper.logSingle('mod_page_view_page', params, AddonModPageProvider_1.COMPONENT, id, name, 'page', {}, siteId);
    };
    AddonModPageProvider.COMPONENT = 'mmaModPage';
    AddonModPageProvider = AddonModPageProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModPageProvider);
    return AddonModPageProvider;
    var AddonModPageProvider_1;
}());

//# sourceMappingURL=page.js.map

/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourceProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service that provides some features for resources.
 */
var AddonModResourceProvider = /** @class */ (function () {
    function AddonModResourceProvider(logger, sitesProvider, courseProvider, filepoolProvider, utils, logHelper) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.filepoolProvider = filepoolProvider;
        this.utils = utils;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModResource:';
        this.logger = logger.getInstance('AddonModResourceProvider');
    }
    AddonModResourceProvider_1 = AddonModResourceProvider;
    /**
     * Get cache key for resource data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModResourceProvider.prototype.getResourceCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'resource:' + courseId;
    };
    /**
     * Get a resource data.
     *
     * @param {number} courseId Course ID.
     * @param {string} key     Name of the property to check.
     * @param {any}  value   Value to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the resource is retrieved.
     */
    AddonModResourceProvider.prototype.getResourceDataByKey = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getResourceCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_7__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_resource_get_resources_by_courses', params, preSets).then(function (response) {
                if (response && response.resources) {
                    var currentResource = response.resources.find(function (resource) {
                        return resource[key] == value;
                    });
                    if (currentResource) {
                        return currentResource;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a resource by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId     Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the resource is retrieved.
     */
    AddonModResourceProvider.prototype.getResourceData = function (courseId, cmId, siteId) {
        return this.getResourceDataByKey(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModResourceProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.invalidateResourceData(courseId, siteId));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModResourceProvider_1.COMPONENT, moduleId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId, 'resource'));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates resource data.
     *
     * @param {number} courseid Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModResourceProvider.prototype.invalidateResourceData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getResourceCacheKey(courseId));
        });
    };
    /**
     * Returns whether or not getResource WS available or not.
     *
     * @return {boolean} If WS is abalaible.
     * @since 3.3
     */
    AddonModResourceProvider.prototype.isGetResourceWSAvailable = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('mod_resource_get_resources_by_courses');
    };
    /**
     * Return whether or not the plugin is enabled.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonModResourceProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canDownloadFiles();
        });
    };
    /**
     * Report the resource as being viewed.
     *
     * @param {number} id Module ID.
     * @param {string} [name] Name of the resource.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModResourceProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            resourceid: id
        };
        return this.logHelper.logSingle('mod_resource_view_resource', params, AddonModResourceProvider_1.COMPONENT, id, name, 'resource', {}, siteId);
    };
    AddonModResourceProvider.COMPONENT = 'mmaModResource';
    AddonModResourceProvider = AddonModResourceProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModResourceProvider);
    return AddonModResourceProvider;
    var AddonModResourceProvider_1;
}());

//# sourceMappingURL=resource.js.map

/***/ }),
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreBlockBaseHandler; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Base handler for blocks.
 *
 * This class is needed because parent classes cannot have @Injectable in Angular v6, so the default handler cannot be a
 * parent class.
 */
var CoreBlockBaseHandler = /** @class */ (function () {
    function CoreBlockBaseHandler() {
        this.name = 'CoreBlockBase';
        this.blockName = 'base';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreBlockBaseHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Returns the data needed to render the block.
     *
     * @param {Injector} injector Injector.
     * @param {any} block The block to render.
     * @param {string} contextLevel The context where the block will be used.
     * @param {number} instanceId The instance ID associated with the context level.
     * @return {CoreBlockHandlerData|Promise<CoreBlockHandlerData>} Data or promise resolved with the data.
     */
    CoreBlockBaseHandler.prototype.getDisplayData = function (injector, block, contextLevel, instanceId) {
        // To be overridden.
        return;
    };
    return CoreBlockBaseHandler;
}());

//# sourceMappingURL=base-block-handler.js.map

/***/ }),
/* 232 */,
/* 233 */,
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreBlockBaseComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__ = __webpack_require__(4);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * Template class to easily create components for blocks.
 */
var CoreBlockBaseComponent = /** @class */ (function () {
    function CoreBlockBaseComponent(injector, loggerName) {
        if (loggerName === void 0) { loggerName = 'AddonBlockComponent'; }
        this.domUtils = injector.get(__WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__["a" /* CoreDomUtilsProvider */]);
        var loggerProvider = injector.get(__WEBPACK_IMPORTED_MODULE_0__providers_logger__["a" /* CoreLoggerProvider */]);
        this.logger = loggerProvider.getInstance(loggerName);
    }
    /**
     * Component being initialized.
     */
    CoreBlockBaseComponent.prototype.ngOnInit = function () {
        this.loaded = false;
        this.loadContent();
    };
    /**
     * Refresh the data.
     *
     * @param {any}       [refresher] Refresher.
     * @param {Function}  [done] Function to call when done.
     * @param {boolean}   [showErrors=false] If show errors to the user of hide them.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreBlockBaseComponent.prototype.doRefresh = function (refresher, done, showErrors) {
        if (showErrors === void 0) { showErrors = false; }
        if (this.loaded) {
            return this.refreshContent(showErrors).finally(function () {
                refresher && refresher.complete();
                done && done();
            });
        }
        return Promise.resolve();
    };
    /**
     * Perform the refresh content function.
     *
     * @param  {boolean}      [showErrors=false] Wether to show errors to the user or hide them.
     * @return {Promise<any>} Resolved when done.
     */
    CoreBlockBaseComponent.prototype.refreshContent = function (showErrors) {
        var _this = this;
        if (showErrors === void 0) { showErrors = false; }
        // Wrap the call in a try/catch so the workflow isn't interrupted if an error occurs.
        var promise;
        try {
            promise = this.invalidateContent();
        }
        catch (ex) {
            // An error ocurred in the function, log the error and just resolve the promise so the workflow continues.
            this.logger.error(ex);
            promise = Promise.resolve();
        }
        return promise.catch(function () {
            // Ignore errors.
        }).then(function () {
            return _this.loadContent(true, showErrors);
        });
    };
    /**
     * Perform the invalidate content function.
     *
     * @return {Promise<any>} Resolved when done.
     */
    CoreBlockBaseComponent.prototype.invalidateContent = function () {
        return Promise.resolve();
    };
    /**
     * Loads the component contents and shows the corresponding error.
     *
     * @param {boolean}       [refresh=false] Whether we're refreshing data.
     * @param  {boolean}      [showErrors=false] Wether to show errors to the user or hide them.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreBlockBaseComponent.prototype.loadContent = function (refresh, showErrors) {
        var _this = this;
        if (showErrors === void 0) { showErrors = false; }
        // Wrap the call in a try/catch so the workflow isn't interrupted if an error occurs.
        var promise;
        try {
            promise = this.fetchContent(refresh);
        }
        catch (ex) {
            // An error ocurred in the function, log the error and just resolve the promise so the workflow continues.
            this.logger.error(ex);
            promise = Promise.resolve();
        }
        return promise.catch(function (error) {
            // Error getting data, fail.
            _this.domUtils.showErrorModalDefault(error, _this.fetchContentDefaultError, true);
        }).finally(function () {
            _this.loaded = true;
        });
    };
    /**
     * Download the component contents.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreBlockBaseComponent.prototype.fetchContent = function (refresh) {
        return Promise.resolve();
    };
    return CoreBlockBaseComponent;
}());

//# sourceMappingURL=base-block-component.js.map

/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFormatDatePipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_time__ = __webpack_require__(24);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Filter to format a date.
 */
var CoreFormatDatePipe = /** @class */ (function () {
    function CoreFormatDatePipe(logger, timeUtils) {
        this.timeUtils = timeUtils;
        this.logger = logger.getInstance('CoreFormatDatePipe');
    }
    /**
     * Format a date.
     *
     * @param {string|number} timestamp Timestamp to format (in milliseconds). If not defined, use current time.
     * @param {string} [format] Format to use. It should be a string code to handle i18n (e.g. core.strftimetime).
     *                          Defaults to strftimedaydatetime.
     * @param {boolean} [convert] If true, convert the format from PHP to Moment. Set it to false for Moment formats.
     * @return {string} Formatted date.
     */
    CoreFormatDatePipe.prototype.transform = function (timestamp, format, convert) {
        timestamp = timestamp || Date.now();
        format = format || 'strftimedaydatetime';
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        // Add "core." if needed.
        if (format.indexOf('strf') == 0 || format.indexOf('df') == 0) {
            format = 'core.' + format;
        }
        if (typeof convert == 'undefined') {
            // Initialize convert param. Set it to false if it's a core.df format, set it to true otherwise.
            convert = format.indexOf('core.df') != 0;
        }
        return this.timeUtils.userDate(timestamp, format, convert);
    };
    CoreFormatDatePipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreFormatDate',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_time__["a" /* CoreTimeUtilsProvider */]])
    ], CoreFormatDatePipe);
    return CoreFormatDatePipe;
}());

//# sourceMappingURL=format-date.js.map

/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreExternalContentDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Directive to handle external content.
 *
 * This directive should be used with any element that links to external content
 * which we want to have available when the app is offline. Typically media and links.
 *
 * If a file is downloaded, its URL will be replaced by the local file URL.
 *
 * From v3.5.2 this directive will also download inline styles, so it can be used in any element as long as it has inline styles.
 */
var CoreExternalContentDirective = /** @class */ (function () {
    function CoreExternalContentDirective(element, logger, filepoolProvider, platform, sitesProvider, domUtils, urlUtils, appProvider, utils) {
        this.filepoolProvider = filepoolProvider;
        this.platform = platform;
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.urlUtils = urlUtils;
        this.appProvider = appProvider;
        this.utils = utils;
        this.initialized = false;
        // This directive can be added dynamically. In that case, the first param is the HTMLElement.
        this.element = element.nativeElement || element;
        this.logger = logger.getInstance('CoreExternalContentDirective');
    }
    /**
     * View has been initialized
     */
    CoreExternalContentDirective.prototype.ngAfterViewInit = function () {
        this.checkAndHandleExternalContent();
        this.initialized = true;
    };
    /**
     * Listen to changes.
     *
     * * @param {{[name: string]: SimpleChange}} changes Changes.
     */
    CoreExternalContentDirective.prototype.ngOnChanges = function (changes) {
        if (changes && this.initialized) {
            // If any of the inputs changes, handle the content again.
            this.checkAndHandleExternalContent();
        }
    };
    /**
     * Add a new source with a certain URL as a sibling of the current element.
     *
     * @param {string} url URL to use in the source.
     */
    CoreExternalContentDirective.prototype.addSource = function (url) {
        if (this.element.tagName !== 'SOURCE') {
            return;
        }
        var newSource = document.createElement('source'), type = this.element.getAttribute('type');
        newSource.setAttribute('src', url);
        if (type) {
            if (this.platform.is('android') && type == 'video/quicktime') {
                // Fix for VideoJS/Chrome bug https://github.com/videojs/video.js/issues/423 .
                newSource.setAttribute('type', 'video/mp4');
            }
            else {
                newSource.setAttribute('type', type);
            }
        }
        this.element.parentNode.insertBefore(newSource, this.element);
    };
    /**
     * Get the URL that should be handled and, if valid, handle it.
     */
    CoreExternalContentDirective.prototype.checkAndHandleExternalContent = function () {
        var _this = this;
        var currentSite = this.sitesProvider.getCurrentSite(), siteId = this.siteId || (currentSite && currentSite.getId()), tagName = this.element.tagName;
        var targetAttr, url;
        // Always handle inline styles (if any).
        this.handleInlineStyles(siteId).catch(function (error) {
            _this.logger.error('Error treating inline styles.', _this.element);
        });
        if (tagName === 'A') {
            targetAttr = 'href';
            url = this.href;
        }
        else if (tagName === 'IMG') {
            targetAttr = 'src';
            url = this.src;
        }
        else if (tagName === 'AUDIO' || tagName === 'VIDEO' || tagName === 'SOURCE' || tagName === 'TRACK') {
            targetAttr = 'src';
            url = this.targetSrc || this.src;
            if (tagName === 'VIDEO') {
                if (this.poster) {
                    // Handle poster.
                    this.handleExternalContent('poster', this.poster, siteId).catch(function () {
                        // Ignore errors.
                    });
                }
            }
        }
        else {
            return;
        }
        this.handleExternalContent(targetAttr, url, siteId).catch(function () {
            // Ignore errors.
        });
    };
    /**
     * Handle external content, setting the right URL.
     *
     * @param {string} targetAttr Attribute to modify.
     * @param {string} url Original URL to treat.
     * @param {string} [siteId] Site ID.
     * @return {Promise<any>} Promise resolved if the element is successfully treated.
     */
    CoreExternalContentDirective.prototype.handleExternalContent = function (targetAttr, url, siteId) {
        var _this = this;
        var tagName = this.element.tagName;
        if (tagName == 'VIDEO' && targetAttr != 'poster') {
            var video = this.element;
            if (video.textTracks) {
                // It's a video with subtitles. In iOS, subtitles position is wrong so it needs to be fixed.
                video.textTracks.onaddtrack = function (event) {
                    var track = event.track;
                    if (track) {
                        track.oncuechange = function () {
                            var line = _this.platform.is('tablet') || _this.platform.is('android') ? 90 : 80;
                            // Position all subtitles to a percentage of video height.
                            Array.from(track.cues).forEach(function (cue) {
                                cue.snapToLines = false;
                                cue.line = line;
                                cue.size = 100; // This solves some Android issue.
                            });
                            // Delete listener.
                            track.oncuechange = null;
                        };
                    }
                };
            }
        }
        if (!url || !url.match(/^https?:\/\//i) || (tagName === 'A' && !this.urlUtils.isDownloadableUrl(url))) {
            this.logger.debug('Ignoring non-downloadable URL: ' + url);
            if (tagName === 'SOURCE') {
                // Restoring original src.
                this.addSource(url);
            }
            return Promise.reject(null);
        }
        // Get the webservice pluginfile URL, we ignore failures here.
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canDownloadFiles() && _this.urlUtils.isPluginFileUrl(url)) {
                _this.element.parentElement.removeChild(_this.element); // Remove element since it'll be broken.
                return Promise.reject(null);
            }
            // Download images, tracks and posters if size is unknown.
            var dwnUnknown = tagName == 'IMG' || tagName == 'TRACK' || targetAttr == 'poster';
            var promise;
            if (targetAttr === 'src' && tagName !== 'SOURCE' && tagName !== 'TRACK' && tagName !== 'VIDEO' &&
                tagName !== 'AUDIO') {
                promise = _this.filepoolProvider.getSrcByUrl(siteId, url, _this.component, _this.componentId, 0, true, dwnUnknown);
            }
            else {
                promise = _this.filepoolProvider.getUrlByUrl(siteId, url, _this.component, _this.componentId, 0, true, dwnUnknown);
            }
            return promise.then(function (finalUrl) {
                if (finalUrl.match(/^https?:\/\//i)) {
                    /* In iOS, if we use the same URL in embedded file and background download then the download only
                       downloads a few bytes (cached ones). Add a hash to the URL so both URLs are different. */
                    finalUrl = finalUrl + '#moodlemobile-embedded';
                }
                _this.logger.debug('Using URL ' + finalUrl + ' for ' + url);
                if (tagName === 'SOURCE') {
                    // The browser does not catch changes in SRC, we need to add a new source.
                    _this.addSource(finalUrl);
                }
                else {
                    _this.element.setAttribute(targetAttr, finalUrl);
                }
                // Set events to download big files (not downloaded automatically).
                if (finalUrl.indexOf('http') === 0 && targetAttr != 'poster' &&
                    (tagName == 'VIDEO' || tagName == 'AUDIO' || tagName == 'A' || tagName == 'SOURCE')) {
                    var eventName = tagName == 'A' ? 'click' : 'play';
                    var clickableEl = _this.element;
                    if (tagName == 'SOURCE') {
                        clickableEl = _this.domUtils.closest(_this.element, 'video,audio');
                        if (!clickableEl) {
                            return;
                        }
                    }
                    clickableEl.addEventListener(eventName, function () {
                        // User played media or opened a downloadable link.
                        // Download the file if in wifi and it hasn't been downloaded already (for big files).
                        if (_this.appProvider.isWifi()) {
                            // We aren't using the result, so it doesn't matter which of the 2 functions we call.
                            _this.filepoolProvider.getUrlByUrl(siteId, url, _this.component, _this.componentId, 0, false);
                        }
                    });
                }
            });
        });
    };
    /**
     * Handle inline styles, trying to download referenced files.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved if the element is successfully treated.
     */
    CoreExternalContentDirective.prototype.handleInlineStyles = function (siteId) {
        var _this = this;
        var inlineStyles = this.element.getAttribute('style');
        if (!inlineStyles) {
            return Promise.resolve();
        }
        var urls = inlineStyles.match(/https?:\/\/[^"'\) ;]*/g);
        if (!urls || !urls.length) {
            return Promise.resolve();
        }
        var promises = [];
        urls = this.utils.uniqueArray(urls); // Remove duplicates.
        urls.forEach(function (url) {
            promises.push(_this.filepoolProvider.getUrlByUrl(siteId, url, _this.component, _this.componentId, 0, true, true)
                .then(function (finalUrl) {
                _this.logger.debug('Using URL ' + finalUrl + ' for ' + url + ' in inline styles');
                inlineStyles = inlineStyles.replace(new RegExp(url, 'gi'), finalUrl);
            }));
        });
        return this.utils.allPromises(promises).then(function () {
            _this.element.setAttribute('style', inlineStyles);
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "siteId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreExternalContentDirective.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "src", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "href", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('target-src'),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "targetSrc", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "poster", void 0);
    CoreExternalContentDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-external-content]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreExternalContentDirective);
    return CoreExternalContentDirective;
}());

//# sourceMappingURL=external-content.js.map

/***/ }),
/* 237 */,
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreRichTextEditorComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__angular_forms__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};









/**
 * Directive to display a rich text editor if enabled.
 *
 * If enabled, this directive will show a rich text editor. Otherwise it'll show a regular textarea.
 *
 * This directive requires an OBJECT model. The text written in the editor or textarea will be stored inside
 * a "text" property in that object. This is to ensure 2-way data-binding, since using a string as a model
 * could be easily broken.
 *
 * Example:
 * <core-rich-text-editor item-content [control]="control" [placeholder]="field.name"></core-rich-text-editor>
 *
 * In the example above, the text written in the editor will be stored in newpost.text.
 */
var CoreRichTextEditorComponent = /** @class */ (function () {
    function CoreRichTextEditorComponent(domUtils, urlUtils, sitesProvider, filepoolProvider, content, elementRef, events, utils, platform) {
        this.domUtils = domUtils;
        this.urlUtils = urlUtils;
        this.sitesProvider = sitesProvider;
        this.filepoolProvider = filepoolProvider;
        this.content = content;
        this.events = events;
        this.utils = utils;
        this.platform = platform;
        // Based on: https://github.com/judgewest2000/Ionic3RichText/
        // @todo: Anchor button, fullscreen...
        // @todo: Textarea height is not being updated when editor is resized. Height is calculated if any css is changed.
        this.placeholder = ''; // Placeholder to set in textarea.
        this.name = 'core-rich-text-editor'; // Name to set to the textarea.
        this.kbHeight = 0; // Last known keyboard height.
        this.minHeight = 200; // Minimum height of the editor.
        this.rteEnabled = false;
        this.editorSupported = true;
        this.contentChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.element = elementRef.nativeElement;
    }
    /**
     * Init editor
     */
    CoreRichTextEditorComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.domUtils.isRichTextEditorEnabled().then(function (enabled) {
            _this.rteEnabled = !!enabled;
        });
        this.editorSupported = this.domUtils.isRichTextEditorSupported();
        // Setup the editor.
        this.editorElement = this.editor.nativeElement;
        this.setContent(this.control.value);
        this.editorElement.onchange = this.onChange.bind(this);
        this.editorElement.onkeyup = this.onChange.bind(this);
        this.editorElement.onpaste = this.onChange.bind(this);
        this.editorElement.oninput = this.onChange.bind(this);
        this.editorElement.onkeydown = this.moveCursor.bind(this);
        // Listen for changes on the control to update the editor (if it is updated from outside of this component).
        this.valueChangeSubscription = this.control.valueChanges.subscribe(function (param) {
            _this.setContent(param);
        });
        // Use paragraph on enter.
        document.execCommand('DefaultParagraphSeparator', false, 'p');
        this.resizeFunction = this.maximizeEditorSize.bind(this);
        window.addEventListener('resize', this.resizeFunction);
        var i = 0;
        this.initHeightInterval = setInterval(function () {
            _this.maximizeEditorSize().then(function (height) {
                if (i >= 5 || height != 0) {
                    clearInterval(_this.initHeightInterval);
                }
                i++;
            });
        }, 750);
        this.keyboardObs = this.events.on(__WEBPACK_IMPORTED_MODULE_7__providers_events__["a" /* CoreEventsProvider */].KEYBOARD_CHANGE, function (kbHeight) {
            _this.kbHeight = kbHeight;
            _this.maximizeEditorSize();
        });
    };
    /**
     * Resize editor to maximize the space occupied.
     *
     * @return {Promise<number>} Resolved with calculated editor size.
     */
    CoreRichTextEditorComponent.prototype.maximizeEditorSize = function () {
        var _this = this;
        this.content.resize();
        var deferred = this.utils.promiseDefer();
        setTimeout(function () {
            var contentVisibleHeight = _this.domUtils.getContentHeight(_this.content) - _this.kbHeight;
            if (contentVisibleHeight <= 0) {
                deferred.resolve(0);
                return;
            }
            setTimeout(function () {
                // Editor is ready, adjust Height if needed.
                var height;
                if (_this.platform.is('android')) {
                    // Android, ignore keyboard height because web view is resized.
                    height = _this.domUtils.getContentHeight(_this.content) - _this.getSurroundingHeight(_this.element);
                }
                else if (_this.platform.is('ios') && _this.kbHeight > 0) {
                    // Keyboard open in iOS.
                    // In this case, the header disappears or is scrollable, so we need to adjust the calculations.
                    height = window.innerHeight - _this.getSurroundingHeight(_this.element);
                    if (_this.element.getBoundingClientRect().top < 40) {
                        // In iOS sometimes the editor is placed below the status bar. Move the scroll a bit so it doesn't happen.
                        window.scrollTo(window.scrollX, window.scrollY - 40);
                    }
                }
                else {
                    // Header is fixed, use the content to calculate the editor height.
                    height = _this.domUtils.getContentHeight(_this.content) - _this.kbHeight - _this.getSurroundingHeight(_this.element);
                }
                if (height > _this.minHeight) {
                    _this.element.style.height = _this.domUtils.formatPixelsSize(height);
                }
                else {
                    _this.element.style.height = '';
                }
                deferred.resolve(height);
            }, 100);
        }, 100);
        return deferred.promise;
    };
    /**
     * Get the height of the surrounding elements from the current to the top element.
     *
     * @param  {any} element Directive DOM element to get surroundings elements from.
     * @return {number}      Surrounding height in px.
     */
    CoreRichTextEditorComponent.prototype.getSurroundingHeight = function (element) {
        var height = 0;
        while (element.parentNode && element.parentNode.tagName != 'ION-CONTENT') {
            var parent_1 = element.parentNode;
            if (element.tagName && element.tagName != 'CORE-LOADING') {
                for (var x = 0; x < parent_1.childNodes.length; x++) {
                    var child = parent_1.childNodes[x];
                    if (child.tagName && child != element) {
                        height += this.domUtils.getElementHeight(child, false, true, true);
                    }
                }
            }
            element = parent_1;
        }
        var cs = getComputedStyle(element);
        height += this.domUtils.getComputedStyleMeasure(cs, 'paddingTop') +
            this.domUtils.getComputedStyleMeasure(cs, 'paddingBottom');
        if (element && element.parentNode && element.parentNode.tagName == 'ION-CONTENT') {
            var cs2 = getComputedStyle(element);
            height -= this.domUtils.getComputedStyleMeasure(cs2, 'paddingTop') +
                this.domUtils.getComputedStyleMeasure(cs2, 'paddingBottom');
        }
        return height;
    };
    /**
     * On change function to sync with form data.
     *
     * @param {Event} $event The event.
     */
    CoreRichTextEditorComponent.prototype.onChange = function ($event) {
        if (this.rteEnabled) {
            if (this.isNullOrWhiteSpace(this.editorElement.innerText)) {
                this.clearText();
            }
            else {
                // The textarea and the form control must receive the original URLs.
                this.restoreExternalContent();
                // Don't emit event so our valueChanges doesn't get notified by this change.
                this.control.setValue(this.editorElement.innerHTML, { emitEvent: false });
                this.control.markAsDirty();
                this.textarea.value = this.editorElement.innerHTML;
                // Treat URLs again for the editor.
                this.treatExternalContent();
            }
        }
        else {
            if (this.isNullOrWhiteSpace(this.textarea.value)) {
                this.clearText();
            }
            else {
                // Don't emit event so our valueChanges doesn't get notified by this change.
                this.control.setValue(this.textarea.value, { emitEvent: false });
                this.control.markAsDirty();
            }
        }
        this.contentChanged.emit(this.control.value);
    };
    /**
     * On key down function to move the cursor.
     * https://stackoverflow.com/questions/6249095/how-to-set-caretcursor-position-in-contenteditable-element-div
     *
     * @param {Event} $event The event.
     */
    CoreRichTextEditorComponent.prototype.moveCursor = function ($event) {
        if (!this.rteEnabled) {
            return;
        }
        if ($event['key'] != 'ArrowLeft' && $event['key'] != 'ArrowRight') {
            return;
        }
        $event.preventDefault();
        $event.stopPropagation();
        var move = $event['key'] == 'ArrowLeft' ? -1 : +1, cursor = this.getCurrentCursorPosition(this.editorElement);
        this.setCurrentCursorPosition(this.editorElement, cursor + move);
    };
    /**
     * Returns the number of chars from the beggining where is placed the cursor.
     *
     * @param  {Node}   parent Parent where to get the position from.
     * @return {number}        Position in chars.
     */
    CoreRichTextEditorComponent.prototype.getCurrentCursorPosition = function (parent) {
        var selection = window.getSelection();
        var charCount = -1, node;
        if (selection.focusNode) {
            if (parent.contains(selection.focusNode)) {
                node = selection.focusNode;
                charCount = selection.focusOffset;
                while (node) {
                    if (node.isSameNode(parent)) {
                        break;
                    }
                    if (node.previousSibling) {
                        node = node.previousSibling;
                        charCount += node.textContent.length;
                    }
                    else {
                        node = node.parentNode;
                        if (node === null) {
                            break;
                        }
                    }
                }
            }
        }
        return charCount;
    };
    /**
     * Set the caret position on the character number.
     *
     * @param {Node}   parent   Parent where to set the position.
     * @param {number} [chars]  Number of chars where to place the caret. If not defined it will go to the end.
     */
    CoreRichTextEditorComponent.prototype.setCurrentCursorPosition = function (parent, chars) {
        /**
         * Loops round all the child text nodes within the supplied node and sets a range from the start of the initial node to
         * the characters.
         *
         * @param  {Node}  node  Node where to start.
         * @param  {Range} range Previous calculated range.
         * @param  {any}   chars Object with counting of characters (input-output param).
         * @return {Range}       Selection range.
         */
        var setRange = function (node, range, chars) {
            if (chars.count === 0) {
                range.setEnd(node, 0);
            }
            else if (node && chars.count > 0) {
                if (node.hasChildNodes()) {
                    // Navigate through children.
                    for (var lp = 0; lp < node.childNodes.length; lp++) {
                        range = setRange(node.childNodes[lp], range, chars);
                        if (chars.count === 0) {
                            break;
                        }
                    }
                }
                else if (node.textContent.length < chars.count) {
                    // Jump this node.
                    // @todo: empty nodes will be omitted.
                    chars.count -= node.textContent.length;
                }
                else {
                    // The cursor will be placed in this element.
                    range.setEnd(node, chars.count);
                    chars.count = 0;
                }
            }
            return range;
        };
        var range = document.createRange();
        if (typeof chars === 'undefined') {
            // Select all so it will go to the end.
            range.selectNode(parent);
            range.selectNodeContents(parent);
        }
        else if (chars < 0 || chars > parent.textContent.length) {
            return;
        }
        else {
            range.selectNode(parent);
            range.setStart(parent, 0);
            range = setRange(parent, range, { count: chars });
        }
        if (range) {
            var selection = window.getSelection();
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    };
    /**
     * Toggle from rte editor to textarea syncing values.
     *
     * @param {Event} $event The event.
     */
    CoreRichTextEditorComponent.prototype.toggleEditor = function ($event) {
        var _this = this;
        $event.preventDefault();
        $event.stopPropagation();
        this.setContent(this.control.value);
        this.rteEnabled = !this.rteEnabled;
        // Set focus and cursor at the end.
        setTimeout(function () {
            if (_this.rteEnabled) {
                _this.editorElement.focus();
            }
            else {
                _this.textarea.setFocus();
            }
        });
    };
    /**
     * Treat elements that can contain external content.
     * We only search for images because the editor should receive unfiltered text, so the multimedia filter won't be applied.
     * Treating videos and audios in here is complex, so if a user manually adds one he won't be able to play it in the editor.
     */
    CoreRichTextEditorComponent.prototype.treatExternalContent = function () {
        var _this = this;
        if (!this.sitesProvider.isLoggedIn()) {
            // Only treat external content if the user is logged in.
            return;
        }
        var elements = Array.from(this.editorElement.querySelectorAll('img')), siteId = this.sitesProvider.getCurrentSiteId(), canDownloadFiles = this.sitesProvider.getCurrentSite().canDownloadFiles();
        elements.forEach(function (el) {
            if (el.getAttribute('data-original-src')) {
                // Already treated.
                return;
            }
            var url = el.src;
            if (!url || !_this.urlUtils.isDownloadableUrl(url) || (!canDownloadFiles && _this.urlUtils.isPluginFileUrl(url))) {
                // Nothing to treat.
                return;
            }
            // Check if it's downloaded.
            return _this.filepoolProvider.getSrcByUrl(siteId, url, _this.component, _this.componentId).then(function (finalUrl) {
                // Check again if it's already treated, this function can be called concurrently more than once.
                if (!el.getAttribute('data-original-src')) {
                    el.setAttribute('data-original-src', el.src);
                    el.setAttribute('src', finalUrl);
                }
            });
        });
    };
    /**
     * Reverts changes made by treatExternalContent.
     */
    CoreRichTextEditorComponent.prototype.restoreExternalContent = function () {
        var elements = Array.from(this.editorElement.querySelectorAll('img'));
        elements.forEach(function (el) {
            var originalUrl = el.getAttribute('data-original-src');
            if (originalUrl) {
                el.setAttribute('src', originalUrl);
                el.removeAttribute('data-original-src');
            }
        });
    };
    /**
     * Check if text is empty.
     * @param {string} value text
     */
    CoreRichTextEditorComponent.prototype.isNullOrWhiteSpace = function (value) {
        if (value == null || typeof value == 'undefined') {
            return true;
        }
        value = value.replace(/[\n\r]/g, '');
        value = value.split(' ').join('');
        return value.length === 0;
    };
    /**
     * Set the content of the textarea and the editor element.
     *
     * @param {string} value New content.
     */
    CoreRichTextEditorComponent.prototype.setContent = function (value) {
        if (this.isNullOrWhiteSpace(value)) {
            this.editorElement.innerHTML = '<p></p>';
            this.textarea.value = '';
        }
        else {
            this.editorElement.innerHTML = value;
            this.textarea.value = value;
            this.treatExternalContent();
        }
    };
    /**
     * Clear the text.
     */
    CoreRichTextEditorComponent.prototype.clearText = function () {
        var _this = this;
        this.setContent(null);
        // Don't emit event so our valueChanges doesn't get notified by this change.
        this.control.setValue(null, { emitEvent: false });
        setTimeout(function () {
            if (_this.rteEnabled) {
                _this.setCurrentCursorPosition(_this.editorElement);
            }
        }, 1);
    };
    /**
     * Execute an action over the selected text.
     *  API docs: https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand
     *
     * @param {any} $event Event data
     * @param {string} command Command to execute.
     */
    CoreRichTextEditorComponent.prototype.buttonAction = function ($event, command) {
        $event.preventDefault();
        $event.stopPropagation();
        if (command) {
            if (command.includes('|')) {
                var parameters = command.split('|')[1];
                command = command.split('|')[0];
                document.execCommand(command, false, parameters);
            }
            else {
                document.execCommand(command, false);
            }
        }
    };
    /**
     * Component being destroyed.
     */
    CoreRichTextEditorComponent.prototype.ngOnDestroy = function () {
        this.valueChangeSubscription && this.valueChangeSubscription.unsubscribe();
        window.removeEventListener('resize', this.resizeFunction);
        clearInterval(this.initHeightInterval);
        this.keyboardObs && this.keyboardObs.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreRichTextEditorComponent.prototype, "placeholder", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_8__angular_forms__["e" /* FormControl */])
    ], CoreRichTextEditorComponent.prototype, "control", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreRichTextEditorComponent.prototype, "name", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreRichTextEditorComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreRichTextEditorComponent.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreRichTextEditorComponent.prototype, "contentChanged", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('editor'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreRichTextEditorComponent.prototype, "editor", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('textarea'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["C" /* TextInput */])
    ], CoreRichTextEditorComponent.prototype, "textarea", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('decorate'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreRichTextEditorComponent.prototype, "decorate", void 0);
    CoreRichTextEditorComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-rich-text-editor',
            templateUrl: 'core-rich-text-editor.html'
        }),
        __param(4, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["f" /* Content */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_7__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["v" /* Platform */]])
    ], CoreRichTextEditorComponent);
    return CoreRichTextEditorComponent;
}());

//# sourceMappingURL=rich-text-editor.js.map

/***/ }),
/* 239 */,
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFeedbackHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__feedback__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_contentlinks_providers_helper__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service that provides helper functions for feedbacks.
 */
var AddonModFeedbackHelperProvider = /** @class */ (function () {
    function AddonModFeedbackHelperProvider(feedbackProvider, userProvider, textUtils, translate, timeUtils, domUtils, courseProvider, linkHelper, sitesProvider, utils) {
        this.feedbackProvider = feedbackProvider;
        this.userProvider = userProvider;
        this.textUtils = textUtils;
        this.translate = translate;
        this.timeUtils = timeUtils;
        this.domUtils = domUtils;
        this.courseProvider = courseProvider;
        this.linkHelper = linkHelper;
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.MODE_RESPONSETIME = 1;
        this.MODE_COURSE = 2;
        this.MODE_CATEGORY = 3;
    }
    /**
     * Check if the page we are going to open is in the history and returns the view controller in the stack to go back.
     *
     * @param {string} pageName       Name of the page we want to navigate.
     * @param {number} instance       Activity instance Id. I.e FeedbackId.
     * @param {string} paramName      Param name where to find the instance number.
     * @param {string} prefix         Prefix to check if we are out of the activity context.
     * @param {NavController} navCtrl Nav Controller of the view.
     * @return {ViewController}   Returns view controller found or null.
     */
    AddonModFeedbackHelperProvider.prototype.getPageView = function (pageName, instance, paramName, prefix, navCtrl) {
        var historyInstance, params, view = navCtrl.getActive();
        while (!view.isFirst()) {
            if (!view.name.startsWith(prefix)) {
                break;
            }
            params = view.getNavParams();
            historyInstance = params.get(paramName) ? params.get(paramName) : params.get('module').instance;
            // Check we are not changing to another activity.
            if (!historyInstance || historyInstance != instance) {
                break;
            }
            // Page found.
            if (view.name == pageName) {
                return view;
            }
            view = navCtrl.getPrevious(view);
        }
        return null;
    };
    /**
     * Retrieves a list of students who didn't submit the feedback with extra info.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    groupId         Group id, 0 means that the function will determine the user group.
     * @param   {number}    page            The page of records to return.
     * @return  {Promise<any>}              Promise resolved when the info is retrieved.
     */
    AddonModFeedbackHelperProvider.prototype.getNonRespondents = function (feedbackId, groupId, page) {
        var _this = this;
        return this.feedbackProvider.getNonRespondents(feedbackId, groupId, page).then(function (responses) {
            return _this.addImageProfileToAttempts(responses.users).then(function (users) {
                responses.users = users;
                return responses;
            });
        });
    };
    /**
     * Get page items responses to be sent.
     *
     * @param   {any[]} items    Items where the values are.
     * @return  {any}            Responses object to be sent.
     */
    AddonModFeedbackHelperProvider.prototype.getPageItemsResponses = function (items) {
        var responses = {};
        items.forEach(function (itemData) {
            var answered = false;
            itemData.hasError = false;
            if (itemData.typ == 'captcha') {
                var value = itemData.value || '', name_1 = itemData.typ + '_' + itemData.id;
                answered = !!value;
                responses[name_1] = 1;
                responses['g-recaptcha-response'] = value;
                responses['recaptcha_element'] = 'dummyvalue';
                if (itemData.required && !answered) {
                    // Check if it has any value.
                    itemData.isEmpty = true;
                }
                else {
                    itemData.isEmpty = false;
                }
            }
            else if (itemData.hasvalue) {
                var name_2, value_1;
                var nameTemp_1 = itemData.typ + '_' + itemData.id;
                if (itemData.typ == 'multichoice' && itemData.subtype == 'c') {
                    name_2 = nameTemp_1 + '[0]';
                    responses[name_2] = 0;
                    itemData.choices.forEach(function (choice, index) {
                        name_2 = nameTemp_1 + '[' + (index + 1) + ']';
                        value_1 = choice.checked ? choice.value : 0;
                        if (!answered && value_1) {
                            answered = true;
                        }
                        responses[name_2] = value_1;
                    });
                }
                else {
                    if (itemData.typ == 'multichoice' && itemData.subtype != 'r') {
                        name_2 = nameTemp_1 + '[0]';
                    }
                    else {
                        name_2 = nameTemp_1;
                    }
                    if (itemData.typ == 'multichoice' || itemData.typ == 'multichoicerated') {
                        value_1 = itemData.value || 0;
                    }
                    else if (itemData.typ == 'numeric') {
                        value_1 = itemData.value || itemData.value == 0 ? itemData.value : '';
                        if (value_1 != '') {
                            if ((itemData.rangefrom != '' && value_1 < itemData.rangefrom) ||
                                (itemData.rangeto != '' && value_1 > itemData.rangeto)) {
                                itemData.hasError = true;
                            }
                        }
                    }
                    else {
                        value_1 = itemData.value || itemData.value == 0 ? itemData.value : '';
                    }
                    answered = !!value_1;
                    responses[name_2] = value_1;
                }
                if (itemData.required && !answered) {
                    // Check if it has any value.
                    itemData.isEmpty = true;
                }
                else {
                    itemData.isEmpty = false;
                }
            }
        });
        return responses;
    };
    /**
     * Returns the feedback user responses with extra info.
     *
     * @param   {number}    feedbackId      Feedback ID.
     * @param   {number}    groupId         Group id, 0 means that the function will determine the user group.
     * @param   {number}    page            The page of records to return.
     * @return  {Promise<any>}              Promise resolved when the info is retrieved.
     */
    AddonModFeedbackHelperProvider.prototype.getResponsesAnalysis = function (feedbackId, groupId, page) {
        var _this = this;
        return this.feedbackProvider.getResponsesAnalysis(feedbackId, groupId, page).then(function (responses) {
            return _this.addImageProfileToAttempts(responses.attempts).then(function (attempts) {
                responses.attempts = attempts;
                return responses;
            });
        });
    };
    /**
     * Handle a show entries link.
     *
     * @param {NavController} navCtrl Nav controller to use to navigate. Can be undefined/null.
     * @param {any} params URL params.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModFeedbackHelperProvider.prototype.handleShowEntriesLink = function (navCtrl, params, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var modal = this.domUtils.showModalLoading(), moduleId = params.id;
        return this.courseProvider.getModuleBasicInfo(moduleId, siteId).then(function (module) {
            var stateParams;
            if (typeof params.showcompleted == 'undefined') {
                // Param showcompleted not defined. Show entry list.
                stateParams = {
                    module: module,
                    courseId: module.course
                };
                return _this.linkHelper.goInSite(navCtrl, 'AddonModFeedbackRespondentsPage', stateParams, siteId);
            }
            return _this.feedbackProvider.getAttempt(module.instance, params.showcompleted, true, siteId).then(function (attempt) {
                stateParams = {
                    moduleId: module.id,
                    attempt: attempt,
                    feedbackId: module.instance,
                    courseId: module.course
                };
                return _this.linkHelper.goInSite(navCtrl, 'AddonModFeedbackAttemptPage', stateParams, siteId);
            });
        }).finally(function () {
            modal.dismiss();
        });
    };
    /**
     * Add Image profile url field on attempts
     *
     * @param  {any}          attempts Attempts array to get profile from.
     * @return {Promise<any>}          Returns the same array with the profileimageurl added if found.
     */
    AddonModFeedbackHelperProvider.prototype.addImageProfileToAttempts = function (attempts) {
        var _this = this;
        var promises = attempts.map(function (attempt) {
            return _this.userProvider.getProfile(attempt.userid, attempt.courseid, true).then(function (user) {
                attempt.profileimageurl = user.profileimageurl;
            }).catch(function () {
                // Error getting profile, resolve promise without adding any extra data.
            });
        });
        return Promise.all(promises).then(function () {
            return attempts;
        });
    };
    /**
     * Helper function to open a feature in the app.
     *
     * @param {string}        feature   Name of the feature to open.
     * @param {NavController} navCtrl   NavController.
     * @param {any}           module    Course module activity object.
     * @param {number}        courseId  Course Id.
     * @param {number}        [group=0] Course module activity object.
     * @return {Promise<void>}    Resolved when navigation animation is done.
     */
    AddonModFeedbackHelperProvider.prototype.openFeature = function (feature, navCtrl, module, courseId, group) {
        if (group === void 0) { group = 0; }
        var pageName = feature && feature != 'analysis' ? 'AddonModFeedback' + feature + 'Page' : 'AddonModFeedbackIndexPage', stateParams = {
            module: module,
            moduleId: module.id,
            courseId: courseId,
            feedbackId: module.instance,
            group: group
        };
        // Only check history if navigating through tabs.
        if (pageName == 'AddonModFeedbackIndexPage') {
            stateParams['tab'] = feature == 'analysis' ? 'analysis' : 'overview';
            var view = this.getPageView(pageName, module.instance, 'feedbackId', 'AddonModFeedback', navCtrl);
            if (view) {
                // Go back to the found page.
                return navCtrl.popTo(view);
            }
        }
        // Not found, open new state.
        return navCtrl.push(pageName, stateParams);
    };
    /**
     * Helper funtion for item type Label.
     *
     * @param  {any} item Item to process.
     * @return {any}      Item processed to show form.
     */
    AddonModFeedbackHelperProvider.prototype.getItemFormLabel = function (item) {
        item.template = 'label';
        item.name = '';
        item.presentation = this.textUtils.replacePluginfileUrls(item.presentation, item.itemfiles);
        return item;
    };
    /**
     * Helper funtion for item type Info.
     *
     * @param  {any} item Item to process.
     * @return {any}      Item processed to show form.
     */
    AddonModFeedbackHelperProvider.prototype.getItemFormInfo = function (item) {
        item.template = 'label';
        var type = parseInt(item.presentation, 10);
        if (type == this.MODE_COURSE || type == this.MODE_CATEGORY) {
            item.presentation = item.otherdata;
            item.value = typeof item.rawValue != 'undefined' ? item.rawValue : item.otherdata;
        }
        else if (type == this.MODE_RESPONSETIME) {
            item.value = '__CURRENT__TIMESTAMP__';
            var tempValue = typeof item.rawValue != 'undefined' ? item.rawValue * 1000 : new Date().getTime();
            item.presentation = this.timeUtils.userDate(tempValue);
        }
        else {
            // Errors on item, return false.
            return false;
        }
        return item;
    };
    /**
     * Helper funtion for item type Numeric.
     *
     * @param  {any} item Item to process.
     * @return {any}      Item processed to show form.
     */
    AddonModFeedbackHelperProvider.prototype.getItemFormNumeric = function (item) {
        item.template = 'numeric';
        var range = item.presentation.split(__WEBPACK_IMPORTED_MODULE_1__feedback__["a" /* AddonModFeedbackProvider */].LINE_SEP) || [];
        range[0] = range.length > 0 ? parseInt(range[0], 10) : undefined;
        range[1] = range.length > 1 ? parseInt(range[1], 10) : undefined;
        item.rangefrom = typeof range[0] == 'number' && !isNaN(range[0]) ? range[0] : '';
        item.rangeto = typeof range[1] == 'number' && !isNaN(range[1]) ? range[1] : '';
        item.value = typeof item.rawValue != 'undefined' ? parseFloat(item.rawValue) : '';
        item.postfix = this.getNumericBoundariesForDisplay(item.rangefrom, item.rangeto);
        return item;
    };
    /**
     * Helper funtion for item type Text field.
     *
     * @param  {any} item Item to process.
     * @return {any}      Item processed to show form.
     */
    AddonModFeedbackHelperProvider.prototype.getItemFormTextfield = function (item) {
        item.template = 'textfield';
        item.length = item.presentation.split(__WEBPACK_IMPORTED_MODULE_1__feedback__["a" /* AddonModFeedbackProvider */].LINE_SEP)[1] || 255;
        item.value = typeof item.rawValue != 'undefined' ? item.rawValue : '';
        return item;
    };
    /**
     * Helper funtion for item type Textarea.
     *
     * @param  {any} item Item to process.
     * @return {any}      Item processed to show form.
     */
    AddonModFeedbackHelperProvider.prototype.getItemFormTextarea = function (item) {
        item.template = 'textarea';
        item.value = typeof item.rawValue != 'undefined' ? item.rawValue : '';
        return item;
    };
    /**
     * Helper funtion for item type Multichoice.
     *
     * @param  {any} item Item to process.
     * @return {any}      Item processed to show form.
     */
    AddonModFeedbackHelperProvider.prototype.getItemFormMultichoice = function (item) {
        var parts = item.presentation.split(__WEBPACK_IMPORTED_MODULE_1__feedback__["a" /* AddonModFeedbackProvider */].MULTICHOICE_TYPE_SEP) || [];
        item.subtype = parts.length > 0 && parts[0] ? parts[0] : 'r';
        item.template = 'multichoice-' + item.subtype;
        item.presentation = parts.length > 1 ? parts[1] : '';
        if (item.subtype != 'd') {
            parts = item.presentation.split(__WEBPACK_IMPORTED_MODULE_1__feedback__["a" /* AddonModFeedbackProvider */].MULTICHOICE_ADJUST_SEP) || [];
            item.presentation = parts.length > 0 ? parts[0] : '';
            // Horizontal are not supported right now. item.horizontal = parts.length > 1 && !!parts[1];
        }
        item.choices = item.presentation.split(__WEBPACK_IMPORTED_MODULE_1__feedback__["a" /* AddonModFeedbackProvider */].LINE_SEP) || [];
        item.choices = item.choices.map(function (choice, index) {
            var weightValue = choice.split(__WEBPACK_IMPORTED_MODULE_1__feedback__["a" /* AddonModFeedbackProvider */].MULTICHOICERATED_VALUE_SEP) || [''];
            choice = weightValue.length == 1 ? weightValue[0] : '(' + weightValue[0] + ') ' + weightValue[1];
            return { value: index + 1, label: choice };
        });
        if (item.subtype === 'r' && item.options.search(__WEBPACK_IMPORTED_MODULE_1__feedback__["a" /* AddonModFeedbackProvider */].MULTICHOICE_HIDENOSELECT) == -1) {
            item.choices.unshift({ value: 0, label: this.translate.instant('addon.mod_feedback.not_selected') });
            item.value = typeof item.rawValue != 'undefined' ? parseInt(item.rawValue, 10) : 0;
        }
        else if (item.subtype === 'd') {
            item.choices.unshift({ value: 0, label: '' });
            item.value = typeof item.rawValue != 'undefined' ? parseInt(item.rawValue, 10) : 0;
        }
        else if (item.subtype === 'c') {
            if (typeof item.rawValue == 'undefined') {
                item.value = '';
            }
            else {
                item.rawValue = '' + item.rawValue;
                var values_1 = item.rawValue.split(__WEBPACK_IMPORTED_MODULE_1__feedback__["a" /* AddonModFeedbackProvider */].LINE_SEP);
                item.choices.forEach(function (choice) {
                    for (var x in values_1) {
                        if (choice.value == values_1[x]) {
                            choice.checked = true;
                            return;
                        }
                    }
                });
            }
        }
        else {
            item.value = typeof item.rawValue != 'undefined' ? parseInt(item.rawValue, 10) : '';
        }
        return item;
    };
    /**
     * Helper funtion for item type Captcha.
     *
     * @param  {any} item Item to process.
     * @return {any}      Item processed to show form.
     */
    AddonModFeedbackHelperProvider.prototype.getItemFormCaptcha = function (item) {
        var data = this.textUtils.parseJSON(item.otherdata);
        if (data && data.length > 3) {
            item.captcha = {
                recaptchapublickey: data[3]
            };
        }
        item.template = 'captcha';
        item.value = '';
        return item;
    };
    /**
     * Process and returns item to print form.
     *
     * @param {any}  item        Item to process.
     * @param {boolean} preview  Previewing options.
     * @return {any}             Item processed to show form.
     */
    AddonModFeedbackHelperProvider.prototype.getItemForm = function (item, preview) {
        switch (item.typ) {
            case 'label':
                return this.getItemFormLabel(item);
            case 'info':
                return this.getItemFormInfo(item);
            case 'numeric':
                return this.getItemFormNumeric(item);
            case 'textfield':
                return this.getItemFormTextfield(item);
            case 'textarea':
                return this.getItemFormTextarea(item);
            case 'multichoice':
                return this.getItemFormMultichoice(item);
            case 'multichoicerated':
                return this.getItemFormMultichoice(item);
            case 'pagebreak':
                if (!preview) {
                    // Pagebreaks are only used on preview.
                    return false;
                }
                break;
            case 'captcha':
                // Captcha is not supported right now. However label will be shown.
                return this.getItemFormCaptcha(item);
            default:
                return false;
        }
        return item;
    };
    /**
     * Returns human-readable boundaries (min - max).
     * Based on Moodle's get_boundaries_for_display.
     *
     * @param {number} rangeFrom Range from.
     * @param {number} rangeTo Range to.
     * @return {string} Human-readable boundaries.
     */
    AddonModFeedbackHelperProvider.prototype.getNumericBoundariesForDisplay = function (rangeFrom, rangeTo) {
        var rangeFromSet = typeof rangeFrom == 'number', rangeToSet = typeof rangeTo == 'number';
        if (!rangeFromSet && rangeToSet) {
            return ' (' + this.translate.instant('addon.mod_feedback.maximal') + ': ' + this.utils.formatFloat(rangeTo) + ')';
        }
        else if (rangeFromSet && !rangeToSet) {
            return ' (' + this.translate.instant('addon.mod_feedback.minimal') + ': ' + this.utils.formatFloat(rangeFrom) + ')';
        }
        else if (!rangeFromSet && !rangeToSet) {
            return '';
        }
        return ' (' + this.utils.formatFloat(rangeFrom) + ' - ' + this.utils.formatFloat(rangeTo) + ')';
    };
    AddonModFeedbackHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__feedback__["a" /* AddonModFeedbackProvider */], __WEBPACK_IMPORTED_MODULE_2__core_user_providers_user__["a" /* CoreUserProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_4__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonModFeedbackHelperProvider);
    return AddonModFeedbackHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModQuizHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__quiz__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__quiz_offline__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__access_rules_delegate__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_course_providers_helper__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_contentlinks_providers_helper__ = __webpack_require__(16);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Helper service that provides some features for quiz.
 */
var AddonModQuizHelperProvider = /** @class */ (function () {
    function AddonModQuizHelperProvider(domUtils, translate, utils, accessRuleDelegate, quizProvider, modalCtrl, quizOfflineProvider, courseHelper, sitesProvider, linkHelper) {
        this.domUtils = domUtils;
        this.translate = translate;
        this.utils = utils;
        this.accessRuleDelegate = accessRuleDelegate;
        this.quizProvider = quizProvider;
        this.modalCtrl = modalCtrl;
        this.quizOfflineProvider = quizOfflineProvider;
        this.courseHelper = courseHelper;
        this.sitesProvider = sitesProvider;
        this.linkHelper = linkHelper;
    }
    /**
     * Validate a preflight data or show a modal to input the preflight data if required.
     * It calls AddonModQuizProvider.startAttempt if a new attempt is needed.
     *
     * @param {any} quiz Quiz.
     * @param {any} accessInfo Quiz access info returned by AddonModQuizProvider.getQuizAccessInformation.
     * @param {any} preflightData Object where to store the preflight data.
     * @param {any} [attempt] Attempt to continue. Don't pass any value if the user needs to start a new attempt.
     * @param {boolean} [offline] Whether the attempt is offline.
     * @param {boolean} [prefetch] Whether user is prefetching.
     * @param {string} [title] The title to display in the modal and in the submit button.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [retrying] Whether we're retrying after a failure.
     * @return {Promise<any>} Promise resolved when the preflight data is validated. The resolve param is the attempt.
     */
    AddonModQuizHelperProvider.prototype.getAndCheckPreflightData = function (quiz, accessInfo, preflightData, attempt, offline, prefetch, title, siteId, retrying) {
        var _this = this;
        var rules = accessInfo && accessInfo.activerulenames;
        var isPreflightCheckRequired = false;
        // Check if the user needs to input preflight data.
        return this.accessRuleDelegate.isPreflightCheckRequired(rules, quiz, attempt, prefetch, siteId).then(function (required) {
            isPreflightCheckRequired = required;
            if (required) {
                // Preflight check is required but no preflightData has been sent. Show a modal with the preflight form.
                return _this.getPreflightData(quiz, accessInfo, attempt, prefetch, title, siteId).then(function (data) {
                    // Data entered by the user, add it to preflight data and check it again.
                    Object.assign(preflightData, data);
                });
            }
        }).then(function () {
            // Get some fixed preflight data from access rules (data that doesn't require user interaction).
            return _this.accessRuleDelegate.getFixedPreflightData(rules, quiz, preflightData, attempt, prefetch, siteId);
        }).then(function () {
            // All the preflight data is gathered, now validate it.
            return _this.validatePreflightData(quiz, accessInfo, preflightData, attempt, offline, prefetch, siteId)
                .catch(function (error) {
                if (prefetch) {
                    return Promise.reject(error);
                }
                else if (retrying && !isPreflightCheckRequired) {
                    // We're retrying after a failure, but the preflight check wasn't required.
                    // This means there's something wrong with some access rule or user is offline and data isn't cached.
                    // Don't retry again because it would lead to an infinite loop.
                    return Promise.reject(error);
                }
                else {
                    // Show error and ask for the preflight again.
                    // Wait to show the error because we want it to be shown over the preflight modal.
                    setTimeout(function () {
                        _this.domUtils.showErrorModalDefault(error, 'core.error', true);
                    }, 100);
                    return _this.getAndCheckPreflightData(quiz, accessInfo, preflightData, attempt, offline, prefetch, title, siteId, true);
                }
            });
        });
    };
    /**
     * Get the preflight data from the user using a modal.
     *
     * @param {any} quiz Quiz.
     * @param {any} accessInfo Quiz access info returned by AddonModQuizProvider.getQuizAccessInformation.
     * @param {any} [attempt] The attempt started/continued. If not supplied, user is starting a new attempt.
     * @param {boolean} [prefetch] Whether the user is prefetching the quiz.
     * @param {string} [title] The title to display in the modal and in the submit button.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the preflight data. Rejected if user cancels.
     */
    AddonModQuizHelperProvider.prototype.getPreflightData = function (quiz, accessInfo, attempt, prefetch, title, siteId) {
        var _this = this;
        var notSupported = [];
        // Check if there is any unsupported rule.
        accessInfo.activerulenames.forEach(function (rule) {
            if (!_this.accessRuleDelegate.isAccessRuleSupported(rule)) {
                notSupported.push(rule);
            }
        });
        if (notSupported.length) {
            return Promise.reject(this.translate.instant('addon.mod_quiz.errorrulesnotsupported') + ' ' +
                JSON.stringify(notSupported));
        }
        // Create and show the modal.
        var modal = this.modalCtrl.create('AddonModQuizPreflightModalPage', {
            title: title,
            quiz: quiz,
            attempt: attempt,
            prefetch: !!prefetch,
            siteId: siteId,
            rules: accessInfo.activerulenames
        });
        modal.present();
        // Wait for modal to be dismissed.
        return new Promise(function (resolve, reject) {
            modal.onDidDismiss(function (data) {
                if (typeof data != 'undefined') {
                    resolve(data);
                }
                else {
                    reject(_this.domUtils.createCanceledError());
                }
            });
        });
    };
    /**
     * Gets the mark string from a question HTML.
     * Example result: "Marked out of 1.00".
     *
     * @param  {string} html Question's HTML.
     * @return {string}      Question's mark.
     */
    AddonModQuizHelperProvider.prototype.getQuestionMarkFromHtml = function (html) {
        var element = this.domUtils.convertToElement(html);
        return this.domUtils.getContentsOfElement(element, '.grade');
    };
    /**
     * Get a quiz ID by attempt ID.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the quiz ID.
     */
    AddonModQuizHelperProvider.prototype.getQuizIdByAttemptId = function (attemptId, siteId) {
        // Use getAttemptReview to retrieve the quiz ID.
        return this.quizProvider.getAttemptReview(attemptId, undefined, false, siteId).then(function (reviewData) {
            if (reviewData.attempt && reviewData.attempt.quiz) {
                return reviewData.attempt.quiz;
            }
            return Promise.reject(null);
        });
    };
    /**
     * Handle a review link.
     *
     * @param {NavController} navCtrl Nav controller, can be undefined/null.
     * @param {number} attemptId Attempt ID.
     * @param {number} [page] Page to load, -1 to all questions in same page.
     * @param {number} [courseId] Course ID.
     * @param {number} [quizId] Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModQuizHelperProvider.prototype.handleReviewLink = function (navCtrl, attemptId, page, courseId, quizId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var modal = this.domUtils.showModalLoading();
        var promise;
        if (quizId) {
            promise = Promise.resolve(quizId);
        }
        else {
            // Retrieve the quiz ID using the attempt ID.
            promise = this.getQuizIdByAttemptId(attemptId);
        }
        return promise.then(function (id) {
            quizId = id;
            // Get the courseId if we don't have it.
            if (courseId) {
                return courseId;
            }
            else {
                return _this.courseHelper.getModuleCourseIdByInstance(quizId, 'quiz', siteId);
            }
        }).then(function (courseId) {
            // Go to the review page.
            var pageParams = {
                quizId: quizId,
                attemptId: attemptId,
                courseId: courseId,
                page: isNaN(page) ? -1 : page
            };
            return _this.linkHelper.goInSite(navCtrl, 'AddonModQuizReviewPage', pageParams, siteId);
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'An error occurred while loading the required data.');
        }).finally(function () {
            modal.dismiss();
        });
    };
    /**
     * Add some calculated data to the attempt.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @param {boolean} highlight Whether we should check if attempt should be highlighted.
     * @param {number} [bestGrade] Quiz's best grade (formatted). Required if highlight=true.
     */
    AddonModQuizHelperProvider.prototype.setAttemptCalculatedData = function (quiz, attempt, highlight, bestGrade) {
        attempt.rescaledGrade = this.quizProvider.rescaleGrade(attempt.sumgrades, quiz, false);
        attempt.finished = this.quizProvider.isAttemptFinished(attempt.state);
        attempt.readableState = this.quizProvider.getAttemptReadableState(quiz, attempt);
        if (quiz.showMarkColumn && attempt.finished) {
            attempt.readableMark = this.quizProvider.formatGrade(attempt.sumgrades, quiz.decimalpoints);
        }
        else {
            attempt.readableMark = '';
        }
        if (quiz.showGradeColumn && attempt.finished) {
            attempt.readableGrade = this.quizProvider.formatGrade(attempt.rescaledGrade, quiz.decimalpoints);
            // Highlight the highest grade if appropriate.
            attempt.highlightGrade = highlight && !attempt.preview && attempt.state == __WEBPACK_IMPORTED_MODULE_6__quiz__["a" /* AddonModQuizProvider */].ATTEMPT_FINISHED &&
                attempt.readableGrade == bestGrade;
        }
        else {
            attempt.readableGrade = '';
        }
    };
    /**
     * Add some calculated data to the quiz.
     *
     * @param {any} quiz Quiz.
     * @param {any} options Options returned by AddonModQuizProvider.getCombinedReviewOptions.
     */
    AddonModQuizHelperProvider.prototype.setQuizCalculatedData = function (quiz, options) {
        quiz.sumGradesFormatted = this.quizProvider.formatGrade(quiz.sumgrades, quiz.decimalpoints);
        quiz.gradeFormatted = this.quizProvider.formatGrade(quiz.grade, quiz.decimalpoints);
        quiz.showAttemptColumn = quiz.attempts != 1;
        quiz.showGradeColumn = options.someoptions.marks >= __WEBPACK_IMPORTED_MODULE_6__quiz__["a" /* AddonModQuizProvider */].QUESTION_OPTIONS_MARK_AND_MAX &&
            this.quizProvider.quizHasGrades(quiz);
        quiz.showMarkColumn = quiz.showGradeColumn && quiz.grade != quiz.sumgrades;
        quiz.showFeedbackColumn = quiz.hasfeedback && options.alloptions.overallfeedback;
    };
    /**
     * Validate the preflight data. It calls AddonModQuizProvider.startAttempt if a new attempt is needed.
     *
     * @param {any} quiz Quiz.
     * @param {any} accessInfo Quiz access info returned by AddonModQuizProvider.getQuizAccessInformation.
     * @param {any} preflightData Object where to store the preflight data.
     * @param {any} [attempt] Attempt to continue. Don't pass any value if the user needs to start a new attempt.
     * @param {boolean} [offline] Whether the attempt is offline.
     * @param {boolean} [sent] Whether preflight data has been entered by the user.
     * @param {boolean} [prefetch] Whether user is prefetching.
     * @param {string} [title] The title to display in the modal and in the submit button.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the preflight data is validated.
     */
    AddonModQuizHelperProvider.prototype.validatePreflightData = function (quiz, accessInfo, preflightData, attempt, offline, prefetch, siteId) {
        var _this = this;
        var rules = accessInfo.activerulenames;
        var promise;
        if (attempt) {
            if (attempt.state != __WEBPACK_IMPORTED_MODULE_6__quiz__["a" /* AddonModQuizProvider */].ATTEMPT_OVERDUE && !attempt.finishedOffline) {
                // We're continuing an attempt. Call getAttemptData to validate the preflight data.
                var page = attempt.currentpage;
                promise = this.quizProvider.getAttemptData(attempt.id, page, preflightData, offline, true, siteId).then(function () {
                    if (offline) {
                        // Get current page stored in local.
                        return _this.quizOfflineProvider.getAttemptById(attempt.id).then(function (localAttempt) {
                            attempt.currentpage = localAttempt.currentpage;
                        }).catch(function () {
                            // No local data.
                        });
                    }
                });
            }
            else {
                // Attempt is overdue or finished in offline, we can only see the summary.
                // Call getAttemptSummary to validate the preflight data.
                promise = this.quizProvider.getAttemptSummary(attempt.id, preflightData, offline, true, false, siteId);
            }
        }
        else {
            // We're starting a new attempt, call startAttempt.
            promise = this.quizProvider.startAttempt(quiz.id, preflightData, false, siteId).then(function (att) {
                attempt = att;
            });
        }
        return promise.then(function () {
            // Preflight data validated.
            _this.accessRuleDelegate.notifyPreflightCheckPassed(rules, quiz, attempt, preflightData, prefetch, siteId);
            return attempt;
        }).catch(function (error) {
            if (_this.utils.isWebServiceError(error)) {
                // The WebService returned an error, assume the preflight failed.
                _this.accessRuleDelegate.notifyPreflightCheckFailed(rules, quiz, attempt, preflightData, prefetch, siteId);
            }
            return Promise.reject(error);
        });
    };
    AddonModQuizHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__access_rules_delegate__["a" /* AddonModQuizAccessRuleDelegate */], __WEBPACK_IMPORTED_MODULE_6__quiz__["a" /* AddonModQuizProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ModalController */], __WEBPACK_IMPORTED_MODULE_7__quiz_offline__["a" /* AddonModQuizOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_9__core_course_providers_helper__["a" /* CoreCourseHelperProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_10__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */]])
    ], AddonModQuizHelperProvider);
    return AddonModQuizHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModForumSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_base_sync__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_fileuploader_providers_fileuploader__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_groups__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__forum__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__helper__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__offline__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__core_rating_providers_sync__ = __webpack_require__(220);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



















/**
 * Service to sync forums.
 */
var AddonModForumSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModForumSyncProvider, _super);
    function AddonModForumSyncProvider(translate, appProvider, courseProvider, eventsProvider, groupsProvider, loggerProvider, sitesProvider, syncProvider, textUtils, timeUtils, uploaderProvider, utils, forumProvider, forumHelper, forumOffline, logHelper, ratingSync) {
        var _this = _super.call(this, 'AddonModForumSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils) || this;
        _this.eventsProvider = eventsProvider;
        _this.groupsProvider = groupsProvider;
        _this.uploaderProvider = uploaderProvider;
        _this.utils = utils;
        _this.forumProvider = forumProvider;
        _this.forumHelper = forumHelper;
        _this.forumOffline = forumOffline;
        _this.logHelper = logHelper;
        _this.ratingSync = ratingSync;
        _this.componentTranslate = courseProvider.translateModuleName('forum');
        return _this;
    }
    AddonModForumSyncProvider_1 = AddonModForumSyncProvider;
    /**
     * Try to synchronize all the forums in a certain site or in all sites.
     *
     * @param  {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModForumSyncProvider.prototype.syncAllForums = function (siteId, force) {
        return this.syncOnSites('all forums', this.syncAllForumsFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all forums on a site.
     *
     * @param  {string} siteId Site ID to sync.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @return {Promise<any>}          Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModForumSyncProvider.prototype.syncAllForumsFunc = function (siteId, force) {
        var _this = this;
        var sitePromises = [];
        // Sync all new discussions.
        sitePromises.push(this.forumOffline.getAllNewDiscussions(siteId).then(function (discussions) {
            var promises = {};
            // Do not sync same forum twice.
            discussions.forEach(function (discussion) {
                if (typeof promises[discussion.forumid] != 'undefined') {
                    return;
                }
                promises[discussion.forumid] = force ? _this.syncForumDiscussions(discussion.forumid, discussion.userid, siteId) :
                    _this.syncForumDiscussionsIfNeeded(discussion.forumid, discussion.userid, siteId);
                promises[discussion.forumid].then(function (result) {
                    if (result && result.updated) {
                        // Sync successful, send event.
                        _this.eventsProvider.trigger(AddonModForumSyncProvider_1.AUTO_SYNCED, {
                            forumId: discussion.forumid,
                            userId: discussion.userid,
                            warnings: result.warnings
                        }, siteId);
                    }
                });
            });
            return Promise.all(_this.utils.objectToArray(promises));
        }));
        // Sync all discussion replies.
        sitePromises.push(this.forumOffline.getAllReplies(siteId).then(function (replies) {
            var promises = {};
            // Do not sync same discussion twice.
            replies.forEach(function (reply) {
                if (typeof promises[reply.discussionid] != 'undefined') {
                    return;
                }
                promises[reply.discussionid] = force ? _this.syncDiscussionReplies(reply.discussionid, reply.userid, siteId) :
                    _this.syncDiscussionRepliesIfNeeded(reply.discussionid, reply.userid, siteId);
                promises[reply.discussionid].then(function (result) {
                    if (result && result.updated) {
                        // Sync successful, send event.
                        _this.eventsProvider.trigger(AddonModForumSyncProvider_1.AUTO_SYNCED, {
                            forumId: reply.forumid,
                            discussionId: reply.discussionid,
                            userId: reply.userid,
                            warnings: result.warnings
                        }, siteId);
                    }
                });
            });
            return Promise.all(_this.utils.objectToArray(promises));
        }));
        sitePromises.push(this.syncRatings(undefined, undefined, force, siteId));
        return Promise.all(sitePromises);
    };
    /**
     * Sync a forum only if a certain time has passed since the last time.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {number} userId   User the discussion belong to.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the forum is synced or if it doesn't need to be synced.
     */
    AddonModForumSyncProvider.prototype.syncForumDiscussionsIfNeeded = function (forumId, userId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var syncId = this.getForumSyncId(forumId, userId);
        return this.isSyncNeeded(syncId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncForumDiscussions(forumId, userId, siteId);
            }
        });
    };
    /**
     * Synchronize all offline discussions of a forum.
     *
     * @param  {number} forumId  Forum ID to be synced.
     * @param  {number} [userId] User the discussions belong to.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModForumSyncProvider.prototype.syncForumDiscussions = function (forumId, userId, siteId) {
        var _this = this;
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var syncId = this.getForumSyncId(forumId, userId);
        if (this.isSyncing(syncId, siteId)) {
            // There's already a sync ongoing for this discussion, return the promise.
            return this.getOngoingSync(syncId, siteId);
        }
        // Verify that forum isn't blocked.
        if (this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_15__forum__["a" /* AddonModForumProvider */].COMPONENT, syncId, siteId)) {
            this.logger.debug('Cannot sync forum ' + forumId + ' because it is blocked.');
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        this.logger.debug('Try to sync forum ' + forumId + ' for user ' + userId);
        var result = {
            warnings: [],
            updated: false
        };
        // Sync offline logs.
        var syncPromise = this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_15__forum__["a" /* AddonModForumProvider */].COMPONENT, forumId, siteId).catch(function () {
            // Ignore errors.
        }).then(function () {
            // Get offline responses to be sent.
            return _this.forumOffline.getNewDiscussions(forumId, siteId, userId).catch(function () {
                // No offline data found, return empty object.
                return [];
            });
        }).then(function (discussions) {
            if (!discussions.length) {
                // Nothing to sync.
                return;
            }
            else if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(null);
            }
            var promises = [];
            discussions.forEach(function (data) {
                var groupsPromise;
                if (data.groupid == __WEBPACK_IMPORTED_MODULE_15__forum__["a" /* AddonModForumProvider */].ALL_GROUPS) {
                    // Fetch all group ids.
                    groupsPromise = _this.forumProvider.getForumById(data.courseid, data.forumid, siteId).then(function (forum) {
                        return _this.groupsProvider.getActivityAllowedGroups(forum.cmid).then(function (groups) {
                            return groups.map(function (group) { return group.id; });
                        });
                    });
                }
                else {
                    groupsPromise = Promise.resolve([data.groupid]);
                }
                promises.push(groupsPromise.then(function (groupIds) {
                    var errors = [];
                    return Promise.all(groupIds.map(function (groupId) {
                        // First of all upload the attachments (if any).
                        return _this.uploadAttachments(forumId, data, true, siteId, userId).then(function (itemId) {
                            // Now try to add the discussion.
                            var options = _this.utils.clone(data.options || {});
                            options.attachmentsid = itemId;
                            return _this.forumProvider.addNewDiscussionOnline(forumId, data.subject, data.message, options, groupId, siteId);
                        }).catch(function (error) {
                            errors.push(error);
                        });
                    })).then(function () {
                        if (errors.length == groupIds.length) {
                            // All requests have failed, reject if errors were not returned by WS.
                            for (var i = 0; i < errors.length; i++) {
                                if (!_this.utils.isWebServiceError(errors[i])) {
                                    return Promise.reject(errors[i]);
                                }
                            }
                        }
                        // All requests succeeded, some failed or all failed with a WS error.
                        result.updated = true;
                        return _this.deleteNewDiscussion(forumId, data.timecreated, siteId, userId).then(function () {
                            if (errors.length == groupIds.length) {
                                // All requests failed with WS error.
                                result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                                    component: _this.componentTranslate,
                                    name: data.name,
                                    error: _this.textUtils.getErrorMessageFromError(errors[0])
                                }));
                            }
                        });
                    });
                }));
            });
            return Promise.all(promises);
        }).then(function () {
            if (result.updated) {
                // Data has been sent to server. Now invalidate the WS calls.
                var promises = [
                    _this.forumProvider.invalidateDiscussionsList(forumId, siteId),
                    _this.forumProvider.invalidateCanAddDiscussion(forumId, siteId),
                ];
                return Promise.all(promises).catch(function () {
                    // Ignore errors.
                });
            }
        }).then(function () {
            // Sync finished, set sync time.
            return _this.setSyncTime(syncId, siteId).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            // All done, return the warnings.
            return result;
        });
        return this.addOngoingSync(syncId, syncPromise, siteId);
    };
    /**
     * Synchronize forum offline ratings.
     *
     * @param {number} [cmId] Course module to be synced. If not defined, sync all forums.
     * @param {number} [discussionId] Discussion id to be synced. If not defined, sync all discussions.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModForumSyncProvider.prototype.syncRatings = function (cmId, discussionId, force, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.ratingSync.syncRatings('mod_forum', 'post', 'module', cmId, discussionId, force, siteId).then(function (results) {
            var updated = false;
            var warnings = [];
            var promises = [];
            results.forEach(function (result) {
                if (result.updated.length) {
                    updated = true;
                    // Invalidate discussions of updated ratings.
                    promises.push(_this.forumProvider.invalidateDiscussionPosts(result.itemSet.itemSetId, siteId));
                }
                if (result.warnings.length) {
                    // Fetch forum to construct the warning message.
                    promises.push(_this.forumProvider.getForum(result.itemSet.courseId, result.itemSet.instanceId, siteId)
                        .then(function (forum) {
                        result.warnings.forEach(function (warning) {
                            warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                                component: _this.componentTranslate,
                                name: forum.name,
                                error: warning
                            }));
                        });
                    }));
                }
            });
            return _this.utils.allPromises(promises).then(function () {
                return { updated: updated, warnings: warnings };
            });
        });
    };
    /**
     * Synchronize all offline discussion replies of a forum.
     *
     * @param  {number} forumId  Forum ID to be synced.
     * @param  {number} [userId] User the discussions belong to.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModForumSyncProvider.prototype.syncForumReplies = function (forumId, userId, siteId) {
        var _this = this;
        // Get offline forum replies to be sent.
        return this.forumOffline.getForumReplies(forumId, siteId, userId).catch(function () {
            // No offline data found, return empty list.
            return [];
        }).then(function (replies) {
            if (!replies.length) {
                // Nothing to sync.
                return { warnings: [], updated: false };
            }
            else if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(null);
            }
            var promises = {};
            // Do not sync same discussion twice.
            replies.forEach(function (reply) {
                if (typeof promises[reply.discussionid] != 'undefined') {
                    return;
                }
                promises[reply.discussionid] = _this.syncDiscussionReplies(reply.discussionid, userId, siteId);
            });
            return Promise.all(_this.utils.objectToArray(promises)).then(function (results) {
                return results.reduce(function (a, b) { return ({
                    warnings: a.warnings.concat(b.warnings),
                    updated: a.updated || b.updated,
                }); }, { warnings: [], updated: false });
            });
        });
    };
    /**
     * Sync a forum discussion replies only if a certain time has passed since the last time.
     *
     * @param  {number} discussionId Discussion ID to be synced.
     * @param  {number} [userId]     User the posts belong to.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the forum discussion is synced or if it doesn't need to be synced.
     */
    AddonModForumSyncProvider.prototype.syncDiscussionRepliesIfNeeded = function (discussionId, userId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var syncId = this.getDiscussionSyncId(discussionId, userId);
        return this.isSyncNeeded(syncId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncDiscussionReplies(discussionId, userId, siteId);
            }
        });
    };
    /**
     * Synchronize all offline replies from a discussion.
     *
     * @param  {number} discussionId Discussion ID to be synced.
     * @param  {number} [userId]     User the posts belong to.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModForumSyncProvider.prototype.syncDiscussionReplies = function (discussionId, userId, siteId) {
        var _this = this;
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var syncId = this.getDiscussionSyncId(discussionId, userId);
        if (this.isSyncing(syncId, siteId)) {
            // There's already a sync ongoing for this discussion, return the promise.
            return this.getOngoingSync(syncId, siteId);
        }
        // Verify that forum isn't blocked.
        if (this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_15__forum__["a" /* AddonModForumProvider */].COMPONENT, syncId, siteId)) {
            this.logger.debug('Cannot sync forum discussion ' + discussionId + ' because it is blocked.');
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        this.logger.debug('Try to sync forum discussion ' + discussionId + ' for user ' + userId);
        var forumId;
        var result = {
            warnings: [],
            updated: false
        };
        // Get offline responses to be sent.
        var syncPromise = this.forumOffline.getDiscussionReplies(discussionId, siteId, userId).catch(function () {
            // No offline data found, return empty object.
            return [];
        }).then(function (replies) {
            if (!replies.length) {
                // Nothing to sync.
                return;
            }
            else if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(null);
            }
            var promises = [];
            replies.forEach(function (data) {
                forumId = data.forumid;
                data.options = data.options || {};
                // First of all upload the attachments (if any).
                var promise = _this.uploadAttachments(forumId, data, false, siteId, userId).then(function (itemId) {
                    // Now try to send the reply.
                    data.options.attachmentsid = itemId;
                    return _this.forumProvider.replyPostOnline(data.postid, data.subject, data.message, data.options, siteId);
                });
                promises.push(promise.then(function () {
                    result.updated = true;
                    return _this.deleteReply(forumId, data.postid, siteId, userId);
                }).catch(function (error) {
                    if (_this.utils.isWebServiceError(error)) {
                        // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.
                        result.updated = true;
                        return _this.deleteReply(forumId, data.postid, siteId, userId).then(function () {
                            // Responses deleted, add a warning.
                            result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                                component: _this.componentTranslate,
                                name: data.name,
                                error: _this.textUtils.getErrorMessageFromError(error)
                            }));
                        });
                    }
                    else {
                        // Couldn't connect to server, reject.
                        return Promise.reject(error);
                    }
                }));
            });
            return Promise.all(promises);
        }).then(function () {
            // Data has been sent to server. Now invalidate the WS calls.
            var promises = [];
            if (forumId) {
                promises.push(_this.forumProvider.invalidateDiscussionsList(forumId, siteId));
            }
            promises.push(_this.forumProvider.invalidateDiscussionPosts(discussionId, siteId));
            return _this.utils.allPromises(promises).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            // Sync finished, set sync time.
            return _this.setSyncTime(syncId, siteId).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            // All done, return the warnings.
            return result;
        });
        return this.addOngoingSync(syncId, syncPromise, siteId);
    };
    /**
     * Delete a new discussion.
     *
     * @param  {number} forumId     Forum ID the discussion belongs to.
     * @param  {number} timecreated The timecreated of the discussion.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @param  {number} [userId]    User the discussion belongs to. If not defined, current user in site.
     * @return {Promise<any>}       Promise resolved when deleted.
     */
    AddonModForumSyncProvider.prototype.deleteNewDiscussion = function (forumId, timecreated, siteId, userId) {
        var promises = [];
        promises.push(this.forumOffline.deleteNewDiscussion(forumId, timecreated, siteId, userId));
        promises.push(this.forumHelper.deleteNewDiscussionStoredFiles(forumId, timecreated, siteId).catch(function () {
            // Ignore errors, maybe there are no files.
        }));
        return Promise.all(promises);
    };
    /**
     * Delete a new discussion.
     *
     * @param  {number} forumId  Forum ID the discussion belongs to.
     * @param  {number} postId   ID of the post being replied.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the discussion belongs to. If not defined, current user in site.
     * @return {Promise<any>}    Promise resolved when deleted.
     */
    AddonModForumSyncProvider.prototype.deleteReply = function (forumId, postId, siteId, userId) {
        var promises = [];
        promises.push(this.forumOffline.deleteReply(postId, siteId, userId));
        promises.push(this.forumHelper.deleteReplyStoredFiles(forumId, postId, siteId, userId).catch(function () {
            // Ignore errors, maybe there are no files.
        }));
        return Promise.all(promises);
    };
    /**
     * Upload attachments of an offline post/discussion.
     *
     * @param  {number}  forumId  Forum ID the post belongs to.
     * @param  {any}     post     Offline post or discussion.
     * @param  {boolean} isDisc   True if it's a new discussion, false if it's a reply.
     * @param  {string}  [siteId] Site ID. If not defined, current site.
     * @param  {number}  [userId] User the reply belongs to. If not defined, current user in site.
     * @return {Promise<any>}     Promise resolved with draftid if uploaded, resolved with undefined if nothing to upload.
     */
    AddonModForumSyncProvider.prototype.uploadAttachments = function (forumId, post, isDisc, siteId, userId) {
        var _this = this;
        var attachments = post && post.options && post.options.attachmentsid;
        if (attachments) {
            // Has some attachments to sync.
            var files_1 = attachments.online || [];
            var promise = void 0;
            if (attachments.offline) {
                // Has offline files.
                if (isDisc) {
                    promise = this.forumHelper.getNewDiscussionStoredFiles(forumId, post.timecreated, siteId);
                }
                else {
                    promise = this.forumHelper.getReplyStoredFiles(forumId, post.postid, siteId, userId);
                }
                promise.then(function (atts) {
                    files_1 = files_1.concat(atts);
                }).catch(function () {
                    // Folder not found, no files to add.
                });
            }
            else {
                promise = Promise.resolve();
            }
            return promise.then(function () {
                return _this.uploaderProvider.uploadOrReuploadFiles(files_1, __WEBPACK_IMPORTED_MODULE_15__forum__["a" /* AddonModForumProvider */].COMPONENT, forumId, siteId);
            });
        }
        // No attachments, resolve.
        return Promise.resolve();
    };
    /**
     * Get the ID of a forum sync.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {number} [userId] User the responses belong to.. If not defined, current user.
     * @return {string}          Sync ID.
     */
    AddonModForumSyncProvider.prototype.getForumSyncId = function (forumId, userId) {
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        return 'forum#' + forumId + '#' + userId;
    };
    /**
     * Get the ID of a discussion sync.
     *
     * @param  {number} discussionId Discussion ID.
     * @param  {number} [userId]     User the responses belong to.. If not defined, current user.
     * @return {string}              Sync ID.
     */
    AddonModForumSyncProvider.prototype.getDiscussionSyncId = function (discussionId, userId) {
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        return 'discussion#' + discussionId + '#' + userId;
    };
    AddonModForumSyncProvider.AUTO_SYNCED = 'addon_mod_forum_autom_synced';
    AddonModForumSyncProvider.MANUAL_SYNCED = 'addon_mod_forum_manual_synced';
    AddonModForumSyncProvider = AddonModForumSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_6__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_groups__["a" /* CoreGroupsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_11__providers_sync__["a" /* CoreSyncProvider */],
            __WEBPACK_IMPORTED_MODULE_12__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_13__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__core_fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_14__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_15__forum__["a" /* AddonModForumProvider */],
            __WEBPACK_IMPORTED_MODULE_16__helper__["a" /* AddonModForumHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_17__offline__["a" /* AddonModForumOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_4__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_18__core_rating_providers_sync__["a" /* CoreRatingSyncProvider */]])
    ], AddonModForumSyncProvider);
    return AddonModForumSyncProvider;
    var AddonModForumSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_2__classes_base_sync__["a" /* CoreSyncBaseProvider */]));

//# sourceMappingURL=sync.js.map

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_emulator_providers_helper__ = __webpack_require__(293);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__addon_messages_providers_messages__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Service to handle notifications.
 */
var AddonNotificationsProvider = /** @class */ (function () {
    function AddonNotificationsProvider(logger, appProvider, sitesProvider, timeUtils, userProvider, emulatorHelper, messageProvider, textUtils) {
        this.appProvider = appProvider;
        this.sitesProvider = sitesProvider;
        this.timeUtils = timeUtils;
        this.userProvider = userProvider;
        this.emulatorHelper = emulatorHelper;
        this.messageProvider = messageProvider;
        this.textUtils = textUtils;
        this.ROOT_CACHE_KEY = 'mmaNotifications:';
        this.logger = logger.getInstance('AddonNotificationsProvider');
    }
    AddonNotificationsProvider_1 = AddonNotificationsProvider;
    /**
     * Function to format notification data.
     *
     * @param {any[]} notifications List of notifications.
     * @param {boolean} [read] Whether the notifications are read or unread.
     * @return {Promise<any[]>} Promise resolved with notifications.
     */
    AddonNotificationsProvider.prototype.formatNotificationsData = function (notifications, read) {
        var _this = this;
        var promises = notifications.map(function (notification) {
            // Set message to show.
            if (notification.component && notification.component == 'mod_forum') {
                notification.mobiletext = notification.smallmessage;
            }
            else if (notification.component && notification.component == 'moodle' && notification.name == 'insights') {
                notification.mobiletext = notification.fullmessagehtml;
            }
            else {
                notification.mobiletext = notification.fullmessage;
            }
            notification.moodlecomponent = notification.component;
            notification.notification = 1;
            notification.notif = 1;
            if (typeof read != 'undefined') {
                notification.read = read;
            }
            if (typeof notification.customdata == 'string') {
                notification.customdata = _this.textUtils.parseJSON(notification.customdata, {});
            }
            // Try to set courseid the notification belongs to.
            if (notification.customdata && notification.customdata.courseid) {
                notification.courseid = notification.customdata.courseid;
            }
            else if (!notification.courseid) {
                var cid = notification.fullmessagehtml.match(/course\/view\.php\?id=([^"]*)/);
                if (cid && cid[1]) {
                    notification.courseid = parseInt(cid[1], 10);
                }
            }
            if (notification.useridfrom > 0) {
                // Try to get the profile picture of the user.
                return _this.userProvider.getProfile(notification.useridfrom, notification.courseid, true).then(function (user) {
                    notification.profileimageurlfrom = user.profileimageurl;
                    notification.userfromfullname = user.fullname;
                    return notification;
                }).catch(function () {
                    // Error getting user. This can happen if device is offline or the user is deleted.
                });
            }
            return Promise.resolve(notification);
        });
        return Promise.all(promises);
    };
    /**
     * Get the cache key for the get notification preferences call.
     *
     * @return {string} Cache key.
     */
    AddonNotificationsProvider.prototype.getNotificationPreferencesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'notificationPreferences';
    };
    /**
     * Get notification preferences.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the notification preferences.
     */
    AddonNotificationsProvider.prototype.getNotificationPreferences = function (siteId) {
        var _this = this;
        this.logger.debug('Get notification preferences');
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getNotificationPreferencesCacheKey(),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            return site.read('core_message_get_user_notification_preferences', {}, preSets).then(function (data) {
                return data.preferences;
            });
        });
    };
    /**
     * Get cache key for notification list WS calls.
     *
     * @return {string} Cache key.
     */
    AddonNotificationsProvider.prototype.getNotificationsCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'list';
    };
    /**
     * Get notifications from site.
     *
     * @param {boolean} read True if should get read notifications, false otherwise.
     * @param {number} limitFrom Position of the first notification to get.
     * @param {number} limitNumber Number of notifications to get or 0 to use the default limit.
     * @param {boolean} [toDisplay=true] True if notifications will be displayed to the user, either in view or in a notification.
     * @param {boolean} [forceCache] True if it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with notifications.
     */
    AddonNotificationsProvider.prototype.getNotifications = function (read, limitFrom, limitNumber, toDisplay, forceCache, ignoreCache, siteId) {
        var _this = this;
        if (limitNumber === void 0) { limitNumber = 0; }
        if (toDisplay === void 0) { toDisplay = true; }
        limitNumber = limitNumber || AddonNotificationsProvider_1.LIST_LIMIT;
        this.logger.debug('Get ' + (read ? 'read' : 'unread') + ' notifications from ' + limitFrom + '. Limit: ' + limitNumber);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                useridto: site.getUserId(),
                useridfrom: 0,
                type: 'notifications',
                read: read ? 1 : 0,
                newestfirst: 1,
                limitfrom: limitFrom,
                limitnum: limitNumber
            };
            var preSets = {
                cacheKey: _this.getNotificationsCacheKey(),
                omitExpires: forceCache,
                getFromCache: forceCache || !ignoreCache,
                emergencyCache: forceCache || !ignoreCache,
            };
            // Get unread notifications.
            return site.read('core_message_get_messages', data, preSets).then(function (response) {
                if (response.messages) {
                    var notifications_1 = response.messages;
                    return _this.formatNotificationsData(notifications_1, read).then(function () {
                        if (_this.appProvider.isDesktop() && toDisplay && !read && limitFrom === 0) {
                            // Store the last received notification. Don't block the user for this.
                            _this.emulatorHelper.storeLastReceivedNotification(AddonNotificationsProvider_1.PUSH_SIMULATION_COMPONENT, notifications_1[0], siteId);
                        }
                        return notifications_1;
                    });
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Get notifications from site using the new WebService.
     *
     * @param {number} offset Position of the first notification to get.
     * @param {number} [limit] Number of notifications to get. Defaults to LIST_LIMIT.
     * @param {boolean} [toDisplay=true] True if notifications will be displayed to the user, either in view or in a notification.
     * @param {boolean} [forceCache] True if it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{notifications: any[], canLoadMore: boolean}>} Promise resolved with notifications and if can load more.
     * @since 3.2
     */
    AddonNotificationsProvider.prototype.getPopupNotifications = function (offset, limit, toDisplay, forceCache, ignoreCache, siteId) {
        var _this = this;
        if (toDisplay === void 0) { toDisplay = true; }
        limit = limit || AddonNotificationsProvider_1.LIST_LIMIT;
        this.logger.debug('Get popup notifications from ' + offset + '. Limit: ' + limit);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                useridto: site.getUserId(),
                newestfirst: 1,
                offset: offset,
                limit: limit + 1 // Get one more to calculate canLoadMore.
            }, preSets = {
                cacheKey: _this.getNotificationsCacheKey(),
                omitExpires: forceCache,
                getFromCache: forceCache || !ignoreCache,
                emergencyCache: forceCache || !ignoreCache,
            };
            // Get notifications.
            return site.read('message_popup_get_popup_notifications', data, preSets).then(function (response) {
                if (response.notifications) {
                    var result_1 = {
                        canLoadMore: response.notifications.length > limit
                    }, notifications_2 = response.notifications.slice(0, limit);
                    result_1.notifications = notifications_2;
                    return _this.formatNotificationsData(notifications_2).then(function () {
                        var first = notifications_2[0];
                        if (_this.appProvider.isDesktop() && toDisplay && offset === 0 && first && !first.read) {
                            // Store the last received notification. Don't block the user for this.
                            _this.emulatorHelper.storeLastReceivedNotification(AddonNotificationsProvider_1.PUSH_SIMULATION_COMPONENT, first, siteId);
                        }
                        return result_1;
                    });
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Get read notifications from site.
     *
     * @param {number} limitFrom Position of the first notification to get.
     * @param {number} limitNumber Number of notifications to get.
     * @param {boolean} [toDisplay=true] True if notifications will be displayed to the user, either in view or in a notification.
     * @param {boolean} [forceCache] True if it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with notifications.
     */
    AddonNotificationsProvider.prototype.getReadNotifications = function (limitFrom, limitNumber, toDisplay, forceCache, ignoreCache, siteId) {
        if (toDisplay === void 0) { toDisplay = true; }
        return this.getNotifications(true, limitFrom, limitNumber, toDisplay, forceCache, ignoreCache, siteId);
    };
    /**
     * Get unread notifications from site.
     *
     * @param {number} limitFrom Position of the first notification to get.
     * @param {number} limitNumber Number of notifications to get.
     * @param {boolean} [toDisplay=true] True if notifications will be displayed to the user, either in view or in a notification.
     * @param {boolean} [forceCache] True if it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with notifications.
     */
    AddonNotificationsProvider.prototype.getUnreadNotifications = function (limitFrom, limitNumber, toDisplay, forceCache, ignoreCache, siteId) {
        if (toDisplay === void 0) { toDisplay = true; }
        return this.getNotifications(false, limitFrom, limitNumber, toDisplay, forceCache, ignoreCache, siteId);
    };
    /**
     * Get unread notifications count. Do not cache calls.
     *
     * @param {number} [userId] The user id who received the notification. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<number>} Promise resolved with the message notifications count.
     */
    AddonNotificationsProvider.prototype.getUnreadNotificationsCount = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // @since 3.2
            if (site.wsAvailable('message_popup_get_unread_popup_notification_count')) {
                userId = userId || site.getUserId();
                var params = {
                    useridto: userId
                };
                var preSets = {
                    getFromCache: false,
                    emergencyCache: false,
                    saveToCache: false,
                    typeExpected: 'number'
                };
                return site.read('message_popup_get_unread_popup_notification_count', params, preSets).catch(function () {
                    // Return no messages if the call fails.
                    return 0;
                });
            }
            // Fallback call.
            var limit = AddonNotificationsProvider_1.LIST_LIMIT + 1;
            return _this.getUnreadNotifications(0, limit, false, false, false, siteId).then(function (unread) {
                // Add + sign if there are more than the limit reachable.
                return (unread.length > AddonNotificationsProvider_1.LIST_LIMIT) ?
                    AddonNotificationsProvider_1.LIST_LIMIT + '+' : unread.length;
            }).catch(function () {
                // Return no messages if the call fails.
                return 0;
            });
        });
    };
    /**
     * Returns whether or not popup WS is available for a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if available, resolved with false or rejected otherwise.
     */
    AddonNotificationsProvider.prototype.isPopupAvailable = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('message_popup_get_popup_notifications');
        });
    };
    /**
     * Mark all message notification as read.
     *
     * @returns {Promise<any>} Resolved when done.
     * @since 3.2
     */
    AddonNotificationsProvider.prototype.markAllNotificationsAsRead = function () {
        var params = {
            useridto: this.sitesProvider.getCurrentSiteUserId()
        };
        return this.sitesProvider.getCurrentSite().write('core_message_mark_all_notifications_as_read', params);
    };
    /**
     * Mark a single notification as read.
     *
     * @param {number} notificationId ID of notification to mark as read
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @returns {Promise<any>} Resolved when done.
     * @since 3.5
     */
    AddonNotificationsProvider.prototype.markNotificationRead = function (notificationId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (site.wsAvailable('core_message_mark_notification_read')) {
                var params = {
                    notificationid: notificationId,
                    timeread: _this.timeUtils.timestamp()
                };
                return site.write('core_message_mark_notification_read', params);
            }
            else {
                // Fallback for versions prior to 3.5.
                return _this.messageProvider.markMessageRead(notificationId, site.id);
            }
        });
    };
    /**
     * Invalidate get notification preferences.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data is invalidated.
     */
    AddonNotificationsProvider.prototype.invalidateNotificationPreferences = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getNotificationPreferencesCacheKey());
        });
    };
    /**
     * Invalidates notifications list WS calls.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the list is invalidated.
     */
    AddonNotificationsProvider.prototype.invalidateNotificationsList = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getNotificationsCacheKey());
        });
    };
    /**
     * Returns whether or not we can mark all notifications as read.
     *
     * @return {boolean} True if enabled, false otherwise.
     * @since 3.2
     */
    AddonNotificationsProvider.prototype.isMarkAllNotificationsAsReadEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_mark_all_notifications_as_read');
    };
    /**
     * Returns whether or not we can count unread notifications precisely.
     *
     * @return {boolean} True if enabled, false otherwise.
     * @since 3.2
     */
    AddonNotificationsProvider.prototype.isPreciseNotificationCountEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('message_popup_get_unread_popup_notification_count');
    };
    /**
     * Returns whether or not the notification preferences are enabled for the current site.
     *
     * @return {boolean} True if enabled, false otherwise.
     * @since 3.2
     */
    AddonNotificationsProvider.prototype.isNotificationPreferencesEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_get_user_notification_preferences');
    };
    AddonNotificationsProvider.READ_CHANGED_EVENT = 'addon_notifications_read_changed_event';
    AddonNotificationsProvider.READ_CRON_EVENT = 'addon_notifications_read_cron_event';
    AddonNotificationsProvider.PUSH_SIMULATION_COMPONENT = 'AddonNotificationsPushSimulation';
    AddonNotificationsProvider.LIST_LIMIT = 20;
    AddonNotificationsProvider = AddonNotificationsProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__core_user_providers_user__["a" /* CoreUserProvider */],
            __WEBPACK_IMPORTED_MODULE_7__core_emulator_providers_helper__["a" /* CoreEmulatorHelperProvider */], __WEBPACK_IMPORTED_MODULE_8__addon_messages_providers_messages__["a" /* AddonMessagesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], AddonNotificationsProvider);
    return AddonNotificationsProvider;
    var AddonNotificationsProvider_1;
}());

//# sourceMappingURL=notifications.js.map

/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModGlossaryOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to handle offline glossary.
 */
var AddonModGlossaryOfflineProvider = /** @class */ (function () {
    function AddonModGlossaryOfflineProvider(fileProvider, sitesProvider, textUtils, utils) {
        this.fileProvider = fileProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.siteSchema = {
            name: 'AddonModGlossaryOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModGlossaryOfflineProvider_1.ENTRIES_TABLE,
                    columns: [
                        {
                            name: 'glossaryid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'concept',
                            type: 'TEXT',
                        },
                        {
                            name: 'definition',
                            type: 'TEXT',
                        },
                        {
                            name: 'definitionformat',
                            type: 'TEXT',
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER',
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER',
                        },
                        {
                            name: 'options',
                            type: 'TEXT',
                        },
                        {
                            name: 'attachments',
                            type: 'TEXT',
                        },
                    ],
                    primaryKeys: ['glossaryid', 'concept', 'timecreated']
                }
            ]
        };
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModGlossaryOfflineProvider_1 = AddonModGlossaryOfflineProvider;
    /**
     * Delete a new entry.
     *
     * @param  {number} glossaryId  Glossary ID.
     * @param  {string} concept     Glossary entry concept.
     * @param  {number} timeCreated The time the entry was created.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<void>}      Promise resolved if deleted, rejected if failure.
     */
    AddonModGlossaryOfflineProvider.prototype.deleteNewEntry = function (glossaryId, concept, timeCreated, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                glossaryid: glossaryId,
                concept: concept,
                timecreated: timeCreated,
            };
            return site.getDb().deleteRecords(AddonModGlossaryOfflineProvider_1.ENTRIES_TABLE, conditions);
        });
    };
    /**
     * Get all the stored new entries from all the glossaries.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with entries.
     */
    AddonModGlossaryOfflineProvider.prototype.getAllNewEntries = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModGlossaryOfflineProvider_1.ENTRIES_TABLE).then(function (records) {
                return records.map(_this.parseRecord.bind(_this));
            });
        });
    };
    /**
     * Get a stored new entry.
     *
     * @param  {number} glossaryId  Glossary ID.
     * @param  {string} concept     Glossary entry concept.
     * @param  {number} timeCreated The time the entry was created.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with entry.
     */
    AddonModGlossaryOfflineProvider.prototype.getNewEntry = function (glossaryId, concept, timeCreated, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                glossaryid: glossaryId,
                concept: concept,
                timecreated: timeCreated,
            };
            return site.getDb().getRecord(AddonModGlossaryOfflineProvider_1.ENTRIES_TABLE, conditions)
                .then(_this.parseRecord.bind(_this));
        });
    };
    /**
     * Get all the stored add entry data from a certain glossary.
     *
     * @param  {number} glossaryId Glossary ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @param  {number} [userId]   User the entries belong to. If not defined, current user in site.
     * @return {Promise<any[]>} Promise resolved with entries.
     */
    AddonModGlossaryOfflineProvider.prototype.getGlossaryNewEntries = function (glossaryId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                glossaryid: glossaryId,
                userId: userId || site.getUserId(),
            };
            return site.getDb().getRecords(AddonModGlossaryOfflineProvider_1.ENTRIES_TABLE, conditions).then(function (records) {
                return records.map(_this.parseRecord.bind(_this));
            });
        });
    };
    /**
     * Check if a concept is used offline.
     *
     * @param  {number} glossaryId    Glossary ID.
     * @param  {string} concept       Concept to check.
     * @param  {number} [timeCreated] Time of the entry we are editing.
     * @param  {string} [siteId]      Site ID. If not defined, current site.
     * @return {Promise<boolean>}     Promise resolved with true if concept is found, false otherwise.
     */
    AddonModGlossaryOfflineProvider.prototype.isConceptUsed = function (glossaryId, concept, timeCreated, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var conditions = {
                glossaryid: glossaryId,
                concept: concept,
            };
            return site.getDb().getRecords(AddonModGlossaryOfflineProvider_1.ENTRIES_TABLE, conditions).then(function (entries) {
                if (!entries.length) {
                    return false;
                }
                if (entries.length > 1 || !timeCreated) {
                    return true;
                }
                // If there's only one entry, check that is not the one we are editing.
                return _this.utils.promiseFails(_this.getNewEntry(glossaryId, concept, timeCreated, siteId));
            });
        }).catch(function () {
            // No offline data found, return false.
            return false;
        });
    };
    /**
     * Save a new entry to be sent later.
     *
     * @param  {number} glossaryId     Glossary ID.
     * @param  {string} concept        Glossary entry concept.
     * @param  {string} definition     Glossary entry concept definition.
     * @param  {number} courseId       Course ID of the glossary.
     * @param  {any}    [options]      Options for the entry.
     * @param  {any}    [attachments]  Result of CoreFileUploaderProvider#storeFilesToUpload for attachments.
     * @param  {number} [timeCreated]  The time the entry was created. If not defined, current time.
     * @param  {string} [siteId]       Site ID. If not defined, current site.
     * @param  {number} [userId]       User the entry belong to. If not defined, current user in site.
     * @param  {any}    [discardEntry] The entry provided will be discarded if found.
     * @return {Promise<false>}        Promise resolved if stored, rejected if failure.
     */
    AddonModGlossaryOfflineProvider.prototype.addNewEntry = function (glossaryId, concept, definition, courseId, options, attachments, timeCreated, siteId, userId, discardEntry) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var entry = {
                glossaryid: glossaryId,
                courseid: courseId,
                concept: concept,
                definition: definition,
                definitionformat: 'html',
                options: JSON.stringify(options),
                attachments: JSON.stringify(attachments),
                userid: userId || site.getUserId(),
                timecreated: timeCreated || new Date().getTime()
            };
            // If editing an offline entry, delete previous first.
            var discardPromise;
            if (discardEntry) {
                discardPromise = _this.deleteNewEntry(glossaryId, discardEntry.concept, discardEntry.timecreated, site.getId());
            }
            else {
                discardPromise = Promise.resolve();
            }
            return discardPromise.then(function () {
                return site.getDb().insertRecord(AddonModGlossaryOfflineProvider_1.ENTRIES_TABLE, entry).then(function () { return false; });
            });
        });
    };
    /**
     * Get the path to the folder where to store files for offline attachments in a glossary.
     *
     * @param  {number} glossaryId Glossary ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<string>}   Promise resolved with the path.
     */
    AddonModGlossaryOfflineProvider.prototype.getGlossaryFolder = function (glossaryId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var siteFolderPath = _this.fileProvider.getSiteFolder(site.getId());
            var folderPath = 'offlineglossary/' + glossaryId;
            return _this.textUtils.concatenatePaths(siteFolderPath, folderPath);
        });
    };
    /**
     * Get the path to the folder where to store files for a new offline entry.
     *
     * @param  {number} glossaryId  Glossary ID.
     * @param  {string} concept     The name of the entry.
     * @param  {number} timeCreated Time to allow duplicated entries.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<string>}    Promise resolved with the path.
     */
    AddonModGlossaryOfflineProvider.prototype.getEntryFolder = function (glossaryId, concept, timeCreated, siteId) {
        var _this = this;
        return this.getGlossaryFolder(glossaryId, siteId).then(function (folderPath) {
            return _this.textUtils.concatenatePaths(folderPath, 'newentry_' + concept + '_' + timeCreated);
        });
    };
    /**
     * Parse "options" and "attachments" columns of a fetched record.
     *
     * @param  {any} records Record object
     * @return {any}         Record object with columns parsed.
     */
    AddonModGlossaryOfflineProvider.prototype.parseRecord = function (record) {
        record.options = this.textUtils.parseJSON(record.options);
        record.attachments = this.textUtils.parseJSON(record.attachments);
        return record;
    };
    // Variables for database.
    AddonModGlossaryOfflineProvider.ENTRIES_TABLE = 'addon_mod_glossary_entrues';
    AddonModGlossaryOfflineProvider = AddonModGlossaryOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonModGlossaryOfflineProvider);
    return AddonModGlossaryOfflineProvider;
    var AddonModGlossaryOfflineProvider_1;
}());

//# sourceMappingURL=offline.js.map

/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModQuizSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_course_providers_module_prefetch_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_question_providers_question__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_question_providers_delegate__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_course_classes_activity_sync__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__quiz__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__quiz_offline__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__prefetch_handler__ = __webpack_require__(314);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


















/**
 * Service to sync quizzes.
 */
var AddonModQuizSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModQuizSyncProvider, _super);
    function AddonModQuizSyncProvider(loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, eventsProvider, timeUtils, quizProvider, quizOfflineProvider, prefetchHandler, questionProvider, questionDelegate, logHelper, prefetchDelegate, courseProvider) {
        var _this = _super.call(this, 'AddonModQuizSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils, prefetchDelegate, prefetchHandler) || this;
        _this.eventsProvider = eventsProvider;
        _this.quizProvider = quizProvider;
        _this.quizOfflineProvider = quizOfflineProvider;
        _this.prefetchHandler = prefetchHandler;
        _this.questionProvider = questionProvider;
        _this.questionDelegate = questionDelegate;
        _this.logHelper = logHelper;
        _this.courseProvider = courseProvider;
        _this.componentTranslate = courseProvider.translateModuleName('quiz');
        return _this;
    }
    AddonModQuizSyncProvider_1 = AddonModQuizSyncProvider;
    /**
     * Finish a sync process: remove offline data if needed, prefetch quiz data, set sync time and return the result.
     *
     * @param {string} siteId Site ID.
     * @param {any} quiz Quiz.
     * @param {number} courseId Course ID.
     * @param {string[]} warnings List of warnings generated by the sync.
     * @param {number} [attemptId] Last attempt ID.
     * @param {any} [offlineAttempt] Offline attempt synchronized, if any.
     * @param {any} [onlineAttempt] Online data for the offline attempt.
     * @param {boolean} [removeAttempt] Whether the offline data should be removed.
     * @param {boolean} [updated] Whether some data was sent to the site.
     * @return {Promise<AddonModQuizSyncResult>} Promise resolved on success.
     */
    AddonModQuizSyncProvider.prototype.finishSync = function (siteId, quiz, courseId, warnings, attemptId, offlineAttempt, onlineAttempt, removeAttempt, updated) {
        var _this = this;
        // Invalidate the data for the quiz and attempt.
        return this.quizProvider.invalidateAllQuizData(quiz.id, courseId, attemptId, siteId).catch(function () {
            // Ignore errors.
        }).then(function () {
            if (removeAttempt && attemptId) {
                return _this.quizOfflineProvider.removeAttemptAndAnswers(attemptId, siteId);
            }
        }).then(function () {
            if (updated) {
                // Data has been sent. Update prefetched data.
                return _this.courseProvider.getModuleBasicInfoByInstance(quiz.id, 'quiz', siteId).then(function (module) {
                    return _this.prefetchAfterUpdateQuiz(module, quiz, courseId, undefined, siteId);
                }).catch(function () {
                    // Ignore errors.
                });
            }
        }).then(function () {
            return _this.setSyncTime(quiz.id, siteId).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            // Check if online attempt was finished because of the sync.
            if (onlineAttempt && !_this.quizProvider.isAttemptFinished(onlineAttempt.state)) {
                // Attempt wasn't finished at start. Check if it's finished now.
                return _this.quizProvider.getUserAttempts(quiz.id, 'all', true, false, false, siteId).then(function (attempts) {
                    // Search the attempt.
                    for (var i in attempts) {
                        var attempt = attempts[i];
                        if (attempt.id == onlineAttempt.id) {
                            return _this.quizProvider.isAttemptFinished(attempt.state);
                        }
                    }
                    return false;
                });
            }
            return false;
        }).then(function (attemptFinished) {
            return {
                warnings: warnings,
                attemptFinished: attemptFinished
            };
        });
    };
    /**
     * Check if a quiz has data to synchronize.
     *
     * @param {number} quizId Quiz ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether it has data to sync.
     */
    AddonModQuizSyncProvider.prototype.hasDataToSync = function (quizId, siteId) {
        return this.quizOfflineProvider.getQuizAttempts(quizId, siteId).then(function (attempts) {
            return !!attempts.length;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Conveniece function to prefetch data after an update.
     *
     * @param {any} module Module.
     * @param {any} quiz Quiz.
     * @param {number} courseId Course ID.
     * @param {RegExp} [regex] If regex matches, don't download the data. Defaults to check files.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModQuizSyncProvider.prototype.prefetchAfterUpdateQuiz = function (module, quiz, courseId, regex, siteId) {
        var _this = this;
        regex = regex || /^.*files$/;
        var shouldDownload;
        // Get the module updates to check if the data was updated or not.
        return this.prefetchDelegate.getModuleUpdates(module, courseId, true, siteId).then(function (result) {
            if (result && result.updates && result.updates.length > 0) {
                // Only prefetch if files haven't changed.
                shouldDownload = !result.updates.find(function (entry) {
                    return entry.name.match(regex);
                });
                if (shouldDownload) {
                    return _this.prefetchHandler.download(module, courseId, undefined, false, false);
                }
            }
        }).then(function () {
            // Prefetch finished or not needed, set the right status.
            return _this.prefetchHandler.setStatusAfterPrefetch(quiz, undefined, shouldDownload, false, siteId);
        });
    };
    /**
     * Try to synchronize all the quizzes in a certain site or in all sites.
     *
     * @param {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModQuizSyncProvider.prototype.syncAllQuizzes = function (siteId, force) {
        return this.syncOnSites('all quizzes', this.syncAllQuizzesFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all quizzes on a site.
     *
     * @param  {string} siteId Site ID to sync.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @param {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModQuizSyncProvider.prototype.syncAllQuizzesFunc = function (siteId, force) {
        var _this = this;
        // Get all offline attempts.
        return this.quizOfflineProvider.getAllAttempts(siteId).then(function (attempts) {
            var quizzes = [], ids = [], // To prevent duplicates.
            promises = [];
            // Get the IDs of all the quizzes that have something to be synced.
            attempts.forEach(function (attempt) {
                if (ids.indexOf(attempt.quizid) == -1) {
                    ids.push(attempt.quizid);
                    quizzes.push({
                        id: attempt.quizid,
                        courseid: attempt.courseid
                    });
                }
            });
            // Sync all quizzes that haven't been synced for a while and that aren't attempted right now.
            quizzes.forEach(function (quiz) {
                if (!_this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_15__quiz__["a" /* AddonModQuizProvider */].COMPONENT, quiz.id, siteId)) {
                    // Quiz not blocked, try to synchronize it.
                    promises.push(_this.quizProvider.getQuizById(quiz.courseid, quiz.id, false, false, siteId).then(function (quiz) {
                        var promise = force ? _this.syncQuiz(quiz, false, siteId) : _this.syncQuizIfNeeded(quiz, false, siteId);
                        return promise.then(function (data) {
                            if (data && data.warnings && data.warnings.length) {
                                // Store the warnings to show them when the user opens the quiz.
                                return _this.setSyncWarnings(quiz.id, data.warnings, siteId).then(function () {
                                    return data;
                                });
                            }
                            return data;
                        }).then(function (data) {
                            if (typeof data != 'undefined') {
                                // Sync successful. Send event.
                                _this.eventsProvider.trigger(AddonModQuizSyncProvider_1.AUTO_SYNCED, {
                                    quizId: quiz.id,
                                    attemptFinished: data.attemptFinished,
                                    warnings: data.warnings
                                }, siteId);
                            }
                        });
                    }));
                }
            });
            return Promise.all(promises);
        });
    };
    /**
     * Sync a quiz only if a certain time has passed since the last time.
     *
     * @param {any} quiz Quiz.
     * @param {boolean} [askPreflight] Whether we should ask for preflight data if needed.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the quiz is synced or if it doesn't need to be synced.
     */
    AddonModQuizSyncProvider.prototype.syncQuizIfNeeded = function (quiz, askPreflight, siteId) {
        var _this = this;
        return this.isSyncNeeded(quiz.id, siteId).then(function (needed) {
            if (needed) {
                return _this.syncQuiz(quiz, askPreflight, siteId);
            }
        });
    };
    /**
     * Try to synchronize a quiz.
     * The promise returned will be resolved with an array with warnings if the synchronization is successful.
     *
     * @param {any} quiz Quiz.
     * @param {boolean} [askPreflight] Whether we should ask for preflight data if needed.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<AddonModQuizSyncResult>} Promise resolved in success.
     */
    AddonModQuizSyncProvider.prototype.syncQuiz = function (quiz, askPreflight, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var warnings = [], courseId = quiz.course;
        var syncPromise, preflightData;
        if (this.isSyncing(quiz.id, siteId)) {
            // There's already a sync ongoing for this quiz, return the promise.
            return this.getOngoingSync(quiz.id, siteId);
        }
        // Verify that quiz isn't blocked.
        if (this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_15__quiz__["a" /* AddonModQuizProvider */].COMPONENT, quiz.id, siteId)) {
            this.logger.debug('Cannot sync quiz ' + quiz.id + ' because it is blocked.');
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        this.logger.debug('Try to sync quiz ' + quiz.id + ' in site ' + siteId);
        // Sync offline logs.
        syncPromise = this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_15__quiz__["a" /* AddonModQuizProvider */].COMPONENT, quiz.id, siteId).catch(function () {
            // Ignore errors.
        }).then(function () {
            // Get all the offline attempts for the quiz.
            return _this.quizOfflineProvider.getQuizAttempts(quiz.id, siteId);
        }).then(function (attempts) {
            // Should return 0 or 1 attempt.
            if (!attempts.length) {
                return _this.finishSync(siteId, quiz, courseId, warnings);
            }
            var offlineAttempt = attempts.pop();
            // Now get the list of online attempts to make sure this attempt exists and isn't finished.
            return _this.quizProvider.getUserAttempts(quiz.id, 'all', true, false, true, siteId).then(function (attempts) {
                var lastAttemptId = attempts.length ? attempts[attempts.length - 1].id : undefined;
                var onlineAttempt;
                // Search the attempt we retrieved from offline.
                for (var i in attempts) {
                    var attempt = attempts[i];
                    if (attempt.id == offlineAttempt.id) {
                        onlineAttempt = attempt;
                        break;
                    }
                }
                if (!onlineAttempt || _this.quizProvider.isAttemptFinished(onlineAttempt.state)) {
                    // Attempt not found or it's finished in online. Discard it.
                    warnings.push(_this.translate.instant('addon.mod_quiz.warningattemptfinished'));
                    return _this.finishSync(siteId, quiz, courseId, warnings, offlineAttempt.id, offlineAttempt, onlineAttempt, true);
                }
                // Get the data stored in offline.
                return _this.quizOfflineProvider.getAttemptAnswers(offlineAttempt.id, siteId).then(function (answersList) {
                    if (!answersList.length) {
                        // No answers stored, finish.
                        return _this.finishSync(siteId, quiz, courseId, warnings, lastAttemptId, offlineAttempt, onlineAttempt, true);
                    }
                    var answers = _this.questionProvider.convertAnswersArrayToObject(answersList), offlineQuestions = _this.quizOfflineProvider.classifyAnswersInQuestions(answers);
                    var finish;
                    // We're going to need preflightData, get it.
                    return _this.quizProvider.getQuizAccessInformation(quiz.id, false, true, siteId).then(function (info) {
                        return _this.prefetchHandler.getPreflightData(quiz, info, onlineAttempt, askPreflight, 'core.settings.synchronization', siteId);
                    }).then(function (data) {
                        preflightData = data;
                        // Now get the online questions data.
                        var pages = _this.quizProvider.getPagesFromLayoutAndQuestions(onlineAttempt.layout, offlineQuestions);
                        return _this.quizProvider.getAllQuestionsData(quiz, onlineAttempt, preflightData, pages, false, true, siteId);
                    }).then(function (onlineQuestions) {
                        // Validate questions, discarding the offline answers that can't be synchronized.
                        return _this.validateQuestions(onlineAttempt.id, onlineQuestions, offlineQuestions, siteId);
                    }).then(function (discardedData) {
                        // Get the answers to send.
                        var answers = _this.quizOfflineProvider.extractAnswersFromQuestions(offlineQuestions);
                        finish = offlineAttempt.finished && !discardedData;
                        if (discardedData) {
                            if (offlineAttempt.finished) {
                                warnings.push(_this.translate.instant('addon.mod_quiz.warningdatadiscardedfromfinished'));
                            }
                            else {
                                warnings.push(_this.translate.instant('addon.mod_quiz.warningdatadiscarded'));
                            }
                        }
                        return _this.quizProvider.processAttempt(quiz, onlineAttempt, answers, preflightData, finish, false, false, siteId);
                    }).then(function () {
                        // Answers sent, now set the current page if the attempt isn't finished.
                        if (!finish) {
                            // Don't pass the quiz instance because we don't want to trigger a Firebase event in this case.
                            return _this.quizProvider.logViewAttempt(onlineAttempt.id, offlineAttempt.currentpage, preflightData, false, undefined, siteId).catch(function () {
                                // Ignore errors.
                            });
                        }
                    }).then(function () {
                        // Data sent. Finish the sync.
                        return _this.finishSync(siteId, quiz, courseId, warnings, lastAttemptId, offlineAttempt, onlineAttempt, true, true);
                    });
                });
            });
        });
        return this.addOngoingSync(quiz.id, syncPromise, siteId);
    };
    /**
     * Validate questions, discarding the offline answers that can't be synchronized.
     *
     * @param {number} attemptId Attempt ID.
     * @param {any} onlineQuestions Online questions
     * @param {any} offlineQuestions Offline questions.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: true if some offline data was discarded, false otherwise.
     */
    AddonModQuizSyncProvider.prototype.validateQuestions = function (attemptId, onlineQuestions, offlineQuestions, siteId) {
        var promises = [];
        var discardedData = false;
        for (var slot in offlineQuestions) {
            var offlineQuestion = offlineQuestions[slot], onlineQuestion = onlineQuestions[slot], offlineSequenceCheck = offlineQuestion.answers[':sequencecheck'];
            if (onlineQuestion) {
                // We found the online data for the question, validate that the sequence check is ok.
                if (!this.questionDelegate.validateSequenceCheck(onlineQuestion, offlineSequenceCheck)) {
                    // Sequence check is not valid, remove the offline data.
                    discardedData = true;
                    promises.push(this.quizOfflineProvider.removeQuestionAndAnswers(attemptId, Number(slot), siteId));
                    delete offlineQuestions[slot];
                }
                else {
                    // Sequence check is valid. Use the online one to prevent synchronization errors.
                    offlineQuestion.answers[':sequencecheck'] = onlineQuestion.sequencecheck;
                }
            }
            else {
                // Online question not found, it can happen for 2 reasons:
                // 1- It's a sequential quiz and the question is in a page already passed.
                // 2- Quiz layout has changed (shouldn't happen since it's blocked if there are attempts).
                discardedData = true;
                promises.push(this.quizOfflineProvider.removeQuestionAndAnswers(attemptId, Number(slot), siteId));
                delete offlineQuestions[slot];
            }
        }
        return Promise.all(promises).then(function () {
            return discardedData;
        });
    };
    AddonModQuizSyncProvider.AUTO_SYNCED = 'addon_mod_quiz_autom_synced';
    AddonModQuizSyncProvider = AddonModQuizSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_15__quiz__["a" /* AddonModQuizProvider */], __WEBPACK_IMPORTED_MODULE_16__quiz_offline__["a" /* AddonModQuizOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_17__prefetch_handler__["a" /* AddonModQuizPrefetchHandler */], __WEBPACK_IMPORTED_MODULE_12__core_question_providers_question__["a" /* CoreQuestionProvider */],
            __WEBPACK_IMPORTED_MODULE_13__core_question_providers_delegate__["a" /* CoreQuestionDelegate */], __WEBPACK_IMPORTED_MODULE_10__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_11__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */], __WEBPACK_IMPORTED_MODULE_9__core_course_providers_course__["a" /* CoreCourseProvider */]])
    ], AddonModQuizSyncProvider);
    return AddonModQuizSyncProvider;
    var AddonModQuizSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_14__core_course_classes_activity_sync__["a" /* CoreCourseActivitySyncBaseProvider */]));

//# sourceMappingURL=quiz-sync.js.map

/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonNotesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_site__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__notes_offline__ = __webpack_require__(446);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_pushnotifications_providers_pushnotifications__ = __webpack_require__(140);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Service to handle notes.
 */
var AddonNotesProvider = /** @class */ (function () {
    function AddonNotesProvider(logger, sitesProvider, appProvider, utils, translate, userProvider, notesOffline, pushNotificationsProvider) {
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        this.utils = utils;
        this.translate = translate;
        this.userProvider = userProvider;
        this.notesOffline = notesOffline;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.ROOT_CACHE_KEY = 'mmaNotes:';
        this.logger = logger.getInstance('AddonNotesProvider');
    }
    /**
     * Add a note.
     *
     * @param  {number} userId       User ID of the person to add the note.
     * @param  {number} courseId     Course ID where the note belongs.
     * @param  {string} publishState Personal, Site or Course.
     * @param  {string} noteText     The note text.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<boolean>}    Promise resolved with boolean: true if note was sent to server, false if stored in device.
     */
    AddonNotesProvider.prototype.addNote = function (userId, courseId, publishState, noteText, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a note to be synchronized later.
        var storeOffline = function () {
            return _this.notesOffline.saveNote(userId, courseId, publishState, noteText, siteId).then(function () {
                return false;
            });
        };
        if (!this.appProvider.isOnline()) {
            // App is offline, store the note.
            return storeOffline();
        }
        // Send note to server.
        return this.addNoteOnline(userId, courseId, publishState, noteText, siteId).then(function () {
            return true;
        }).catch(function (error) {
            if (_this.utils.isWebServiceError(error)) {
                // It's a WebService error, the user cannot send the message so don't store it.
                return Promise.reject(error);
            }
            // Error sending note, store it to retry later.
            return storeOffline();
        });
    };
    /**
     * Add a note. It will fail if offline or cannot connect.
     *
     * @param  {number} userId       User ID of the person to add the note.
     * @param  {number} courseId     Course ID where the note belongs.
     * @param  {string} publishState Personal, Site or Course.
     * @param  {string} noteText     The note text.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when added, rejected otherwise.
     */
    AddonNotesProvider.prototype.addNoteOnline = function (userId, courseId, publishState, noteText, siteId) {
        var _this = this;
        var notes = [
            {
                courseid: courseId,
                format: 1,
                publishstate: publishState,
                text: noteText,
                userid: userId
            }
        ];
        return this.addNotesOnline(notes, siteId).then(function (response) {
            if (response && response[0] && response[0].noteid === -1) {
                // There was an error, and it should be translated already.
                return Promise.reject(_this.utils.createFakeWSError(response[0].errormessage));
            }
            // A note was added, invalidate the course notes.
            return _this.invalidateNotes(courseId, undefined, siteId).catch(function () {
                // Ignore errors.
            });
        });
    };
    /**
     * Add several notes. It will fail if offline or cannot connect.
     *
     * @param  {any[]}  notes    Notes to save.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when added, rejected otherwise. Promise resolved doesn't mean that notes
     *                           have been added, the resolve param can contain errors for notes not sent.
     */
    AddonNotesProvider.prototype.addNotesOnline = function (notes, siteId) {
        if (!notes || !notes.length) {
            return Promise.resolve();
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                notes: notes
            };
            return site.write('core_notes_create_notes', data);
        });
    };
    /**
     * Returns whether or not the notes plugin is enabled for a certain site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if enabled, resolved with false or rejected otherwise.
     */
    AddonNotesProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canUseAdvancedFeature('enablenotes');
        });
    };
    /**
     * Returns whether or not the add note plugin is enabled for a certain course.
     *
     * @param  {number} courseId  ID of the course.
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if enabled, resolved with false or rejected otherwise.
     */
    AddonNotesProvider.prototype.isPluginAddNoteEnabledForCourse = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // The only way to detect if it's enabled is to perform a WS call.
            // We use an invalid user ID (-1) to avoid saving the note if the user has permissions.
            var data = {
                notes: [
                    {
                        userid: -1,
                        publishstate: 'personal',
                        courseid: courseId,
                        text: '',
                        format: 1
                    }
                ]
            }, preSets = {
                updateFrequency: __WEBPACK_IMPORTED_MODULE_5__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            /* Use .read to cache data and be able to check it in offline. This means that, if a user loses the capabilities
               to add notes, he'll still see the option in the app. */
            return _this.utils.promiseWorks(site.read('core_notes_create_notes', data, preSets));
        });
    };
    /**
     * Returns whether or not the read notes plugin is enabled for a certain course.
     *
     * @param  {number} courseId  ID of the course.
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if enabled, resolved with false or rejected otherwise.
     */
    AddonNotesProvider.prototype.isPluginViewNotesEnabledForCourse = function (courseId, siteId) {
        return this.utils.promiseWorks(this.getNotes(courseId, undefined, false, true, siteId));
    };
    /**
     * Get prefix cache key for course notes.
     *
     * @param  {number} courseId ID of the course to get the notes from.
     * @return {string}          Cache key.
     */
    AddonNotesProvider.prototype.getNotesPrefixCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'notes:' + courseId + ':';
    };
    /**
     * Get the cache key for the get notes call.
     *
     * @param  {number} courseId ID of the course to get the notes from.
     * @param  {number}  [userId]      ID of the user to get the notes from if requested.
     * @return {string}          Cache key.
     */
    AddonNotesProvider.prototype.getNotesCacheKey = function (courseId, userId) {
        return this.getNotesPrefixCacheKey(courseId) + (userId ? userId : '');
    };
    /**
     * Get users notes for a certain site, course and personal notes.
     *
     * @param  {number}  courseId      ID of the course to get the notes from.
     * @param  {number}  [userId]      ID of the user to get the notes from if requested.
     * @param  {boolean} [ignoreCache] True when we should not get the value from the cache.
     * @param  {boolean} [onlyOnline]  True to return only online notes, false to return both online and offline.
     * @param  {string}  [siteId]      Site ID. If not defined, current site.
     * @return {Promise<any>}          Promise to be resolved when the notes are retrieved.
     */
    AddonNotesProvider.prototype.getNotes = function (courseId, userId, ignoreCache, onlyOnline, siteId) {
        var _this = this;
        this.logger.debug('Get notes for course ' + courseId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                courseid: courseId
            };
            if (userId) {
                data['userid'] = userId;
            }
            var preSets = {
                cacheKey: _this.getNotesCacheKey(courseId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_5__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('core_notes_get_course_notes', data, preSets).then(function (notes) {
                if (onlyOnline) {
                    return notes;
                }
                // Get offline notes and add them to the list.
                return _this.notesOffline.getNotesForCourseAndUser(courseId, userId, siteId).then(function (offlineNotes) {
                    offlineNotes.forEach(function (note) {
                        var fieldName = note.publishstate + 'notes';
                        if (!notes[fieldName]) {
                            notes[fieldName] = [];
                        }
                        note.offline = true;
                        // Add note to the start of array since last notes are shown first.
                        notes[fieldName].unshift(note);
                    });
                    return notes;
                });
            });
        });
    };
    /**
     * Get user data for notes since they only have userid.
     *
     * @param  {any[]}  notes    Notes to get the data for.
     * @param  {number} courseId ID of the course the notes belong to.
     * @return {Promise<any>}    Promise always resolved. Resolve param is the formatted notes.
     */
    AddonNotesProvider.prototype.getNotesUserData = function (notes, courseId) {
        var _this = this;
        var promises = notes.map(function (note) {
            // Get the user profile to retrieve the user image.
            return _this.userProvider.getProfile(note.userid, note.courseid, true).then(function (user) {
                note.userfullname = user.fullname;
                note.userprofileimageurl = user.profileimageurl || null;
            }).catch(function () {
                note.userfullname = _this.translate.instant('addon.notes.userwithid', { id: note.userid });
            });
        });
        return Promise.all(promises).then(function () {
            return notes;
        });
    };
    /**
     * Invalidate get notes WS call.
     *
     * @param  {number} courseId Course ID.
     * @param  {number} [userId] User ID if needed.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when data is invalidated.
     */
    AddonNotesProvider.prototype.invalidateNotes = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (userId) {
                return site.invalidateWsCacheForKey(_this.getNotesCacheKey(courseId, userId));
            }
            return site.invalidateWsCacheForKeyStartingWith(_this.getNotesPrefixCacheKey(courseId));
        });
    };
    /**
     * Report notes as being viewed.
     *
     * @param {number} courseId  ID of the course.
     * @param {number} [userId]  User ID if needed.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonNotesProvider.prototype.logView = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseid: courseId,
                userid: userId || 0
            };
            _this.pushNotificationsProvider.logViewListEvent('notes', 'core_notes_view_notes', params, site.getId());
            return site.write('core_notes_view_notes', params);
        });
    };
    AddonNotesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_7__core_user_providers_user__["a" /* CoreUserProvider */],
            __WEBPACK_IMPORTED_MODULE_8__notes_offline__["a" /* AddonNotesOfflineProvider */], __WEBPACK_IMPORTED_MODULE_9__core_pushnotifications_providers_pushnotifications__["a" /* CorePushNotificationsProvider */]])
    ], AddonNotesProvider);
    return AddonNotesProvider;
}());

//# sourceMappingURL=notes.js.map

/***/ }),
/* 247 */,
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












/**
 * Service that provides some features for books.
 */
var AddonModBookProvider = /** @class */ (function () {
    function AddonModBookProvider(logger, sitesProvider, textUtils, fileProvider, filepoolProvider, http, utils, courseProvider, domUtils, logHelper) {
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.filepoolProvider = filepoolProvider;
        this.http = http;
        this.utils = utils;
        this.courseProvider = courseProvider;
        this.domUtils = domUtils;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModBook:';
        this.logger = logger.getInstance('AddonModBookProvider');
    }
    AddonModBookProvider_1 = AddonModBookProvider;
    /**
     * Get a book by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the book is retrieved.
     */
    AddonModBookProvider.prototype.getBook = function (courseId, cmId, siteId) {
        return this.getBookByField(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Get a book with key=value. If more than one is found, only the first will be returned.
     *
     * @param {number} courseId Course ID.
     * @param {string} key Name of the property to check.
     * @param {any} value Value to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the book is retrieved.
     */
    AddonModBookProvider.prototype.getBookByField = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getBookDataCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_11__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_book_get_books_by_courses', params, preSets).then(function (response) {
                // Search the book.
                if (response && response.books) {
                    for (var i in response.books) {
                        var book = response.books[i];
                        if (book[key] == value) {
                            return book;
                        }
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get book data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModBookProvider.prototype.getBookDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'book:' + courseId;
    };
    /**
     * Gets a chapter contents.
     *
     * @param {AddonModBookContentsMap} contentsMap Contents map returned by getContentsMap.
     * @param {string} chapterId Chapter to retrieve.
     * @param {number} moduleId The module ID.
     * @return {Promise<string>} Promise resolved with the contents.
     */
    AddonModBookProvider.prototype.getChapterContent = function (contentsMap, chapterId, moduleId) {
        var _this = this;
        var indexUrl = contentsMap[chapterId] ? contentsMap[chapterId].indexUrl : undefined, siteId = this.sitesProvider.getCurrentSiteId();
        var promise;
        if (!indexUrl) {
            // It shouldn't happen.
            this.logger.debug('Could not locate the index chapter');
            return Promise.reject(null);
        }
        if (this.fileProvider.isAvailable()) {
            promise = this.filepoolProvider.downloadUrl(siteId, indexUrl, false, AddonModBookProvider_1.COMPONENT, moduleId);
        }
        else {
            // We return the live URL.
            return Promise.resolve(this.sitesProvider.getCurrentSite().fixPluginfileURL(indexUrl));
        }
        return promise.then(function (url) {
            // Fetch the URL content.
            var promise = _this.http.get(url).toPromise();
            return promise.then(function (response) {
                var content = response.text();
                if (typeof content !== 'string') {
                    return Promise.reject(null);
                }
                else {
                    // Now that we have the content, we update the SRC to point back to the external resource.
                    return _this.domUtils.restoreSourcesInHtml(content, contentsMap[chapterId].paths);
                }
            });
        });
    };
    /**
     * Convert an array of book contents into an object where contents are organized in chapters.
     * Each chapter has an indexUrl and the list of contents in that chapter.
     *
     * @param {any[]} contents The module contents.
     * @return {AddonModBookContentsMap} Contents map.
     */
    AddonModBookProvider.prototype.getContentsMap = function (contents) {
        var _this = this;
        var map = {};
        if (!contents) {
            return map;
        }
        contents.forEach(function (content) {
            if (_this.isFileDownloadable(content)) {
                var chapter = void 0, matches = void 0, split = void 0, filepathIsChapter = void 0, key = void 0;
                // Search the chapter number in the filepath.
                matches = content.filepath.match(/\/(\d+)\//);
                if (matches && matches[1]) {
                    chapter = matches[1];
                    filepathIsChapter = content.filepath == '/' + chapter + '/';
                    // Init the chapter if it's not defined yet.
                    map[chapter] = map[chapter] || { paths: {} };
                    if (content.filename == 'index.html' && filepathIsChapter) {
                        // Index of the chapter, set indexUrl of the chapter.
                        map[chapter].indexUrl = content.fileurl;
                    }
                    else {
                        if (filepathIsChapter) {
                            // It's a file in the root folder OR the WS isn't returning the filepath as it should (MDL-53671).
                            // Try to get the path to the file from the URL.
                            split = content.fileurl.split('mod_book/chapter' + content.filepath);
                            key = split[1] || content.filename; // Use filename if we couldn't find the path.
                        }
                        else {
                            // Remove the chapter folder from the path and add the filename.
                            key = content.filepath.replace('/' + chapter + '/', '') + content.filename;
                        }
                        map[chapter].paths[_this.textUtils.decodeURIComponent(key)] = content.fileurl;
                    }
                }
            }
        });
        return map;
    };
    /**
     * Get the first chapter of a book.
     *
     * @param {AddonModBookTocChapter[]} chapters The chapters list.
     * @return {string} The chapter id.
     */
    AddonModBookProvider.prototype.getFirstChapter = function (chapters) {
        if (!chapters || !chapters.length) {
            return;
        }
        return chapters[0].id;
    };
    /**
     * Get the next chapter to the given one.
     *
     * @param {AddonModBookTocChapter[]} chapters The chapters list.
     * @param {string} chapterId The current chapter.
     * @return {string} The next chapter id.
     */
    AddonModBookProvider.prototype.getNextChapter = function (chapters, chapterId) {
        var next = '0';
        for (var i = 0; i < chapters.length; i++) {
            if (chapters[i].id == chapterId) {
                if (typeof chapters[i + 1] != 'undefined') {
                    next = chapters[i + 1].id;
                    break;
                }
            }
        }
        return next;
    };
    /**
     * Get the previous chapter to the given one.
     *
     * @param {AddonModBookTocChapter[]} chapters The chapters list.
     * @param {string} chapterId The current chapter.
     * @return {string} The next chapter id.
     */
    AddonModBookProvider.prototype.getPreviousChapter = function (chapters, chapterId) {
        var previous = '0';
        for (var i = 0; i < chapters.length; i++) {
            if (chapters[i].id == chapterId) {
                break;
            }
            previous = chapters[i].id;
        }
        return previous;
    };
    /**
     * Get the book toc as an array.
     *
     * @param {any[]} contents The module contents.
     * @return {any[]} The toc.
     */
    AddonModBookProvider.prototype.getToc = function (contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return this.textUtils.parseJSON(contents[0].content, []);
    };
    /**
     * Get the book toc as an array of chapters (not nested).
     *
     * @param {any[]} contents The module contents.
     * @return {AddonModBookTocChapter[]} The toc as a list.
     */
    AddonModBookProvider.prototype.getTocList = function (contents) {
        var chapters = [], toc = this.getToc(contents);
        toc.forEach(function (chapter) {
            // Add the chapter to the list.
            var chapterId = chapter.href.replace('/index.html', '');
            chapters.push({ id: chapterId, title: chapter.title, level: chapter.level });
            if (chapter.subitems) {
                // Add all the subchapters to the list.
                chapter.subitems.forEach(function (subChapter) {
                    chapterId = subChapter.href.replace('/index.html', '');
                    chapters.push({ id: chapterId, title: subChapter.title, level: subChapter.level });
                });
            }
        });
        return chapters;
    };
    /**
     * Invalidates book data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModBookProvider.prototype.invalidateBookData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getBookDataCacheKey(courseId));
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID of the module.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModBookProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.invalidateBookData(courseId, siteId));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModBookProvider_1.COMPONENT, moduleId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @param {any} file File to check.
     * @return {boolean} Whether it's downloadable.
     */
    AddonModBookProvider.prototype.isFileDownloadable = function (file) {
        return file.type === 'file';
    };
    /**
     * Return whether or not the plugin is enabled.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonModBookProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canDownloadFiles();
        });
    };
    /**
     * Report a book as being viewed.
     *
     * @param {number} id Module ID.
     * @param {string} chapterId Chapter ID.
     * @param {string} [name] Name of the book.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModBookProvider.prototype.logView = function (id, chapterId, name, siteId) {
        var params = {
            bookid: id,
            chapterid: chapterId
        };
        return this.logHelper.logSingle('mod_book_view_book', params, AddonModBookProvider_1.COMPONENT, id, name, 'book', { chapterid: chapterId }, siteId);
    };
    AddonModBookProvider.COMPONENT = 'mmaModBook';
    AddonModBookProvider = AddonModBookProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_1__angular_http__["d" /* Http */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModBookProvider);
    return AddonModBookProvider;
    var AddonModBookProvider_1;
}());

//# sourceMappingURL=book.js.map

/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModImscpProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service that provides some features for IMSCP.
 */
var AddonModImscpProvider = /** @class */ (function () {
    function AddonModImscpProvider(appProvider, courseProvider, filepoolProvider, sitesProvider, textUtils, utils, logHelper) {
        this.appProvider = appProvider;
        this.courseProvider = courseProvider;
        this.filepoolProvider = filepoolProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModImscp:';
    }
    AddonModImscpProvider_1 = AddonModImscpProvider;
    /**
     * Get the IMSCP toc as an array.
     *
     * @param  {any[]} contents The module contents.
     * @return {any} The toc.
     */
    AddonModImscpProvider.prototype.getToc = function (contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return JSON.parse(contents[0].content);
    };
    /**
     * Get the imscp toc as an array of items (not nested) to build the navigation tree.
     *
     * @param  {any[]} contents The module contents.
     * @return {any[]} The toc as a list.
     */
    AddonModImscpProvider.prototype.createItemList = function (contents) {
        var items = [];
        this.getToc(contents).forEach(function (el) {
            items.push({ href: el.href, title: el.title, level: el.level });
            el.subitems.forEach(function (sel) {
                items.push({ href: sel.href, title: sel.title, level: sel.level });
            });
        });
        return items;
    };
    /**
     * Get the previous item to the given one.
     *
     * @param  {any[]}  items  The items list.
     * @param  {string} itemId The current item.
     * @return {string} The previous item id.
     */
    AddonModImscpProvider.prototype.getPreviousItem = function (items, itemId) {
        var position = this.getItemPosition(items, itemId);
        if (position != -1) {
            for (var i = position - 1; i >= 0; i--) {
                if (items[i] && items[i].href) {
                    return items[i].href;
                }
            }
        }
        return '';
    };
    /**
     * Get the next item to the given one.
     *
     * @param  {any[]}  items  The items list.
     * @param  {string} itemId The current item.
     * @return {string} The next item id.
     */
    AddonModImscpProvider.prototype.getNextItem = function (items, itemId) {
        var position = this.getItemPosition(items, itemId);
        if (position != -1) {
            for (var i = position + 1; i < items.length; i++) {
                if (items[i] && items[i].href) {
                    return items[i].href;
                }
            }
        }
        return '';
    };
    /**
     * Get the position of a item.
     *
     * @param  {any[]}  items  The items list.
     * @param  {string} itemId The item to search.
     * @return {number} The item position.
     */
    AddonModImscpProvider.prototype.getItemPosition = function (items, itemId) {
        for (var i = 0; i < items.length; i++) {
            if (items[i].href == itemId) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Check if we should ommit the file download.
     *
     * @param  {string} fileName The file name
     * @return {boolean} True if we should ommit the file.
     */
    AddonModImscpProvider.prototype.checkSpecialFiles = function (fileName) {
        return fileName == 'imsmanifest.xml';
    };
    /**
     * Get cache key for imscp data WS calls.
     *
     * @param  {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModImscpProvider.prototype.getImscpDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'imscp:' + courseId;
    };
    /**
     * Get a imscp with key=value. If more than one is found, only the first will be returned.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} key      Name of the property to check.
     * @param  {any}    value    Value to search.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the imscp is retrieved.
     */
    AddonModImscpProvider.prototype.getImscpByKey = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            };
            var preSets = {
                cacheKey: _this.getImscpDataCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_8__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_imscp_get_imscps_by_courses', params, preSets).then(function (response) {
                if (response && response.imscps) {
                    var currentImscp = response.imscps.find(function (imscp) { return imscp[key] == value; });
                    if (currentImscp) {
                        return currentImscp;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a imscp by course module ID.
     *
     * @param  {number} courseId Course ID.
     * @param  {number} cmId     Course module ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the imscp is retrieved.
     */
    AddonModImscpProvider.prototype.getImscp = function (courseId, cmId, siteId) {
        return this.getImscpByKey(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Given a filepath, get a certain fileurl from module contents.
     *
     * @param  {any[]}  contents       Module contents.
     * @param  {string} targetFilePath Path of the searched file.
     * @return {string} File URL.
     */
    AddonModImscpProvider.prototype.getFileUrlFromContents = function (contents, targetFilePath) {
        var _this = this;
        var indexUrl;
        contents.forEach(function (content) {
            if (content.type == 'file' && !indexUrl) {
                var filePath = _this.textUtils.concatenatePaths(content.filepath, content.filename);
                var filePathAlt = filePath.charAt(0) === '/' ? filePath.substr(1) : '/' + filePath;
                // Check if it's main file.
                if (filePath === targetFilePath || filePathAlt === targetFilePath) {
                    indexUrl = content.fileurl;
                }
            }
        });
        return indexUrl;
    };
    /**
     * Get src of a imscp item.
     *
     * @param  {any}    module     The module object.
     * @param  {string} [itemHref] Href of item to get. If not defined, gets src of main item.
     * @return {Promise<string>} Promise resolved with the item src.
     */
    AddonModImscpProvider.prototype.getIframeSrc = function (module, itemHref) {
        var _this = this;
        if (!itemHref) {
            var toc = this.getToc(module.contents);
            if (!toc.length) {
                return Promise.reject(null);
            }
            itemHref = toc[0].href;
        }
        var siteId = this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.getPackageDirUrlByUrl(siteId, module.url).then(function (dirPath) {
            return _this.textUtils.concatenatePaths(dirPath, itemHref);
        }).catch(function () {
            // Error getting directory, there was an error downloading or we're in browser. Return online URL if connected.
            if (_this.appProvider.isOnline()) {
                var indexUrl_1 = _this.getFileUrlFromContents(module.contents, itemHref);
                if (indexUrl_1) {
                    return _this.sitesProvider.getSite(siteId).then(function (site) {
                        return site.fixPluginfileURL(indexUrl_1);
                    });
                }
            }
            return Promise.reject(null);
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the content is invalidated.
     */
    AddonModImscpProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.invalidateImscpData(courseId, siteId));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModImscpProvider_1.COMPONENT, moduleId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates imscp data.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModImscpProvider.prototype.invalidateImscpData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getImscpDataCacheKey(courseId));
        });
    };
    /**
     * Check if a file is downloadable. The file param must have 'type' and 'filename' attributes
     * like in core_course_get_contents response.
     *
     * @param  {any} file File to check.
     * @return {boolean} True if downloadable, false otherwise.
     */
    AddonModImscpProvider.prototype.isFileDownloadable = function (file) {
        return file.type === 'file' && !this.checkSpecialFiles(file.filename);
    };
    /**
     * Return whether or not the plugin is enabled in a certain site.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonModImscpProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canDownloadFiles();
        });
    };
    /**
     * Report a IMSCP as being viewed.
     *
     * @param  {string} id Module ID.
     * @param {string} [name] Name of the imscp.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModImscpProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            imscpid: id
        };
        return this.logHelper.logSingle('mod_imscp_view_imscp', params, AddonModImscpProvider_1.COMPONENT, id, name, 'imscp', {}, siteId);
    };
    AddonModImscpProvider.COMPONENT = 'mmaModImscp';
    AddonModImscpProvider = AddonModImscpProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModImscpProvider);
    return AddonModImscpProvider;
    var AddonModImscpProvider_1;
}());

//# sourceMappingURL=imscp.js.map

/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModQuizOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_question_providers_question__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_question_providers_behaviour_delegate__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__quiz__ = __webpack_require__(154);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service to handle offline quiz.
 */
var AddonModQuizOfflineProvider = /** @class */ (function () {
    function AddonModQuizOfflineProvider(logger, sitesProvider, timeUtils, questionProvider, translate, utils, behaviourDelegate) {
        this.sitesProvider = sitesProvider;
        this.timeUtils = timeUtils;
        this.questionProvider = questionProvider;
        this.translate = translate;
        this.utils = utils;
        this.behaviourDelegate = behaviourDelegate;
        this.siteSchema = {
            name: 'AddonModQuizOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModQuizOfflineProvider_1.ATTEMPTS_TABLE,
                    columns: [
                        {
                            name: 'id',
                            type: 'INTEGER',
                            primaryKey: true
                        },
                        {
                            name: 'attempt',
                            type: 'INTEGER'
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'quizid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'currentpage',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        },
                        {
                            name: 'finished',
                            type: 'INTEGER'
                        }
                    ]
                }
            ]
        };
        this.logger = logger.getInstance('AddonModQuizOfflineProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModQuizOfflineProvider_1 = AddonModQuizOfflineProvider;
    /**
     * Classify the answers in questions.
     *
     * @param {any} answers List of answers.
     * @return {any} Object with the questions, the keys are the slot. Each question contains its answers.
     */
    AddonModQuizOfflineProvider.prototype.classifyAnswersInQuestions = function (answers) {
        var questionsWithAnswers = {};
        // Classify the answers in each question.
        for (var name_1 in answers) {
            var slot = this.questionProvider.getQuestionSlotFromName(name_1), nameWithoutPrefix = this.questionProvider.removeQuestionPrefix(name_1);
            if (!questionsWithAnswers[slot]) {
                questionsWithAnswers[slot] = {
                    answers: {},
                    prefix: name_1.substr(0, name_1.indexOf(nameWithoutPrefix))
                };
            }
            questionsWithAnswers[slot].answers[nameWithoutPrefix] = answers[name_1];
        }
        return questionsWithAnswers;
    };
    /**
     * Given a list of questions with answers classified in it (@see AddonModQuizOfflineProvider.classifyAnswersInQuestions),
     * returns a list of answers (including prefix in the name).
     *
     * @param {any} questions Questions.
     * @return {any} Answers.
     */
    AddonModQuizOfflineProvider.prototype.extractAnswersFromQuestions = function (questions) {
        var answers = {};
        for (var slot in questions) {
            var question = questions[slot];
            for (var name_2 in question.answers) {
                answers[question.prefix + name_2] = question.answers[name_2];
            }
        }
        return answers;
    };
    /**
     * Get all the offline attempts in a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the offline attempts.
     */
    AddonModQuizOfflineProvider.prototype.getAllAttempts = function (siteId) {
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getAllRecords(AddonModQuizOfflineProvider_1.ATTEMPTS_TABLE);
        });
    };
    /**
     * Retrieve an attempt answers from site DB.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the answers.
     */
    AddonModQuizOfflineProvider.prototype.getAttemptAnswers = function (attemptId, siteId) {
        return this.questionProvider.getAttemptAnswers(__WEBPACK_IMPORTED_MODULE_8__quiz__["a" /* AddonModQuizProvider */].COMPONENT, attemptId, siteId);
    };
    /**
     * Retrieve an attempt from site DB.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the attempt.
     */
    AddonModQuizOfflineProvider.prototype.getAttemptById = function (attemptId, siteId) {
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecord(AddonModQuizOfflineProvider_1.ATTEMPTS_TABLE, { id: attemptId });
        });
    };
    /**
     * Retrieve an attempt from site DB.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @param {number} [userId]  User ID. If not defined, user current site's user.
     * @return {Promise<any[]>} Promise resolved with the attempts.
     */
    AddonModQuizOfflineProvider.prototype.getQuizAttempts = function (quizId, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().getRecords(AddonModQuizOfflineProvider_1.ATTEMPTS_TABLE, { quizid: quizId, userid: userId });
        });
    };
    /**
     * Load local state in the questions.
     *
     * @param {number} attemptId Attempt ID.
     * @param {any[]} questions List of questions.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModQuizOfflineProvider.prototype.loadQuestionsLocalStates = function (attemptId, questions, siteId) {
        var _this = this;
        var promises = [];
        questions.forEach(function (question) {
            promises.push(_this.questionProvider.getQuestion(__WEBPACK_IMPORTED_MODULE_8__quiz__["a" /* AddonModQuizProvider */].COMPONENT, attemptId, question.slot, siteId)
                .then(function (q) {
                var state = _this.questionProvider.getState(q.state);
                question.state = q.state;
                question.status = _this.translate.instant('core.question.' + state.status);
            }).catch(function () {
                // Question not found.
            }));
        });
        return Promise.all(promises).then(function () {
            return questions;
        });
    };
    /**
     * Process an attempt, saving its data.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @param {any} questions Object with the questions of the quiz. The keys should be the question slot.
     * @param {any} data Data to save.
     * @param {boolean} [finish] Whether to finish the quiz.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModQuizOfflineProvider.prototype.processAttempt = function (quiz, attempt, questions, data, finish, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var now = this.timeUtils.timestamp();
        var db;
        return this.sitesProvider.getSiteDb(siteId).then(function (siteDb) {
            db = siteDb;
            // Check if an attempt already exists.
            return _this.getAttemptById(attempt.id, siteId).catch(function () {
                // Attempt doesn't exist, create a new entry.
                return {
                    quizid: quiz.id,
                    userid: attempt.userid,
                    id: attempt.id,
                    courseid: quiz.course,
                    timecreated: now,
                    attempt: attempt.attempt,
                    currentpage: attempt.currentpage
                };
            });
        }).then(function (entry) {
            // Save attempt in DB.
            entry.timemodified = now;
            entry.finished = finish ? 1 : 0;
            return db.insertRecord(AddonModQuizOfflineProvider_1.ATTEMPTS_TABLE, entry);
        }).then(function () {
            // Attempt has been saved, now we need to save the answers.
            return _this.saveAnswers(quiz, attempt, questions, data, now, siteId);
        });
    };
    /**
     * Remove an attempt and its answers from local DB.
     *
     * @param {number} attemptId Attempt ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModQuizOfflineProvider.prototype.removeAttemptAndAnswers = function (attemptId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        // Remove stored answers and questions.
        promises.push(this.questionProvider.removeAttemptAnswers(__WEBPACK_IMPORTED_MODULE_8__quiz__["a" /* AddonModQuizProvider */].COMPONENT, attemptId, siteId));
        promises.push(this.questionProvider.removeAttemptQuestions(__WEBPACK_IMPORTED_MODULE_8__quiz__["a" /* AddonModQuizProvider */].COMPONENT, attemptId, siteId));
        // Remove the attempt.
        promises.push(this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.deleteRecords(AddonModQuizOfflineProvider_1.ATTEMPTS_TABLE, { id: attemptId });
        }));
        return Promise.all(promises);
    };
    /**
     * Remove a question and its answers from local DB.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} slot Question slot.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when finished.
     */
    AddonModQuizOfflineProvider.prototype.removeQuestionAndAnswers = function (attemptId, slot, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.questionProvider.removeQuestion(__WEBPACK_IMPORTED_MODULE_8__quiz__["a" /* AddonModQuizProvider */].COMPONENT, attemptId, slot, siteId));
        promises.push(this.questionProvider.removeQuestionAnswers(__WEBPACK_IMPORTED_MODULE_8__quiz__["a" /* AddonModQuizProvider */].COMPONENT, attemptId, slot, siteId));
        return Promise.all(promises);
    };
    /**
     * Save an attempt's answers and calculate state for questions modified.
     *
     * @param {any} quiz Quiz.
     * @param {any} attempt Attempt.
     * @param {any} questions Object with the questions of the quiz. The keys should be the question slot.
     * @param {any} answers Answers to save.
     * @param {number} [timeMod] Time modified to set in the answers. If not defined, current time.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModQuizOfflineProvider.prototype.saveAnswers = function (quiz, attempt, questions, answers, timeMod, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        timeMod = timeMod || this.timeUtils.timestamp();
        var questionsWithAnswers = {}, newStates = {};
        var promises = [];
        // Classify the answers in each question.
        for (var name_3 in answers) {
            var slot = this.questionProvider.getQuestionSlotFromName(name_3), nameWithoutPrefix = this.questionProvider.removeQuestionPrefix(name_3);
            if (questions[slot]) {
                if (!questionsWithAnswers[slot]) {
                    questionsWithAnswers[slot] = questions[slot];
                    questionsWithAnswers[slot].answers = {};
                }
                questionsWithAnswers[slot].answers[nameWithoutPrefix] = answers[name_3];
            }
        }
        var _loop_1 = function (slot) {
            var question = questionsWithAnswers[slot];
            promises.push(this_1.behaviourDelegate.determineNewState(quiz.preferredbehaviour, __WEBPACK_IMPORTED_MODULE_8__quiz__["a" /* AddonModQuizProvider */].COMPONENT, attempt.id, question, siteId).then(function (state) {
                // Check if state has changed.
                if (state && state.name != question.state) {
                    newStates[question.slot] = state.name;
                }
            }));
        };
        var this_1 = this;
        // First determine the new state of each question. We won't save the new state yet.
        for (var slot in questionsWithAnswers) {
            _loop_1(slot);
        }
        return Promise.all(promises).then(function () {
            // Now save the answers.
            return _this.questionProvider.saveAnswers(__WEBPACK_IMPORTED_MODULE_8__quiz__["a" /* AddonModQuizProvider */].COMPONENT, quiz.id, attempt.id, attempt.userid, answers, timeMod, siteId);
        }).then(function () {
            // Answers have been saved, now we can save the questions with the states.
            promises = [];
            for (var slot in newStates) {
                var question = questionsWithAnswers[slot];
                promises.push(_this.questionProvider.saveQuestion(__WEBPACK_IMPORTED_MODULE_8__quiz__["a" /* AddonModQuizProvider */].COMPONENT, quiz.id, attempt.id, attempt.userid, question, newStates[slot], siteId));
            }
            return _this.utils.allPromises(promises).catch(function (err) {
                // Ignore errors when saving question state.
                _this.logger.error('Error saving question state', err);
            });
        });
    };
    /**
     * Set attempt's current page.
     *
     * @param {number} attemptId Attempt ID.
     * @param {number} page Page to set.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModQuizOfflineProvider.prototype.setAttemptCurrentPage = function (attemptId, page, siteId) {
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.updateRecords(AddonModQuizOfflineProvider_1.ATTEMPTS_TABLE, { currentpage: page }, { id: attemptId });
        });
    };
    // Variables for database.
    AddonModQuizOfflineProvider.ATTEMPTS_TABLE = 'addon_mod_quiz_attempts';
    AddonModQuizOfflineProvider = AddonModQuizOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__core_question_providers_question__["a" /* CoreQuestionProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__core_question_providers_behaviour_delegate__["a" /* CoreQuestionBehaviourDelegate */]])
    ], AddonModQuizOfflineProvider);
    return AddonModQuizOfflineProvider;
    var AddonModQuizOfflineProvider_1;
}());

//# sourceMappingURL=quiz-offline.js.map

/***/ }),
/* 251 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModScormOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__scorm__ = __webpack_require__(217);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service to handle offline SCORM.
 */
var AddonModScormOfflineProvider = /** @class */ (function () {
    function AddonModScormOfflineProvider(logger, sitesProvider, timeUtils, syncProvider, utils, textUtils, userProvider) {
        this.sitesProvider = sitesProvider;
        this.timeUtils = timeUtils;
        this.syncProvider = syncProvider;
        this.utils = utils;
        this.textUtils = textUtils;
        this.userProvider = userProvider;
        this.siteSchema = {
            name: 'AddonModScormOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModScormOfflineProvider_1.ATTEMPTS_TABLE,
                    columns: [
                        {
                            name: 'scormid',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'attempt',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        },
                        {
                            name: 'snapshot',
                            type: 'TEXT'
                        },
                    ],
                    primaryKeys: ['scormid', 'userid', 'attempt']
                },
                {
                    name: AddonModScormOfflineProvider_1.TRACKS_TABLE,
                    columns: [
                        {
                            name: 'scormid',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'attempt',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'scoid',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'element',
                            type: 'TEXT',
                            notNull: true
                        },
                        {
                            name: 'value',
                            type: 'TEXT'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        },
                        {
                            name: 'synced',
                            type: 'INTEGER'
                        },
                    ],
                    primaryKeys: ['scormid', 'userid', 'attempt', 'scoid', 'element']
                }
            ]
        };
        this.logger = logger.getInstance('AddonModScormOfflineProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModScormOfflineProvider_1 = AddonModScormOfflineProvider;
    /**
     * Changes an attempt number in the data stored in offline.
     * This function is used to convert attempts into new attempts, so the stored snapshot will be removed and
     * entries will be marked as not synced.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Number of the attempt to change.
     * @param {number} newAttempt New attempt number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the attempt number changes.
     */
    AddonModScormOfflineProvider.prototype.changeAttemptNumber = function (scormId, attempt, newAttempt, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Change attempt number from ' + attempt + ' to ' + newAttempt + ' in SCORM ' + scormId);
            // Update the attempt number.
            var db = site.getDb(), currentAttemptConditions = { scormid: scormId, userid: userId, attempt: attempt }, newAttemptConditions = { scormid: scormId, userid: userId, attempt: newAttempt };
            var newData = {
                attempt: newAttempt,
                timemodified: _this.timeUtils.timestamp()
            };
            // Block the SCORM so it can't be synced.
            _this.syncProvider.blockOperation(__WEBPACK_IMPORTED_MODULE_8__scorm__["a" /* AddonModScormProvider */].COMPONENT, scormId, 'changeAttemptNumber', site.id);
            return db.updateRecords(AddonModScormOfflineProvider_1.ATTEMPTS_TABLE, newData, currentAttemptConditions).then(function () {
                // Now update the attempt number of all the tracks and mark them as not synced.
                newData = {
                    attempt: newAttempt,
                    synced: 0
                };
                return db.updateRecords(AddonModScormOfflineProvider_1.TRACKS_TABLE, newData, currentAttemptConditions)
                    .catch(function (error) {
                    // Failed to update the tracks, restore the old attempt number.
                    return db.updateRecords(AddonModScormOfflineProvider_1.ATTEMPTS_TABLE, { attempt: attempt }, newAttemptConditions).then(function () {
                        return Promise.reject(error);
                    });
                });
            }).finally(function () {
                // Unblock the SCORM.
                _this.syncProvider.unblockOperation(__WEBPACK_IMPORTED_MODULE_8__scorm__["a" /* AddonModScormProvider */].COMPONENT, scormId, 'changeAttemptNumber', site.id);
            });
        });
    };
    /**
     * Creates a new offline attempt. It can be created from scratch or as a copy of another attempt.
     *
     * @param {any} scorm SCORM.
     * @param {number} attempt Number of the new attempt.
     * @param {any} userData User data to store in the attempt.
     * @param {any} [snapshot] Optional. Snapshot to store in the attempt.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the new attempt is created.
     */
    AddonModScormOfflineProvider.prototype.createNewAttempt = function (scorm, attempt, userData, snapshot, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Creating new offline attempt ' + attempt + ' in SCORM ' + scorm.id);
            // Block the SCORM so it can't be synced.
            _this.syncProvider.blockOperation(__WEBPACK_IMPORTED_MODULE_8__scorm__["a" /* AddonModScormProvider */].COMPONENT, scorm.id, 'createNewAttempt', site.id);
            // Create attempt in DB.
            var db = site.getDb(), entry = {
                scormid: scorm.id,
                userid: userId,
                attempt: attempt,
                courseid: scorm.course,
                timecreated: _this.timeUtils.timestamp(),
                timemodified: _this.timeUtils.timestamp(),
                snapshot: null
            };
            if (snapshot) {
                // Save a snapshot of the data we had when we created the attempt.
                // Remove the default data, we don't want to store it.
                entry.snapshot = JSON.stringify(_this.removeDefaultData(snapshot));
            }
            return db.insertRecord(AddonModScormOfflineProvider_1.ATTEMPTS_TABLE, entry).then(function () {
                // Store all the data in userData.
                var promises = [];
                for (var key in userData) {
                    var sco = userData[key], tracks = [];
                    for (var element in sco.userdata) {
                        tracks.push({ element: element, value: sco.userdata[element] });
                    }
                    promises.push(_this.saveTracks(scorm, sco.scoid, attempt, tracks, userData, site.id, userId));
                }
                return Promise.all(promises);
            }).finally(function () {
                // Unblock the SCORM.
                _this.syncProvider.unblockOperation(__WEBPACK_IMPORTED_MODULE_8__scorm__["a" /* AddonModScormProvider */].COMPONENT, scorm.id, 'createNewAttempt', site.id);
            });
        });
    };
    /**
     * Delete all the stored data from an attempt.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when all the data has been deleted.
     */
    AddonModScormOfflineProvider.prototype.deleteAttempt = function (scormId, attempt, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Delete offline attempt ' + attempt + ' in SCORM ' + scormId);
            var promises = [], db = site.getDb();
            // Delete the attempt.
            promises.push(db.deleteRecords(AddonModScormOfflineProvider_1.ATTEMPTS_TABLE, { scormid: scormId, userid: userId,
                attempt: attempt }));
            // Delete all the tracks.
            promises.push(db.deleteRecords(AddonModScormOfflineProvider_1.TRACKS_TABLE, { scormid: scormId, userid: userId,
                attempt: attempt }));
            return Promise.all(promises);
        });
    };
    /**
     * Helper function to return a formatted list of interactions for reports.
     * This function is based in Moodle's scorm_format_interactions.
     *
     * @param {any} scoUserData Userdata from a certain SCO.
     * @return {any} Formatted userdata.
     */
    AddonModScormOfflineProvider.prototype.formatInteractions = function (scoUserData) {
        var formatted = {};
        // Defined in order to unify scorm1.2 and scorm2004.
        formatted.score_raw = '';
        formatted.status = '';
        formatted.total_time = '00:00:00';
        formatted.session_time = '00:00:00';
        for (var element in scoUserData) {
            var value = scoUserData[element];
            // Ignore elements that are calculated.
            if (element == 'score_raw' || element == 'status' || element == 'total_time' || element == 'session_time') {
                return;
            }
            formatted[element] = value;
            switch (element) {
                case 'cmi.core.lesson_status':
                case 'cmi.completion_status':
                    if (value == 'not attempted') {
                        value = 'notattempted';
                    }
                    formatted.status = value;
                    break;
                case 'cmi.core.score.raw':
                case 'cmi.score.raw':
                    formatted.score_raw = this.textUtils.roundToDecimals(value, 2); // Round to 2 decimals max.
                    break;
                case 'cmi.core.session_time':
                case 'cmi.session_time':
                    formatted.session_time = value;
                    break;
                case 'cmi.core.total_time':
                case 'cmi.total_time':
                    formatted.total_time = value;
                    break;
                default:
            }
        }
        return formatted;
    };
    /**
     * Get all the offline attempts in a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved when the offline attempts are retrieved.
     */
    AddonModScormOfflineProvider.prototype.getAllAttempts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getAllRecords(AddonModScormOfflineProvider_1.ATTEMPTS_TABLE);
        }).then(function (attempts) {
            attempts.forEach(function (attempt) {
                attempt.snapshot = _this.textUtils.parseJSON(attempt.snapshot);
            });
            return attempts;
        });
    };
    /**
     * Get an offline attempt.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<number>} Promise resolved with the attempt.
     */
    AddonModScormOfflineProvider.prototype.getAttempt = function (scormId, attempt, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().getRecord(AddonModScormOfflineProvider_1.ATTEMPTS_TABLE, { scormid: scormId, userid: userId,
                attempt: attempt });
        }).then(function (entry) {
            entry.snapshot = _this.textUtils.parseJSON(entry.snapshot);
            return entry;
        });
    };
    /**
     * Get the creation time of an attempt.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<number>} Promise resolved with time the attempt was created.
     */
    AddonModScormOfflineProvider.prototype.getAttemptCreationTime = function (scormId, attempt, siteId, userId) {
        return this.getAttempt(scormId, attempt, siteId, userId).catch(function () {
            return {}; // Attempt not found.
        }).then(function (entry) {
            return entry.timecreated;
        });
    };
    /**
     * Get the offline attempts done by a user in the given SCORM.
     *
     * @param {number} scormId  SCORM ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any[]>} Promise resolved when the offline attempts are retrieved.
     */
    AddonModScormOfflineProvider.prototype.getAttempts = function (scormId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().getRecords(AddonModScormOfflineProvider_1.ATTEMPTS_TABLE, { scormid: scormId, userid: userId });
        }).then(function (attempts) {
            attempts.forEach(function (attempt) {
                attempt.snapshot = _this.textUtils.parseJSON(attempt.snapshot);
            });
            return attempts;
        });
    };
    /**
     * Get the snapshot of an attempt.
     *
     * @param {number} scormId  SCORM ID.
     * @param {number} attempt  Attempt number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved with the snapshot or undefined if no snapshot.
     */
    AddonModScormOfflineProvider.prototype.getAttemptSnapshot = function (scormId, attempt, siteId, userId) {
        return this.getAttempt(scormId, attempt, siteId, userId).catch(function () {
            return {}; // Attempt not found.
        }).then(function (entry) {
            return entry.snapshot;
        });
    };
    /**
     * Get launch URLs from a list of SCOs, indexing them by SCO ID.
     *
     * @param {any[]} scos List of SCOs. Each SCO needs to have 'id' and 'launch' properties.
     * @return {{[scoId: number]: string}} Launch URLs indexed by SCO ID.
     */
    AddonModScormOfflineProvider.prototype.getLaunchUrlsFromScos = function (scos) {
        scos = scos || [];
        var response = {};
        scos.forEach(function (sco) {
            response[sco.id] = sco.launch;
        });
        return response;
    };
    /**
     * Get data stored in local DB for a certain scorm and attempt.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {boolean} [excludeSynced] Whether it should only return not synced entries.
     * @param {boolean} [excludeNotSynced] Whether it should only return synced entries.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any[]>} Promise resolved with the entries.
     */
    AddonModScormOfflineProvider.prototype.getScormStoredData = function (scormId, attempt, excludeSynced, excludeNotSynced, siteId, userId) {
        var _this = this;
        if (excludeSynced && excludeNotSynced) {
            return Promise.resolve([]);
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var conditions = {
                scormid: scormId,
                userid: userId,
                attempt: attempt
            };
            if (excludeSynced) {
                conditions.synced = 0;
            }
            else if (excludeNotSynced) {
                conditions.synced = 1;
            }
            return site.getDb().getRecords(AddonModScormOfflineProvider_1.TRACKS_TABLE, conditions);
        }).then(function (tracks) {
            tracks.forEach(function (track) {
                track.value = _this.textUtils.parseJSON(track.value);
            });
            return tracks;
        });
    };
    /**
     * Get the user data for a certain SCORM and offline attempt.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {any[]} scos SCOs returned by AddonModScormProvider.getScos. If not supplied, this function will only return the
     *                     SCOs that have something stored and cmi.launch_data will be undefined.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when the user data is retrieved.
     */
    AddonModScormOfflineProvider.prototype.getScormUserData = function (scormId, attempt, scos, siteId, userId) {
        var _this = this;
        scos = scos || [];
        var fullName = '', userName = '';
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            // Get username and fullname.
            if (userId == site.getUserId()) {
                fullName = site.getInfo().fullname;
                userName = site.getInfo().username;
            }
            else {
                return _this.userProvider.getProfile(userId).then(function (profile) {
                    fullName = profile.fullname;
                    userName = profile.username || '';
                }).catch(function () {
                    // Ignore errors.
                });
            }
        }).then(function () {
            // Get user data. Ordering when using a compound index is complex, so we won't order by scoid.
            return _this.getScormStoredData(scormId, attempt, false, false, siteId, userId).then(function (entries) {
                var response = {}, launchUrls = _this.getLaunchUrlsFromScos(scos);
                // Gather user data retrieved from DB, grouping it by scoid.
                entries.forEach(function (entry) {
                    var scoId = entry.scoid;
                    if (!response[scoId]) {
                        // Initialize SCO.
                        response[scoId] = {
                            scoid: scoId,
                            userdata: {
                                userid: userId,
                                scoid: scoId,
                                timemodified: 0
                            }
                        };
                    }
                    response[scoId].userdata[entry.element] = entry.value;
                    if (entry.timemodified > response[scoId].userdata.timemodified) {
                        response[scoId].userdata.timemodified = entry.timemodified;
                    }
                });
                // Format each user data retrieved.
                for (var scoId in response) {
                    var sco = response[scoId];
                    sco.userdata = _this.formatInteractions(sco.userdata);
                }
                // Create empty entries for the SCOs without user data stored.
                scos.forEach(function (sco) {
                    if (!response[sco.id]) {
                        response[sco.id] = {
                            scoid: sco.id,
                            userdata: {
                                status: '',
                                score_raw: ''
                            }
                        };
                    }
                });
                // Calculate defaultdata.
                for (var scoId in response) {
                    var sco = response[scoId];
                    sco.defaultdata = {};
                    sco.defaultdata['cmi.core.student_id'] = userName;
                    sco.defaultdata['cmi.core.student_name'] = fullName;
                    sco.defaultdata['cmi.core.lesson_mode'] = 'normal'; // Overridden in player.
                    sco.defaultdata['cmi.core.credit'] = 'credit'; // Overridden in player.
                    if (sco.userdata.status === '') {
                        sco.defaultdata['cmi.core.entry'] = 'ab-initio';
                    }
                    else if (sco.userdata['cmi.core.exit'] === 'suspend') {
                        sco.defaultdata['cmi.core.entry'] = 'resume';
                    }
                    else {
                        sco.defaultdata['cmi.core.entry'] = '';
                    }
                    sco.defaultdata['cmi.student_data.mastery_score'] = _this.scormIsset(sco.userdata, 'masteryscore');
                    sco.defaultdata['cmi.student_data.max_time_allowed'] = _this.scormIsset(sco.userdata, 'max_time_allowed');
                    sco.defaultdata['cmi.student_data.time_limit_action'] = _this.scormIsset(sco.userdata, 'time_limit_action');
                    sco.defaultdata['cmi.core.total_time'] = _this.scormIsset(sco.userdata, 'cmi.core.total_time', '00:00:00');
                    sco.defaultdata['cmi.launch_data'] = launchUrls[sco.scoid];
                    // Now handle standard userdata items.
                    sco.defaultdata['cmi.core.lesson_location'] = _this.scormIsset(sco.userdata, 'cmi.core.lesson_location');
                    sco.defaultdata['cmi.core.lesson_status'] = _this.scormIsset(sco.userdata, 'cmi.core.lesson_status');
                    sco.defaultdata['cmi.core.score.raw'] = _this.scormIsset(sco.userdata, 'cmi.core.score.raw');
                    sco.defaultdata['cmi.core.score.max'] = _this.scormIsset(sco.userdata, 'cmi.core.score.max');
                    sco.defaultdata['cmi.core.score.min'] = _this.scormIsset(sco.userdata, 'cmi.core.score.min');
                    sco.defaultdata['cmi.core.exit'] = _this.scormIsset(sco.userdata, 'cmi.core.exit');
                    sco.defaultdata['cmi.suspend_data'] = _this.scormIsset(sco.userdata, 'cmi.suspend_data');
                    sco.defaultdata['cmi.comments'] = _this.scormIsset(sco.userdata, 'cmi.comments');
                    sco.defaultdata['cmi.student_preference.language'] = _this.scormIsset(sco.userdata, 'cmi.student_preference.language');
                    sco.defaultdata['cmi.student_preference.audio'] = _this.scormIsset(sco.userdata, 'cmi.student_preference.audio', '0');
                    sco.defaultdata['cmi.student_preference.speed'] = _this.scormIsset(sco.userdata, 'cmi.student_preference.speed', '0');
                    sco.defaultdata['cmi.student_preference.text'] = _this.scormIsset(sco.userdata, 'cmi.student_preference.text', '0');
                    // Some data needs to be both in default data and user data.
                    sco.userdata.student_id = userName;
                    sco.userdata.student_name = fullName;
                    sco.userdata.mode = sco.defaultdata['cmi.core.lesson_mode'];
                    sco.userdata.credit = sco.defaultdata['cmi.core.credit'];
                    sco.userdata.entry = sco.defaultdata['cmi.core.entry'];
                }
                return response;
            });
        });
    };
    /**
     * Insert a track in the offline tracks store.
     * This function is based on Moodle's scorm_insert_track.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} scoId SCO ID.
     * @param {number} attempt Attempt number.
     * @param {string} element Name of the element to insert.
     * @param {any} value Value to insert.
     * @param {boolean} [forceCompleted] True if SCORM forces completed.
     * @param {any} [scoData] User data for the given SCO.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not set use site's current user.
     * @return {Promise<any>} Promise resolved when the insert is done.
     */
    AddonModScormOfflineProvider.prototype.insertTrack = function (scormId, scoId, attempt, element, value, forceCompleted, scoData, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            scoData = scoData || {};
            var promises = [], // List of promises for actions previous to the real insert.
            scoUserData = scoData.userdata || {}, db = site.getDb();
            var lessonStatusInserted = false;
            if (forceCompleted) {
                if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                    if (scoUserData['cmi.core.score.raw']) {
                        value = 'completed';
                    }
                }
                if (element == 'cmi.core.score.raw') {
                    if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                        lessonStatusInserted = true;
                        promises.push(_this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed'));
                    }
                }
            }
            return Promise.all(promises).then(function () {
                // Don't update x.start.time, keep the original value.
                if (!scoUserData[element] || element != 'x.start.time') {
                    var promise_1 = _this.insertTrackToDB(db, userId, scormId, scoId, attempt, element, value);
                    return promise_1.catch(function (error) {
                        if (lessonStatusInserted) {
                            // Rollback previous insert.
                            promise_1 = _this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete');
                            return promise_1.then(function () {
                                return Promise.reject(error);
                            });
                        }
                        return Promise.reject(null);
                    });
                }
            });
        });
    };
    /**
     * Insert a track in the DB.
     *
     * @param {SQLiteDB} db Site's DB.
     * @param {number} userId User ID.
     * @param {number} scormId SCORM ID.
     * @param {number} scoId SCO ID.
     * @param {number} attempt Attempt number.
     * @param {string} element Name of the element to insert.
     * @param {any} value Value of the element to insert.
     * @param {boolean} synchronous True if insert should NOT return a promise. Please use it only if synchronous is a must.
     * @return {boolean|Promise<any>} Returns a promise if synchronous=false, otherwise returns a boolean.
     */
    AddonModScormOfflineProvider.prototype.insertTrackToDB = function (db, userId, scormId, scoId, attempt, element, value, synchronous) {
        var entry = {
            userid: userId,
            scormid: scormId,
            scoid: scoId,
            attempt: attempt,
            element: element,
            value: typeof value == 'undefined' ? null : JSON.stringify(value),
            timemodified: this.timeUtils.timestamp(),
            synced: 0
        };
        if (synchronous) {
            // The insert operation is always asynchronous, always return true.
            db.insertRecord(AddonModScormOfflineProvider_1.TRACKS_TABLE, entry);
            return true;
        }
        else {
            return db.insertRecord(AddonModScormOfflineProvider_1.TRACKS_TABLE, entry);
        }
    };
    /**
     * Insert a track in the offline tracks store, returning a synchronous value.
     * Please use this function only if synchronous is a must. It's recommended to use insertTrack.
     * This function is based on Moodle's scorm_insert_track.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} scoId SCO ID.
     * @param {number} attempt Attempt number.
     * @param {string} element Name of the element to insert.
     * @param {any} value Value of the element to insert.
     * @param {boolean} [forceCompleted] True if SCORM forces completed.
     * @param {any} [scoData] User data for the given SCO.
     * @param {number} [userId] User ID. If not set use current user.
     * @return {boolean} Promise resolved when the insert is done.
     */
    AddonModScormOfflineProvider.prototype.insertTrackSync = function (scormId, scoId, attempt, element, value, forceCompleted, scoData, userId) {
        scoData = scoData || {};
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        if (!this.sitesProvider.isLoggedIn()) {
            // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
            return false;
        }
        var scoUserData = scoData.userdata || {}, db = this.sitesProvider.getCurrentSite().getDb();
        var lessonStatusInserted = false;
        if (forceCompleted) {
            if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                if (scoUserData['cmi.core.score.raw']) {
                    value = 'completed';
                }
            }
            if (element == 'cmi.core.score.raw') {
                if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                    lessonStatusInserted = true;
                    if (!this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed', true)) {
                        return false;
                    }
                }
            }
        }
        // Don't update x.start.time, keep the original value.
        if (!scoUserData[element] || element != 'x.start.time') {
            if (!this.insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, true)) {
                // Insert failed.
                if (lessonStatusInserted) {
                    // Rollback previous insert.
                    this.insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete', true);
                }
                return false;
            }
            return true;
        }
    };
    /**
     * Mark all the entries from a SCO and attempt as synced.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {number} scoId SCO ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when marked.
     */
    AddonModScormOfflineProvider.prototype.markAsSynced = function (scormId, attempt, scoId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Mark SCO ' + scoId + ' as synced for attempt ' + attempt + ' in SCORM ' + scormId);
            return site.getDb().updateRecords(AddonModScormOfflineProvider_1.TRACKS_TABLE, { synced: 1 }, {
                scormid: scormId,
                userid: userId,
                attempt: attempt,
                scoid: scoId,
                synced: 0
            });
        });
    };
    /**
     * Removes the default data form user data.
     *
     * @param {any} userData User data returned by AddonModScormProvider.getScormUserData.
     * @return {any} User data without default data.
     */
    AddonModScormOfflineProvider.prototype.removeDefaultData = function (userData) {
        var result = this.utils.clone(userData);
        for (var key in result) {
            delete result[key].defaultdata;
        }
        return result;
    };
    /**
     * Saves a SCORM tracking record in offline.
     *
     * @param {any} scorm SCORM.
     * @param {number} scoId Sco ID.
     * @param {number} attempt Attempt number.
     * @param {any[]} tracks Tracking data to store.
     * @param {any} userData User data for this attempt and SCO.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when data is saved.
     */
    AddonModScormOfflineProvider.prototype.saveTracks = function (scorm, scoId, attempt, tracks, userData, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            // Block the SCORM so it can't be synced.
            _this.syncProvider.blockOperation(__WEBPACK_IMPORTED_MODULE_8__scorm__["a" /* AddonModScormProvider */].COMPONENT, scorm.id, 'saveTracksOffline', siteId);
            // Insert all the tracks.
            var promises = [];
            tracks.forEach(function (track) {
                promises.push(_this.insertTrack(scorm.id, scoId, attempt, track.element, track.value, scorm.forcecompleted, userData[scoId], siteId, userId));
            });
            return Promise.all(promises).finally(function () {
                // Unblock the SCORM operation.
                _this.syncProvider.unblockOperation(__WEBPACK_IMPORTED_MODULE_8__scorm__["a" /* AddonModScormProvider */].COMPONENT, scorm.id, 'saveTracksOffline', siteId);
            });
        });
    };
    /**
     * Saves a SCORM tracking record in offline returning a synchronous value.
     * Please use this function only if synchronous is a must. It's recommended to use saveTracks.
     *
     * @param  {any} scorm    SCORM.
     * @param  {number} scoId    Sco ID.
     * @param  {number} attempt  Attempt number.
     * @param  {Object[]} tracks Tracking data to store.
     * @param  {any} userData User data for this attempt and SCO.
     * @return {boolean}         True if data to insert is valid, false otherwise. Returning true doesn't mean that the data
     *                           has been stored, this function can return true but the insertion can still fail somehow.
     */
    AddonModScormOfflineProvider.prototype.saveTracksSync = function (scorm, scoId, attempt, tracks, userData, userId) {
        var _this = this;
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        var success = true;
        tracks.forEach(function (track) {
            if (!_this.insertTrackSync(scorm.id, scoId, attempt, track.element, track.value, scorm.forcecompleted, userData[scoId], userId)) {
                success = false;
            }
        });
        return success;
    };
    /**
     * Check for a parameter in userData and return it if it's set or return 'ifempty' if it's empty.
     * Based on Moodle's scorm_isset function.
     *
     * @param {any} userData Contains user's data.
     * @param {string} param Name of parameter that should be checked.
     * @param {any} [ifEmpty] Value to be replaced with if param is not set.
     * @return {any} Value from userData[param] if set, ifEmpty otherwise.
     */
    AddonModScormOfflineProvider.prototype.scormIsset = function (userData, param, ifEmpty) {
        if (ifEmpty === void 0) { ifEmpty = ''; }
        if (typeof userData[param] != 'undefined') {
            return userData[param];
        }
        return ifEmpty;
    };
    /**
     * Set an attempt's snapshot.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {any} userData User data to store as snapshot.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined use site's current user.
     * @return {Promise<any>} Promise resolved when snapshot has been stored.
     */
    AddonModScormOfflineProvider.prototype.setAttemptSnapshot = function (scormId, attempt, userData, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Set snapshot for attempt ' + attempt + ' in SCORM ' + scormId);
            var newData = {
                timemodified: _this.timeUtils.timestamp(),
                snapshot: JSON.stringify(_this.removeDefaultData(userData))
            };
            return site.getDb().updateRecords(AddonModScormOfflineProvider_1.ATTEMPTS_TABLE, newData, { scormid: scormId,
                userid: userId, attempt: attempt });
        });
    };
    // Variables for database.
    AddonModScormOfflineProvider.ATTEMPTS_TABLE = 'addon_mod_scorm_offline_attempts';
    AddonModScormOfflineProvider.TRACKS_TABLE = 'addon_mod_scorm_offline_scos_tracks';
    AddonModScormOfflineProvider = AddonModScormOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__core_user_providers_user__["a" /* CoreUserProvider */]])
    ], AddonModScormOfflineProvider);
    return AddonModScormOfflineProvider;
    var AddonModScormOfflineProvider_1;
}());

//# sourceMappingURL=scorm-offline.js.map

/***/ }),
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CorePluginFileDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Delegate to register pluginfile information handlers.
 */
var CorePluginFileDelegate = /** @class */ (function () {
    function CorePluginFileDelegate(logger) {
        this.handlers = {};
        this.logger = logger.getInstance('CorePluginFileDelegate');
    }
    /**
     * Get the handler for a certain pluginfile url.
     *
     * @param {string} component Component of the plugin.
     * @return {CorePluginFileHandler} Handler. Undefined if no handler found for the plugin.
     */
    CorePluginFileDelegate.prototype.getPluginHandler = function (component) {
        if (typeof this.handlers[component] != 'undefined') {
            return this.handlers[component];
        }
    };
    /**
     * Get the RegExp of the component and filearea described in the URL.
     *
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {RegExp}  RegExp to match the revision or undefined if not found.
     */
    CorePluginFileDelegate.prototype.getComponentRevisionRegExp = function (args) {
        // Get handler based on component (args[1]).
        var handler = this.getPluginHandler(args[1]);
        if (handler && handler.getComponentRevisionRegExp) {
            return handler.getComponentRevisionRegExp(args);
        }
    };
    /**
     * Register a handler.
     *
     * @param {CorePluginFileHandler} handler The handler to register.
     * @return {boolean} True if registered successfully, false otherwise.
     */
    CorePluginFileDelegate.prototype.registerHandler = function (handler) {
        if (typeof this.handlers[handler.component] !== 'undefined') {
            this.logger.log("Handler '" + handler.component + "' already registered");
            return false;
        }
        this.logger.log("Registered handler '" + handler.component + "'");
        this.handlers[handler.component] = handler;
        return true;
    };
    /**
     * Removes the revision number from a file URL.
     *
     * @param {string} url URL to be replaced.
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {string} Replaced URL without revision.
     */
    CorePluginFileDelegate.prototype.removeRevisionFromUrl = function (url, args) {
        // Get handler based on component (args[1]).
        var handler = this.getPluginHandler(args[1]);
        if (handler && handler.getComponentRevisionRegExp && handler.getComponentRevisionReplace) {
            var revisionRegex = handler.getComponentRevisionRegExp(args);
            if (revisionRegex) {
                return url.replace(revisionRegex, handler.getComponentRevisionReplace(args));
            }
        }
        return url;
    };
    CorePluginFileDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__logger__["a" /* CoreLoggerProvider */]])
    ], CorePluginFileDelegate);
    return CorePluginFileDelegate;
}());

//# sourceMappingURL=plugin-file-delegate.js.map

/***/ }),
/* 256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleMainResourceComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_helper__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_module_delegate__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_pages_section_section_ts__ = __webpack_require__(1439);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_contentlinks_providers_helper__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__addon_blog_providers_blog__ = __webpack_require__(209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_constants__ = __webpack_require__(39);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












/**
 * Template class to easily create CoreCourseModuleMainComponent of resources (or activities without syncing).
 */
var CoreCourseModuleMainResourceComponent = /** @class */ (function () {
    function CoreCourseModuleMainResourceComponent(injector, loggerName) {
        if (loggerName === void 0) { loggerName = 'CoreCourseModuleMainResourceComponent'; }
        this.fetchContentDefaultError = 'core.course.errorgetmodule'; // Default error to show when loading contents.
        this.textUtils = injector.get(__WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */]);
        this.courseHelper = injector.get(__WEBPACK_IMPORTED_MODULE_6__core_course_providers_helper__["a" /* CoreCourseHelperProvider */]);
        this.translate = injector.get(__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]);
        this.domUtils = injector.get(__WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */]);
        this.moduleDelegate = injector.get(__WEBPACK_IMPORTED_MODULE_7__core_course_providers_module_delegate__["a" /* CoreCourseModuleDelegate */]);
        this.courseSectionPage = injector.get(__WEBPACK_IMPORTED_MODULE_8__core_course_pages_section_section_ts__["a" /* CoreCourseSectionPage */], null);
        this.linkHelper = injector.get(__WEBPACK_IMPORTED_MODULE_9__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */]);
        this.navCtrl = injector.get(__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */], null);
        this.blogProvider = injector.get(__WEBPACK_IMPORTED_MODULE_10__addon_blog_providers_blog__["a" /* AddonBlogProvider */], null);
        this.dataRetrieved = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        var loggerProvider = injector.get(__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */]);
        this.logger = loggerProvider.getInstance(loggerName);
    }
    /**
     * Component being initialized.
     */
    CoreCourseModuleMainResourceComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.description = this.module.description;
        this.componentId = this.module.id;
        this.externalUrl = this.module.url;
        this.loaded = false;
        this.refreshIcon = 'spinner';
        this.blogProvider.isPluginEnabled().then(function (enabled) {
            _this.blog = enabled;
        });
    };
    /**
     * Refresh the data.
     *
     * @param {any}       [refresher] Refresher.
     * @param {Function}  [done] Function to call when done.
     * @param {boolean}   [showErrors=false] If show errors to the user of hide them.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.doRefresh = function (refresher, done, showErrors) {
        var _this = this;
        if (showErrors === void 0) { showErrors = false; }
        if (this.loaded && this.module) {
            /* If it's a single activity course and the refresher is displayed within the component,
               call doRefresh on the section page to refresh the course data. */
            var promise = void 0;
            if (this.courseSectionPage && !this.moduleDelegate.displayRefresherInSingleActivity(this.module.modname)) {
                promise = this.courseSectionPage.doRefresh();
            }
            else {
                promise = Promise.resolve();
            }
            return promise.finally(function () {
                return _this.refreshContent(true, showErrors).finally(function () {
                    refresher && refresher.complete();
                    done && done();
                });
            });
        }
        return Promise.resolve();
    };
    /**
     * Perform the refresh content function.
     *
     * @param  {boolean}      [sync=false]       If the refresh needs syncing.
     * @param  {boolean}      [showErrors=false] Wether to show errors to the user or hide them.
     * @return {Promise<any>} Resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.refreshContent = function (sync, showErrors) {
        var _this = this;
        if (sync === void 0) { sync = false; }
        if (showErrors === void 0) { showErrors = false; }
        if (!this.module) {
            // This can happen if course format changes from single activity to weekly/topics.
            return Promise.resolve();
        }
        this.refreshIcon = 'spinner';
        // Wrap the call in a try/catch so the workflow isn't interrupted if an error occurs.
        // E.g. when changing course format we cannot know when will this.module become undefined, so it could cause errors.
        var promise;
        try {
            promise = this.invalidateContent();
        }
        catch (ex) {
            // An error ocurred in the function, log the error and just resolve the promise so the workflow continues.
            this.logger.error(ex);
            promise = Promise.resolve();
        }
        return promise.catch(function () {
            // Ignore errors.
        }).then(function () {
            return _this.loadContent(true);
        }).finally(function () {
            _this.refreshIcon = 'refresh';
        });
    };
    /**
     * Perform the invalidate content function.
     *
     * @return {Promise<any>} Resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.invalidateContent = function () {
        return Promise.resolve();
    };
    /**
     * Download the component contents.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.fetchContent = function (refresh) {
        return Promise.resolve();
    };
    /**
     * Loads the component contents and shows the corresponding error.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.loadContent = function (refresh) {
        var _this = this;
        if (!this.module) {
            // This can happen if course format changes from single activity to weekly/topics.
            return Promise.resolve();
        }
        // Wrap the call in a try/catch so the workflow isn't interrupted if an error occurs.
        // E.g. when changing course format we cannot know when will this.module become undefined, so it could cause errors.
        var promise;
        try {
            promise = this.fetchContent(refresh);
        }
        catch (ex) {
            // An error ocurred in the function, log the error and just resolve the promise so the workflow continues.
            this.logger.error(ex);
            promise = Promise.resolve();
        }
        return promise.catch(function (error) {
            // Error getting data, fail.
            _this.domUtils.showErrorModalDefault(error, _this.fetchContentDefaultError, true);
        }).finally(function () {
            _this.loaded = true;
            _this.refreshIcon = 'refresh';
        });
    };
    /**
     * Fill the context menu options
     */
    CoreCourseModuleMainResourceComponent.prototype.fillContextMenu = function (refresh) {
        if (refresh === void 0) { refresh = false; }
        // All data obtained, now fill the context menu.
        this.courseHelper.fillContextMenu(this, this.module, this.courseId, refresh, this.component);
    };
    /**
     * Check if the module is prefetched or being prefetched. To make it faster, just use the data calculated by fillContextMenu.
     * This means that you need to call fillContextMenu to make this work.
     */
    CoreCourseModuleMainResourceComponent.prototype.isPrefetched = function () {
        return this.prefetchStatus != __WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE && this.prefetchStatus != __WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
    };
    /**
     * Expand the description.
     */
    CoreCourseModuleMainResourceComponent.prototype.expandDescription = function () {
        this.textUtils.expandText(this.translate.instant('core.description'), this.description, this.component, this.module.id);
    };
    /**
     * Go to blog posts.
     *
     * @param {any} event Event.
     */
    CoreCourseModuleMainResourceComponent.prototype.gotoBlog = function (event) {
        // Always use redirect to make it the new history root (to avoid "loops" in history).
        this.linkHelper.goInSite(this.navCtrl, 'AddonBlogEntriesPage', { cmId: this.module.id });
    };
    /**
     * Prefetch the module.
     *
     * @param {Function}  [done] Function to call when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.prefetch = function (done) {
        this.courseHelper.contextMenuPrefetch(this, this.module, this.courseId, done);
    };
    /**
     * Confirm and remove downloaded files.
     */
    CoreCourseModuleMainResourceComponent.prototype.removeFiles = function () {
        this.courseHelper.confirmAndRemoveFiles(this.module, this.courseId);
    };
    /**
     * Component being destroyed.
     */
    CoreCourseModuleMainResourceComponent.prototype.ngOnDestroy = function () {
        this.isDestroyed = true;
        this.contextMenuStatusObserver && this.contextMenuStatusObserver.off();
    };
    /**
     * User entered the page that contains the component. This function should be called by the page that contains this component.
     */
    CoreCourseModuleMainResourceComponent.prototype.ionViewDidEnter = function () {
        this.isCurrentView = true;
    };
    /**
     * User left the page that contains the component. This function should be called by the page that contains this component.
     */
    CoreCourseModuleMainResourceComponent.prototype.ionViewDidLeave = function () {
        this.isCurrentView = false;
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseModuleMainResourceComponent.prototype, "module", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreCourseModuleMainResourceComponent.prototype, "courseId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreCourseModuleMainResourceComponent.prototype, "dataRetrieved", void 0);
    return CoreCourseModuleMainResourceComponent;
}());

//# sourceMappingURL=main-resource-component.js.map

/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseResourcePrefetchHandlerBase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__module_prefetch_handler__ = __webpack_require__(1018);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Base prefetch handler to be registered in CoreCourseModulePrefetchDelegate. It is useful to minimize the amount of
 * functions that handlers need to implement. It also provides some helper features like preventing a module to be
 * downloaded twice at the same time.
 *
 * If your handler inherits from this service, you just need to override the functions that you want to change.
 *
 * This class should be used for RESOURCES whose main purpose is downloading files present in module.contents.
 */
var CoreCourseResourcePrefetchHandlerBase = /** @class */ (function (_super) {
    __extends(CoreCourseResourcePrefetchHandlerBase, _super);
    function CoreCourseResourcePrefetchHandlerBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Download the module.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {string} [dirPath] Path of the directory where to store all the content files.
     * @return {Promise<any>} Promise resolved when all content is downloaded.
     */
    CoreCourseResourcePrefetchHandlerBase.prototype.download = function (module, courseId, dirPath) {
        return this.downloadOrPrefetch(module, courseId, false, dirPath);
    };
    /**
     * Download or prefetch the content.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files. This is to keep the files
     *                           relative paths and make the package work in an iframe. Undefined to download the files
     *                           in the filepool root folder.
     * @return {Promise<any>} Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    CoreCourseResourcePrefetchHandlerBase.prototype.downloadOrPrefetch = function (module, courseId, prefetch, dirPath) {
        var _this = this;
        if (!this.appProvider.isOnline()) {
            // Cannot download in offline.
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        var siteId = this.sitesProvider.getCurrentSiteId();
        if (this.isDownloading(module.id, siteId)) {
            // There's already a download ongoing for this module, return the promise.
            return this.getOngoingDownload(module.id, siteId);
        }
        // Get module info to be able to handle links.
        var prefetchPromise = this.courseProvider.getModuleBasicInfo(module.id, siteId).then(function () {
            // Load module contents (ignore cache so we always have the latest data).
            return _this.loadContents(module, courseId, true);
        }).then(function () {
            // Get the intro files.
            return _this.getIntroFiles(module, courseId, true);
        }).then(function (introFiles) {
            var downloadFn = prefetch ? _this.filepoolProvider.prefetchPackage.bind(_this.filepoolProvider) :
                _this.filepoolProvider.downloadPackage.bind(_this.filepoolProvider), contentFiles = _this.getContentDownloadableFiles(module), promises = [];
            if (dirPath) {
                // Download intro files in filepool root folder.
                promises.push(_this.filepoolProvider.downloadOrPrefetchFiles(siteId, introFiles, prefetch, false, _this.component, module.id));
                // Download content files inside dirPath.
                promises.push(downloadFn(siteId, contentFiles, _this.component, module.id, undefined, dirPath));
            }
            else {
                // No dirPath, download everything in filepool root folder.
                var files = introFiles.concat(contentFiles);
                promises.push(downloadFn(siteId, files, _this.component, module.id));
            }
            return Promise.all(promises);
        });
        return this.addOngoingDownload(module.id, prefetchPromise, siteId);
    };
    /**
     * Get list of files. If not defined, we'll assume they're in module.contents.
     *
     * @param {any} module Module.
     * @param {Number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    CoreCourseResourcePrefetchHandlerBase.prototype.getFiles = function (module, courseId, single) {
        var _this = this;
        // Load module contents if needed.
        return this.loadContents(module, courseId).then(function () {
            return _this.getIntroFiles(module, courseId).then(function (files) {
                return files.concat(_this.getContentDownloadableFiles(module));
            });
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId The course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseResourcePrefetchHandlerBase.prototype.invalidateContent = function (moduleId, courseId) {
        var promises = [], siteId = this.sitesProvider.getCurrentSiteId();
        promises.push(this.courseProvider.invalidateModule(moduleId));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, this.component, moduleId));
        return Promise.all(promises);
    };
    /**
     * Load module contents into module.contents if they aren't loaded already.
     *
     * @param {any} module Module to load the contents.
     * @param {number} [courseId] The course ID. Recommended to speed up the process and minimize data usage.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise}           Promise resolved when loaded.
     */
    CoreCourseResourcePrefetchHandlerBase.prototype.loadContents = function (module, courseId, ignoreCache) {
        return this.courseProvider.loadModuleContents(module, courseId, undefined, false, ignoreCache);
    };
    /**
     * Prefetch a module.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @param {string} [dirPath] Path of the directory where to store all the content files.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseResourcePrefetchHandlerBase.prototype.prefetch = function (module, courseId, single, dirPath) {
        return this.downloadOrPrefetch(module, courseId, true, dirPath);
    };
    return CoreCourseResourcePrefetchHandlerBase;
}(__WEBPACK_IMPORTED_MODULE_0__module_prefetch_handler__["a" /* CoreCourseModulePrefetchHandlerBase */]));

//# sourceMappingURL=resource-prefetch-handler.js.map

/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCompileInitComponent; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Base class for components that will display a component using core-compile-html and want to call a
 * componentInit function returned by the handler JS.
 */
var CoreSitePluginsCompileInitComponent = /** @class */ (function () {
    function CoreSitePluginsCompileInitComponent(sitePluginsProvider, utils) {
        this.sitePluginsProvider = sitePluginsProvider;
        this.utils = utils;
        this.content = ''; // Content.
        this.jsData = {}; // Data to pass to the component.
    }
    /**
     * Function called when the component is created.
     *
     * @param {any} instance The component instance.
     */
    CoreSitePluginsCompileInitComponent.prototype.componentCreated = function (instance) {
        // Check if the JS defined an init function.
        if (instance && this.handlerSchema && this.handlerSchema.methodJSResult &&
            this.handlerSchema.methodJSResult.componentInit) {
            this.handlerSchema.methodJSResult.componentInit.apply(instance);
        }
    };
    /**
     * Get the handler data.
     *
     * @param {string} name The name of the handler.
     */
    CoreSitePluginsCompileInitComponent.prototype.getHandlerData = function (name) {
        // Retrieve the handler data.
        var handler = this.sitePluginsProvider.getSitePluginHandler(name);
        this.handlerSchema = handler && handler.handlerSchema;
        if (this.handlerSchema) {
            // Load first template.
            if (this.handlerSchema.methodTemplates && this.handlerSchema.methodTemplates.length) {
                this.content = handler.handlerSchema.methodTemplates[0].html;
                this.jsData.CONTENT_TEMPLATES = this.utils.objectToKeyValueMap(handler.handlerSchema.methodTemplates, 'id', 'html');
            }
            // Pass data from the method result to the component.
            if (this.handlerSchema.methodOtherdata) {
                this.jsData.CONTENT_OTHERDATA = this.handlerSchema.methodOtherdata;
            }
            if (this.handlerSchema.methodJSResult) {
                this.jsData.CONTENT_JS_RESULT = this.handlerSchema.methodJSResult;
            }
        }
    };
    return CoreSitePluginsCompileInitComponent;
}());

//# sourceMappingURL=compile-init-component.js.map

/***/ }),
/* 259 */,
/* 260 */,
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInfiniteLoadingComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(4);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};



/**
 * Component to show a infinite loading trigger and spinner while more data is being loaded.
 *
 * Usage:
 * <core-infinite-loading [action]="loadingAction" [enabled]="dataLoaded"></core-inifinite-loading>
 */
var CoreInfiniteLoadingComponent = /** @class */ (function () {
    function CoreInfiniteLoadingComponent(content, domUtils) {
        this.content = content;
        this.domUtils = domUtils;
        this.error = false;
        this.position = 'bottom';
        this.loadingMore = false; // Hide button and avoid loading more.
        this.action = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Detect changes on input properties.
     *
     * @param {SimpleChange}} changes Changes.
     */
    CoreInfiniteLoadingComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.enabled && this.enabled && this.position == 'bottom') {
            // Infinite scroll enabled. If the list doesn't fill the full height, infinite scroll isn't triggered automatically.
            // Send a fake scroll event to make infinite scroll check if it should load more items.
            setTimeout(function () {
                var event = new Event('scroll');
                _this.content.ionScroll.emit(event);
            }, 400);
        }
    };
    /**
     * Load More items calling the action provided.
     *
     * @param {InfiniteScroll} [infiniteScroll] Infinite scroll object only if triggered from the scroll.
     */
    CoreInfiniteLoadingComponent.prototype.loadMore = function (infiniteScroll) {
        if (this.loadingMore) {
            return;
        }
        if (infiniteScroll) {
            this.infiniteScroll = infiniteScroll;
        }
        this.loadingMore = true;
        this.action.emit(this.complete.bind(this));
    };
    /**
     * Complete loading.
     */
    CoreInfiniteLoadingComponent.prototype.complete = function () {
        if (this.position == 'top') {
            // Wait a bit before allowing loading more, otherwise it could be re-triggered automatically when it shouldn't.
            setTimeout(this.completeLoadMore.bind(this), 400);
        }
        else {
            this.completeLoadMore();
        }
    };
    /**
     * Complete loading.
     */
    CoreInfiniteLoadingComponent.prototype.completeLoadMore = function () {
        var _this = this;
        this.loadingMore = false;
        this.infiniteScroll && this.infiniteScroll.complete();
        this.infiniteScroll = undefined;
        // More items loaded. If the list doesn't fill the full height, infinite scroll isn't triggered automatically.
        // Send a fake scroll event to make infinite scroll check if it should load more items.
        setTimeout(function () {
            var event = new Event('scroll');
            _this.content.ionScroll.emit(event);
        });
    };
    /**
     * Get the height of the element.
     *
     * @return {number} Height.
     */
    CoreInfiniteLoadingComponent.prototype.getHeight = function () {
        return this.getElementHeight(this.topButton) + this.getElementHeight(this.infiniteEl) +
            this.getElementHeight(this.bottomButton) + this.getElementHeight(this.spinnerContainer);
    };
    /**
     * Get the height of an element.
     *
     * @param {ElementRef} element Element ref.
     * @return {number} Height.
     */
    CoreInfiniteLoadingComponent.prototype.getElementHeight = function (element) {
        if (element && element.nativeElement) {
            return this.domUtils.getElementHeight(element.nativeElement, true, true, true);
        }
        return 0;
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreInfiniteLoadingComponent.prototype, "enabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreInfiniteLoadingComponent.prototype, "error", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreInfiniteLoadingComponent.prototype, "position", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreInfiniteLoadingComponent.prototype, "action", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('topbutton'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreInfiniteLoadingComponent.prototype, "topButton", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('infinitescroll'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreInfiniteLoadingComponent.prototype, "infiniteEl", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('bottombutton'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreInfiniteLoadingComponent.prototype, "bottomButton", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('spinnercontainer'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreInfiniteLoadingComponent.prototype, "spinnerContainer", void 0);
    CoreInfiniteLoadingComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-infinite-loading',
            templateUrl: 'core-infinite-loading.html',
        }),
        __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["f" /* Content */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreInfiniteLoadingComponent);
    return CoreInfiniteLoadingComponent;
}());

//# sourceMappingURL=infinite-loading.js.map

/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pipes_pipes_module__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__course_progress_course_progress__ = __webpack_require__(278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__course_list_item_course_list_item__ = __webpack_require__(1411);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__course_options_menu_course_options_menu__ = __webpack_require__(590);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__my_courses_my_courses__ = __webpack_require__(1412);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











var CoreCoursesComponentsModule = /** @class */ (function () {
    function CoreCoursesComponentsModule() {
    }
    CoreCoursesComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_7__course_progress_course_progress__["a" /* CoreCoursesCourseProgressComponent */],
                __WEBPACK_IMPORTED_MODULE_8__course_list_item_course_list_item__["a" /* CoreCoursesCourseListItemComponent */],
                __WEBPACK_IMPORTED_MODULE_9__course_options_menu_course_options_menu__["a" /* CoreCoursesCourseOptionsMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_10__my_courses_my_courses__["a" /* CoreCoursesMyCoursesComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_6__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_7__course_progress_course_progress__["a" /* CoreCoursesCourseProgressComponent */],
                __WEBPACK_IMPORTED_MODULE_8__course_list_item_course_list_item__["a" /* CoreCoursesCourseListItemComponent */],
                __WEBPACK_IMPORTED_MODULE_9__course_options_menu_course_options_menu__["a" /* CoreCoursesCourseOptionsMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_10__my_courses_my_courses__["a" /* CoreCoursesMyCoursesComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_9__course_options_menu_course_options_menu__["a" /* CoreCoursesCourseOptionsMenuComponent */]
            ]
        })
    ], CoreCoursesComponentsModule);
    return CoreCoursesComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 263 */,
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModChatProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Service that provides some features for chats.
 */
var AddonModChatProvider = /** @class */ (function () {
    function AddonModChatProvider(sitesProvider, userProvider, logHelper, utils, translate) {
        this.sitesProvider = sitesProvider;
        this.userProvider = userProvider;
        this.logHelper = logHelper;
        this.utils = utils;
        this.translate = translate;
        this.ROOT_CACHE_KEY = 'AddonModChat:';
    }
    AddonModChatProvider_1 = AddonModChatProvider;
    /**
     * Get a chat.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the chat is retrieved.
     */
    AddonModChatProvider.prototype.getChat = function (courseId, cmId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            };
            var preSets = {
                cacheKey: _this.getChatsCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_6__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_chat_get_chats_by_courses', params, preSets).then(function (response) {
                if (response.chats) {
                    var chat = response.chats.find(function (chat) { return chat.coursemodule == cmId; });
                    if (chat) {
                        return chat;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Log the user into a chat room.
     *
     * @param  {number} chatId Chat instance ID.
     * @return {Promise<any>} Promise resolved when the WS is executed.
     */
    AddonModChatProvider.prototype.loginUser = function (chatId) {
        var params = {
            chatid: chatId
        };
        return this.sitesProvider.getCurrentSite().write('mod_chat_login_user', params).then(function (response) {
            if (response.chatsid) {
                return response.chatsid;
            }
            return Promise.reject(null);
        });
    };
    /**
     * Report a chat as being viewed.
     *
     * @param  {number} id Chat instance ID.
     * @param {string} [name] Name of the chat.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModChatProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            chatid: id
        };
        return this.logHelper.logSingle('mod_chat_view_chat', params, AddonModChatProvider_1.COMPONENT, id, name, 'chat', {}, siteId);
    };
    /**
     * Send a message to a chat.
     *
     * @param  {number} sessionId  Chat sessiond ID.
     * @param  {string} message    Message text.
     * @param  {number} beepUserId Beep user ID.
     * @return {Promise<any>} Promise resolved when the WS is executed.
     */
    AddonModChatProvider.prototype.sendMessage = function (sessionId, message, beepUserId) {
        var params = {
            chatsid: sessionId,
            messagetext: message,
            beepid: beepUserId
        };
        return this.sitesProvider.getCurrentSite().write('mod_chat_send_chat_message', params).then(function (response) {
            if (response.messageid) {
                return response.messageid;
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get the latest messages from a chat session.
     *
     * @param  {number} sessionId Chat sessiond ID.
     * @param  {number} lastTime  Last time when messages were retrieved.
     * @return {Promise<any>} Promise resolved when the WS is executed.
     */
    AddonModChatProvider.prototype.getLatestMessages = function (sessionId, lastTime) {
        var params = {
            chatsid: sessionId,
            chatlasttime: lastTime
        };
        /* We use write to not use cache. It doesn't make sense to store the messages in cache
           because we won't be able to retireve them if AddonModChatProvider.loginUser fails. */
        return this.sitesProvider.getCurrentSite().write('mod_chat_get_chat_latest_messages', params);
    };
    /**
     * Get user data for messages since they only have userid.
     *
     * @param  {any[]}  messages Messages to get the user data for.
     * @param  {number} courseId ID of the course the messages belong to.
     * @return {Promise<any>} Promise always resolved with the formatted messages.
     */
    AddonModChatProvider.prototype.getMessagesUserData = function (messages, courseId) {
        var _this = this;
        var promises = messages.map(function (message) {
            return _this.userProvider.getProfile(message.userid, courseId, true).then(function (user) {
                message.userfullname = user.fullname;
                message.userprofileimageurl = user.profileimageurl;
            }).catch(function () {
                // Error getting profile, most probably the user is deleted.
                message.userfullname = _this.translate.instant('core.deleteduser') + ' ' + message.userid;
            });
        });
        return Promise.all(promises).then(function () {
            return messages;
        });
    };
    /**
     * Get the actives users of a current chat.
     *
     * @param  {number} sessionId Chat sessiond ID.
     * @return {Promise<any>} Promise resolved when the WS is executed.
     */
    AddonModChatProvider.prototype.getChatUsers = function (sessionId) {
        var params = {
            chatsid: sessionId
        };
        var preSets = {
            getFromCache: false
        };
        return this.sitesProvider.getCurrentSite().read('mod_chat_get_chat_users', params, preSets);
    };
    /**
     * Return whether WS for passed sessions are available.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with a boolean.
     */
    AddonModChatProvider.prototype.areSessionsAvailable = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('mod_chat_get_sessions') && site.wsAvailable('mod_chat_get_session_messages');
        });
    };
    /**
     * Get chat sessions.
     *
     * @param {number} chatId Chat ID.
     * @param {number} [groupId=0] Group ID, 0 means that the function will determine the user group.
     * @param {boolean} [showAll=false] Whether to include incomplete sessions or not.
     * @param {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of sessions.
     * @since 3.5
     */
    AddonModChatProvider.prototype.getSessions = function (chatId, groupId, showAll, ignoreCache, siteId) {
        var _this = this;
        if (groupId === void 0) { groupId = 0; }
        if (showAll === void 0) { showAll = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                chatid: chatId,
                groupid: groupId,
                showall: showAll ? 1 : 0
            };
            var preSets = {
                cacheKey: _this.getSessionsCacheKey(chatId, groupId, showAll),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_6__classes_site__["a" /* CoreSite */].FREQUENCY_SOMETIMES
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_chat_get_sessions', params, preSets).then(function (response) {
                if (!response || !response.sessions) {
                    return Promise.reject(null);
                }
                return response.sessions;
            });
        });
    };
    /**
     * Get chat session messages.
     *
     * @param {number} chatId Chat ID.
     * @param {number} sessionStart Session start time.
     * @param {number} sessionEnd Session end time.
     * @param {number} [groupId=0] Group ID, 0 means that the function will determine the user group.
     * @param {boolean} [ignoreCache=false] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the list of messages.
     * @since 3.5
     */
    AddonModChatProvider.prototype.getSessionMessages = function (chatId, sessionStart, sessionEnd, groupId, ignoreCache, siteId) {
        var _this = this;
        if (groupId === void 0) { groupId = 0; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                chatid: chatId,
                sessionstart: sessionStart,
                sessionend: sessionEnd,
                groupid: groupId
            };
            var preSets = {
                cacheKey: _this.getSessionMessagesCacheKey(chatId, sessionStart, groupId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_6__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_chat_get_session_messages', params, preSets).then(function (response) {
                if (!response || !response.messages) {
                    return Promise.reject(null);
                }
                return response.messages;
            });
        });
    };
    /**
     * Invalidate chats.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModChatProvider.prototype.invalidateChats = function (courseId) {
        var site = this.sitesProvider.getCurrentSite();
        return site.invalidateWsCacheForKey(this.getChatsCacheKey(courseId));
    };
    /**
     * Invalidate chat sessions.
     *
     * @param {number} chatId Chat ID.
     * @param {number} [groupId=0] Group ID, 0 means that the function will determine the user group.
     * @param {boolean} [showAll=false] Whether to include incomplete sessions or not.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModChatProvider.prototype.invalidateSessions = function (chatId, groupId, showAll) {
        if (groupId === void 0) { groupId = 0; }
        if (showAll === void 0) { showAll = false; }
        var site = this.sitesProvider.getCurrentSite();
        return site.invalidateWsCacheForKey(this.getSessionsCacheKey(chatId, groupId, showAll));
    };
    /**
     * Invalidate all chat sessions.
     *
     * @param {number} chatId Chat ID.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModChatProvider.prototype.invalidateAllSessions = function (chatId) {
        var site = this.sitesProvider.getCurrentSite();
        return site.invalidateWsCacheForKeyStartingWith(this.getSessionsCacheKeyPrefix(chatId));
    };
    /**
     * Invalidate chat session messages.
     *
     * @param {number} chatId Chat ID.
     * @param {number} sessionStart Session start time.
     * @param {number} [groupId=0] Group ID, 0 means that the function will determine the user group.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModChatProvider.prototype.invalidateSessionMessages = function (chatId, sessionStart, groupId) {
        if (groupId === void 0) { groupId = 0; }
        var site = this.sitesProvider.getCurrentSite();
        return site.invalidateWsCacheForKey(this.getSessionMessagesCacheKey(chatId, sessionStart, groupId));
    };
    /**
     * Invalidate all chat session messages.
     *
     * @param {number} chatId Chat ID.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModChatProvider.prototype.invalidateAllSessionMessages = function (chatId) {
        var site = this.sitesProvider.getCurrentSite();
        return site.invalidateWsCacheForKeyStartingWith(this.getSessionMessagesCacheKeyPrefix(chatId));
    };
    /**
     * Get cache key for chats WS call.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModChatProvider.prototype.getChatsCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'chats:' + courseId;
    };
    /**
     * Get cache key for sessions WS call.
     *
     * @param {number} chatId Chat ID.
     * @param {number} groupId Goup ID, 0 means that the function will determine the user group.
     * @param {boolean} showAll Whether to include incomplete sessions or not.
     * @return {string} Cache key.
     */
    AddonModChatProvider.prototype.getSessionsCacheKey = function (chatId, groupId, showAll) {
        return this.getSessionsCacheKeyPrefix(chatId) + groupId + ':' + (showAll ? 1 : 0);
    };
    /**
     * Get cache key prefix for sessions WS call.
     *
     * @param {number} chatId Chat ID.
     * @return {string} Cache key prefix.
     */
    AddonModChatProvider.prototype.getSessionsCacheKeyPrefix = function (chatId) {
        return this.ROOT_CACHE_KEY + 'sessions:' + chatId + ':';
    };
    /**
     * Get cache key for session messages WS call.
     *
     * @param {number} chatId Chat ID.
     * @param {number} sessionStart Session start time.
     * @param {number} groupId Group ID, 0 means that the function will determine the user group.
     * @return {string} Cache key.
     */
    AddonModChatProvider.prototype.getSessionMessagesCacheKey = function (chatId, sessionStart, groupId) {
        return this.getSessionMessagesCacheKeyPrefix(chatId) + sessionStart + ':' + groupId;
    };
    /**
     * Get cache key prefix for session messages WS call.
     *
     * @param {number} chatId Chat ID.
     * @return {string} Cache key prefix.
     */
    AddonModChatProvider.prototype.getSessionMessagesCacheKeyPrefix = function (chatId) {
        return this.ROOT_CACHE_KEY + 'sessionsMessages:' + chatId + ':';
    };
    AddonModChatProvider.COMPONENT = 'mmaModChat';
    AddonModChatProvider.POLL_INTERVAL = 4000;
    AddonModChatProvider = AddonModChatProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__core_user_providers_user__["a" /* CoreUserProvider */],
            __WEBPACK_IMPORTED_MODULE_4__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], AddonModChatProvider);
    return AddonModChatProvider;
    var AddonModChatProvider_1;
}());

//# sourceMappingURL=chat.js.map

/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModForumHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_fileuploader_providers_fileuploader__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__forum__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__offline__ = __webpack_require__(216);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service that provides some features for forums.
 */
var AddonModForumHelperProvider = /** @class */ (function () {
    function AddonModForumHelperProvider(translate, fileProvider, sitesProvider, uploaderProvider, timeUtils, userProvider, appProvider, utils, forumProvider, forumOffline) {
        this.translate = translate;
        this.fileProvider = fileProvider;
        this.sitesProvider = sitesProvider;
        this.uploaderProvider = uploaderProvider;
        this.timeUtils = timeUtils;
        this.userProvider = userProvider;
        this.appProvider = appProvider;
        this.utils = utils;
        this.forumProvider = forumProvider;
        this.forumOffline = forumOffline;
    }
    /**
     * Add a new discussion.
     *
     * @param {number} forumId Forum ID.
     * @param {string} name Forum name.
     * @param {number} courseId Course ID the forum belongs to.
     * @param {string} subject New discussion's subject.
     * @param {string} message New discussion's message.
     * @param {any[]} [attachments] New discussion's attachments.
     * @param {any} [options] Options (subscribe, pin, ...).
     * @param {number[]} [groupIds] Groups this discussion belongs to.
     * @param {number} [timeCreated] The time the discussion was created. Only used when editing discussion.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number[]>} Promise resolved with ids of the created discussions or null if stored offline
     */
    AddonModForumHelperProvider.prototype.addNewDiscussion = function (forumId, name, courseId, subject, message, attachments, options, groupIds, timeCreated, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        groupIds = groupIds && groupIds.length > 0 ? groupIds : [0];
        var saveOffline = false;
        var attachmentsIds = [];
        var offlineAttachments;
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            // Multiple groups, the discussion is being posted to all groups.
            var groupId = groupIds.length > 1 ? __WEBPACK_IMPORTED_MODULE_9__forum__["a" /* AddonModForumProvider */].ALL_GROUPS : groupIds[0];
            if (offlineAttachments) {
                options.attachmentsid = offlineAttachments;
            }
            return _this.forumOffline.addNewDiscussion(forumId, name, courseId, subject, message, options, groupId, timeCreated, siteId).then(function () {
                return null;
            });
        };
        // First try to upload attachments, once per group.
        var promise;
        if (attachments && attachments.length > 0) {
            var promises = groupIds.map(function () {
                return _this.uploadOrStoreNewDiscussionFiles(forumId, timeCreated, attachments, false).then(function (attach) {
                    attachmentsIds.push(attach);
                });
            });
            promise = Promise.all(promises).catch(function () {
                // Cannot upload them in online, save them in offline.
                saveOffline = true;
                return _this.uploadOrStoreNewDiscussionFiles(forumId, timeCreated, attachments, true).then(function (attach) {
                    offlineAttachments = attach;
                });
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            // If we are editing an offline discussion, discard previous first.
            var discardPromise;
            if (timeCreated) {
                discardPromise = _this.forumOffline.deleteNewDiscussion(forumId, timeCreated, siteId);
            }
            else {
                discardPromise = Promise.resolve();
            }
            return discardPromise.then(function () {
                if (saveOffline || !_this.appProvider.isOnline()) {
                    return storeOffline();
                }
                var errors = [];
                var discussionIds = [];
                var promises = groupIds.map(function (groupId, index) {
                    var grouOptions = _this.utils.clone(options);
                    if (attachmentsIds[index]) {
                        grouOptions.attachmentsid = attachmentsIds[index];
                    }
                    return _this.forumProvider.addNewDiscussionOnline(forumId, subject, message, grouOptions, groupId, siteId)
                        .then(function (discussionId) {
                        discussionIds.push(discussionId);
                    }).catch(function (error) {
                        errors.push(error);
                    });
                });
                return Promise.all(promises).then(function () {
                    if (errors.length == groupIds.length) {
                        // All requests have failed.
                        for (var i = 0; i < errors.length; i++) {
                            if (_this.utils.isWebServiceError(errors[i]) || attachments.length > 0) {
                                // The WebService has thrown an error or offline not supported, reject.
                                return Promise.reject(errors[i]);
                            }
                        }
                        // Couldn't connect to server, store offline.
                        return storeOffline();
                    }
                    return discussionIds;
                });
            });
        });
    };
    /**
     * Convert offline reply to online format in order to be compatible with them.
     *
     * @param  {any}    offlineReply Offline version of the reply.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved with the object converted to Online.
     */
    AddonModForumHelperProvider.prototype.convertOfflineReplyToOnline = function (offlineReply, siteId) {
        var reply = {
            attachments: [],
            canreply: false,
            children: [],
            created: offlineReply.timecreated,
            discussion: offlineReply.discussionid,
            id: false,
            mailed: 0,
            mailnow: 0,
            message: offlineReply.message,
            messageformat: 1,
            messagetrust: 0,
            modified: false,
            parent: offlineReply.postid,
            postread: false,
            subject: offlineReply.subject,
            totalscore: 0,
            userid: offlineReply.userid,
            isprivatereply: offlineReply.options && offlineReply.options.private
        }, promises = [];
        // Treat attachments if any.
        if (offlineReply.options && offlineReply.options.attachmentsid) {
            reply.attachments = offlineReply.options.attachmentsid.online || [];
            if (offlineReply.options.attachmentsid.offline) {
                promises.push(this.getReplyStoredFiles(offlineReply.forumid, reply.parent, siteId, reply.userid)
                    .then(function (files) {
                    reply.attachments = reply.attachments.concat(files);
                }));
            }
        }
        // Get user data.
        promises.push(this.userProvider.getProfile(offlineReply.userid, offlineReply.courseid, true).then(function (user) {
            reply.userfullname = user.fullname;
            reply.userpictureurl = user.profileimageurl;
        }).catch(function () {
            // Ignore errors.
        }));
        return Promise.all(promises).then(function () {
            reply.attachment = reply.attachments.length > 0 ? 1 : 0;
            return reply;
        });
    };
    /**
     * Delete stored attachment files for a new discussion.
     *
     * @param  {number} forumId     Forum ID.
     * @param  {number} timecreated The time the discussion was created.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}       Promise resolved when deleted.
     */
    AddonModForumHelperProvider.prototype.deleteNewDiscussionStoredFiles = function (forumId, timecreated, siteId) {
        var _this = this;
        return this.forumOffline.getNewDiscussionFolder(forumId, timecreated, siteId).then(function (folderPath) {
            return _this.fileProvider.removeDir(folderPath).catch(function () {
                // Ignore any errors, CoreFileProvider.removeDir fails if folder doesn't exists.
            });
        });
    };
    /**
     * Delete stored attachment files for a reply.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {number} postId   ID of the post being replied.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the reply belongs to. If not defined, current user in site.
     * @return {Promise<any>}    Promise resolved when deleted.
     */
    AddonModForumHelperProvider.prototype.deleteReplyStoredFiles = function (forumId, postId, siteId, userId) {
        var _this = this;
        return this.forumOffline.getReplyFolder(forumId, postId, siteId, userId).then(function (folderPath) {
            return _this.fileProvider.removeDir(folderPath).catch(function () {
                // Ignore any errors, CoreFileProvider.removeDir fails if folder doesn't exists.
            });
        });
    };
    /**
     * Returns the availability message of the given forum.
     *
     * @param {any} forum Forum instance.
     * @return {string} Message or null if the forum has no cut-off or due date.
     */
    AddonModForumHelperProvider.prototype.getAvailabilityMessage = function (forum) {
        if (this.isCutoffDateReached(forum)) {
            return this.translate.instant('addon.mod_forum.cutoffdatereached');
        }
        else if (this.isDueDateReached(forum)) {
            var dueDate = this.timeUtils.userDate(forum.duedate * 1000);
            return this.translate.instant('addon.mod_forum.thisforumisdue', { $a: dueDate });
        }
        else if (forum.duedate > 0) {
            var dueDate = this.timeUtils.userDate(forum.duedate * 1000);
            return this.translate.instant('addon.mod_forum.thisforumhasduedate', { $a: dueDate });
        }
        else {
            return null;
        }
    };
    /**
     * Get a forum discussion by id.
     *
     * This function is inefficient because it needs to fetch all discussion pages in the worst case.
     *
     * @param {number} forumId Forum ID.
     * @param {number} discussionId Discussion ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the discussion data.
     */
    AddonModForumHelperProvider.prototype.getDiscussionById = function (forumId, discussionId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var findDiscussion = function (page) {
            return _this.forumProvider.getDiscussions(forumId, undefined, page, false, siteId).then(function (response) {
                if (response.discussions && response.discussions.length > 0) {
                    var discussion = response.discussions.find(function (discussion) { return discussion.id == discussionId; });
                    if (discussion) {
                        return discussion;
                    }
                    if (response.canLoadMore) {
                        return findDiscussion(page + 1);
                    }
                }
                return Promise.reject(null);
            });
        };
        return findDiscussion(0);
    };
    /**
     * Get a list of stored attachment files for a new discussion. See AddonModForumHelper#storeNewDiscussionFiles.
     *
     * @param  {number} forumId     Forum ID.
     * @param  {number} timecreated The time the discussion was created.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any[]>}     Promise resolved with the files.
     */
    AddonModForumHelperProvider.prototype.getNewDiscussionStoredFiles = function (forumId, timecreated, siteId) {
        var _this = this;
        return this.forumOffline.getNewDiscussionFolder(forumId, timecreated, siteId).then(function (folderPath) {
            return _this.uploaderProvider.getStoredFiles(folderPath);
        });
    };
    /**
     * Get a list of stored attachment files for a reply. See AddonModForumHelper#storeReplyFiles.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {number} postId   ID of the post being replied.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the reply belongs to. If not defined, current user in site.
     * @return {Promise<any[]>}  Promise resolved with the files.
     */
    AddonModForumHelperProvider.prototype.getReplyStoredFiles = function (forumId, postId, siteId, userId) {
        var _this = this;
        return this.forumOffline.getReplyFolder(forumId, postId, siteId, userId).then(function (folderPath) {
            return _this.uploaderProvider.getStoredFiles(folderPath);
        });
    };
    /**
     * Check if the data of a post/discussion has changed.
     *
     * @param  {any} post       Current data.
     * @param  {any} [original] Original ata.
     * @return {boolean} True if data has changed, false otherwise.
     */
    AddonModForumHelperProvider.prototype.hasPostDataChanged = function (post, original) {
        if (!original || original.subject == null) {
            // There is no original data, assume it hasn't changed.
            return false;
        }
        if (post.subject != original.subject || post.message != original.message) {
            return true;
        }
        if (post.isprivatereply != original.isprivatereply) {
            return true;
        }
        return this.uploaderProvider.areFileListDifferent(post.files, original.files);
    };
    /**
     * Is the cutoff date for the forum reached?
     *
     * @param {any} forum Forum instance.
     * @return {boolean}
     */
    AddonModForumHelperProvider.prototype.isCutoffDateReached = function (forum) {
        var now = Date.now() / 1000;
        return forum.cutoffdate > 0 && forum.cutoffdate < now;
    };
    /**
     * Is the due date for the forum reached?
     *
     * @param {any} forum Forum instance.
     * @return {boolean}
     */
    AddonModForumHelperProvider.prototype.isDueDateReached = function (forum) {
        var now = Date.now() / 1000;
        return forum.duedate > 0 && forum.duedate < now;
    };
    /**
     * Given a list of files (either online files or local files), store the local files in a local folder
     * to be submitted later.
     *
     * @param  {number} forumId     Forum ID.
     * @param  {number} timecreated The time the discussion was created.
     * @param  {any[]}  files       List of files.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}       Promise resolved if success, rejected otherwise.
     */
    AddonModForumHelperProvider.prototype.storeNewDiscussionFiles = function (forumId, timecreated, files, siteId) {
        var _this = this;
        // Get the folder where to store the files.
        return this.forumOffline.getNewDiscussionFolder(forumId, timecreated, siteId).then(function (folderPath) {
            return _this.uploaderProvider.storeFilesToUpload(folderPath, files);
        });
    };
    /**
     * Given a list of files (either online files or local files), store the local files in a local folder
     * to be submitted later.
     *
     * @param  {number} forumId  Forum ID.
     * @param  {number} postId   ID of the post being replied.
     * @param  {any[]}  files    List of files.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the reply belongs to. If not defined, current user in site.
     * @return {Promise<any>}    Promise resolved if success, rejected otherwise.
     */
    AddonModForumHelperProvider.prototype.storeReplyFiles = function (forumId, postId, files, siteId, userId) {
        var _this = this;
        // Get the folder where to store the files.
        return this.forumOffline.getReplyFolder(forumId, postId, siteId, userId).then(function (folderPath) {
            return _this.uploaderProvider.storeFilesToUpload(folderPath, files);
        });
    };
    /**
     * Upload or store some files for a new discussion, depending if the user is offline or not.
     *
     * @param  {number}  forumId     Forum ID.
     * @param  {number}  timecreated The time the discussion was created.
     * @param  {any[]}   files       List of files.
     * @param  {boolean} offline     True if files sould be stored for offline, false to upload them.
     * @param  {string}  [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved if success.
     */
    AddonModForumHelperProvider.prototype.uploadOrStoreNewDiscussionFiles = function (forumId, timecreated, files, offline, siteId) {
        if (offline) {
            return this.storeNewDiscussionFiles(forumId, timecreated, files, siteId);
        }
        else {
            return this.uploaderProvider.uploadOrReuploadFiles(files, __WEBPACK_IMPORTED_MODULE_9__forum__["a" /* AddonModForumProvider */].COMPONENT, forumId, siteId);
        }
    };
    /**
     * Upload or store some files for a reply, depending if the user is offline or not.
     *
     * @param  {number}  forumId  Forum ID.
     * @param  {number}  postId   ID of the post being replied.
     * @param  {any[]}   files    List of files.
     * @param  {boolean} offline  True if files sould be stored for offline, false to upload them.
     * @param  {string}  [siteId] Site ID. If not defined, current site.
     * @param  {number}  [userId] User the reply belongs to. If not defined, current user in site.
     * @return {Promise<any>}     Promise resolved if success.
     */
    AddonModForumHelperProvider.prototype.uploadOrStoreReplyFiles = function (forumId, postId, files, offline, siteId, userId) {
        if (offline) {
            return this.storeReplyFiles(forumId, postId, files, siteId, userId);
        }
        else {
            return this.uploaderProvider.uploadOrReuploadFiles(files, __WEBPACK_IMPORTED_MODULE_9__forum__["a" /* AddonModForumProvider */].COMPONENT, forumId, siteId);
        }
    };
    AddonModForumHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__core_fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__core_user_providers_user__["a" /* CoreUserProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__forum__["a" /* AddonModForumProvider */],
            __WEBPACK_IMPORTED_MODULE_10__offline__["a" /* AddonModForumOfflineProvider */]])
    ], AddonModForumHelperProvider);
    return AddonModForumHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLocalFileComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Component to handle a local file. Only files inside the app folder can be managed.
 *
 * Shows the file name, icon (depending on extension), size and time modified.
 * Also, if managing is enabled it will also show buttons to rename and delete the file.
 */
var CoreLocalFileComponent = /** @class */ (function () {
    function CoreLocalFileComponent(mimeUtils, utils, translate, textUtils, fileProvider, domUtils, timeUtils) {
        this.mimeUtils = mimeUtils;
        this.utils = utils;
        this.translate = translate;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.domUtils = domUtils;
        this.timeUtils = timeUtils;
        this.newFileName = '';
        this.onDelete = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onRename = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onClick = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreLocalFileComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.manage = this.utils.isTrueOrOne(this.manage);
        this.loadFileBasicData();
        // Get the size and timemodified.
        this.fileProvider.getMetadata(this.file).then(function (metadata) {
            if (metadata.size >= 0) {
                _this.size = _this.textUtils.bytesToSize(metadata.size, 2);
            }
            _this.timemodified = _this.timeUtils.userDate(metadata.modificationTime, 'core.strftimedatetimeshort');
        });
    };
    /**
     * Load the basic data for the file.
     */
    CoreLocalFileComponent.prototype.loadFileBasicData = function () {
        this.fileName = this.file.name;
        this.fileIcon = this.mimeUtils.getFileIcon(this.file.name);
        this.fileExtension = this.mimeUtils.getFileExtension(this.file.name);
        // Let's calculate the relative path for the file.
        this.relativePath = this.fileProvider.removeBasePath(this.file.toURL());
        if (!this.relativePath) {
            // Didn't find basePath, use fullPath but if the user tries to manage the file it'll probably fail.
            this.relativePath = this.file.fullPath;
        }
    };
    /**
     * File clicked.
     *
     * @param {Event} e Click event.
     */
    CoreLocalFileComponent.prototype.fileClicked = function (e) {
        if (this.editMode) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        if (this.utils.isTrueOrOne(this.overrideClick) && this.onClick.observers.length) {
            this.onClick.emit();
        }
        else {
            this.utils.openFile(this.file.toURL());
        }
    };
    /**
     * Activate the edit mode.
     *
     * @param {Event} e Click event.
     */
    CoreLocalFileComponent.prototype.activateEdit = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.editMode = true;
        this.newFileName = this.file.name;
    };
    /**
     * Rename the file.
     *
     * @param {string} newName New name.
     * @param {Event}  e       Click event.
     */
    CoreLocalFileComponent.prototype.changeName = function (newName, e) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        if (newName == this.file.name) {
            // Name hasn't changed, stop.
            this.editMode = false;
            return;
        }
        var modal = this.domUtils.showModalLoading(), fileAndDir = this.fileProvider.getFileAndDirectoryFromPath(this.relativePath), newPath = this.textUtils.concatenatePaths(fileAndDir.directory, newName);
        // Check if there's a file with this name.
        this.fileProvider.getFile(newPath).then(function () {
            // There's a file with this name, show error and stop.
            _this.domUtils.showErrorModal('core.errorfileexistssamename', true);
        }).catch(function () {
            // File doesn't exist, move it.
            return _this.fileProvider.moveFile(_this.relativePath, newPath).then(function (fileEntry) {
                _this.editMode = false;
                _this.file = fileEntry;
                _this.loadFileBasicData();
                _this.onRename.emit({ file: _this.file });
            }).catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.errorrenamefile', true);
            });
        }).finally(function () {
            modal.dismiss();
        });
    };
    /**
     * Delete the file.
     *
     * @param {Event} e Click event.
     */
    CoreLocalFileComponent.prototype.deleteFile = function (e) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        // Ask confirmation.
        this.domUtils.showConfirm(this.translate.instant('core.confirmdeletefile')).then(function () {
            var modal = _this.domUtils.showModalLoading();
            return _this.fileProvider.removeFile(_this.relativePath).then(function () {
                _this.onDelete.emit();
            }).finally(function () {
                modal.dismiss();
            });
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.errordeletefile', true);
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLocalFileComponent.prototype, "file", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLocalFileComponent.prototype, "manage", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLocalFileComponent.prototype, "overrideClick", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreLocalFileComponent.prototype, "onDelete", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreLocalFileComponent.prototype, "onRename", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreLocalFileComponent.prototype, "onClick", void 0);
    CoreLocalFileComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-local-file',
            templateUrl: 'core-local-file.html'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */]])
    ], CoreLocalFileComponent);
    return CoreLocalFileComponent;
}());

//# sourceMappingURL=local-file.js.map

/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBadgesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service to handle badges.
 */
var AddonBadgesProvider = /** @class */ (function () {
    function AddonBadgesProvider(logger, sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.ROOT_CACHE_KEY = 'mmaBadges:';
        this.logger = logger.getInstance('AddonBadgesProvider');
    }
    /**
     * Returns whether or not the badge plugin is enabled for a certain site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if enabled, false otherwise.
     */
    AddonBadgesProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canUseAdvancedFeature('enablebadges')) {
                return false;
            }
            else if (!site.wsAvailable('core_course_get_user_navigation_options')) {
                return false;
            }
            return true;
        });
    };
    /**
     * Get the cache key for the get badges call.
     *
     * @param {number} courseId ID of the course to get the badges from.
     * @param {number} userId ID of the user to get the badges from.
     * @return {string} Cache key.
     */
    AddonBadgesProvider.prototype.getBadgesCacheKey = function (courseId, userId) {
        return this.ROOT_CACHE_KEY + 'badges:' + courseId + ':' + userId;
    };
    /**
     * Get issued badges for a certain user in a course.
     *
     * @param {number} courseId ID of the course to get the badges from.
     * @param {number} userId ID of the user to get the badges from.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}Promise to be resolved when the badges are retrieved.
     */
    AddonBadgesProvider.prototype.getUserBadges = function (courseId, userId, siteId) {
        var _this = this;
        this.logger.debug('Get badges for course ' + courseId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                courseid: courseId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getBadgesCacheKey(courseId, userId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_3__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('core_badges_get_user_badges', data, preSets).then(function (response) {
                if (response && response.badges) {
                    return response.badges;
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Invalidate get badges WS call.
     *
     * @param {number} courseId Course ID.
     * @param {number} userId ID of the user to get the badges from.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data is invalidated.
     */
    AddonBadgesProvider.prototype.invalidateUserBadges = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getBadgesCacheKey(courseId, userId));
        });
    };
    AddonBadgesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonBadgesProvider);
    return AddonBadgesProvider;
}());

//# sourceMappingURL=badges.js.map

/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreIframeComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_iframe__ = __webpack_require__(37);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 */
var CoreIframeComponent = /** @class */ (function () {
    function CoreIframeComponent(logger, iframeUtils, domUtils, sanitizer) {
        this.iframeUtils = iframeUtils;
        this.domUtils = domUtils;
        this.sanitizer = sanitizer;
        this.loaded = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.IFRAME_TIMEOUT = 15000;
        this.logger = logger.getInstance('CoreIframe');
        this.loaded = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreIframeComponent.prototype.ngOnInit = function () {
        var _this = this;
        var iframe = this.iframe && this.iframe.nativeElement;
        this.iframeWidth = this.domUtils.formatPixelsSize(this.iframeWidth) || '100%';
        this.iframeHeight = this.domUtils.formatPixelsSize(this.iframeHeight) || '100%';
        // Show loading only with external URLs.
        this.loading = !this.src || !!this.src.match(/^https?:\/\//i);
        this.iframeUtils.treatFrame(iframe);
        if (this.loading) {
            iframe.addEventListener('load', function () {
                _this.loading = false;
                _this.loaded.emit(iframe); // Notify iframe was loaded.
            });
            iframe.addEventListener('error', function () {
                _this.loading = false;
                _this.domUtils.showErrorModal('core.errorloadingcontent', true);
            });
            setTimeout(function () {
                _this.loading = false;
            }, this.IFRAME_TIMEOUT);
        }
    };
    /**
     * Detect changes on input properties.
     */
    CoreIframeComponent.prototype.ngOnChanges = function (changes) {
        if (changes.src) {
            this.safeUrl = this.sanitizer.bypassSecurityTrustResourceUrl(changes.src.currentValue);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('iframe'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreIframeComponent.prototype, "iframe", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIframeComponent.prototype, "src", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIframeComponent.prototype, "iframeWidth", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIframeComponent.prototype, "iframeHeight", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreIframeComponent.prototype, "loaded", void 0);
    CoreIframeComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-iframe',
            templateUrl: 'core-iframe.html'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_iframe__["a" /* CoreIframeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__["c" /* DomSanitizer */]])
    ], CoreIframeComponent);
    return CoreIframeComponent;
}());

//# sourceMappingURL=iframe.js.map

/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFeedbackSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__offline__ = __webpack_require__(282);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__feedback__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_classes_activity_sync__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_course_providers_module_prefetch_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__prefetch_handler__ = __webpack_require__(614);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

















/**
 * Service to sync feedbacks.
 */
var AddonModFeedbackSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModFeedbackSyncProvider, _super);
    function AddonModFeedbackSyncProvider(sitesProvider, loggerProvider, appProvider, feedbackOffline, eventsProvider, feedbackProvider, translate, utils, textUtils, courseProvider, syncProvider, timeUtils, logHelper, prefetchDelegate, prefetchHandler) {
        var _this = _super.call(this, 'AddonModFeedbackSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils, prefetchDelegate, prefetchHandler) || this;
        _this.sitesProvider = sitesProvider;
        _this.loggerProvider = loggerProvider;
        _this.appProvider = appProvider;
        _this.feedbackOffline = feedbackOffline;
        _this.eventsProvider = eventsProvider;
        _this.feedbackProvider = feedbackProvider;
        _this.translate = translate;
        _this.utils = utils;
        _this.textUtils = textUtils;
        _this.courseProvider = courseProvider;
        _this.logHelper = logHelper;
        _this.componentTranslate = courseProvider.translateModuleName('feedback');
        return _this;
    }
    AddonModFeedbackSyncProvider_1 = AddonModFeedbackSyncProvider;
    /**
     * Conveniece function to prefetch data after an update.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID.
     * @param {RegExp} [regex] If regex matches, don't download the data. Defaults to check files and timers.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModFeedbackSyncProvider.prototype.prefetchAfterUpdate = function (module, courseId, regex, siteId) {
        regex = regex || /^.*files$|^timers/;
        return _super.prototype.prefetchAfterUpdate.call(this, module, courseId, regex, siteId);
    };
    /**
     * Try to synchronize all the feedbacks in a certain site or in all sites.
     *
     * @param  {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} force Wether to force sync not depending on last execution.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModFeedbackSyncProvider.prototype.syncAllFeedbacks = function (siteId, force) {
        return this.syncOnSites('all feedbacks', this.syncAllFeedbacksFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all pending feedbacks on a site.
     *
     * @param {string}  [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} force    Wether to force sync not depending on last execution.
     * @param {Promise<any>}     Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModFeedbackSyncProvider.prototype.syncAllFeedbacksFunc = function (siteId, force) {
        var _this = this;
        // Sync all new responses.
        return this.feedbackOffline.getAllFeedbackResponses(siteId).then(function (responses) {
            var promises = {};
            var _loop_1 = function (i) {
                var response = responses[i];
                if (typeof promises[response.feedbackid] != 'undefined') {
                    return "continue";
                }
                promises[response.feedbackid] = force ? _this.syncFeedback(response.feedbackid, siteId) :
                    _this.syncFeedbackIfNeeded(response.feedbackid, siteId);
                promises[response.feedbackid].then(function (result) {
                    if (result && result.updated) {
                        // Sync successful, send event.
                        _this.eventsProvider.trigger(AddonModFeedbackSyncProvider_1.AUTO_SYNCED, {
                            feedbackId: response.feedbackid,
                            userId: response.userid,
                            warnings: result.warnings
                        }, siteId);
                    }
                });
            };
            // Do not sync same feedback twice.
            for (var i in responses) {
                _loop_1(i);
            }
            // Promises will be an object so, convert to an array first;
            return Promise.all(_this.utils.objectToArray(promises));
        });
    };
    /**
     * Sync a feedback only if a certain time has passed since the last time.
     *
     * @param  {number} feedbackId  Feedback ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}       Promise resolved when the feedback is synced or if it doesn't need to be synced.
     */
    AddonModFeedbackSyncProvider.prototype.syncFeedbackIfNeeded = function (feedbackId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.isSyncNeeded(feedbackId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncFeedback(feedbackId, siteId);
            }
        });
    };
    /**
     * Synchronize all offline responses of a feedback.
     *
     * @param  {number} feedbackId Feedback ID to be synced.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModFeedbackSyncProvider.prototype.syncFeedback = function (feedbackId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var syncId = feedbackId;
        if (this.isSyncing(syncId, siteId)) {
            // There's already a sync ongoing for this feedback, return the promise.
            return this.getOngoingSync(syncId, siteId);
        }
        // Verify that feedback isn't blocked.
        if (this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_8__feedback__["a" /* AddonModFeedbackProvider */].COMPONENT, syncId, siteId)) {
            this.logger.debug("Cannot sync feedback '" + syncId + "' because it is blocked.");
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        var result = {
            warnings: [],
            updated: false
        };
        var courseId, feedback;
        this.logger.debug("Try to sync feedback '" + feedbackId + "' in site " + siteId + "'");
        // Sync offline logs.
        var syncPromise = this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_8__feedback__["a" /* AddonModFeedbackProvider */].COMPONENT, feedbackId, siteId).catch(function () {
            // Ignore errors.
        }).then(function () {
            // Get offline responses to be sent.
            return _this.feedbackOffline.getFeedbackResponses(feedbackId, siteId).catch(function () {
                // No offline data found, return empty array.
                return [];
            });
        }).then(function (responses) {
            if (!responses.length) {
                // Nothing to sync.
                return;
            }
            if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(null);
            }
            courseId = responses[0].courseid;
            return _this.feedbackProvider.getFeedbackById(courseId, feedbackId, siteId).then(function (feedbackData) {
                feedback = feedbackData;
                if (!feedback.multiple_submit) {
                    // If it does not admit multiple submits, check if it is completed to know if we can submit.
                    return _this.feedbackProvider.isCompleted(feedbackId);
                }
                else {
                    return false;
                }
            }).then(function (isCompleted) {
                if (isCompleted) {
                    // Cannot submit again, delete resposes.
                    var promises_1 = [];
                    responses.forEach(function (data) {
                        promises_1.push(_this.feedbackOffline.deleteFeedbackPageResponses(feedbackId, data.page, siteId));
                    });
                    result.updated = true;
                    result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                        component: _this.componentTranslate,
                        name: feedback.name,
                        error: _this.translate.instant('addon.mod_feedback.this_feedback_is_already_submitted')
                    }));
                    return Promise.all(promises_1);
                }
                return _this.feedbackProvider.getCurrentCompletedTimeModified(feedbackId, true, siteId).then(function (timemodified) {
                    // Sort by page.
                    responses.sort(function (a, b) {
                        return a.page - b.page;
                    });
                    responses = responses.map(function (data) {
                        return {
                            func: _this.processPage.bind(_this),
                            params: [feedback, data, siteId, timemodified, result],
                            blocking: true
                        };
                    });
                    // Execute all the processes in order to solve dependencies.
                    return _this.utils.executeOrderedPromises(responses);
                });
            });
        }).then(function () {
            if (result.updated) {
                // Data has been sent to server, update data.
                return _this.courseProvider.getModuleBasicInfoByInstance(feedbackId, 'feedback', siteId).then(function (module) {
                    return _this.prefetchAfterUpdate(module, courseId, undefined, siteId);
                }).catch(function () {
                    // Ignore errors.
                });
            }
        }).then(function () {
            // Sync finished, set sync time.
            return _this.setSyncTime(syncId, siteId);
        }).then(function () {
            return result;
        });
        return this.addOngoingSync(syncId, syncPromise, siteId);
    };
    /**
     * Convenience function to sync process page calls.
     *
     * @param  {any}          feedback     Feedback object.
     * @param  {any}          data         Response data.
     * @param  {string}       siteId       Site Id.
     * @param  {number}       timemodified Current completed modification time.
     * @param  {any}          result       Result object to be modified.
     * @return {Promise<any>}              Resolve when done or rejected with error.
     */
    AddonModFeedbackSyncProvider.prototype.processPage = function (feedback, data, siteId, timemodified, result) {
        var _this = this;
        // Delete all pages that are submitted before changing website.
        if (timemodified > data.timemodified) {
            return this.feedbackOffline.deleteFeedbackPageResponses(feedback.id, data.page, siteId);
        }
        return this.feedbackProvider.processPageOnline(feedback.id, data.page, data.responses, false, siteId).then(function () {
            result.updated = true;
            return _this.feedbackOffline.deleteFeedbackPageResponses(feedback.id, data.page, siteId);
        }).catch(function (error) {
            if (error && error.wserror) {
                // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.
                result.updated = true;
                return _this.feedbackOffline.deleteFeedbackPageResponses(feedback.id, data.page, siteId).then(function () {
                    // Responses deleted, add a warning.
                    result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                        component: _this.componentTranslate,
                        name: feedback.name,
                        error: _this.textUtils.getErrorMessageFromError(error)
                    }));
                });
            }
            else {
                // Couldn't connect to server, reject.
                return Promise.reject(error);
            }
        });
    };
    AddonModFeedbackSyncProvider.AUTO_SYNCED = 'addon_mod_feedback_autom_synced';
    AddonModFeedbackSyncProvider = AddonModFeedbackSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_7__offline__["a" /* AddonModFeedbackOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_8__feedback__["a" /* AddonModFeedbackProvider */],
            __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_15__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_13__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */], __WEBPACK_IMPORTED_MODULE_14__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */],
            __WEBPACK_IMPORTED_MODULE_16__prefetch_handler__["a" /* AddonModFeedbackPrefetchHandler */]])
    ], AddonModFeedbackSyncProvider);
    return AddonModFeedbackSyncProvider;
    var AddonModFeedbackSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_12__core_course_classes_activity_sync__["a" /* CoreCourseActivitySyncBaseProvider */]));

//# sourceMappingURL=sync.js.map

/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModLessonOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lesson__ = __webpack_require__(158);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Service to handle offline lesson.
 */
var AddonModLessonOfflineProvider = /** @class */ (function () {
    function AddonModLessonOfflineProvider(logger, sitesProvider, timeUtils, textUtils, utils) {
        this.sitesProvider = sitesProvider;
        this.timeUtils = timeUtils;
        this.textUtils = textUtils;
        this.utils = utils;
        this.siteSchema = {
            name: 'AddonModLessonOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModLessonOfflineProvider_1.RETAKES_TABLE,
                    columns: [
                        {
                            name: 'lessonid',
                            type: 'INTEGER',
                            primaryKey: true // Only 1 offline retake per lesson.
                        },
                        {
                            name: 'retake',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'finished',
                            type: 'INTEGER'
                        },
                        {
                            name: 'outoftime',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        },
                        {
                            name: 'lastquestionpage',
                            type: 'INTEGER'
                        },
                    ]
                },
                {
                    name: AddonModLessonOfflineProvider_1.PAGE_ATTEMPTS_TABLE,
                    columns: [
                        {
                            name: 'lessonid',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'retake',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'pageid',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER',
                            notNull: true
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'data',
                            type: 'TEXT'
                        },
                        {
                            name: 'type',
                            type: 'INTEGER'
                        },
                        {
                            name: 'newpageid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'correct',
                            type: 'INTEGER'
                        },
                        {
                            name: 'answerid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'useranswer',
                            type: 'TEXT'
                        },
                    ],
                    // A user can attempt several times per page and retake.
                    primaryKeys: ['lessonid', 'retake', 'pageid', 'timemodified']
                }
            ]
        };
        this.logger = logger.getInstance('AddonModLessonOfflineProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModLessonOfflineProvider_1 = AddonModLessonOfflineProvider;
    /**
     * Delete an offline attempt.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Lesson retake number.
     * @param {number} pageId Page ID.
     * @param {number} timemodified The timemodified of the attempt.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonOfflineProvider.prototype.deleteAttempt = function (lessonId, retake, pageId, timemodified, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(AddonModLessonOfflineProvider_1.PAGE_ATTEMPTS_TABLE, {
                lessonid: lessonId,
                retake: retake,
                pageid: pageId,
                timemodified: timemodified
            });
        });
    };
    /**
     * Delete offline lesson retake.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonOfflineProvider.prototype.deleteRetake = function (lessonId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(AddonModLessonOfflineProvider_1.RETAKES_TABLE, { lessonid: lessonId });
        });
    };
    /**
     * Delete offline attempts for a retake and page.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Lesson retake number.
     * @param {number} pageId Page ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonOfflineProvider.prototype.deleteRetakeAttemptsForPage = function (lessonId, retake, pageId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(AddonModLessonOfflineProvider_1.PAGE_ATTEMPTS_TABLE, { lessonid: lessonId,
                retake: retake, pageid: pageId });
        });
    };
    /**
     * Mark a retake as finished.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} courseId Course ID the lesson belongs to.
     * @param {number} retake Retake number.
     * @param {boolean} finished  Whether retake is finished.
     * @param {boolean} outOfTime If the user ran out of time.
     * @param {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}           Promise resolved in success, rejected otherwise.
     */
    AddonModLessonOfflineProvider.prototype.finishRetake = function (lessonId, courseId, retake, finished, outOfTime, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Get current stored retake (if any). If not found, it will create a new one.
            return _this.getRetakeWithFallback(lessonId, courseId, retake, site.id).then(function (entry) {
                entry.finished = finished ? 1 : 0;
                entry.outoftime = outOfTime ? 1 : 0;
                entry.timemodified = _this.timeUtils.timestamp();
                return site.getDb().insertRecord(AddonModLessonOfflineProvider_1.RETAKES_TABLE, entry);
            });
        });
    };
    /**
     * Get all the offline page attempts in a certain site.
     *
     * @param {string} [siteId] Site ID. If not set, use current site.
     * @return {Promise<any>} Promise resolved when the offline attempts are retrieved.
     */
    AddonModLessonOfflineProvider.prototype.getAllAttempts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getAllRecords(AddonModLessonOfflineProvider_1.PAGE_ATTEMPTS_TABLE);
        }).then(function (attempts) {
            return _this.parsePageAttempts(attempts);
        });
    };
    /**
     * Get all the lessons that have offline data in a certain site.
     *
     * @param {string} [siteId] Site ID. If not set, use current site.
     * @return {Promise<any>} Promise resolved with an object containing the lessons.
     */
    AddonModLessonOfflineProvider.prototype.getAllLessonsWithData = function (siteId) {
        var _this = this;
        var promises = [], lessons = {};
        // Get the lessons from page attempts.
        promises.push(this.getAllAttempts(siteId).then(function (entries) {
            _this.getLessonsFromEntries(lessons, entries);
        }).catch(function () {
            // Ignore errors.
        }));
        // Get the lessons from retakes.
        promises.push(this.getAllRetakes(siteId).then(function (entries) {
            _this.getLessonsFromEntries(lessons, entries);
        }).catch(function () {
            // Ignore errors.
        }));
        return Promise.all(promises).then(function () {
            return _this.utils.objectToArray(lessons);
        });
    };
    /**
     * Get all the offline retakes in a certain site.
     *
     * @param {string} [siteId] Site ID. If not set, use current site.
     * @return {Promise<any>} Promise resolved when the offline retakes are retrieved.
     */
    AddonModLessonOfflineProvider.prototype.getAllRetakes = function (siteId) {
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getAllRecords(AddonModLessonOfflineProvider_1.RETAKES_TABLE);
        });
    };
    /**
     * Retrieve the last offline attempt stored in a retake.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the attempt (undefined if no attempts).
     */
    AddonModLessonOfflineProvider.prototype.getLastQuestionPageAttempt = function (lessonId, retake, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getRetakeWithFallback(lessonId, 0, retake, siteId).then(function (retakeData) {
            if (!retakeData.lastquestionpage) {
                // No question page attempted.
                return;
            }
            return _this.getRetakeAttemptsForPage(lessonId, retake, retakeData.lastquestionpage, siteId).then(function (attempts) {
                // Return the attempt with highest timemodified.
                return attempts.reduce(function (a, b) {
                    return a.timemodified > b.timemodified ? a : b;
                });
            });
        }).catch(function () {
            // Error, return undefined.
        });
    };
    /**
     * Retrieve all offline attempts for a lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the attempts.
     */
    AddonModLessonOfflineProvider.prototype.getLessonAttempts = function (lessonId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModLessonOfflineProvider_1.PAGE_ATTEMPTS_TABLE, { lessonid: lessonId });
        }).then(function (attempts) {
            return _this.parsePageAttempts(attempts);
        });
    };
    /**
     * Given a list of DB entries (either retakes or page attempts), get the list of lessons.
     *
     * @param {any} lessons Object where to store the lessons.
     * @param {any[]} entries List of DB entries.
     */
    AddonModLessonOfflineProvider.prototype.getLessonsFromEntries = function (lessons, entries) {
        entries.forEach(function (entry) {
            if (!lessons[entry.lessonid]) {
                lessons[entry.lessonid] = {
                    id: entry.lessonid,
                    courseId: entry.courseid
                };
            }
        });
    };
    /**
     * Get attempts for question pages and retake in a lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {boolean} [correct] True to only fetch correct attempts, false to get them all.
     * @param {number} [pageId] If defined, only get attempts on this page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>}  Promise resolved with the attempts.
     */
    AddonModLessonOfflineProvider.prototype.getQuestionsAttempts = function (lessonId, retake, correct, pageId, siteId) {
        var promise;
        if (pageId) {
            // Page ID is set, only get the attempts for that page.
            promise = this.getRetakeAttemptsForPage(lessonId, retake, pageId, siteId);
        }
        else {
            // Page ID not specified, get all the attempts.
            promise = this.getRetakeAttemptsForType(lessonId, retake, __WEBPACK_IMPORTED_MODULE_6__lesson__["a" /* AddonModLessonProvider */].TYPE_QUESTION, siteId);
        }
        return promise.then(function (attempts) {
            if (correct) {
                return attempts.filter(function (attempt) {
                    return !!attempt.correct;
                });
            }
            return attempts;
        });
    };
    /**
     * Retrieve a retake from site DB.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the retake.
     */
    AddonModLessonOfflineProvider.prototype.getRetake = function (lessonId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(AddonModLessonOfflineProvider_1.RETAKES_TABLE, { lessonid: lessonId });
        });
    };
    /**
     * Retrieve all offline attempts for a retake.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake   Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the retake attempts.
     */
    AddonModLessonOfflineProvider.prototype.getRetakeAttempts = function (lessonId, retake, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModLessonOfflineProvider_1.PAGE_ATTEMPTS_TABLE, { lessonid: lessonId, retake: retake });
        }).then(function (attempts) {
            return _this.parsePageAttempts(attempts);
        });
    };
    /**
     * Retrieve offline attempts for a retake and page.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake   Lesson retake number.
     * @param {number} pageId   Page ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved with the retake attempts.
     */
    AddonModLessonOfflineProvider.prototype.getRetakeAttemptsForPage = function (lessonId, retake, pageId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModLessonOfflineProvider_1.PAGE_ATTEMPTS_TABLE, { lessonid: lessonId, retake: retake,
                pageid: pageId });
        }).then(function (attempts) {
            return _this.parsePageAttempts(attempts);
        });
    };
    /**
     * Retrieve offline attempts for certain pages for a retake.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake   Retake number.
     * @param {number} type     Type of the pages to get: TYPE_QUESTION or TYPE_STRUCTURE.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved with the retake attempts.
     */
    AddonModLessonOfflineProvider.prototype.getRetakeAttemptsForType = function (lessonId, retake, type, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModLessonOfflineProvider_1.PAGE_ATTEMPTS_TABLE, { lessonid: lessonId, retake: retake,
                type: type });
        }).then(function (attempts) {
            return _this.parsePageAttempts(attempts);
        });
    };
    /**
     * Get stored retake. If not found or doesn't match the retake number, return a new one.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} courseId Course ID the lesson belongs to.
     * @param {number} retake Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the retake.
     */
    AddonModLessonOfflineProvider.prototype.getRetakeWithFallback = function (lessonId, courseId, retake, siteId) {
        // Get current stored retake.
        return this.getRetake(lessonId, siteId).then(function (retakeData) {
            if (retakeData.retake != retake) {
                // The stored retake doesn't match the retake number, create a new one.
                return Promise.reject(null);
            }
            return retakeData;
        }).catch(function () {
            // No retake, create a new one.
            return {
                lessonid: lessonId,
                retake: retake,
                courseid: courseId,
                finished: 0
            };
        });
    };
    /**
     * Check if there is a finished retake for a certain lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean.
     */
    AddonModLessonOfflineProvider.prototype.hasFinishedRetake = function (lessonId, siteId) {
        return this.getRetake(lessonId, siteId).then(function (retake) {
            return !!retake.finished;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Check if a lesson has offline data.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean.
     */
    AddonModLessonOfflineProvider.prototype.hasOfflineData = function (lessonId, siteId) {
        var promises = [];
        var hasData = false;
        promises.push(this.getRetake(lessonId, siteId).then(function () {
            hasData = true;
        }).catch(function () {
            // Ignore errors.
        }));
        promises.push(this.getLessonAttempts(lessonId, siteId).then(function (attempts) {
            hasData = hasData || !!attempts.length;
        }).catch(function () {
            // Ignore errors.
        }));
        return Promise.all(promises).then(function () {
            return hasData;
        });
    };
    /**
     * Check if there are offline attempts for a retake.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with a boolean.
     */
    AddonModLessonOfflineProvider.prototype.hasRetakeAttempts = function (lessonId, retake, siteId) {
        return this.getRetakeAttempts(lessonId, retake, siteId).then(function (list) {
            return !!list.length;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Parse some properties of a page attempt.
     *
     * @param {any} attempt The attempt to treat.
     * @return {any} The treated attempt.
     */
    AddonModLessonOfflineProvider.prototype.parsePageAttempt = function (attempt) {
        attempt.data = this.textUtils.parseJSON(attempt.data);
        attempt.useranswer = this.textUtils.parseJSON(attempt.useranswer);
        return attempt;
    };
    /**
     * Parse some properties of some page attempts.
     *
     * @param {any[]} attempts The attempts to treat.
     * @return {any[]} The treated attempts.
     */
    AddonModLessonOfflineProvider.prototype.parsePageAttempts = function (attempts) {
        var _this = this;
        attempts.forEach(function (attempt) {
            _this.parsePageAttempt(attempt);
        });
        return attempts;
    };
    /**
     * Process a lesson page, saving its data.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} courseId Course ID the lesson belongs to.
     * @param {number} retake Retake number.
     * @param {any} page Page.
     * @param {any} data Data to save.
     * @param {number} newPageId New page ID (calculated).
     * @param {number} [answerId] The answer ID that the user answered.
     * @param {boolean} [correct] If answer is correct. Only for question pages.
     * @param {any} [userAnswer] The user's answer (userresponse from checkAnswer).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModLessonOfflineProvider.prototype.processPage = function (lessonId, courseId, retake, page, data, newPageId, answerId, correct, userAnswer, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var entry = {
                lessonid: lessonId,
                retake: retake,
                pageid: page.id,
                timemodified: _this.timeUtils.timestamp(),
                courseid: courseId,
                data: data ? JSON.stringify(data) : null,
                type: page.type,
                newpageid: newPageId,
                correct: correct ? 1 : 0,
                answerid: Number(answerId),
                useranswer: userAnswer ? JSON.stringify(userAnswer) : null,
            };
            return site.getDb().insertRecord(AddonModLessonOfflineProvider_1.PAGE_ATTEMPTS_TABLE, entry);
        }).then(function () {
            if (page.type == __WEBPACK_IMPORTED_MODULE_6__lesson__["a" /* AddonModLessonProvider */].TYPE_QUESTION) {
                // It's a question page, set it as last question page attempted.
                return _this.setLastQuestionPageAttempted(lessonId, courseId, retake, page.id, siteId);
            }
        });
    };
    /**
     * Set the last question page attempted in a retake.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} courseId Course ID the lesson belongs to.
     * @param {number} retake Retake number.
     * @param {number} lastPage ID of the last question page attempted.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonModLessonOfflineProvider.prototype.setLastQuestionPageAttempted = function (lessonId, courseId, retake, lastPage, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Get current stored retake (if any). If not found, it will create a new one.
            return _this.getRetakeWithFallback(lessonId, courseId, retake, site.id).then(function (entry) {
                entry.lastquestionpage = lastPage;
                entry.timemodified = _this.timeUtils.timestamp();
                return site.getDb().insertRecord(AddonModLessonOfflineProvider_1.RETAKES_TABLE, entry);
            });
        });
    };
    // Variables for database. We use lowercase in the names to match the WS responses.
    AddonModLessonOfflineProvider.RETAKES_TABLE = 'addon_mod_lesson_retakes';
    AddonModLessonOfflineProvider.PAGE_ATTEMPTS_TABLE = 'addon_mod_lesson_page_attempts';
    AddonModLessonOfflineProvider = AddonModLessonOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonModLessonOfflineProvider);
    return AddonModLessonOfflineProvider;
    var AddonModLessonOfflineProvider_1;
}());

//# sourceMappingURL=lesson-offline.js.map

/***/ }),
/* 271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModLessonSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_course_providers_module_prefetch_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_course_classes_activity_sync__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__lesson__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__lesson_offline__ = __webpack_require__(270);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__prefetch_handler__ = __webpack_require__(311);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


















/**
 * Service to sync lesson.
 */
var AddonModLessonSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModLessonSyncProvider, _super);
    function AddonModLessonSyncProvider(loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, courseProvider, eventsProvider, lessonProvider, lessonOfflineProvider, prefetchHandler, timeUtils, utils, urlUtils, logHelper, prefetchDelegate) {
        var _this = _super.call(this, 'AddonModLessonSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils, prefetchDelegate, prefetchHandler) || this;
        _this.courseProvider = courseProvider;
        _this.eventsProvider = eventsProvider;
        _this.lessonProvider = lessonProvider;
        _this.lessonOfflineProvider = lessonOfflineProvider;
        _this.prefetchHandler = prefetchHandler;
        _this.utils = utils;
        _this.urlUtils = urlUtils;
        _this.logHelper = logHelper;
        _this.siteSchema = {
            name: 'AddonModLessonSyncProvider',
            version: 1,
            tables: [
                {
                    name: AddonModLessonSyncProvider_1.RETAKES_FINISHED_TABLE,
                    columns: [
                        {
                            name: 'lessonid',
                            type: 'INTEGER',
                            primaryKey: true
                        },
                        {
                            name: 'retake',
                            type: 'INTEGER'
                        },
                        {
                            name: 'pageid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timefinished',
                            type: 'INTEGER'
                        }
                    ]
                }
            ]
        };
        _this.componentTranslate = courseProvider.translateModuleName('lesson');
        _this.sitesProvider.registerSiteSchema(_this.siteSchema);
        return _this;
    }
    AddonModLessonSyncProvider_1 = AddonModLessonSyncProvider;
    /**
     * Unmark a retake as finished in a synchronization.
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonSyncProvider.prototype.deleteRetakeFinishedInSync = function (lessonId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(AddonModLessonSyncProvider_1.RETAKES_FINISHED_TABLE, { lessonid: lessonId });
        }).catch(function () {
            // Ignore errors, maybe there is none.
        });
    };
    /**
     * Get a retake finished in a synchronization for a certain lesson (if any).
     *
     * @param {number} lessonId Lesson ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the retake entry (undefined if no retake).
     */
    AddonModLessonSyncProvider.prototype.getRetakeFinishedInSync = function (lessonId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(AddonModLessonSyncProvider_1.RETAKES_FINISHED_TABLE, { lessonid: lessonId });
        }).catch(function () {
            // Ignore errors, return undefined.
        });
    };
    /**
     * Check if a lesson has data to synchronize.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake  Retake number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether it has data to sync.
     */
    AddonModLessonSyncProvider.prototype.hasDataToSync = function (lessonId, retake, siteId) {
        var promises = [];
        var hasDataToSync = false;
        promises.push(this.lessonOfflineProvider.hasRetakeAttempts(lessonId, retake, siteId).then(function (hasAttempts) {
            hasDataToSync = hasDataToSync || hasAttempts;
        }).catch(function () {
            // Ignore errors.
        }));
        promises.push(this.lessonOfflineProvider.hasFinishedRetake(lessonId, siteId).then(function (hasFinished) {
            hasDataToSync = hasDataToSync || hasFinished;
        }));
        return Promise.all(promises).then(function () {
            return hasDataToSync;
        });
    };
    /**
     * Mark a retake as finished in a synchronization.
     *
     * @param {number} lessonId Lesson ID.
     * @param {number} retake The retake number.
     * @param {number} pageId The page ID to start reviewing from.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonSyncProvider.prototype.setRetakeFinishedInSync = function (lessonId, retake, pageId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().insertRecord(AddonModLessonSyncProvider_1.RETAKES_FINISHED_TABLE, {
                lessonid: lessonId,
                retake: Number(retake),
                pageid: Number(pageId),
                timefinished: _this.timeUtils.timestamp()
            });
        });
    };
    /**
     * Try to synchronize all the lessons in a certain site or in all sites.
     *
     * @param {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModLessonSyncProvider.prototype.syncAllLessons = function (siteId, force) {
        return this.syncOnSites('all lessons', this.syncAllLessonsFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all lessons on a site.
     *
     * @param  {string} siteId Site ID to sync.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @param {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModLessonSyncProvider.prototype.syncAllLessonsFunc = function (siteId, force) {
        var _this = this;
        // Get all the lessons that have something to be synchronized.
        return this.lessonOfflineProvider.getAllLessonsWithData(siteId).then(function (lessons) {
            // Sync all lessons that haven't been synced for a while.
            var promises = [];
            lessons.map(function (lesson) {
                var promise = force ? _this.syncLesson(lesson.id, false, false, siteId) :
                    _this.syncLessonIfNeeded(lesson.id, false, siteId);
                return promise.then(function (result) {
                    if (result && result.updated) {
                        // Sync successful, send event.
                        _this.eventsProvider.trigger(AddonModLessonSyncProvider_1.AUTO_SYNCED, {
                            lessonId: lesson.id,
                            warnings: result.warnings
                        }, siteId);
                    }
                });
            });
            return Promise.all(promises);
        });
    };
    /**
     * Sync a lesson only if a certain time has passed since the last time.
     *
     * @param {any} lessonId Lesson ID.
     * @param {boolean} [askPreflight] Whether we should ask for password if needed.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the lesson is synced or if it doesn't need to be synced.
     */
    AddonModLessonSyncProvider.prototype.syncLessonIfNeeded = function (lessonId, askPassword, siteId) {
        var _this = this;
        return this.isSyncNeeded(lessonId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncLesson(lessonId, askPassword, false, siteId);
            }
        });
    };
    /**
     * Try to synchronize a lesson.
     *
     * @param {number} lessonId Lesson ID.
     * @param {boolean} askPassword True if we should ask for password if needed, false otherwise.
     * @param {boolean} ignoreBlock True to ignore the sync block setting.
     * @param {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<AddonModLessonSyncResult>} Promise resolved in success.
     */
    AddonModLessonSyncProvider.prototype.syncLesson = function (lessonId, askPassword, ignoreBlock, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var result = {
            warnings: [],
            updated: false
        };
        var syncPromise, lesson, courseId, password, accessInfo;
        if (this.isSyncing(lessonId, siteId)) {
            // There's already a sync ongoing for this lesson, return the promise.
            return this.getOngoingSync(lessonId, siteId);
        }
        // Verify that lesson isn't blocked.
        if (!ignoreBlock && this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_15__lesson__["a" /* AddonModLessonProvider */].COMPONENT, lessonId, siteId)) {
            this.logger.debug('Cannot sync lesson ' + lessonId + ' because it is blocked.');
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        this.logger.debug('Try to sync lesson ' + lessonId + ' in site ' + siteId);
        // Sync offline logs.
        syncPromise = this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_15__lesson__["a" /* AddonModLessonProvider */].COMPONENT, lessonId, siteId).catch(function () {
            // Ignore errors.
        }).then(function () {
            // Try to synchronize the attempts first.
            return _this.lessonOfflineProvider.getLessonAttempts(lessonId, siteId);
        }).then(function (attempts) {
            if (!attempts.length) {
                return;
            }
            else if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(null);
            }
            courseId = attempts[0].courseid;
            // Get the info, access info and the lesson password if needed.
            return _this.lessonProvider.getLessonById(courseId, lessonId, false, false, siteId).then(function (lessonData) {
                lesson = lessonData;
                return _this.prefetchHandler.getLessonPassword(lessonId, false, true, askPassword, siteId);
            }).then(function (data) {
                var attemptsLength = attempts.length, promises = [];
                accessInfo = data.accessInfo;
                password = data.password;
                lesson = data.lesson || lesson;
                // Filter the attempts, get only the ones that belong to the current retake.
                attempts = attempts.filter(function (attempt) {
                    if (attempt.retake != accessInfo.attemptscount) {
                        // Attempt doesn't belong to current retake, delete.
                        promises.push(_this.lessonOfflineProvider.deleteAttempt(lesson.id, attempt.retake, attempt.pageid, attempt.timemodified, siteId).catch(function () {
                            // Ignore errors.
                        }));
                        return false;
                    }
                    return true;
                });
                if (attempts.length != attemptsLength) {
                    // Some attempts won't be sent, add a warning.
                    result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                        component: _this.componentTranslate,
                        name: lesson.name,
                        error: _this.translate.instant('addon.mod_lesson.warningretakefinished')
                    }));
                }
                return Promise.all(promises);
            }).then(function () {
                if (!attempts.length) {
                    return;
                }
                // Send the attempts in the same order they were answered.
                attempts.sort(function (a, b) {
                    return a.timemodified - b.timemodified;
                });
                attempts = attempts.map(function (attempt) {
                    return {
                        func: _this.sendAttempt.bind(_this),
                        params: [lesson, password, attempt, result, siteId],
                        blocking: true
                    };
                });
                return _this.utils.executeOrderedPromises(attempts);
            });
        }).then(function () {
            // Attempts sent or there was none. If there is a finished retake, send it.
            return _this.lessonOfflineProvider.getRetake(lessonId, siteId).then(function (retake) {
                if (!retake.finished) {
                    // The retake isn't marked as finished, nothing to send. Delete the retake.
                    return _this.lessonOfflineProvider.deleteRetake(lessonId, siteId);
                }
                else if (!_this.appProvider.isOnline()) {
                    // Cannot sync in offline.
                    return Promise.reject(null);
                }
                var promise;
                courseId = retake.courseid || courseId;
                if (lesson) {
                    // Data already retrieved when syncing attempts.
                    promise = Promise.resolve();
                }
                else {
                    promise = _this.lessonProvider.getLessonById(courseId, lessonId, false, false, siteId).then(function (lessonData) {
                        lesson = lessonData;
                        return _this.prefetchHandler.getLessonPassword(lessonId, false, true, askPassword, siteId);
                    }).then(function (data) {
                        accessInfo = data.accessInfo;
                        password = data.password;
                        lesson = data.lesson || lesson;
                    });
                }
                return promise.then(function () {
                    if (retake.retake != accessInfo.attemptscount) {
                        // The retake changed, add a warning if it isn't there already.
                        if (!result.warnings.length) {
                            result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                                component: _this.componentTranslate,
                                name: lesson.name,
                                error: _this.translate.instant('addon.mod_lesson.warningretakefinished')
                            }));
                        }
                        return _this.lessonOfflineProvider.deleteRetake(lessonId, siteId);
                    }
                    // All good, finish the retake.
                    return _this.lessonProvider.finishRetakeOnline(lessonId, password, false, false, siteId).then(function (response) {
                        result.updated = true;
                        if (!ignoreBlock) {
                            // Mark the retake as finished in a sync if it can be reviewed.
                            if (response.data && response.data.reviewlesson) {
                                var params = _this.urlUtils.extractUrlParams(response.data.reviewlesson.value);
                                if (params && params.pageid) {
                                    // The retake can be reviewed, mark it as finished. Don't block the user for this.
                                    _this.setRetakeFinishedInSync(lessonId, retake.retake, params.pageid, siteId);
                                }
                            }
                        }
                        return _this.lessonOfflineProvider.deleteRetake(lessonId, siteId);
                    }).catch(function (error) {
                        if (error && _this.utils.isWebServiceError(error)) {
                            // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.
                            result.updated = true;
                            return _this.lessonOfflineProvider.deleteRetake(lessonId, siteId).then(function () {
                                // Retake deleted, add a warning.
                                result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                                    component: _this.componentTranslate,
                                    name: lesson.name,
                                    error: _this.textUtils.getErrorMessageFromError(error)
                                }));
                            });
                        }
                        else {
                            // Couldn't connect to server, reject.
                            return Promise.reject(error);
                        }
                    });
                });
            }, function () {
                // No retake stored, nothing to do.
            });
        }).then(function () {
            if (result.updated && courseId) {
                // Data has been sent to server, update data.
                return _this.courseProvider.getModuleBasicInfoByInstance(lessonId, 'lesson', siteId).then(function (module) {
                    return _this.prefetchAfterUpdate(module, courseId, undefined, siteId);
                }).catch(function () {
                    // Ignore errors.
                });
            }
        }).then(function () {
            // Sync finished, set sync time.
            return _this.setSyncTime(lessonId, siteId).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            // All done, return the result.
            return result;
        });
        return this.addOngoingSync(lessonId, syncPromise, siteId);
    };
    /**
     * Send an attempt to the site and delete it afterwards.
     *
     * @param {any} lesson Lesson.
     * @param {string} password Password (if any).
     * @param {any} attempt Attempt to send.
     * @param {AddonModLessonSyncResult} result Result where to store the data.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonSyncProvider.prototype.sendAttempt = function (lesson, password, attempt, result, siteId) {
        var _this = this;
        return this.lessonProvider.processPageOnline(lesson.id, attempt.pageid, attempt.data, password, false, siteId).then(function () {
            result.updated = true;
            return _this.lessonOfflineProvider.deleteAttempt(lesson.id, attempt.retake, attempt.pageid, attempt.timemodified, siteId);
        }).catch(function (error) {
            if (error && _this.utils.isWebServiceError(error)) {
                // The WebService has thrown an error, this means that the attempt cannot be submitted. Delete it.
                result.updated = true;
                return _this.lessonOfflineProvider.deleteAttempt(lesson.id, attempt.retake, attempt.pageid, attempt.timemodified, siteId).then(function () {
                    // Attempt deleted, add a warning.
                    result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                        component: _this.componentTranslate,
                        name: lesson.name,
                        error: _this.textUtils.getErrorMessageFromError(error)
                    }));
                });
            }
            else {
                // Couldn't connect to server, reject.
                return Promise.reject(error);
            }
        });
    };
    AddonModLessonSyncProvider.AUTO_SYNCED = 'addon_mod_lesson_autom_synced';
    // Variables for database.
    AddonModLessonSyncProvider.RETAKES_FINISHED_TABLE = 'addon_mod_lesson_retakes_finished_sync';
    AddonModLessonSyncProvider = AddonModLessonSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_15__lesson__["a" /* AddonModLessonProvider */], __WEBPACK_IMPORTED_MODULE_16__lesson_offline__["a" /* AddonModLessonOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_17__prefetch_handler__["a" /* AddonModLessonPrefetchHandler */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */], __WEBPACK_IMPORTED_MODULE_13__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */]])
    ], AddonModLessonSyncProvider);
    return AddonModLessonSyncProvider;
    var AddonModLessonSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_14__core_course_classes_activity_sync__["a" /* CoreCourseActivitySyncBaseProvider */]));

//# sourceMappingURL=lesson-sync.js.map

/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModScormSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_module_prefetch_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_course_classes_activity_sync__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__scorm__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__scorm_offline__ = __webpack_require__(251);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__prefetch_handler__ = __webpack_require__(315);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

















/**
 * Service to sync SCORMs.
 */
var AddonModScormSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModScormSyncProvider, _super);
    function AddonModScormSyncProvider(loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, eventsProvider, timeUtils, scormProvider, scormOfflineProvider, prefetchHandler, utils, prefetchDelegate, courseProvider, logHelper) {
        var _this = _super.call(this, 'AddonModScormSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils, prefetchDelegate, prefetchHandler) || this;
        _this.eventsProvider = eventsProvider;
        _this.scormProvider = scormProvider;
        _this.scormOfflineProvider = scormOfflineProvider;
        _this.utils = utils;
        _this.courseProvider = courseProvider;
        _this.logHelper = logHelper;
        _this.componentTranslate = courseProvider.translateModuleName('scorm');
        return _this;
    }
    AddonModScormSyncProvider_1 = AddonModScormSyncProvider;
    /**
     * Add an offline attempt to the right of the new attempts array if possible.
     * If the attempt cannot be created as a new attempt then it will be deleted.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt The offline attempt to treat.
     * @param {number} lastOffline Last offline attempt number.
     * @param {number[]} newAttemptsSameOrder Attempts that'll be created as new attempts but keeping the current order.
     * @param {any} newAttemptsAtEnd Object with attempts that'll be created at the end of the list of attempts (should be max 1).
     * @param {number} lastOfflineCreated Time when the last offline attempt was created.
     * @param {boolean} lastOfflineIncomplete Whether the last offline attempt is incomplete.
     * @param {string[]} warnings Array where to add the warnings.
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModScormSyncProvider.prototype.addToNewOrDelete = function (scormId, attempt, lastOffline, newAttemptsSameOrder, newAttemptsAtEnd, lastOfflineCreated, lastOfflineIncomplete, warnings, siteId) {
        var _this = this;
        if (attempt == lastOffline) {
            newAttemptsSameOrder.push(attempt);
            return Promise.resolve();
        }
        // Check if the attempt can be created.
        return this.scormOfflineProvider.getAttemptCreationTime(scormId, attempt, siteId).then(function (time) {
            if (time > lastOfflineCreated) {
                // This attempt was created after the last offline attempt, we'll add it to the end of the list if possible.
                if (lastOfflineIncomplete) {
                    // It can't be added because the last offline attempt is incomplete, delete it.
                    _this.logger.debug('Try to delete attempt ' + attempt + ' because it cannot be created as a new attempt.');
                    return _this.scormOfflineProvider.deleteAttempt(scormId, attempt, siteId).then(function () {
                        warnings.push(_this.translate.instant('addon.mod_scorm.warningofflinedatadeleted', { number: attempt }));
                    }).catch(function () {
                        // Maybe there's something wrong with the data or the storage implementation.
                    });
                }
                else {
                    // Add the attempt at the end.
                    newAttemptsAtEnd[time] = attempt;
                }
            }
            else {
                newAttemptsSameOrder.push(attempt);
            }
        });
    };
    /**
     * Check if can retry an attempt synchronization.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {number} lastOnline Last online attempt number.
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved if can retry the synchronization, rejected otherwise.
     */
    AddonModScormSyncProvider.prototype.canRetrySync = function (scormId, attempt, lastOnline, siteId) {
        var _this = this;
        // If it's the last attempt we don't need to ignore cache because we already did it.
        var refresh = lastOnline != attempt;
        return this.scormProvider.getScormUserData(scormId, attempt, undefined, false, refresh, siteId).then(function (siteData) {
            // Get synchronization snapshot (if sync fails it should store a snapshot).
            return _this.scormOfflineProvider.getAttemptSnapshot(scormId, attempt, siteId).then(function (snapshot) {
                if (!snapshot || !Object.keys(snapshot).length || !_this.snapshotEquals(snapshot, siteData)) {
                    // No snapshot or it doesn't match, we can't retry the synchronization.
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Create new attempts at the end of the offline attempts list.
     *
     * @param {number} scormId SCORM ID.
     * @param {any} newAttempts Object with the attempts to create. The keys are the timecreated, the values are the attempt number.
     * @param {number} lastOffline Number of last offline attempt.
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModScormSyncProvider.prototype.createNewAttemptsAtEnd = function (scormId, newAttempts, lastOffline, siteId) {
        var _this = this;
        var times = Object.keys(newAttempts).sort(), // Sort in ASC order.
        promises = [];
        if (!times.length) {
            return Promise.resolve();
        }
        times.forEach(function (time, index) {
            var attempt = newAttempts[time];
            promises.push(_this.scormOfflineProvider.changeAttemptNumber(scormId, attempt, lastOffline + index + 1, siteId));
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Finish a sync process: remove offline data if needed, prefetch SCORM data, set sync time and return the result.
     *
     * @param {string} siteId Site ID.
     * @param {any} scorm SCORM.
     * @param {string[]} warnings List of warnings generated by the sync.
     * @param {number} [lastOnline] Last online attempt number before the sync.
     * @param {boolean} [lastOnlineWasFinished] Whether the last online attempt was finished before the sync.
     * @param {AddonModScormAttemptCountResult} [initialCount] Attempt count before the sync.
     * @param {boolean} [updated] Whether some data was sent to the site.
     * @return {Promise<AddonModScormSyncResult>} Promise resolved on success.
     */
    AddonModScormSyncProvider.prototype.finishSync = function (siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, updated) {
        var _this = this;
        var promise;
        if (updated) {
            // Update downloaded data.
            promise = this.courseProvider.getModuleBasicInfoByInstance(scorm.id, 'scorm', siteId).then(function (module) {
                return _this.prefetchAfterUpdate(module, scorm.course, undefined, siteId);
            }).catch(function () {
                // Ignore errors.
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            return _this.setSyncTime(scorm.id, siteId).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            // Check if an attempt was finished in Moodle.
            if (initialCount) {
                // Get attempt count again to check if an attempt was finished.
                return _this.scormProvider.getAttemptCount(scorm.id, undefined, false, siteId).then(function (attemptsData) {
                    if (attemptsData.online.length > initialCount.online.length) {
                        return true;
                    }
                    else if (!lastOnlineWasFinished && lastOnline > 0) {
                        // Last online attempt wasn't finished, let's check if it is now.
                        return _this.scormProvider.isAttemptIncomplete(scorm.id, lastOnline, false, true, siteId).then(function (inc) {
                            return !inc;
                        });
                    }
                    return false;
                });
            }
            return false;
        }).then(function (attemptFinished) {
            return {
                warnings: warnings,
                attemptFinished: attemptFinished,
                updated: updated
            };
        });
    };
    /**
     * Get the creation time and the status (complete/incomplete) of an offline attempt.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {string} siteId Site ID.
     * @return {Promise<{incomplete: boolean, timecreated: number}>} Promise resolved with the data.
     */
    AddonModScormSyncProvider.prototype.getOfflineAttemptData = function (scormId, attempt, siteId) {
        var _this = this;
        // Check if last offline attempt is incomplete.
        return this.scormProvider.isAttemptIncomplete(scormId, attempt, true, false, siteId).then(function (incomplete) {
            return _this.scormOfflineProvider.getAttemptCreationTime(scormId, attempt, siteId).then(function (timecreated) {
                return {
                    incomplete: incomplete,
                    timecreated: timecreated
                };
            });
        });
    };
    /**
     * Change the number of some offline attempts. We need to move all offline attempts after the collisions
     * too, otherwise we would overwrite data.
     * Example: We have offline attempts 1, 2 and 3. #1 and #2 have collisions. #1 can be synced, but #2 needs
     * to be a new attempt. #3 will now be #4, and #2 will now be #3.
     *
     * @param {number} scormId SCORM ID.
     * @param {number[]} newAttempts Attempts that need to be converted into new attempts.
     * @param {number} lastOnline Last online attempt.
     * @param {number} lastCollision Last attempt with collision (exists in online and offline).
     * @param {number[]} offlineAttempts Numbers of offline attempts.
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when attempts have been moved.
     */
    AddonModScormSyncProvider.prototype.moveNewAttempts = function (scormId, newAttempts, lastOnline, lastCollision, offlineAttempts, siteId) {
        var _this = this;
        if (!newAttempts.length) {
            return Promise.resolve();
        }
        var promise = Promise.resolve(), lastSuccessful;
        // Sort offline attempts in DESC order.
        offlineAttempts = offlineAttempts.sort(function (a, b) {
            return Number(a) <= Number(b) ? 1 : -1;
        });
        // First move the offline attempts after the collisions.
        offlineAttempts.forEach(function (attempt) {
            if (attempt > lastCollision) {
                // We use a chain of promises because we need to move them in order.
                promise = promise.then(function () {
                    var newNumber = attempt + newAttempts.length;
                    return _this.scormOfflineProvider.changeAttemptNumber(scormId, attempt, newNumber, siteId).then(function () {
                        lastSuccessful = attempt;
                    });
                });
            }
        });
        return promise.then(function () {
            var successful = [];
            var promises = [];
            // Sort newAttempts in ASC order.
            newAttempts = newAttempts.sort(function (a, b) {
                return Number(a) >= Number(b) ? 1 : -1;
            });
            // Now move the attempts in newAttempts.
            newAttempts.forEach(function (attempt, index) {
                // No need to use chain of promises.
                var newNumber = lastOnline + index + 1;
                promises.push(_this.scormOfflineProvider.changeAttemptNumber(scormId, attempt, newNumber, siteId).then(function () {
                    successful.push(attempt);
                }));
            });
            return Promise.all(promises).catch(function (error) {
                // Moving the new attempts failed (it shouldn't happen). Let's undo the new attempts move.
                promises = [];
                successful.forEach(function (attempt) {
                    var newNumber = lastOnline + newAttempts.indexOf(attempt) + 1;
                    promises.push(_this.scormOfflineProvider.changeAttemptNumber(scormId, newNumber, attempt, siteId));
                });
                return _this.utils.allPromises(promises).then(function () {
                    return Promise.reject(error); // It will now enter the .catch that moves offline attempts after collisions.
                });
            });
        }).catch(function (error) {
            // Moving offline attempts after collisions failed (it shouldn't happen). Let's undo the changes.
            if (!lastSuccessful) {
                return Promise.reject(error);
            }
            var attemptsToUndo = [];
            var promise = Promise.resolve();
            for (var i = lastSuccessful; offlineAttempts.indexOf(i) != -1; i++) {
                attemptsToUndo.push(i);
            }
            attemptsToUndo.forEach(function (attempt) {
                promise = promise.then(function () {
                    // Move it back.
                    return _this.scormOfflineProvider.changeAttemptNumber(scormId, attempt + newAttempts.length, attempt, siteId);
                });
            });
            return promise.then(function () {
                return Promise.reject(error);
            });
        });
    };
    /**
     * Save a snapshot from a synchronization.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attemot number.
     * @param {string} siteId  Site ID.
     * @return {Promise<any>} Promise resolved when the snapshot is stored.
     */
    AddonModScormSyncProvider.prototype.saveSyncSnapshot = function (scormId, attempt, siteId) {
        var _this = this;
        // Try to get current state from the site.
        return this.scormProvider.getScormUserData(scormId, attempt, undefined, false, true, siteId).then(function (data) {
            return _this.scormOfflineProvider.setAttemptSnapshot(scormId, attempt, data, siteId);
        }, function () {
            // Error getting user data from the site. We'll have to build it ourselves.
            // Let's try to get cached data about the attempt.
            return _this.scormProvider.getScormUserData(scormId, attempt, undefined, false, false, siteId).catch(function () {
                // No cached data.
                return {};
            }).then(function (data) {
                // We need to add the synced data to the snapshot.
                return _this.scormOfflineProvider.getScormStoredData(scormId, attempt, false, true, siteId).then(function (synced) {
                    synced.forEach(function (entry) {
                        if (!data[entry.scoid]) {
                            data[entry.scoid] = {
                                scoid: entry.scoid,
                                userdata: {}
                            };
                        }
                        data[entry.scoid].userdata[entry.element] = entry.value;
                    });
                    return _this.scormOfflineProvider.setAttemptSnapshot(scormId, attempt, data, siteId);
                });
            });
        });
    };
    /**
     * Compares an attempt's snapshot with the data retrieved from the site.
     * It only compares elements with dot notation. This means that, if some SCO has been added to Moodle web
     * but the user hasn't generated data for it, then the snapshot will be detected as equal.
     *
     * @param {any} snapshot Attempt's snapshot.
     * @param {any} userData Data retrieved from the site.
     * @return {boolean} True if snapshot is equal to the user data, false otherwise.
     */
    AddonModScormSyncProvider.prototype.snapshotEquals = function (snapshot, userData) {
        // Check that snapshot contains the data from the site.
        for (var scoId in userData) {
            var siteSco = userData[scoId], snapshotSco = snapshot[scoId];
            for (var element in siteSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!snapshotSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }
        // Now check the opposite way: site userData contains the data from the snapshot.
        for (var scoId in snapshot) {
            var siteSco = userData[scoId], snapshotSco = snapshot[scoId];
            for (var element in snapshotSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!siteSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    /**
     * Try to synchronize all the SCORMs in a certain site or in all sites.
     *
     * @param {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} force Wether to force sync not depending on last execution.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModScormSyncProvider.prototype.syncAllScorms = function (siteId, force) {
        return this.syncOnSites('all SCORMs', this.syncAllScormsFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all SCORMs on a site.
     *
     * @param  {string} siteId Site ID to sync.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @param {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModScormSyncProvider.prototype.syncAllScormsFunc = function (siteId, force) {
        var _this = this;
        // Get all offline attempts.
        return this.scormOfflineProvider.getAllAttempts(siteId).then(function (attempts) {
            var scorms = [], ids = [], // To prevent duplicates.
            promises = [];
            // Get the IDs of all the SCORMs that have something to be synced.
            attempts.forEach(function (attempt) {
                if (ids.indexOf(attempt.scormid) == -1) {
                    ids.push(attempt.scormid);
                    scorms.push({
                        id: attempt.scormid,
                        courseId: attempt.courseid
                    });
                }
            });
            // Sync all SCORMs that haven't been synced for a while and that aren't attempted right now.
            scorms.forEach(function (scorm) {
                if (!_this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_14__scorm__["a" /* AddonModScormProvider */].COMPONENT, scorm.id, siteId)) {
                    promises.push(_this.scormProvider.getScormById(scorm.courseId, scorm.id, '', false, siteId).then(function (scorm) {
                        var promise = force ? _this.syncScorm(scorm, siteId) : _this.syncScormIfNeeded(scorm, siteId);
                        return promise.then(function (data) {
                            if (typeof data != 'undefined') {
                                // We tried to sync. Send event.
                                _this.eventsProvider.trigger(AddonModScormSyncProvider_1.AUTO_SYNCED, {
                                    scormId: scorm.id,
                                    attemptFinished: data.attemptFinished,
                                    warnings: data.warnings,
                                    updated: data.updated
                                }, siteId);
                            }
                        });
                    }));
                }
            });
            return Promise.all(promises);
        });
    };
    /**
     * Send data from a SCORM offline attempt to the site.
     *
     * @param {number} scormId SCORM ID.
     * @param {number} attempt Attempt number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the attempt is successfully synced.
     */
    AddonModScormSyncProvider.prototype.syncAttempt = function (scormId, attempt, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.logger.debug('Try to sync attempt ' + attempt + ' in SCORM ' + scormId + ' and site ' + siteId);
        // Get only not synced entries.
        return this.scormOfflineProvider.getScormStoredData(scormId, attempt, true, false, siteId).then(function (entries) {
            var scos = {}, promises = [];
            var somethingSynced = false;
            // Get data to send (only elements with dots like cmi.core.exit, in Mobile we store more data to make offline work).
            entries.forEach(function (entry) {
                if (entry.element.indexOf('.') > -1) {
                    if (!scos[entry.scoid]) {
                        scos[entry.scoid] = [];
                    }
                    scos[entry.scoid].push({
                        element: entry.element,
                        value: entry.value
                    });
                }
            });
            var _loop_1 = function (id) {
                var scoId = Number(id), tracks = scos[scoId];
                promises.push(_this.scormProvider.saveTracksOnline(scormId, scoId, attempt, tracks, siteId).then(function () {
                    // Sco data successfully sent. Mark them as synced. This is needed because some SCOs sync might fail.
                    return _this.scormOfflineProvider.markAsSynced(scormId, attempt, scoId, siteId).catch(function () {
                        // Ignore errors.
                    }).then(function () {
                        somethingSynced = true;
                    });
                }));
            };
            // Send the data in each SCO.
            for (var id in scos) {
                _loop_1(id);
            }
            return _this.utils.allPromises(promises).then(function () {
                // Attempt has been sent. Let's delete it from local.
                return _this.scormOfflineProvider.deleteAttempt(scormId, attempt, siteId).catch(function () {
                    // Failed to delete (shouldn't happen). Let's retry once.
                    return _this.scormOfflineProvider.deleteAttempt(scormId, attempt, siteId).catch(function () {
                        // Maybe there's something wrong with the data or the storage implementation.
                        _this.logger.error('After sync: error deleting attempt ' + attempt + ' in SCORM ' + scormId);
                    });
                });
            }).catch(function (error) {
                if (somethingSynced) {
                    // Some SCOs have been synced and some not.
                    // Try to store a snapshot of the current state to be able to re-try the synchronization later.
                    _this.logger.error('Error synchronizing some SCOs for attempt ' + attempt + ' in SCORM ' +
                        scormId + '. Saving snapshot.');
                    return _this.saveSyncSnapshot(scormId, attempt, siteId).then(function () {
                        return Promise.reject(error);
                    });
                }
                else {
                    _this.logger.error('Error synchronizing attempt ' + attempt + ' in SCORM ' + scormId);
                }
                return Promise.reject(error);
            });
        });
    };
    /**
     * Sync a SCORM only if a certain time has passed since the last time.
     *
     * @param {any} scorm SCORM.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the SCORM is synced or if it doesn't need to be synced.
     */
    AddonModScormSyncProvider.prototype.syncScormIfNeeded = function (scorm, siteId) {
        var _this = this;
        return this.isSyncNeeded(scorm.id, siteId).then(function (needed) {
            if (needed) {
                return _this.syncScorm(scorm, siteId);
            }
        });
    };
    /**
     * Try to synchronize a SCORM.
     * The promise returned will be resolved with an array with warnings if the synchronization is successful. A successful
     * synchronization doesn't mean that all the data has been sent to the site, it's possible that some attempt can't be sent.
     *
     * @param {any} scorm SCORM.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<AddonModScormSyncResult>} Promise resolved in success.
     */
    AddonModScormSyncProvider.prototype.syncScorm = function (scorm, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var warnings = [], syncPromise, initialCount, lastOnline = 0, lastOnlineWasFinished = false;
        if (this.isSyncing(scorm.id, siteId)) {
            // There's already a sync ongoing for this SCORM, return the promise.
            return this.getOngoingSync(scorm.id, siteId);
        }
        // Verify that SCORM isn't blocked.
        if (this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_14__scorm__["a" /* AddonModScormProvider */].COMPONENT, scorm.id, siteId)) {
            this.logger.debug('Cannot sync SCORM ' + scorm.id + ' because it is blocked.');
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        this.logger.debug('Try to sync SCORM ' + scorm.id + ' in site ' + siteId);
        // Sync offline logs.
        syncPromise = this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_14__scorm__["a" /* AddonModScormProvider */].COMPONENT, scorm.id, siteId).catch(function () {
            // Ignore errors.
        }).then(function () {
            // Get attempts data. We ignore cache for online attempts, so this call will fail if offline or server down.
            return _this.scormProvider.getAttemptCount(scorm.id, false, true, siteId);
        }).then(function (attemptsData) {
            if (!attemptsData.offline || !attemptsData.offline.length) {
                // Nothing to sync.
                return _this.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished);
            }
            initialCount = attemptsData;
            var collisions = [];
            // Check if there are collisions between offline and online attempts (same number).
            attemptsData.online.forEach(function (attempt) {
                lastOnline = Math.max(lastOnline, attempt);
                if (attemptsData.offline.indexOf(attempt) > -1) {
                    collisions.push(attempt);
                }
            });
            // Check if last online attempt is finished. Ignore cache.
            var promise = lastOnline > 0 ? _this.scormProvider.isAttemptIncomplete(scorm.id, lastOnline, false, true, siteId) :
                Promise.resolve(false);
            return promise.then(function (incomplete) {
                lastOnlineWasFinished = !incomplete;
                if (!collisions.length && !incomplete) {
                    // No collisions and last attempt is complete. Send offline attempts to Moodle.
                    var promises_1 = [];
                    attemptsData.offline.forEach(function (attempt) {
                        if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                            promises_1.push(_this.syncAttempt(scorm.id, attempt, siteId));
                        }
                    });
                    return Promise.all(promises_1).then(function () {
                        // All data synced, finish.
                        return _this.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, true);
                    });
                }
                else if (collisions.length) {
                    // We have collisions, treat them.
                    return _this.treatCollisions(scorm.id, collisions, lastOnline, attemptsData.offline, siteId).then(function (warns) {
                        warnings = warnings.concat(warns);
                        // The offline attempts might have changed since some collisions can be converted to new attempts.
                        return _this.scormOfflineProvider.getAttempts(scorm.id, siteId).then(function (entries) {
                            var promises = [];
                            var cannotSyncSome = false;
                            entries = entries.map(function (entry) {
                                return entry.attempt; // Get only the attempt number.
                            });
                            if (incomplete && entries.indexOf(lastOnline) > -1) {
                                // Last online was incomplete, but it was continued in offline.
                                incomplete = false;
                            }
                            entries.forEach(function (attempt) {
                                // We'll always sync attempts previous to lastOnline (failed sync or continued in offline).
                                // We'll only sync new attemps if last online attempt is completed.
                                if (!incomplete || attempt <= lastOnline) {
                                    if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                                        promises.push(_this.syncAttempt(scorm.id, attempt, siteId));
                                    }
                                }
                                else {
                                    cannotSyncSome = true;
                                }
                            });
                            return Promise.all(promises).then(function () {
                                if (cannotSyncSome) {
                                    warnings.push(_this.translate.instant('addon.mod_scorm.warningsynconlineincomplete'));
                                }
                                return _this.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, true);
                            });
                        });
                    });
                }
                else {
                    // No collisions, but last online attempt is incomplete so we can't send offline attempts.
                    warnings.push(_this.translate.instant('addon.mod_scorm.warningsynconlineincomplete'));
                    return _this.finishSync(siteId, scorm, warnings, lastOnline, lastOnlineWasFinished, initialCount, false);
                }
            });
        });
        return this.addOngoingSync(scorm.id, syncPromise, siteId);
    };
    /**
     * Treat collisions found in a SCORM synchronization process.
     *
     * @param {number} scormId SCORM ID.
     * @param {number[]} collisions Numbers of attempts that exist both in online and offline.
     * @param {number} lastOnline Last online attempt.
     * @param {number[]} offlineAttempts Numbers of offline attempts.
     * @param {string} siteId Site ID.
     * @return {Promise<string[]} Promise resolved when the collisions have been treated. It returns warnings array.
     * @description
     *
     * Treat collisions found in a SCORM synchronization process. A collision is when an attempt exists both in offline
     * and online. A collision can be:
     *
     * - Two different attempts.
     * - An online attempt continued in offline.
     * - A failure in a previous sync.
     *
     * This function will move into new attempts the collisions that can't be merged. It will usually keep the order of the
     * offline attempts EXCEPT if the offline attempt was created after the last offline attempt (edge case).
     *
     * Edge case: A user creates offline attempts and when he syncs we retrieve an incomplete online attempt, so the offline
     * attempts cannot be synced. Then the user continues that online attempt and goes offline, so a collision is created.
     * When we perform the next sync we detect that this collision cannot be merged, so this offline attempt needs to be
     * created as a new attempt. Since this attempt was created after the last offline attempt, it will be added ot the end
     * of the list if the last attempt is completed. If the last attempt is not completed then the offline data will de deleted
     * because we can't create a new attempt.
     */
    AddonModScormSyncProvider.prototype.treatCollisions = function (scormId, collisions, lastOnline, offlineAttempts, siteId) {
        var _this = this;
        var warnings = [], newAttemptsSameOrder = [], // Attempts that will be created as new attempts but keeping the current order.
        newAttemptsAtEnd = {}, // Attempts that will be created at the end of the list of attempts (should be max 1 attempt).
        lastCollision = Math.max.apply(Math, collisions);
        var lastOffline = Math.max.apply(Math, offlineAttempts);
        // Get needed data from the last offline attempt.
        return this.getOfflineAttemptData(scormId, lastOffline, siteId).then(function (lastOfflineData) {
            var promises = [];
            collisions.forEach(function (attempt) {
                // First get synced entries to detect if it was a failed synchronization.
                promises.push(_this.scormOfflineProvider.getScormStoredData(scormId, attempt, false, true, siteId).then(function (synced) {
                    if (synced && synced.length) {
                        // The attempt has synced entries, it seems to be a failed synchronization.
                        // Let's get the entries that haven't been synced, maybe it just failed to delete the attempt.
                        return _this.scormOfflineProvider.getScormStoredData(scormId, attempt, true, false, siteId)
                            .then(function (entries) {
                            // Check if there are elements to sync.
                            var hasDataToSend = false;
                            for (var i in entries) {
                                var entry = entries[i];
                                if (entry.element.indexOf('.') > -1) {
                                    hasDataToSend = true;
                                    break;
                                }
                            }
                            if (hasDataToSend) {
                                // There are elements to sync. We need to check if it's possible to sync them or not.
                                return _this.canRetrySync(scormId, attempt, lastOnline, siteId).catch(function () {
                                    // Cannot retry sync, we'll create a new offline attempt if possible.
                                    return _this.addToNewOrDelete(scormId, attempt, lastOffline, newAttemptsSameOrder, newAttemptsAtEnd, lastOfflineData.timecreated, lastOfflineData.incomplete, warnings, siteId);
                                });
                            }
                            else {
                                // Nothing to sync, delete the attempt.
                                return _this.scormOfflineProvider.deleteAttempt(scormId, attempt, siteId).catch(function () {
                                    // Maybe there's something wrong with the data or the storage implementation.
                                });
                            }
                        });
                    }
                    else {
                        // It's not a failed synchronization. Check if it's an attempt continued in offline.
                        return _this.scormOfflineProvider.getAttemptSnapshot(scormId, attempt, siteId).then(function (snapshot) {
                            if (snapshot && Object.keys(snapshot).length) {
                                // It has a snapshot, it means it continued an online attempt. We need to check if they've diverged.
                                // If it's the last attempt we don't need to ignore cache because we already did it.
                                var refresh = lastOnline != attempt;
                                return _this.scormProvider.getScormUserData(scormId, attempt, undefined, false, refresh, siteId)
                                    .then(function (data) {
                                    if (!_this.snapshotEquals(snapshot, data)) {
                                        // Snapshot has diverged, it will be converted into a new attempt if possible.
                                        return _this.addToNewOrDelete(scormId, attempt, lastOffline, newAttemptsSameOrder, newAttemptsAtEnd, lastOfflineData.timecreated, lastOfflineData.incomplete, warnings, siteId);
                                    }
                                });
                            }
                            else {
                                // No snapshot, it's a different attempt.
                                newAttemptsSameOrder.push(attempt);
                            }
                        });
                    }
                }));
            });
            return Promise.all(promises).then(function () {
                return _this.moveNewAttempts(scormId, newAttemptsSameOrder, lastOnline, lastCollision, offlineAttempts, siteId)
                    .then(function () {
                    // The new attempts that need to keep the order have been created.
                    // Now create the new attempts at the end of the list of offline attempts. It should only be 1 attempt max.
                    lastOffline = lastOffline + newAttemptsSameOrder.length;
                    return _this.createNewAttemptsAtEnd(scormId, newAttemptsAtEnd, lastOffline, siteId).then(function () {
                        return warnings;
                    });
                });
            });
        });
    };
    AddonModScormSyncProvider.AUTO_SYNCED = 'addon_mod_scorm_autom_synced';
    AddonModScormSyncProvider = AddonModScormSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_14__scorm__["a" /* AddonModScormProvider */], __WEBPACK_IMPORTED_MODULE_15__scorm_offline__["a" /* AddonModScormOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_16__prefetch_handler__["a" /* AddonModScormPrefetchHandler */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */], __WEBPACK_IMPORTED_MODULE_10__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_11__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModScormSyncProvider);
    return AddonModScormSyncProvider;
    var AddonModScormSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_13__core_course_classes_activity_sync__["a" /* CoreCourseActivitySyncBaseProvider */]));

//# sourceMappingURL=scorm-sync.js.map

/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModWikiOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service to handle offline wiki.
 */
var AddonModWikiOfflineProvider = /** @class */ (function () {
    function AddonModWikiOfflineProvider(logger, sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.siteSchema = {
            name: 'AddonModWikiOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModWikiOfflineProvider_1.NEW_PAGES_TABLE,
                    columns: [
                        {
                            name: 'wikiid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'subwikiid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'groupid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'title',
                            type: 'TEXT'
                        },
                        {
                            name: 'cachedcontent',
                            type: 'TEXT'
                        },
                        {
                            name: 'contentformat',
                            type: 'TEXT'
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        },
                        {
                            name: 'caneditpage',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['wikiid', 'subwikiid', 'userid', 'groupid', 'title']
                }
            ]
        };
        this.logger = logger.getInstance('AddonModWikiOfflineProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModWikiOfflineProvider_1 = AddonModWikiOfflineProvider;
    /**
     * Convert a value to a positive number. If not a number or less than 0, 0 will be returned.
     *
     * @param {any} value Value to convert.
     * @return {number} Converted value.
     */
    AddonModWikiOfflineProvider.prototype.convertToPositiveNumber = function (value) {
        value = parseInt(value, 10);
        return value > 0 ? value : 0;
    };
    /**
     * Delete a new page.
     *
     * @param {string} title Title of the page.
     * @param {number} [subwikiId] Subwiki ID. If not defined, wikiId, userId and groupId should be defined.
     * @param {number} [wikiId] Wiki ID. Optional, will be used create subwiki if not informed.
     * @param {number} [userId] User ID. Optional, will be used create subwiki if not informed.
     * @param {number} [groupId] Group ID. Optional, will be used create subwiki if not informed.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if deleted, rejected if failure.
     */
    AddonModWikiOfflineProvider.prototype.deleteNewPage = function (title, subwikiId, wikiId, userId, groupId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            subwikiId = _this.convertToPositiveNumber(subwikiId);
            wikiId = _this.convertToPositiveNumber(wikiId);
            userId = _this.convertToPositiveNumber(userId);
            groupId = _this.convertToPositiveNumber(groupId);
            return site.getDb().deleteRecords(AddonModWikiOfflineProvider_1.NEW_PAGES_TABLE, {
                subwikiid: subwikiId,
                wikiid: wikiId,
                userid: userId,
                groupid: groupId,
                title: title
            });
        });
    };
    /**
     * Get all the stored new pages from all the wikis.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with pages.
     */
    AddonModWikiOfflineProvider.prototype.getAllNewPages = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getAllRecords(AddonModWikiOfflineProvider_1.NEW_PAGES_TABLE);
        });
    };
    /**
     * Get a stored new page.
     *
     * @param {string} title Title of the page.
     * @param {number} [subwikiId] Subwiki ID. If not defined, wikiId, userId and groupId should be defined.
     * @param {number} [wikiId] Wiki ID. Optional, will be used create subwiki if not informed.
     * @param {number} [userId] User ID. Optional, will be used create subwiki if not informed.
     * @param {number} [groupId] Group ID. Optional, will be used create subwiki if not informed.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with page.
     */
    AddonModWikiOfflineProvider.prototype.getNewPage = function (title, subwikiId, wikiId, userId, groupId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            subwikiId = _this.convertToPositiveNumber(subwikiId);
            wikiId = _this.convertToPositiveNumber(wikiId);
            userId = _this.convertToPositiveNumber(userId);
            groupId = _this.convertToPositiveNumber(groupId);
            return site.getDb().getRecord(AddonModWikiOfflineProvider_1.NEW_PAGES_TABLE, {
                subwikiid: subwikiId,
                wikiid: wikiId,
                userid: userId,
                groupid: groupId,
                title: title
            });
        });
    };
    /**
     * Get all the stored new pages from a certain subwiki.
     *
     * @param {number} [subwikiId] Subwiki ID. If not defined, wikiId, userId and groupId should be defined.
     * @param {number} [wikiId] Wiki ID. Optional, will be used create subwiki if not informed.
     * @param {number} [userId] User ID. Optional, will be used create subwiki if not informed.
     * @param {number} [groupId] Group ID. Optional, will be used create subwiki if not informed.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with pages.
     */
    AddonModWikiOfflineProvider.prototype.getSubwikiNewPages = function (subwikiId, wikiId, userId, groupId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            subwikiId = _this.convertToPositiveNumber(subwikiId);
            wikiId = _this.convertToPositiveNumber(wikiId);
            userId = _this.convertToPositiveNumber(userId);
            groupId = _this.convertToPositiveNumber(groupId);
            return site.getDb().getRecords(AddonModWikiOfflineProvider_1.NEW_PAGES_TABLE, {
                subwikiid: subwikiId,
                wikiid: wikiId,
                userid: userId,
                groupid: groupId
            });
        });
    };
    /**
     * Get all the stored new pages from a list of subwikis.
     *
     * @param {any[]} subwikis List of subwiki.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with pages.
     */
    AddonModWikiOfflineProvider.prototype.getSubwikisNewPages = function (subwikis, siteId) {
        var _this = this;
        var promises = [];
        var pages = [];
        subwikis.forEach(function (subwiki) {
            promises.push(_this.getSubwikiNewPages(subwiki.id, subwiki.wikiid, subwiki.userid, subwiki.groupid, siteId)
                .then(function (subwikiPages) {
                pages = pages.concat(subwikiPages);
            }));
        });
        return Promise.all(promises).then(function () {
            return pages;
        });
    };
    /**
     * Save a new page to be sent later.
     *
     * @param {string} title Title of the page.
     * @param {string} content Content of the page.
     * @param {number} [subwikiId] Subwiki ID. If not defined, wikiId, userId and groupId should be defined.
     * @param {number} [wikiId] Wiki ID. Optional, will be used create subwiki if not informed.
     * @param {number} [userId] User ID. Optional, will be used create subwiki if not informed.
     * @param {number} [groupId] Group ID. Optional, will be used create subwiki if not informed.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if stored, rejected if failure.
     */
    AddonModWikiOfflineProvider.prototype.saveNewPage = function (title, content, subwikiId, wikiId, userId, groupId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var now = new Date().getTime(), entry = {
                title: title,
                cachedcontent: content,
                subwikiid: _this.convertToPositiveNumber(subwikiId),
                wikiid: _this.convertToPositiveNumber(wikiId),
                userid: _this.convertToPositiveNumber(userId),
                groupid: _this.convertToPositiveNumber(groupId),
                contentformat: 'html',
                timecreated: now,
                timemodified: now,
                caneditpage: 1
            };
            return site.getDb().insertRecord(AddonModWikiOfflineProvider_1.NEW_PAGES_TABLE, entry);
        });
    };
    /**
     * Check if a list of subwikis have offline data stored.
     *
     * @param {any[]} subwikis List of subwikis.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return{Promise<boolean>} Promise resolved with boolean: whether it has offline data.
     */
    AddonModWikiOfflineProvider.prototype.subwikisHaveOfflineData = function (subwikis, siteId) {
        return this.getSubwikisNewPages(subwikis, siteId).then(function (pages) {
            return !!pages.length;
        }).catch(function () {
            // Error, return false.
            return false;
        });
    };
    // Variables for database.
    AddonModWikiOfflineProvider.NEW_PAGES_TABLE = 'addon_mod_wiki_new_pages_store';
    AddonModWikiOfflineProvider = AddonModWikiOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonModWikiOfflineProvider);
    return AddonModWikiOfflineProvider;
    var AddonModWikiOfflineProvider_1;
}());

//# sourceMappingURL=wiki-offline.js.map

/***/ }),
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModWikiSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_groups__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__classes_base_sync__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__wiki__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__wiki_offline__ = __webpack_require__(273);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
















/**
 * Service to sync wikis.
 */
var AddonModWikiSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModWikiSyncProvider, _super);
    function AddonModWikiSyncProvider(loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, courseProvider, eventsProvider, wikiProvider, wikiOfflineProvider, utils, groupsProvider, timeUtils, logHelper) {
        var _this = _super.call(this, 'AddonModWikiSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils) || this;
        _this.eventsProvider = eventsProvider;
        _this.wikiProvider = wikiProvider;
        _this.wikiOfflineProvider = wikiOfflineProvider;
        _this.utils = utils;
        _this.groupsProvider = groupsProvider;
        _this.logHelper = logHelper;
        _this.componentTranslate = courseProvider.translateModuleName('wiki');
        return _this;
    }
    AddonModWikiSyncProvider_1 = AddonModWikiSyncProvider;
    /**
     * Get a string to identify a subwiki. If it doesn't have a subwiki ID it will be identified by wiki ID, user ID and group ID.
     *
     * @param {number} subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.
     * @param {number} [wikiId] Wiki ID. Optional, will be used to create the subwiki if subwiki ID not provided.
     * @param {number} [userId] User ID. Optional, will be used to create the subwiki if subwiki ID not provided.
     * @param {number} [groupId] Group ID. Optional, will be used to create the subwiki if subwiki ID not provided.
     * @return {string} Identifier.
     */
    AddonModWikiSyncProvider.prototype.getSubwikiBlockId = function (subwikiId, wikiId, userId, groupId) {
        subwikiId = this.wikiOfflineProvider.convertToPositiveNumber(subwikiId);
        if (subwikiId && subwikiId > 0) {
            return String(subwikiId);
        }
        wikiId = this.wikiOfflineProvider.convertToPositiveNumber(wikiId);
        if (wikiId) {
            userId = this.wikiOfflineProvider.convertToPositiveNumber(userId);
            groupId = this.wikiOfflineProvider.convertToPositiveNumber(groupId);
            return wikiId + ':' + userId + ':' + groupId;
        }
    };
    /**
     * Try to synchronize all the wikis in a certain site or in all sites.
     *
     * @param {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModWikiSyncProvider.prototype.syncAllWikis = function (siteId, force) {
        return this.syncOnSites('all wikis', this.syncAllWikisFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all wikis on a site.
     *
     * @param  {string} siteId Site ID to sync.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @param {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModWikiSyncProvider.prototype.syncAllWikisFunc = function (siteId, force) {
        var _this = this;
        // Get all the pages created in offline.
        return this.wikiOfflineProvider.getAllNewPages(siteId).then(function (pages) {
            var promises = [], subwikis = {};
            // Get subwikis to sync.
            pages.forEach(function (page) {
                var index = _this.getSubwikiBlockId(page.subwikiid, page.wikiid, page.userid, page.groupid);
                subwikis[index] = page;
            });
            var _loop_1 = function (id) {
                var subwiki = subwikis[id];
                var promise = force ? _this.syncSubwiki(subwiki.subwikiid, subwiki.wikiid, subwiki.userid, subwiki.groupid, siteId)
                    : _this.syncSubwikiIfNeeded(subwiki.subwikiid, subwiki.wikiid, subwiki.userid, subwiki.groupid, siteId);
                promises.push(promise.then(function (result) {
                    if (result && result.updated) {
                        // Sync successful, send event.
                        _this.eventsProvider.trigger(AddonModWikiSyncProvider_1.AUTO_SYNCED, {
                            siteId: siteId,
                            subwikiId: subwiki.subwikiid,
                            wikiId: subwiki.wikiid,
                            userId: subwiki.userid,
                            groupId: subwiki.groupid,
                            created: result.created,
                            discarded: result.discarded,
                            warnings: result.warnings
                        });
                    }
                }));
            };
            // Sync all subwikis.
            for (var id in subwikis) {
                _loop_1(id);
            }
            return Promise.all(promises);
        });
    };
    /**
     * Sync a subwiki only if a certain time has passed since the last time.
     *
     * @param {number} subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.
     * @param {number} [wikiId] Wiki ID. Optional, will be used to create the subwiki if subwiki ID not provided.
     * @param {number} [userId] User ID. Optional, will be used to create the subwiki if subwiki ID not provided.
     * @param {number} [groupId] Group ID. Optional, will be used to create the subwiki if subwiki ID not provided.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void|AddonModWikiSyncSubwikiResult>} Promise resolved when subwiki is synced or doesn't need to be synced.
     */
    AddonModWikiSyncProvider.prototype.syncSubwikiIfNeeded = function (subwikiId, wikiId, userId, groupId, siteId) {
        var _this = this;
        var blockId = this.getSubwikiBlockId(subwikiId, wikiId, userId, groupId);
        return this.isSyncNeeded(blockId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncSubwiki(subwikiId, wikiId, userId, groupId, siteId);
            }
        });
    };
    /**
     * Synchronize a subwiki.
     *
     * @param {number} subwikiId Subwiki ID. If not defined, wikiId, userId and groupId should be defined.
     * @param {number} [wikiId] Wiki ID. Optional, will be used to create the subwiki if subwiki ID not provided.
     * @param {number} [userId] User ID. Optional, will be used to create the subwiki if subwiki ID not provided.
     * @param {number} [groupId] Group ID. Optional, will be used to create the subwiki if subwiki ID not provided.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<AddonModWikiSyncSubwikiResult>} Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModWikiSyncProvider.prototype.syncSubwiki = function (subwikiId, wikiId, userId, groupId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var result = {
            warnings: [],
            updated: false,
            created: [],
            discarded: []
        }, subwikiBlockId = this.getSubwikiBlockId(subwikiId, wikiId, userId, groupId);
        if (this.isSyncing(subwikiBlockId, siteId)) {
            // There's already a sync ongoing for this subwiki, return the promise.
            return this.getOngoingSync(subwikiBlockId, siteId);
        }
        // Verify that subwiki isn't blocked.
        if (this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_14__wiki__["a" /* AddonModWikiProvider */].COMPONENT, subwikiBlockId, siteId)) {
            this.logger.debug('Cannot sync subwiki ' + subwikiBlockId + ' because it is blocked.');
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        this.logger.debug('Try to sync subwiki ' + subwikiBlockId);
        // Get offline responses to be sent.
        var syncPromise = this.wikiOfflineProvider.getSubwikiNewPages(subwikiId, wikiId, userId, groupId, siteId).catch(function () {
            // No offline data found, return empty array.
            return [];
        }).then(function (pages) {
            if (!pages || !pages.length) {
                // Nothing to sync.
                return;
            }
            else if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(_this.translate.instant('core.networkerrormsg'));
            }
            var promises = [];
            // Send the pages.
            pages.forEach(function (page) {
                promises.push(_this.wikiProvider.newPageOnline(page.title, page.cachedcontent, subwikiId, wikiId, userId, groupId, siteId).then(function (pageId) {
                    result.updated = true;
                    // Add page to created pages array.
                    result.created.push({
                        pageId: pageId,
                        title: page.title
                    });
                    // Delete the local page.
                    return _this.wikiOfflineProvider.deleteNewPage(page.title, subwikiId, wikiId, userId, groupId, siteId);
                }).catch(function (error) {
                    if (_this.utils.isWebServiceError(error)) {
                        // The WebService has thrown an error, this means that the page cannot be submitted. Delete it.
                        return _this.wikiOfflineProvider.deleteNewPage(page.title, subwikiId, wikiId, userId, groupId, siteId)
                            .then(function () {
                            result.updated = true;
                            // Page deleted, add the page to discarded pages and add a warning.
                            var warning = _this.translate.instant('core.warningofflinedatadeleted', {
                                component: _this.translate.instant('addon.mod_wiki.wikipage'),
                                name: page.title,
                                error: _this.textUtils.getErrorMessageFromError(error)
                            });
                            result.discarded.push({
                                title: page.title,
                                warning: warning
                            });
                            result.warnings.push(warning);
                        });
                    }
                    else {
                        // Couldn't connect to server, reject.
                        return Promise.reject(error);
                    }
                }));
            });
            return Promise.all(promises);
        }).then(function () {
            // Sync finished, set sync time.
            return _this.setSyncTime(subwikiBlockId, siteId).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            // All done, return the warnings.
            return result;
        });
        return this.addOngoingSync(subwikiBlockId, syncPromise, siteId);
    };
    /**
     * Tries to synchronize a wiki.
     *
     * @param {number} wikiId Wiki ID.
     * @param {number} [courseId] Course ID.
     * @param {number} [cmId] Wiki course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<AddonModWikiSyncWikiResult>} Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModWikiSyncProvider.prototype.syncWiki = function (wikiId, courseId, cmId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Sync offline logs.
        return this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_14__wiki__["a" /* AddonModWikiProvider */].COMPONENT, wikiId, siteId).catch(function () {
            // Ignore errors.
        }).then(function () {
            // Sync is done at subwiki level, get all the subwikis.
            return _this.wikiProvider.getSubwikis(wikiId);
        }).then(function (subwikis) {
            var promises = [], result = {
                warnings: [],
                updated: false,
                subwikis: {},
                siteId: siteId
            };
            subwikis.forEach(function (subwiki) {
                promises.push(_this.syncSubwiki(subwiki.id, subwiki.wikiid, subwiki.userid, subwiki.groupid, siteId).then(function (data) {
                    if (data && data.updated) {
                        result.warnings = result.warnings.concat(data.warnings);
                        result.updated = true;
                        result.subwikis[subwiki.id] = {
                            created: data.created,
                            discarded: data.discarded
                        };
                    }
                }));
            });
            return Promise.all(promises).then(function () {
                var promises = [];
                if (result.updated) {
                    // Something has changed, invalidate data.
                    if (wikiId) {
                        promises.push(_this.wikiProvider.invalidateSubwikis(wikiId));
                        promises.push(_this.wikiProvider.invalidateSubwikiPages(wikiId));
                        promises.push(_this.wikiProvider.invalidateSubwikiFiles(wikiId));
                    }
                    if (courseId) {
                        promises.push(_this.wikiProvider.invalidateWikiData(courseId));
                    }
                    if (cmId) {
                        promises.push(_this.groupsProvider.invalidateActivityAllowedGroups(cmId));
                        promises.push(_this.groupsProvider.invalidateActivityGroupMode(cmId));
                    }
                }
                return Promise.all(promises).catch(function () {
                    // Ignore errors.
                }).then(function () {
                    return result;
                });
            });
        });
    };
    AddonModWikiSyncProvider.AUTO_SYNCED = 'addon_mod_wiki_autom_synced';
    AddonModWikiSyncProvider.MANUAL_SYNCED = 'addon_mod_wiki_manual_synced';
    AddonModWikiSyncProvider = AddonModWikiSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_14__wiki__["a" /* AddonModWikiProvider */], __WEBPACK_IMPORTED_MODULE_15__wiki_offline__["a" /* AddonModWikiOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_groups__["a" /* CoreGroupsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModWikiSyncProvider);
    return AddonModWikiSyncProvider;
    var AddonModWikiSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_13__classes_base_sync__["a" /* CoreSyncBaseProvider */]));

//# sourceMappingURL=wiki-sync.js.map

/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModWorkshopSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_base_sync__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__workshop__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__helper__ = __webpack_require__(192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__offline__ = __webpack_require__(175);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
















/**
 * Service to sync workshops.
 */
var AddonModWorkshopSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModWorkshopSyncProvider, _super);
    function AddonModWorkshopSyncProvider(translate, appProvider, courseProvider, eventsProvider, loggerProvider, sitesProvider, syncProvider, textUtils, timeUtils, utils, workshopProvider, workshopHelper, workshopOffline, logHelper) {
        var _this = _super.call(this, 'AddonModWorkshopSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils) || this;
        _this.eventsProvider = eventsProvider;
        _this.utils = utils;
        _this.workshopProvider = workshopProvider;
        _this.workshopHelper = workshopHelper;
        _this.workshopOffline = workshopOffline;
        _this.logHelper = logHelper;
        _this.componentTranslate = courseProvider.translateModuleName('workshop');
        return _this;
    }
    AddonModWorkshopSyncProvider_1 = AddonModWorkshopSyncProvider;
    /**
     * Check if an workshop has data to synchronize.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved with boolean: true if has data to sync, false otherwise.
     */
    AddonModWorkshopSyncProvider.prototype.hasDataToSync = function (workshopId, siteId) {
        return this.workshopOffline.hasWorkshopOfflineData(workshopId, siteId);
    };
    /**
     * Try to synchronize all workshops that need it and haven't been synchronized in a while.
     *
     * @param  {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @return {Promise<any>}    Promise resolved when the sync is done.
     */
    AddonModWorkshopSyncProvider.prototype.syncAllWorkshops = function (siteId, force) {
        return this.syncOnSites('all workshops', this.syncAllWorkshopsFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all workshops on a site.
     *
     * @param  {string} siteId Site ID to sync.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModWorkshopSyncProvider.prototype.syncAllWorkshopsFunc = function (siteId, force) {
        var _this = this;
        return this.workshopOffline.getAllWorkshops(siteId).then(function (workshopIds) {
            // Sync all workshops that haven't been synced for a while.
            var promises = workshopIds.map(function (workshopId) {
                var promise = force ? _this.syncWorkshop(workshopId, siteId) : _this.syncWorkshopIfNeeded(workshopId, siteId);
                return promise.then(function (data) {
                    if (data && data.updated) {
                        // Sync done. Send event.
                        _this.eventsProvider.trigger(AddonModWorkshopSyncProvider_1.AUTO_SYNCED, {
                            workshopId: workshopId,
                            warnings: data.warnings
                        }, siteId);
                    }
                });
            });
            return Promise.all(promises);
        });
    };
    /**
     * Sync a workshop only if a certain time has passed since the last time.
     *
     * @param  {number} workshopId Workshop ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when the workshop is synced or if it doesn't need to be synced.
     */
    AddonModWorkshopSyncProvider.prototype.syncWorkshopIfNeeded = function (workshopId, siteId) {
        var _this = this;
        return this.isSyncNeeded(workshopId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncWorkshop(workshopId, siteId);
            }
        });
    };
    /**
     * Try to synchronize a workshop.
     *
     * @param  {number} workshopId  Workshop ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}       Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModWorkshopSyncProvider.prototype.syncWorkshop = function (workshopId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.isSyncing(workshopId, siteId)) {
            // There's already a sync ongoing for this discussion, return the promise.
            return this.getOngoingSync(workshopId, siteId);
        }
        // Verify that workshop isn't blocked.
        if (this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_13__workshop__["a" /* AddonModWorkshopProvider */].COMPONENT, workshopId, siteId)) {
            this.logger.debug('Cannot sync workshop ' + workshopId + ' because it is blocked.');
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        this.logger.debug('Try to sync workshop ' + workshopId);
        var syncPromises = [];
        // Get offline submissions to be sent.
        syncPromises.push(this.workshopOffline.getSubmissions(workshopId, siteId).catch(function () {
            // No offline data found, return empty array.
            return [];
        }));
        // Get offline submission assessments to be sent.
        syncPromises.push(this.workshopOffline.getAssessments(workshopId, siteId).catch(function () {
            // No offline data found, return empty array.
            return [];
        }));
        // Get offline submission evaluations to be sent.
        syncPromises.push(this.workshopOffline.getEvaluateSubmissions(workshopId, siteId).catch(function () {
            // No offline data found, return empty array.
            return [];
        }));
        // Get offline assessment evaluations to be sent.
        syncPromises.push(this.workshopOffline.getEvaluateAssessments(workshopId, siteId).catch(function () {
            // No offline data found, return empty array.
            return [];
        }));
        // Sync offline logs.
        syncPromises.push(this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_13__workshop__["a" /* AddonModWorkshopProvider */].COMPONENT, workshopId, siteId));
        var result = {
            warnings: [],
            updated: false
        };
        // Get offline submissions to be sent.
        var syncPromise = Promise.all(syncPromises).then(function (syncs) {
            var courseId;
            // Get courseId from the first object
            for (var x in syncs) {
                if (syncs[x].length > 0 && syncs[x][0].courseid) {
                    courseId = syncs[x][0].courseid;
                    break;
                }
            }
            if (!courseId) {
                // Nothing to sync.
                return;
            }
            else if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(null);
            }
            return _this.workshopProvider.getWorkshopById(courseId, workshopId, siteId).then(function (workshop) {
                var submissionsActions = syncs[0], assessments = syncs[1], submissionEvaluations = syncs[2], assessmentEvaluations = syncs[3], promises = [], offlineSubmissions = {};
                submissionsActions.forEach(function (action) {
                    if (typeof offlineSubmissions[action.submissionid] == 'undefined') {
                        offlineSubmissions[action.submissionid] = [];
                    }
                    offlineSubmissions[action.submissionid].push(action);
                });
                Object.keys(offlineSubmissions).forEach(function (submissionId) {
                    var submissionActions = offlineSubmissions[submissionId];
                    promises.push(_this.syncSubmission(workshop, submissionActions, result, siteId).then(function () {
                        result.updated = true;
                    }));
                });
                assessments.forEach(function (assessment) {
                    promises.push(_this.syncAssessment(workshop, assessment, result, siteId).then(function () {
                        result.updated = true;
                    }));
                });
                submissionEvaluations.forEach(function (evaluation) {
                    promises.push(_this.syncEvaluateSubmission(workshop, evaluation, result, siteId).then(function () {
                        result.updated = true;
                    }));
                });
                assessmentEvaluations.forEach(function (evaluation) {
                    promises.push(_this.syncEvaluateAssessment(workshop, evaluation, result, siteId).then(function () {
                        result.updated = true;
                    }));
                });
                return Promise.all(promises);
            }).then(function () {
                if (result.updated) {
                    // Data has been sent to server. Now invalidate the WS calls.
                    return _this.workshopProvider.invalidateContentById(workshopId, courseId, siteId).catch(function () {
                        // Ignore errors.
                    });
                }
            });
        }).then(function () {
            // Sync finished, set sync time.
            return _this.setSyncTime(workshopId, siteId).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            // All done, return the warnings.
            return result;
        });
        return this.addOngoingSync(workshopId, syncPromise, siteId);
    };
    /**
     * Synchronize a submission.
     *
     * @param  {any}    workshop          Workshop.
     * @param  {any[]}  submissionActions Submission actions offline data.
     * @param  {any}    result            Object with the result of the sync.
     * @param  {string} siteId            Site ID.
     * @return {Promise<any>}             Promise resolved if success, rejected otherwise.
     */
    AddonModWorkshopSyncProvider.prototype.syncSubmission = function (workshop, submissionActions, result, siteId) {
        var _this = this;
        var discardError;
        var editing = false;
        // Sort entries by timemodified.
        submissionActions = submissionActions.sort(function (a, b) {
            return a.timemodified - b.timemodified;
        });
        var timePromise = null;
        var submissionId = submissionActions[0].submissionid;
        if (submissionId > 0) {
            editing = true;
            timePromise = this.workshopProvider.getSubmission(workshop.id, submissionId, siteId).then(function (submission) {
                return submission.timemodified;
            }).catch(function () {
                return -1;
            });
        }
        else {
            timePromise = Promise.resolve(0);
        }
        return timePromise.then(function (timemodified) {
            if (timemodified < 0 || timemodified >= submissionActions[0].timemodified) {
                // The entry was not found in Moodle or the entry has been modified, discard the action.
                result.updated = true;
                discardError = _this.translate.instant('addon.mod_workshop.warningsubmissionmodified');
                return _this.workshopOffline.deleteAllSubmissionActions(workshop.id, submissionId, siteId);
            }
            var promise = Promise.resolve();
            submissionActions.forEach(function (action) {
                promise = promise.then(function () {
                    submissionId = action.submissionid > 0 ? action.submissionid : submissionId;
                    var fileProm;
                    // Upload attachments first if any.
                    if (action.attachmentsid) {
                        fileProm = _this.workshopHelper.getSubmissionFilesFromOfflineFilesObject(action.attachmentsid, workshop.id, submissionId, editing, siteId).then(function (files) {
                            return _this.workshopHelper.uploadOrStoreSubmissionFiles(workshop.id, submissionId, files, editing, false, siteId);
                        });
                    }
                    else {
                        // Remove all files.
                        fileProm = _this.workshopHelper.uploadOrStoreSubmissionFiles(workshop.id, submissionId, [], editing, false, siteId);
                    }
                    return fileProm.then(function (attachmentsId) {
                        if (workshop.submissiontypefile == __WEBPACK_IMPORTED_MODULE_13__workshop__["a" /* AddonModWorkshopProvider */].SUBMISSION_TYPE_DISABLED) {
                            attachmentsId = null;
                        }
                        // Perform the action.
                        switch (action.action) {
                            case 'add':
                                return _this.workshopProvider.addSubmissionOnline(workshop.id, action.title, action.content, attachmentsId, siteId).then(function (newSubmissionId) {
                                    submissionId = newSubmissionId;
                                });
                            case 'update':
                                return _this.workshopProvider.updateSubmissionOnline(submissionId, action.title, action.content, attachmentsId, siteId);
                            case 'delete':
                                return _this.workshopProvider.deleteSubmissionOnline(submissionId, siteId);
                            default:
                                return Promise.resolve();
                        }
                    }).catch(function (error) {
                        if (error && _this.utils.isWebServiceError(error)) {
                            // The WebService has thrown an error, this means it cannot be performed. Discard.
                            discardError = _this.textUtils.getErrorMessageFromError(error);
                        }
                        else {
                            // Couldn't connect to server, reject.
                            return Promise.reject(error);
                        }
                    }).then(function () {
                        // Delete the offline data.
                        result.updated = true;
                        return _this.workshopOffline.deleteSubmissionAction(action.workshopid, action.submissionid, action.action, siteId).then(function () {
                            // Delete stored files.
                            if (action.action == 'add' || action.action == 'update') {
                                var editing_1 = action.action == 'update';
                                return _this.workshopHelper.deleteSubmissionStoredFiles(action.workshopid, action.submissionid, editing_1, siteId);
                            }
                        });
                    });
                });
            });
            return promise.then(function () {
                if (discardError) {
                    // Submission was discarded, add a warning.
                    var message = _this.translate.instant('core.warningofflinedatadeleted', {
                        component: _this.componentTranslate,
                        name: workshop.name,
                        error: discardError
                    });
                    if (result.warnings.indexOf(message) == -1) {
                        result.warnings.push(message);
                    }
                }
            });
        });
    };
    /**
     * Synchronize an assessment.
     *
     * @param  {any}    workshop   Workshop.
     * @param  {any}    assessment Assessment offline data.
     * @param  {any}    result     Object with the result of the sync.
     * @param  {string} siteId     Site ID.
     * @return {Promise<any>}      Promise resolved if success, rejected otherwise.
     */
    AddonModWorkshopSyncProvider.prototype.syncAssessment = function (workshop, assessmentData, result, siteId) {
        var _this = this;
        var discardError;
        var assessmentId = assessmentData.assessmentid;
        var timePromise = this.workshopProvider.getAssessment(workshop.id, assessmentId, siteId).then(function (assessment) {
            return assessment.timemodified;
        }).catch(function () {
            return -1;
        });
        return timePromise.then(function (timemodified) {
            if (timemodified < 0 || timemodified >= assessmentData.timemodified) {
                // The entry was not found in Moodle or the entry has been modified, discard the action.
                result.updated = true;
                discardError = _this.translate.instant('addon.mod_workshop.warningassessmentmodified');
                return _this.workshopOffline.deleteAssessment(workshop.id, assessmentId, siteId);
            }
            var fileProm;
            var inputData = assessmentData.inputdata;
            // Upload attachments first if any.
            if (inputData.feedbackauthorattachmentsid) {
                fileProm = _this.workshopHelper.getAssessmentFilesFromOfflineFilesObject(inputData.feedbackauthorattachmentsid, workshop.id, assessmentId, siteId).then(function (files) {
                    return _this.workshopHelper.uploadOrStoreAssessmentFiles(workshop.id, assessmentId, files, false, siteId);
                });
            }
            else {
                // Remove all files.
                fileProm = _this.workshopHelper.uploadOrStoreAssessmentFiles(workshop.id, assessmentId, [], false, siteId);
            }
            return fileProm.then(function (attachmentsId) {
                inputData.feedbackauthorattachmentsid = attachmentsId || 0;
                return _this.workshopProvider.updateAssessmentOnline(assessmentId, inputData, siteId);
            }).catch(function (error) {
                if (error && _this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means it cannot be performed. Discard.
                    discardError = _this.textUtils.getErrorMessageFromError(error);
                }
                else {
                    // Couldn't connect to server, reject.
                    return Promise.reject(error);
                }
            }).then(function () {
                // Delete the offline data.
                result.updated = true;
                return _this.workshopOffline.deleteAssessment(workshop.id, assessmentId, siteId).then(function () {
                    _this.workshopHelper.deleteAssessmentStoredFiles(workshop.id, assessmentId, siteId);
                });
            });
        }).then(function () {
            if (discardError) {
                // Assessment was discarded, add a warning.
                var message = _this.translate.instant('core.warningofflinedatadeleted', {
                    component: _this.componentTranslate,
                    name: workshop.name,
                    error: discardError
                });
                if (result.warnings.indexOf(message) == -1) {
                    result.warnings.push(message);
                }
            }
        });
    };
    /**
     * Synchronize a submission evaluation.
     *
     * @param  {any}    workshop Workshop.
     * @param  {any}    evaluate Submission evaluation offline data.
     * @param  {any}    result   Object with the result of the sync.
     * @param  {string} siteId   Site ID.
     * @return {Promise<any>}    Promise resolved if success, rejected otherwise.
     */
    AddonModWorkshopSyncProvider.prototype.syncEvaluateSubmission = function (workshop, evaluate, result, siteId) {
        var _this = this;
        var discardError;
        var submissionId = evaluate.submissionid;
        var timePromise = this.workshopProvider.getSubmission(workshop.id, submissionId, siteId).then(function (submission) {
            return submission.timemodified;
        }).catch(function () {
            return -1;
        });
        return timePromise.then(function (timemodified) {
            if (timemodified < 0 || timemodified >= evaluate.timemodified) {
                // The entry was not found in Moodle or the entry has been modified, discard the action.
                result.updated = true;
                discardError = _this.translate.instant('addon.mod_workshop.warningsubmissionmodified');
                return _this.workshopOffline.deleteEvaluateSubmission(workshop.id, submissionId, siteId);
            }
            return _this.workshopProvider.evaluateSubmissionOnline(submissionId, evaluate.feedbacktext, evaluate.published, evaluate.gradeover, siteId).catch(function (error) {
                if (error && _this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means it cannot be performed. Discard.
                    discardError = _this.textUtils.getErrorMessageFromError(error);
                }
                else {
                    // Couldn't connect to server, reject.
                    return Promise.reject(error);
                }
            }).then(function () {
                // Delete the offline data.
                result.updated = true;
                return _this.workshopOffline.deleteEvaluateSubmission(workshop.id, submissionId, siteId);
            });
        }).then(function () {
            if (discardError) {
                // Assessment was discarded, add a warning.
                var message = _this.translate.instant('core.warningofflinedatadeleted', {
                    component: _this.componentTranslate,
                    name: workshop.name,
                    error: discardError
                });
                if (result.warnings.indexOf(message) == -1) {
                    result.warnings.push(message);
                }
            }
        });
    };
    /**
     * Synchronize a assessment evaluation.
     *
     * @param  {any}    workshop Workshop.
     * @param  {any}    evaluate Assessment evaluation offline data.
     * @param  {any}    result   Object with the result of the sync.
     * @param  {string} siteId   Site ID.
     * @return {Promise<any>}    Promise resolved if success, rejected otherwise.
     */
    AddonModWorkshopSyncProvider.prototype.syncEvaluateAssessment = function (workshop, evaluate, result, siteId) {
        var _this = this;
        var discardError;
        var assessmentId = evaluate.assessmentid;
        var timePromise = this.workshopProvider.getAssessment(workshop.id, assessmentId, siteId).then(function (assessment) {
            return assessment.timemodified;
        }).catch(function () {
            return -1;
        });
        return timePromise.then(function (timemodified) {
            if (timemodified < 0 || timemodified >= evaluate.timemodified) {
                // The entry was not found in Moodle or the entry has been modified, discard the action.
                result.updated = true;
                discardError = _this.translate.instant('addon.mod_workshop.warningassessmentmodified');
                return _this.workshopOffline.deleteEvaluateAssessment(workshop.id, assessmentId, siteId);
            }
            return _this.workshopProvider.evaluateAssessmentOnline(assessmentId, evaluate.feedbacktext, evaluate.weight, evaluate.gradinggradeover, siteId).catch(function (error) {
                if (error && _this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means it cannot be performed. Discard.
                    discardError = _this.textUtils.getErrorMessageFromError(error);
                }
                else {
                    // Couldn't connect to server, reject.
                    return Promise.reject(error);
                }
            }).then(function () {
                // Delete the offline data.
                result.updated = true;
                return _this.workshopOffline.deleteEvaluateAssessment(workshop.id, assessmentId, siteId);
            });
        }).then(function () {
            if (discardError) {
                // Assessment was discarded, add a warning.
                var message = _this.translate.instant('core.warningofflinedatadeleted', {
                    component: _this.componentTranslate,
                    name: workshop.name,
                    error: discardError
                });
                if (result.warnings.indexOf(message) == -1) {
                    result.warnings.push(message);
                }
            }
        });
    };
    AddonModWorkshopSyncProvider.AUTO_SYNCED = 'addon_mod_workshop_autom_synced';
    AddonModWorkshopSyncProvider.MANUAL_SYNCED = 'addon_mod_workshop_manual_synced';
    AddonModWorkshopSyncProvider = AddonModWorkshopSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_sync__["a" /* CoreSyncProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_13__workshop__["a" /* AddonModWorkshopProvider */],
            __WEBPACK_IMPORTED_MODULE_14__helper__["a" /* AddonModWorkshopHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_15__offline__["a" /* AddonModWorkshopOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModWorkshopSyncProvider);
    return AddonModWorkshopSyncProvider;
    var AddonModWorkshopSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_2__classes_base_sync__["a" /* CoreSyncBaseProvider */]));

//# sourceMappingURL=sync.js.map

/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFabDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Directive to move ion-fab components as direct children of the nearest ion-content.
 *
 * Example usage:
 *
 * <ion-fab core-fab>
 */
var CoreFabDirective = /** @class */ (function () {
    function CoreFabDirective(el, content) {
        this.content = content;
        this.element = el.nativeElement;
    }
    /**
     * Initialize Component.
     */
    CoreFabDirective.prototype.ngOnInit = function () {
        if (this.content) {
            this.content.getNativeElement().classList.add('has-fab');
            this.content.getFixedElement().appendChild(this.element);
        }
    };
    /**
     * Destroy component.
     */
    CoreFabDirective.prototype.ngOnDestroy = function () {
        if (this.content) {
            this.content.getNativeElement().classList.remove('has-fab');
        }
    };
    CoreFabDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: 'ion-fab[core-fab]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["f" /* Content */]])
    ], CoreFabDirective);
    return CoreFabDirective;
}());

//# sourceMappingURL=fab.js.map

/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModDataOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_fileuploader_providers_fileuploader__ = __webpack_require__(67);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Service to handle Offline data.
 */
var AddonModDataOfflineProvider = /** @class */ (function () {
    function AddonModDataOfflineProvider(logger, sitesProvider, textUtils, fileProvider, fileUploaderProvider, utils) {
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.fileUploaderProvider = fileUploaderProvider;
        this.utils = utils;
        this.siteSchema = {
            name: 'AddonModDataOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModDataOfflineProvider_1.DATA_ENTRY_TABLE,
                    columns: [
                        {
                            name: 'dataid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'groupid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'action',
                            type: 'TEXT'
                        },
                        {
                            name: 'entryid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'fields',
                            type: 'TEXT'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['dataid', 'entryid', 'action']
                }
            ],
            migrate: function (db, oldVersion, siteId) {
                if (oldVersion == 0) {
                    // Move the records from the old table.
                    var newTable_1 = AddonModDataOfflineProvider_1.DATA_ENTRY_TABLE;
                    var oldTable_1 = 'addon_mod_data_entry';
                    return db.tableExists(oldTable_1).then(function () {
                        return db.insertRecordsFrom(newTable_1, oldTable_1).then(function () {
                            return db.dropTable(oldTable_1);
                        });
                    }).catch(function () {
                        // Old table does not exist, ignore.
                    });
                }
            }
        };
        this.logger = logger.getInstance('AddonModDataOfflineProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModDataOfflineProvider_1 = AddonModDataOfflineProvider;
    /**
     * Delete all the actions of an entry.
     *
     * @param  {number} dataId   Database ID.
     * @param  {number} entryId  Database entry ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved if deleted, rejected if failure.
     */
    AddonModDataOfflineProvider.prototype.deleteAllEntryActions = function (dataId, entryId, siteId) {
        var _this = this;
        return this.getEntryActions(dataId, entryId, siteId).then(function (actions) {
            var promises = [];
            actions.forEach(function (action) {
                promises.push(_this.deleteEntry(dataId, entryId, action.action, siteId));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Delete an stored entry.
     *
     * @param  {number} dataId       Database ID.
     * @param  {number} entryId      Database entry Id.
     * @param  {string} action       Action to be done
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}             Promise resolved if deleted, rejected if failure.
     */
    AddonModDataOfflineProvider.prototype.deleteEntry = function (dataId, entryId, action, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.deleteEntryFiles(dataId, entryId, action, site.id).then(function () {
                return site.getDb().deleteRecords(AddonModDataOfflineProvider_1.DATA_ENTRY_TABLE, { dataid: dataId, entryid: entryId,
                    action: action });
            });
        });
    };
    /**
     * Delete entry offline files.
     *
     * @param  {number} dataId Database ID.
     * @param  {number} entryId Database entry ID.
     * @param  {string} action Action to be done.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if deleted, rejected if failure.
     */
    AddonModDataOfflineProvider.prototype.deleteEntryFiles = function (dataId, entryId, action, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.getEntry(dataId, entryId, action, site.id).then(function (entry) {
                if (!entry.fields) {
                    return;
                }
                var promises = [];
                entry.fields.forEach(function (field) {
                    var value = _this.textUtils.parseJSON(field.value);
                    if (!value.offline) {
                        return;
                    }
                    var promise = _this.getEntryFieldFolder(dataId, entryId, field.fieldid, site.id).then(function (folderPath) {
                        return _this.fileUploaderProvider.getStoredFiles(folderPath);
                    }).then(function (files) {
                        return _this.fileUploaderProvider.clearTmpFiles(files);
                    }).catch(function () {
                        // Files not found, ignore.
                    });
                    promises.push(promise);
                });
                return Promise.all(promises);
            }).catch(function () {
                // Entry not found, ignore.
            });
        });
    };
    /**
     * Get all the stored entry data from all the databases.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<AddonModDataOfflineAction[]>} Promise resolved with entries.
     */
    AddonModDataOfflineProvider.prototype.getAllEntries = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getAllRecords(AddonModDataOfflineProvider_1.DATA_ENTRY_TABLE);
        }).then(function (entries) {
            return entries.map(_this.parseRecord.bind(_this));
        });
    };
    /**
     * Get all the stored entry actions from a certain database, sorted by modification time.
     *
     * @param  {number} dataId Database ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<AddonModDataOfflineAction[]>} Promise resolved with entries.
     */
    AddonModDataOfflineProvider.prototype.getDatabaseEntries = function (dataId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModDataOfflineProvider_1.DATA_ENTRY_TABLE, { dataid: dataId }, 'timemodified');
        }).then(function (entries) {
            return entries.map(_this.parseRecord.bind(_this));
        });
    };
    /**
     * Get an stored entry data.
     *
     * @param  {number} dataId      Database ID.
     * @param  {number} entryId     Database entry Id.
     * @param  {string} action      Action to be done
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<AddonModDataOfflineAction>} Promise resolved with entry.
     */
    AddonModDataOfflineProvider.prototype.getEntry = function (dataId, entryId, action, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(AddonModDataOfflineProvider_1.DATA_ENTRY_TABLE, { dataid: dataId, entryid: entryId,
                action: action });
        }).then(function (entry) {
            return _this.parseRecord(entry);
        });
    };
    /**
     * Get an all stored entry actions data.
     *
     * @param  {number} dataId      Database ID.
     * @param  {number} entryId     Database entry Id.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<AddonModDataOfflineAction[]>} Promise resolved with entry actions.
     */
    AddonModDataOfflineProvider.prototype.getEntryActions = function (dataId, entryId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModDataOfflineProvider_1.DATA_ENTRY_TABLE, { dataid: dataId, entryid: entryId });
        }).then(function (entries) {
            return entries.map(_this.parseRecord.bind(_this));
        });
    };
    /**
     * Check if there are offline entries to send.
     *
     * @param  {number} dataId    Database ID.
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>}          Promise resolved with boolean: true if has offline answers, false otherwise.
     */
    AddonModDataOfflineProvider.prototype.hasOfflineData = function (dataId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.utils.promiseWorks(site.getDb().recordExists(AddonModDataOfflineProvider_1.DATA_ENTRY_TABLE, { dataid: dataId }));
        });
    };
    /**
     * Get the path to the folder where to store files for offline files in a database.
     *
     * @param  {number} dataId      Database ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<string>}    Promise resolved with the path.
     */
    AddonModDataOfflineProvider.prototype.getDatabaseFolder = function (dataId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var siteFolderPath = _this.fileProvider.getSiteFolder(site.getId()), folderPath = 'offlinedatabase/' + dataId;
            return _this.textUtils.concatenatePaths(siteFolderPath, folderPath);
        });
    };
    /**
     * Get the path to the folder where to store files for a new offline entry.
     *
     * @param  {number} dataId      Database ID.
     * @param  {number} entryId     The ID of the entry.
     * @param  {number} fieldId     Field ID.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<string>}    Promise resolved with the path.
     */
    AddonModDataOfflineProvider.prototype.getEntryFieldFolder = function (dataId, entryId, fieldId, siteId) {
        var _this = this;
        return this.getDatabaseFolder(dataId, siteId).then(function (folderPath) {
            return _this.textUtils.concatenatePaths(folderPath, entryId + '_' + fieldId);
        });
    };
    /**
     * Parse "fields" of an offline record.
     *
     * @param {any} record Record object
     * @return {AddonModDataOfflineAction} Record object with columns parsed.
     */
    AddonModDataOfflineProvider.prototype.parseRecord = function (record) {
        record.fields = this.textUtils.parseJSON(record.fields);
        return record;
    };
    /**
     * Save an entry data to be sent later.
     *
     * @param  {number} dataId          Database ID.
     * @param  {number} entryId         Database entry Id. If action is add entryId should be 0 and -timemodified will be used.
     * @param  {string} action          Action to be done to the entry: [add, edit, delete, approve, disapprove]
     * @param  {number} courseId        Course ID of the database.
     * @param  {number} [groupId]       Group ID. Only provided when adding.
     * @param  {any[]}  [fields]        Array of field data of the entry if needed.
     * @param  {number} [timemodified]  The time the entry was modified. If not defined, current time.
     * @param  {string} [siteId]        Site ID. If not defined, current site.
     * @return {Promise<any>}           Promise resolved if stored, rejected if failure.
     */
    AddonModDataOfflineProvider.prototype.saveEntry = function (dataId, entryId, action, courseId, groupId, fields, timemodified, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            timemodified = timemodified || new Date().getTime();
            entryId = typeof entryId == 'undefined' || entryId === null ? -timemodified : entryId;
            var entry = {
                dataid: dataId,
                courseid: courseId,
                groupid: groupId,
                action: action,
                entryid: entryId,
                fields: JSON.stringify(fields || []),
                timemodified: timemodified
            };
            return site.getDb().insertRecord(AddonModDataOfflineProvider_1.DATA_ENTRY_TABLE, entry);
        });
    };
    // Variables for database.
    AddonModDataOfflineProvider.DATA_ENTRY_TABLE = 'addon_mod_data_entry_1';
    AddonModDataOfflineProvider = AddonModDataOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_6__core_fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonModDataOfflineProvider);
    return AddonModDataOfflineProvider;
    var AddonModDataOfflineProvider_1;
}());

//# sourceMappingURL=offline.js.map

/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesCourseProgressComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_user_providers_user__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_providers_helper__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__course_options_menu_course_options_menu__ = __webpack_require__(590);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};










/**
 * This component is meant to display a course for a list of courses with progress.
 *
 * Example usage:
 *
 * <core-courses-course-progress [course]="course">
 * </core-courses-course-progress>
 */
var CoreCoursesCourseProgressComponent = /** @class */ (function () {
    function CoreCoursesCourseProgressComponent(navCtrl, courseHelper, domUtils, courseProvider, eventsProvider, sitesProvider, coursesProvider, popoverCtrl, userProvider) {
        this.navCtrl = navCtrl;
        this.courseHelper = courseHelper;
        this.domUtils = domUtils;
        this.courseProvider = courseProvider;
        this.eventsProvider = eventsProvider;
        this.sitesProvider = sitesProvider;
        this.coursesProvider = coursesProvider;
        this.popoverCtrl = popoverCtrl;
        this.userProvider = userProvider;
        this.showAll = false; // If true, will show all actions, options, star and progress.
        this.showDownload = true; // If true, will show download button. Only works if the options menu is not shown.
        this.prefetchCourseData = {
            downloadSucceeded: false,
            prefetchCourseIcon: 'spinner',
            title: 'core.course.downloadcourse'
        };
        this.showSpinner = false;
        this.isDestroyed = false;
    }
    /**
     * Component being initialized.
     */
    CoreCoursesCourseProgressComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.downloadCourseEnabled = !this.coursesProvider.isDownloadCourseDisabledInSite();
        if (this.downloadCourseEnabled) {
            this.initPrefetchCourse();
        }
        // This field is only available from 3.6 onwards.
        this.courseOptionMenuEnabled = this.showAll && typeof this.course.isfavourite != 'undefined';
        // Refresh the enabled flag if site is updated.
        this.siteUpdatedObserver = this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].SITE_UPDATED, function () {
            var wasEnabled = _this.downloadCourseEnabled;
            _this.downloadCourseEnabled = !_this.coursesProvider.isDownloadCourseDisabledInSite();
            if (!wasEnabled && _this.downloadCourseEnabled) {
                // Download course is enabled now, initialize it.
                _this.initPrefetchCourse();
            }
        }, this.sitesProvider.getCurrentSiteId());
    };
    /**
     * Initialize prefetch course.
     */
    CoreCoursesCourseProgressComponent.prototype.initPrefetchCourse = function () {
        var _this = this;
        if (typeof this.courseStatusObserver != 'undefined') {
            // Already initialized.
            return;
        }
        // Listen for status change in course.
        this.courseStatusObserver = this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].COURSE_STATUS_CHANGED, function (data) {
            if (data.courseId == _this.course.id || data.courseId == __WEBPACK_IMPORTED_MODULE_7__core_course_providers_course__["a" /* CoreCourseProvider */].ALL_COURSES_CLEARED) {
                _this.updateCourseStatus(data.status);
            }
        }, this.sitesProvider.getCurrentSiteId());
        // Determine course prefetch icon.
        this.courseHelper.getCourseStatusIconAndTitle(this.course.id).then(function (data) {
            _this.prefetchCourseData.prefetchCourseIcon = data.icon;
            _this.prefetchCourseData.title = data.title;
            if (data.icon == 'spinner') {
                // Course is being downloaded. Get the download promise.
                var promise = _this.courseHelper.getCourseDownloadPromise(_this.course.id);
                if (promise) {
                    // There is a download promise. If it fails, show an error.
                    promise.catch(function (error) {
                        if (!_this.isDestroyed) {
                            _this.domUtils.showErrorModalDefault(error, 'core.course.errordownloadingcourse', true);
                        }
                    });
                }
                else {
                    // No download, this probably means that the app was closed while downloading. Set previous status.
                    _this.courseProvider.setCoursePreviousStatus(_this.course.id);
                }
            }
        });
    };
    /**
     * Open a course.
     *
     * @param {any} course The course to open.
     */
    CoreCoursesCourseProgressComponent.prototype.openCourse = function (course) {
        this.courseHelper.openCourse(this.navCtrl, course);
    };
    /**
     * Prefetch the course.
     *
     * @param {Event} e Click event.
     */
    CoreCoursesCourseProgressComponent.prototype.prefetchCourse = function (e) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        this.courseHelper.confirmAndPrefetchCourse(this.prefetchCourseData, this.course).catch(function (error) {
            if (!_this.isDestroyed) {
                _this.domUtils.showErrorModalDefault(error, 'core.course.errordownloadingcourse', true);
            }
        });
    };
    /**
     * Update the course status icon and title.
     *
     * @param {string} status Status to show.
     */
    CoreCoursesCourseProgressComponent.prototype.updateCourseStatus = function (status) {
        var statusData = this.courseHelper.getCourseStatusIconAndTitleFromStatus(status);
        this.prefetchCourseData.prefetchCourseIcon = statusData.icon;
        this.prefetchCourseData.title = statusData.title;
    };
    /**
     * Show the context menu.
     *
     * @param {Event} e Click Event.
     */
    CoreCoursesCourseProgressComponent.prototype.showCourseOptionsMenu = function (e) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        var popover = this.popoverCtrl.create(__WEBPACK_IMPORTED_MODULE_9__course_options_menu_course_options_menu__["a" /* CoreCoursesCourseOptionsMenuComponent */], {
            course: this.course,
            prefetch: this.prefetchCourseData
        });
        popover.onDidDismiss(function (action) {
            if (action) {
                switch (action) {
                    case 'download':
                        if (_this.prefetchCourseData.prefetchCourseIcon != 'spinner') {
                            _this.prefetchCourse(e);
                        }
                        break;
                    case 'hide':
                        _this.setCourseHidden(true);
                        break;
                    case 'show':
                        _this.setCourseHidden(false);
                        break;
                    case 'favourite':
                        _this.setCourseFavourite(true);
                        break;
                    case 'unfavourite':
                        _this.setCourseFavourite(false);
                        break;
                    default:
                        break;
                }
            }
        });
        popover.present({
            ev: e
        });
    };
    /**
     * Hide/Unhide the course from the course list.
     *
     * @param {boolean} hide True to hide and false to show.
     */
    CoreCoursesCourseProgressComponent.prototype.setCourseHidden = function (hide) {
        var _this = this;
        this.showSpinner = true;
        // We should use null to unset the preference.
        this.userProvider.updateUserPreference('block_myoverview_hidden_course_' + this.course.id, hide ? 1 : null).then(function () {
            _this.course.hidden = hide;
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__["a" /* CoreCoursesProvider */].EVENT_MY_COURSES_UPDATED, { course: _this.course }, _this.sitesProvider.getCurrentSiteId());
        }).catch(function (error) {
            if (!_this.isDestroyed) {
                _this.domUtils.showErrorModalDefault(error, 'Error changing course visibility.');
            }
        }).finally(function () {
            _this.showSpinner = false;
        });
    };
    /**
     * Favourite/Unfavourite the course from the course list.
     *
     * @param {boolean} favourite True to favourite and false to unfavourite.
     */
    CoreCoursesCourseProgressComponent.prototype.setCourseFavourite = function (favourite) {
        var _this = this;
        this.showSpinner = true;
        this.coursesProvider.setFavouriteCourse(this.course.id, favourite).then(function () {
            _this.course.isfavourite = favourite;
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__["a" /* CoreCoursesProvider */].EVENT_MY_COURSES_UPDATED, { course: _this.course }, _this.sitesProvider.getCurrentSiteId());
        }).catch(function (error) {
            if (!_this.isDestroyed) {
                _this.domUtils.showErrorModalDefault(error, 'Error changing course favourite attribute.');
            }
        }).finally(function () {
            _this.showSpinner = false;
        });
    };
    /**
     * Component destroyed.
     */
    CoreCoursesCourseProgressComponent.prototype.ngOnDestroy = function () {
        this.isDestroyed = true;
        this.siteUpdatedObserver && this.siteUpdatedObserver.off();
        this.courseStatusObserver && this.courseStatusObserver.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCoursesCourseProgressComponent.prototype, "course", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCoursesCourseProgressComponent.prototype, "showAll", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCoursesCourseProgressComponent.prototype, "showDownload", void 0);
    CoreCoursesCourseProgressComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-courses-course-progress',
            templateUrl: 'core-courses-course-progress.html'
        }),
        __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */], __WEBPACK_IMPORTED_MODULE_8__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__["a" /* CoreCoursesProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["w" /* PopoverController */], __WEBPACK_IMPORTED_MODULE_5__core_user_providers_user__["a" /* CoreUserProvider */]])
    ], CoreCoursesCourseProgressComponent);
    return CoreCoursesCourseProgressComponent;
}());

//# sourceMappingURL=course-progress.js.map

/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModChoiceProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__offline__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service that provides some features for choices.
 */
var AddonModChoiceProvider = /** @class */ (function () {
    function AddonModChoiceProvider(sitesProvider, appProvider, filepoolProvider, utils, choiceOffline, logHelper) {
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        this.filepoolProvider = filepoolProvider;
        this.utils = utils;
        this.choiceOffline = choiceOffline;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModChoice:';
    }
    AddonModChoiceProvider_1 = AddonModChoiceProvider;
    /**
     * Check if results can be seen by a student. The student can see the results if:
     *     - they're always published, OR
     *     - they're published after the choice is closed and it's closed, OR
     *     - they're published after answering and the user has answered.
     *
     * @param  {any}     choice      Choice to check.
     * @param  {boolean} hasAnswered True if user has answered the choice, false otherwise.
     * @return {boolean} True if the students can see the results.
     */
    AddonModChoiceProvider.prototype.canStudentSeeResults = function (choice, hasAnswered) {
        var now = new Date().getTime();
        return choice.showresults === AddonModChoiceProvider_1.RESULTS_ALWAYS ||
            choice.showresults === AddonModChoiceProvider_1.RESULTS_AFTER_CLOSE &&
                choice.timeclose !== 0 && choice.timeclose <= now ||
            choice.showresults === AddonModChoiceProvider_1.RESULTS_AFTER_ANSWER && hasAnswered;
    };
    /**
     * Delete responses from a choice.
     *
     * @param  {number}   choiceId    Choice ID.
     * @param  {string}   name        Choice name.
     * @param  {number}   courseId    Course ID the choice belongs to.
     * @param  {number[]} [responses] IDs of the answers. If not defined, delete all the answers of the current user.
     * @param  {string}   [siteId]    Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: true if response was sent to server, false if stored in device.
     */
    AddonModChoiceProvider.prototype.deleteResponses = function (choiceId, name, courseId, responses, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        responses = responses || [];
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.choiceOffline.saveResponse(choiceId, name, courseId, responses, true, siteId).then(function () {
                return false;
            });
        };
        if (!this.appProvider.isOnline()) {
            // App is offline, store the action.
            return storeOffline();
        }
        // If there's already a response to be sent to the server, discard it first.
        return this.choiceOffline.deleteResponse(choiceId, siteId).then(function () {
            return _this.deleteResponsesOnline(choiceId, responses, siteId).then(function () {
                return true;
            }).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means that responses cannot be submitted.
                    return Promise.reject(error);
                }
                // Couldn't connect to server, store in offline.
                return storeOffline();
            });
        });
    };
    /**
     * Delete responses from a choice. It will fail if offline or cannot connect.
     *
     * @param  {number}   choiceId    Choice ID.
     * @param  {number[]} [responses] IDs of the answers. If not defined, delete all the answers of the current user.
     * @param  {string}   [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when responses are successfully deleted.
     */
    AddonModChoiceProvider.prototype.deleteResponsesOnline = function (choiceId, responses, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                choiceid: choiceId,
                responses: responses
            };
            return site.write('mod_choice_delete_choice_responses', params).then(function (response) {
                // Other errors ocurring.
                if (!response || response.status === false) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
                // Invalidate related data.
                var promises = [
                    _this.invalidateOptions(choiceId, site.id),
                    _this.invalidateResults(choiceId, site.id)
                ];
                return Promise.all(promises).catch(function () {
                    // Ignore errors.
                });
            });
        });
    };
    /**
     * Get cache key for choice data WS calls.
     *
     * @param  {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModChoiceProvider.prototype.getChoiceDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'choice:' + courseId;
    };
    /**
     * Get cache key for choice options WS calls.
     *
     * @param  {number} choiceId Choice ID.
     * @return {string} Cache key.
     */
    AddonModChoiceProvider.prototype.getChoiceOptionsCacheKey = function (choiceId) {
        return this.ROOT_CACHE_KEY + 'options:' + choiceId;
    };
    /**
     * Get cache key for choice results WS calls.
     *
     * @param  {number} choiceId Choice ID.
     * @return {string} Cache key.
     */
    AddonModChoiceProvider.prototype.getChoiceResultsCacheKey = function (choiceId) {
        return this.ROOT_CACHE_KEY + 'results:' + choiceId;
    };
    /**
     * Get a choice with key=value. If more than one is found, only the first will be returned.
     *
     * @param  {string}  siteId             Site ID.
     * @param  {number}  courseId           Course ID.
     * @param  {string}  key                Name of the property to check.
     * @param  {any}     value              Value to search.
     * @param  {boolean} [forceCache] True to always get the value from cache, false otherwise. Default false.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>} Promise resolved when the choice is retrieved.
     */
    AddonModChoiceProvider.prototype.getChoiceByDataKey = function (siteId, courseId, key, value, forceCache, ignoreCache) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            };
            var preSets = {
                cacheKey: _this.getChoiceDataCacheKey(courseId),
                omitExpires: forceCache,
                updateFrequency: __WEBPACK_IMPORTED_MODULE_7__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            else if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_choice_get_choices_by_courses', params, preSets).then(function (response) {
                if (response && response.choices) {
                    var currentChoice = response.choices.find(function (choice) { return choice[key] == value; });
                    if (currentChoice) {
                        return currentChoice;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a choice by course module ID.
     *
     * @param  {number}  courseId           Course ID.
     * @param  {number}  cmId               Course module ID.
     * @param  {string}  [siteId]           Site ID. If not defined, current site.
     * @param  {boolean} [forceCache] True to always get the value from cache, false otherwise. Default false.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>} Promise resolved when the choice is retrieved.
     */
    AddonModChoiceProvider.prototype.getChoice = function (courseId, cmId, siteId, forceCache, ignoreCache) {
        return this.getChoiceByDataKey(siteId, courseId, 'coursemodule', cmId, forceCache, ignoreCache);
    };
    /**
     * Get a choice by ID.
     *
     * @param  {number}  courseId           Course ID.
     * @param  {number}  choiceId           Choice ID.
     * @param  {string}  [siteId]           Site ID. If not defined, current site.
     * @param  {boolean} [forceCache] True to always get the value from cache, false otherwise. Default false.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>} Promise resolved when the choice is retrieved.
     */
    AddonModChoiceProvider.prototype.getChoiceById = function (courseId, choiceId, siteId, forceCache, ignoreCache) {
        return this.getChoiceByDataKey(siteId, courseId, 'id', choiceId, forceCache, ignoreCache);
    };
    /**
     * Get choice options.
     *
     * @param {number} choiceId Choice ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with choice options.
     */
    AddonModChoiceProvider.prototype.getOptions = function (choiceId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                choiceid: choiceId
            };
            var preSets = {
                cacheKey: _this.getChoiceOptionsCacheKey(choiceId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_7__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_choice_get_choice_options', params, preSets).then(function (response) {
                if (response.options) {
                    return response.options;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get choice results.
     *
     * @param {number} choiceId Choice ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with choice results.
     */
    AddonModChoiceProvider.prototype.getResults = function (choiceId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                choiceid: choiceId
            };
            var preSets = {
                cacheKey: _this.getChoiceResultsCacheKey(choiceId)
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_choice_get_choice_results', params, preSets).then(function (response) {
                if (response.options) {
                    return response.options;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidate choice data.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModChoiceProvider.prototype.invalidateChoiceData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(null).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getChoiceDataCacheKey(courseId));
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data is invalidated.
     */
    AddonModChoiceProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.getChoice(courseId, moduleId).then(function (choice) {
            return Promise.all([
                _this.invalidateChoiceData(courseId),
                _this.invalidateOptions(choice.id),
                _this.invalidateResults(choice.id),
            ]);
        }));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModChoiceProvider_1.COMPONENT, moduleId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidate choice options.
     *
     * @param  {number} choiceId Choice ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModChoiceProvider.prototype.invalidateOptions = function (choiceId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getChoiceOptionsCacheKey(choiceId));
        });
    };
    /**
     * Invalidate choice results.
     *
     * @param  {number} choiceId Choice ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModChoiceProvider.prototype.invalidateResults = function (choiceId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getChoiceResultsCacheKey(choiceId));
        });
    };
    /**
     * Report the choice as being viewed.
     *
     * @param  {string} id Choice ID.
     * @param {string} [name] Name of the choice.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModChoiceProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            choiceid: id
        };
        return this.logHelper.logSingle('mod_choice_view_choice', params, AddonModChoiceProvider_1.COMPONENT, id, name, 'choice', {}, siteId);
    };
    /**
     * Send a response to a choice to Moodle.
     *
     * @param  {number}   choiceId  Choice ID.
     * @param  {string}   name      Choice name.
     * @param  {number}   courseId  Course ID the choice belongs to.
     * @param  {number[]} responses IDs of selected options.
     * @param  {string}   [siteId]  Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: true if response was sent to server, false if stored in device.
     */
    AddonModChoiceProvider.prototype.submitResponse = function (choiceId, name, courseId, responses, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.choiceOffline.saveResponse(choiceId, name, courseId, responses, false, siteId).then(function () {
                return false;
            });
        };
        if (!this.appProvider.isOnline()) {
            // App is offline, store the action.
            return storeOffline();
        }
        // If there's already a response to be sent to the server, discard it first.
        return this.choiceOffline.deleteResponse(choiceId, siteId).then(function () {
            return _this.submitResponseOnline(choiceId, responses, siteId).then(function () {
                return true;
            }).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means that responses cannot be submitted.
                    return Promise.reject(error);
                }
                else {
                    // Couldn't connect to server, store it offline.
                    return storeOffline();
                }
            });
        });
    };
    /**
     * Send a response to a choice to Moodle. It will fail if offline or cannot connect.
     *
     * @param  {number}   choiceId  Choice ID.
     * @param  {number[]} responses IDs of selected options.
     * @param  {string}   [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when responses are successfully submitted.
     */
    AddonModChoiceProvider.prototype.submitResponseOnline = function (choiceId, responses, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                choiceid: choiceId,
                responses: responses
            };
            return site.write('mod_choice_submit_choice_response', params).then(function () {
                // Invalidate related data.
                var promises = [
                    _this.invalidateOptions(choiceId, siteId),
                    _this.invalidateResults(choiceId, siteId)
                ];
                return Promise.all(promises).catch(function () {
                    // Ignore errors.
                });
            });
        });
    };
    AddonModChoiceProvider.COMPONENT = 'mmaModChoice';
    AddonModChoiceProvider.RESULTS_NOT = 0;
    AddonModChoiceProvider.RESULTS_AFTER_ANSWER = 1;
    AddonModChoiceProvider.RESULTS_AFTER_CLOSE = 2;
    AddonModChoiceProvider.RESULTS_ALWAYS = 3;
    AddonModChoiceProvider.PUBLISH_ANONYMOUS = false;
    AddonModChoiceProvider.PUBLISH_NAMES = true;
    AddonModChoiceProvider = AddonModChoiceProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__offline__["a" /* AddonModChoiceOfflineProvider */], __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModChoiceProvider);
    return AddonModChoiceProvider;
    var AddonModChoiceProvider_1;
}());

//# sourceMappingURL=choice.js.map

/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModChoiceOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(1);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Service to handle offline choices.
 */
var AddonModChoiceOfflineProvider = /** @class */ (function () {
    function AddonModChoiceOfflineProvider(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.siteSchema = {
            name: 'AddonModChoiceOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModChoiceOfflineProvider_1.CHOICE_TABLE,
                    columns: [
                        {
                            name: 'choiceid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'name',
                            type: 'TEXT'
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'responses',
                            type: 'TEXT'
                        },
                        {
                            name: 'deleting',
                            type: 'INTEGER'
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['choiceid', 'userid']
                }
            ]
        };
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModChoiceOfflineProvider_1 = AddonModChoiceOfflineProvider;
    /**
     * Delete a response.
     *
     * @param  {number} choiceId Choice ID to remove.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the responses belong to. If not defined, current user in site.
     * @return {Promise<any>} Promise resolved if stored, rejected if failure.
     */
    AddonModChoiceOfflineProvider.prototype.deleteResponse = function (choiceId, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().deleteRecords(AddonModChoiceOfflineProvider_1.CHOICE_TABLE, { choiceid: choiceId, userid: userId });
        });
    };
    /**
     * Get all offline responses.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promi[se resolved with responses.
     */
    AddonModChoiceOfflineProvider.prototype.getResponses = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModChoiceOfflineProvider_1.CHOICE_TABLE).then(function (records) {
                records.forEach(function (record) {
                    record.responses = JSON.parse(record.responses);
                });
                return records;
            });
        });
    };
    /**
     * Check if there are offline responses to send.
     *
     * @param  {number} choiceId Choice ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the responses belong to. If not defined, current user in site.
     * @return {Promise<boolean>} Promise resolved with boolean: true if has offline answers, false otherwise.
     */
    AddonModChoiceOfflineProvider.prototype.hasResponse = function (choiceId, siteId, userId) {
        return this.getResponse(choiceId, siteId, userId).then(function (response) {
            return !!response.choiceid;
        }).catch(function (error) {
            // No offline data found, return false.
            return false;
        });
    };
    /**
     * Get response to be synced.
     *
     * @param  {number} choiceId Choice ID to get.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the responses belong to. If not defined, current user in site.
     * @return {Promise<any>} Promise resolved with the object to be synced.
     */
    AddonModChoiceOfflineProvider.prototype.getResponse = function (choiceId, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().getRecord(AddonModChoiceOfflineProvider_1.CHOICE_TABLE, { choiceid: choiceId, userid: userId })
                .then(function (record) {
                record.responses = JSON.parse(record.responses);
                return record;
            });
        });
    };
    /**
     * Offline version for sending a response to a choice to Moodle.
     *
     * @param  {number}   choiceId  Choice ID.
     * @param  {string}   name      Choice name.
     * @param  {number}   courseId  Course ID the choice belongs to.
     * @param  {number[]} responses IDs of selected options.
     * @param  {boolean}  deleting  If true, the user is deleting responses, if false, submitting.
     * @param  {string}   [siteId]  Site ID. If not defined, current site.
     * @param  {number}   [userId]  User the responses belong to. If not defined, current user in site.
     * @return {Promise<any>} Promise resolved when results are successfully submitted.
     */
    AddonModChoiceOfflineProvider.prototype.saveResponse = function (choiceId, name, courseId, responses, deleting, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var entry = {
                choiceid: choiceId,
                name: name,
                courseid: courseId,
                userid: userId || site.getUserId(),
                responses: JSON.stringify(responses),
                deleting: deleting ? 1 : 0,
                timecreated: new Date().getTime()
            };
            return site.getDb().insertRecord(AddonModChoiceOfflineProvider_1.CHOICE_TABLE, entry);
        });
    };
    // Variables for database.
    AddonModChoiceOfflineProvider.CHOICE_TABLE = 'addon_mod_choice_responses';
    AddonModChoiceOfflineProvider = AddonModChoiceOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonModChoiceOfflineProvider);
    return AddonModChoiceOfflineProvider;
    var AddonModChoiceOfflineProvider_1;
}());

//# sourceMappingURL=offline.js.map

/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModChoiceSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__offline__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__choice__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_course_providers_module_prefetch_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_course_classes_activity_sync__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__prefetch_handler__ = __webpack_require__(562);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

















/**
 * Service to sync choices.
 */
var AddonModChoiceSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModChoiceSyncProvider, _super);
    function AddonModChoiceSyncProvider(sitesProvider, loggerProvider, appProvider, choiceOffline, eventsProvider, choiceProvider, translate, utils, textUtils, courseProvider, syncProvider, timeUtils, logHelper, prefetchHandler, prefetchDelegate) {
        var _this = _super.call(this, 'AddonModChoiceSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils, prefetchDelegate, prefetchHandler) || this;
        _this.sitesProvider = sitesProvider;
        _this.appProvider = appProvider;
        _this.choiceOffline = choiceOffline;
        _this.eventsProvider = eventsProvider;
        _this.choiceProvider = choiceProvider;
        _this.utils = utils;
        _this.textUtils = textUtils;
        _this.courseProvider = courseProvider;
        _this.logHelper = logHelper;
        _this.componentTranslate = courseProvider.translateModuleName('choice');
        return _this;
    }
    AddonModChoiceSyncProvider_1 = AddonModChoiceSyncProvider;
    /**
     * Get the ID of a choice sync.
     *
     * @param  {number} choiceId Choice ID.
     * @param  {number} userId   User the responses belong to.
     * @return {string} Sync ID.
     */
    AddonModChoiceSyncProvider.prototype.getSyncId = function (choiceId, userId) {
        return choiceId + '#' + userId;
    };
    /**
     * Try to synchronize all the choices in a certain site or in all sites.
     *
     * @param  {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} force Wether to force sync not depending on last execution.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModChoiceSyncProvider.prototype.syncAllChoices = function (siteId, force) {
        return this.syncOnSites('choices', this.syncAllChoicesFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all pending choices on a site.
     *
     * @param {string}  [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} force    Wether to force sync not depending on last execution.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModChoiceSyncProvider.prototype.syncAllChoicesFunc = function (siteId, force) {
        var _this = this;
        return this.choiceOffline.getResponses(siteId).then(function (responses) {
            // Sync all responses.
            var promises = responses.map(function (response) {
                var promise = force ? _this.syncChoice(response.choiceid, response.userid, siteId) :
                    _this.syncChoiceIfNeeded(response.choiceid, response.userid, siteId);
                return promise.then(function (result) {
                    if (result && result.updated) {
                        // Sync successful, send event.
                        _this.eventsProvider.trigger(AddonModChoiceSyncProvider_1.AUTO_SYNCED, {
                            choiceId: response.choiceid,
                            userId: response.userid,
                            warnings: result.warnings
                        }, siteId);
                    }
                });
            });
            return Promise.all(promises);
        });
    };
    /**
     * Sync an choice only if a certain time has passed since the last time.
     *
     * @param  {number} choiceId Choice ID to be synced.
     * @param  {number} userId   User the answers belong to.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the choice is synced or it doesn't need to be synced.
     */
    AddonModChoiceSyncProvider.prototype.syncChoiceIfNeeded = function (choiceId, userId, siteId) {
        var _this = this;
        var syncId = this.getSyncId(choiceId, userId);
        return this.isSyncNeeded(syncId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncChoice(choiceId, userId, siteId);
            }
        });
    };
    /**
     * Synchronize a choice.
     *
     * @param  {number} choiceId Choice ID to be synced.
     * @param  {number} [userId] User the answers belong to.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModChoiceSyncProvider.prototype.syncChoice = function (choiceId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            siteId = site.getId();
            var syncId = _this.getSyncId(choiceId, userId);
            if (_this.isSyncing(syncId, siteId)) {
                // There's already a sync ongoing for this discussion, return the promise.
                return _this.getOngoingSync(syncId, siteId);
            }
            _this.logger.debug("Try to sync choice '" + choiceId + "' for user '" + userId + "'");
            var courseId;
            var result = {
                warnings: [],
                updated: false
            };
            // Sync offline logs.
            var syncPromise = _this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_8__choice__["a" /* AddonModChoiceProvider */].COMPONENT, choiceId, siteId).catch(function () {
                // Ignore errors.
            }).then(function () {
                return _this.choiceOffline.getResponse(choiceId, siteId, userId).catch(function () {
                    // No offline data found, return empty object.
                    return {};
                });
            }).then(function (data) {
                if (!data.choiceid) {
                    // Nothing to sync.
                    return;
                }
                if (!_this.appProvider.isOnline()) {
                    // Cannot sync in offline.
                    return Promise.reject(null);
                }
                courseId = data.courseid;
                // Send the responses.
                var promise;
                if (data.deleting) {
                    // A user has deleted some responses.
                    promise = _this.choiceProvider.deleteResponsesOnline(choiceId, data.responses, siteId);
                }
                else {
                    // A user has added some responses.
                    promise = _this.choiceProvider.submitResponseOnline(choiceId, data.responses, siteId);
                }
                return promise.then(function () {
                    result.updated = true;
                    return _this.choiceOffline.deleteResponse(choiceId, siteId, userId);
                }).catch(function (error) {
                    if (_this.utils.isWebServiceError(error)) {
                        // The WebService has thrown an error, this means that responses cannot be submitted. Delete them.
                        result.updated = true;
                        return _this.choiceOffline.deleteResponse(choiceId, siteId, userId).then(function () {
                            // Responses deleted, add a warning.
                            result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                                component: _this.componentTranslate,
                                name: data.name,
                                error: _this.textUtils.getErrorMessageFromError(error)
                            }));
                        });
                    }
                    // Couldn't connect to server, reject.
                    return Promise.reject(error);
                });
            }).then(function () {
                if (courseId) {
                    // Data has been sent to server, prefetch choice if needed.
                    return _this.courseProvider.getModuleBasicInfoByInstance(choiceId, 'choice', siteId).then(function (module) {
                        return _this.prefetchAfterUpdate(module, courseId, undefined, siteId);
                    }).catch(function () {
                        // Ignore errors.
                    });
                }
            }).then(function () {
                // Sync finished, set sync time.
                return _this.setSyncTime(syncId, siteId);
            }).then(function () {
                // All done, return the warnings.
                return result;
            });
            return _this.addOngoingSync(syncId, syncPromise, siteId);
        });
    };
    AddonModChoiceSyncProvider.AUTO_SYNCED = 'addon_mod_choice_autom_synced';
    AddonModChoiceSyncProvider = AddonModChoiceSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_7__offline__["a" /* AddonModChoiceOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_8__choice__["a" /* AddonModChoiceProvider */],
            __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_15__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */], __WEBPACK_IMPORTED_MODULE_16__prefetch_handler__["a" /* AddonModChoicePrefetchHandler */],
            __WEBPACK_IMPORTED_MODULE_13__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */]])
    ], AddonModChoiceSyncProvider);
    return AddonModChoiceSyncProvider;
    var AddonModChoiceSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_14__core_course_classes_activity_sync__["a" /* CoreCourseActivitySyncBaseProvider */]));

//# sourceMappingURL=sync.js.map

/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFeedbackOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__ = __webpack_require__(24);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to handle Offline feedback.
 */
var AddonModFeedbackOfflineProvider = /** @class */ (function () {
    function AddonModFeedbackOfflineProvider(logger, sitesProvider, textUtils, timeUtils) {
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.timeUtils = timeUtils;
        this.siteSchema = {
            name: 'AddonModFeedbackOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModFeedbackOfflineProvider_1.FEEDBACK_TABLE,
                    columns: [
                        {
                            name: 'feedbackid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'page',
                            type: 'INTEGER'
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'responses',
                            type: 'TEXT'
                        },
                        {
                            name: 'timemodified',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['feedbackid', 'page']
                }
            ]
        };
        this.logger = logger.getInstance('AddonModFeedbackOfflineProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModFeedbackOfflineProvider_1 = AddonModFeedbackOfflineProvider;
    /**
     * Delete the stored for a certain feedback page.
     *
     * @param  {number} feedbackId Feedback ID.
     * @param  {number} page       Page of the form to delete responses from.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved if deleted, rejected if failure.
     */
    AddonModFeedbackOfflineProvider.prototype.deleteFeedbackPageResponses = function (feedbackId, page, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(AddonModFeedbackOfflineProvider_1.FEEDBACK_TABLE, { feedbackid: feedbackId, page: page });
        });
    };
    /**
     * Get all the stored feedback responses data from all the feedback.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved with entries.
     */
    AddonModFeedbackOfflineProvider.prototype.getAllFeedbackResponses = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getAllRecords(AddonModFeedbackOfflineProvider_1.FEEDBACK_TABLE).then(function (entries) {
                entries.forEach(function (entry) {
                    entry.responses = _this.textUtils.parseJSON(entry.responses);
                });
                return entries;
            });
        });
    };
    /**
     * Get all the stored responses from a certain feedback.
     *
     * @param  {number} feedbackId Feedback ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved with responses.
     */
    AddonModFeedbackOfflineProvider.prototype.getFeedbackResponses = function (feedbackId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(AddonModFeedbackOfflineProvider_1.FEEDBACK_TABLE, { feedbackid: feedbackId });
        }).then(function (entries) {
            entries.forEach(function (entry) {
                entry.responses = _this.textUtils.parseJSON(entry.responses);
            });
            return entries;
        });
    };
    /**
     * Get the stored responses for a certain feedback page.
     *
     * @param  {number} feedbackId Feedback ID.
     * @param  {number} page       Page of the form to get responses from.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved with responses.
     */
    AddonModFeedbackOfflineProvider.prototype.getFeedbackPageResponses = function (feedbackId, page, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(AddonModFeedbackOfflineProvider_1.FEEDBACK_TABLE, { feedbackid: feedbackId, page: page });
        }).then(function (entry) {
            entry.responses = _this.textUtils.parseJSON(entry.responses);
            return entry;
        });
    };
    /**
     * Get if the feedback have something to be synced.
     *
     * @param  {number} feedbackId Feedback ID.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved with true if the feedback have something to be synced.
     */
    AddonModFeedbackOfflineProvider.prototype.hasFeedbackOfflineData = function (feedbackId, siteId) {
        return this.getFeedbackResponses(feedbackId, siteId).then(function (responses) {
            return !!responses.length;
        });
    };
    /**
     * Save page responses to be sent later.
     *
     * @param  {number} feedbackId   Feedback ID.
     * @param  {number} page         The page being processed.
     * @param  {any} responses    The data to be processed the key is the field name (usually type[index]_id)
     * @param  {number} courseId     Course ID the feedback belongs to.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}             Promise resolved if stored, rejected if failure.
     */
    AddonModFeedbackOfflineProvider.prototype.saveResponses = function (feedbackId, page, responses, courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var entry = {
                feedbackid: feedbackId,
                page: page,
                courseid: courseId,
                responses: JSON.stringify(responses),
                timemodified: _this.timeUtils.timestamp()
            };
            return site.getDb().insertRecord(AddonModFeedbackOfflineProvider_1.FEEDBACK_TABLE, entry);
        });
    };
    // Variables for database.
    AddonModFeedbackOfflineProvider.FEEDBACK_TABLE = 'addon_mod_feedback_answers';
    AddonModFeedbackOfflineProvider = AddonModFeedbackOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__["a" /* CoreTimeUtilsProvider */]])
    ], AddonModFeedbackOfflineProvider);
    return AddonModFeedbackOfflineProvider;
    var AddonModFeedbackOfflineProvider_1;
}());

//# sourceMappingURL=offline.js.map

/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourceHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_helper__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__resource__ = __webpack_require__(222);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_mimetype__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_text__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service that provides helper functions for resources.
 */
var AddonModResourceHelperProvider = /** @class */ (function () {
    function AddonModResourceHelperProvider(courseProvider, domUtils, resourceProvider, courseHelper, textUtils, mimetypeUtils, fileProvider, appProvider, filepoolProvider, sitesProvider) {
        this.courseProvider = courseProvider;
        this.domUtils = domUtils;
        this.resourceProvider = resourceProvider;
        this.courseHelper = courseHelper;
        this.textUtils = textUtils;
        this.mimetypeUtils = mimetypeUtils;
        this.fileProvider = fileProvider;
        this.appProvider = appProvider;
        this.filepoolProvider = filepoolProvider;
        this.sitesProvider = sitesProvider;
        /* Constants to determine how a resource should be displayed in Moodle. */
        // Try the best way.
        this.DISPLAY_AUTO = 0;
        // Display using object tag.
        this.DISPLAY_EMBED = 1;
    }
    /**
     * Get the HTML to display an embedded resource.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @return {Promise<any>} Promise resolved with the HTML.
     */
    AddonModResourceHelperProvider.prototype.getEmbeddedHtml = function (module, courseId) {
        var _this = this;
        return this.courseHelper.downloadModuleWithMainFileIfNeeded(module, courseId, __WEBPACK_IMPORTED_MODULE_4__resource__["a" /* AddonModResourceProvider */].COMPONENT, module.id, module.contents).then(function (result) {
            var file = module.contents[0], ext = _this.mimetypeUtils.getFileExtension(file.filename), type = _this.mimetypeUtils.getExtensionType(ext), mimeType = _this.mimetypeUtils.getMimeType(ext);
            if (type == 'image') {
                return '<img src="' + result.path + '"></img>';
            }
            if (type == 'audio' || type == 'video') {
                return '<' + type + ' controls title="' + file.filename + '"" src="' + result.path + '">' +
                    '<source src="' + result.path + '" type="' + mimeType + '">' +
                    '</' + type + '>';
            }
            // Shouldn't reach here, the user should have called CoreMimetypeUtilsProvider#canBeEmbedded.
            return '';
        });
    };
    /**
     * Download all the files needed and returns the src of the iframe.
     *
     * @param {any} module The module object.
     * @return {Promise<string>} Promise resolved with the iframe src.
     */
    AddonModResourceHelperProvider.prototype.getIframeSrc = function (module) {
        var _this = this;
        if (!module.contents.length) {
            return Promise.reject(null);
        }
        var mainFile = module.contents[0];
        var mainFilePath = mainFile.filename;
        if (mainFile.filepath !== '/') {
            mainFilePath = mainFile.filepath.substr(1) + mainFilePath;
        }
        return this.filepoolProvider.getPackageDirUrlByUrl(this.sitesProvider.getCurrentSiteId(), module.url).then(function (dirPath) {
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return _this.textUtils.concatenatePaths(dirPath, mainFilePath);
        }).catch(function () {
            // Error getting directory, there was an error downloading or we're in browser. Return online URL.
            if (_this.appProvider.isOnline() && mainFile.fileurl) {
                // This URL is going to be injected in an iframe, we need this to make it work.
                return Promise.resolve(_this.sitesProvider.getCurrentSite().fixPluginfileURL(mainFile.fileurl));
            }
            return Promise.reject(null);
        });
    };
    /**
     * Whether the resource has to be displayed embedded.
     *
     * @param {any} module    The module object.
     * @param {number} [display] The display mode (if available).
     * @return {boolean}         Whether the resource should be displayed embeded.
     */
    AddonModResourceHelperProvider.prototype.isDisplayedEmbedded = function (module, display) {
        if ((!module.contents.length && !module.contentsinfo) || !this.fileProvider.isAvailable() ||
            (!this.sitesProvider.getCurrentSite().isVersionGreaterEqualThan('3.7') && this.isNextcloudFile(module))) {
            return false;
        }
        var ext;
        if (module.contentsinfo) {
            ext = this.mimetypeUtils.getExtension(module.contentsinfo.mimetypes[0]);
        }
        else {
            ext = this.mimetypeUtils.getFileExtension(module.contents[0].filename);
        }
        return (display == this.DISPLAY_EMBED || display == this.DISPLAY_AUTO) && this.mimetypeUtils.canBeEmbedded(ext);
    };
    /**
     * Whether the resource has to be displayed in an iframe.
     *
     * @param {any} module The module object.
     * @return {boolean}   Whether the resource should be displayed in an iframe.
     */
    AddonModResourceHelperProvider.prototype.isDisplayedInIframe = function (module) {
        if ((!module.contents.length && !module.contentsinfo) || !this.fileProvider.isAvailable()) {
            return false;
        }
        var mimetype;
        if (module.contentsinfo) {
            mimetype = module.contentsinfo.mimetypes[0];
        }
        else {
            var ext = this.mimetypeUtils.getFileExtension(module.contents[0].filename);
            mimetype = this.mimetypeUtils.getMimeType(ext);
        }
        return mimetype == 'text/html';
    };
    /**
     * Check if the resource is a Nextcloud file.
     *
     * @param {any} module Module to check.
     * @return {boolean} Whether it's a Nextcloud file.
     */
    AddonModResourceHelperProvider.prototype.isNextcloudFile = function (module) {
        if (module.contentsinfo) {
            return module.contentsinfo.repositorytype == 'nextcloud';
        }
        return module.contents && module.contents[0] && module.contents[0].repositorytype == 'nextcloud';
    };
    /**
     * Opens a file of the resource activity.
     *
     * @param  {any} module        Module where to get the contents.
     * @param  {number} courseId   Course Id, used for completion purposes.
     * @return {Promise<any>}      Resolved when done.
     */
    AddonModResourceHelperProvider.prototype.openModuleFile = function (module, courseId) {
        var _this = this;
        var modal = this.domUtils.showModalLoading();
        // Download and open the file from the resource contents.
        return this.courseHelper.downloadModuleAndOpenFile(module, courseId, __WEBPACK_IMPORTED_MODULE_4__resource__["a" /* AddonModResourceProvider */].COMPONENT, module.id, module.contents).then(function () {
            _this.resourceProvider.logView(module.instance, module.name).then(function () {
                _this.courseProvider.checkModuleCompletion(courseId, module.completiondata);
            }).catch(function () {
                // Ignore errors.
            });
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'addon.mod_resource.errorwhileloadingthecontent', true);
        }).finally(function () {
            modal.dismiss();
        });
    };
    AddonModResourceHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__resource__["a" /* AddonModResourceProvider */], __WEBPACK_IMPORTED_MODULE_3__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonModResourceHelperProvider);
    return AddonModResourceHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModSurveyProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__offline__ = __webpack_require__(285);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service that provides some features for surveys.
 */
var AddonModSurveyProvider = /** @class */ (function () {
    function AddonModSurveyProvider(logger, sitesProvider, appProvider, filepoolProvider, utils, surveyOffline, logHelper) {
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        this.filepoolProvider = filepoolProvider;
        this.utils = utils;
        this.surveyOffline = surveyOffline;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModSurvey:';
        this.logger = logger.getInstance('AddonModSurveyProvider');
    }
    AddonModSurveyProvider_1 = AddonModSurveyProvider;
    /**
     * Get a survey's questions.
     *
     * @param {number} surveyId Survey ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the questions are retrieved.
     */
    AddonModSurveyProvider.prototype.getQuestions = function (surveyId, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                surveyid: surveyId
            }, preSets = {
                cacheKey: _this.getQuestionsCacheKey(surveyId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_8__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_survey_get_questions', params, preSets).then(function (response) {
                if (response.questions) {
                    return response.questions;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for survey questions WS calls.
     *
     * @param {number} surveyId Survey ID.
     * @return {string}         Cache key.
     */
    AddonModSurveyProvider.prototype.getQuestionsCacheKey = function (surveyId) {
        return this.ROOT_CACHE_KEY + 'questions:' + surveyId;
    };
    /**
     * Get cache key for survey data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModSurveyProvider.prototype.getSurveyCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'survey:' + courseId;
    };
    /**
     * Get a survey data.
     *
     * @param {number} courseId Course ID.
     * @param {string} key Name of the property to check.
     * @param {any} value Value to search.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the survey is retrieved.
     */
    AddonModSurveyProvider.prototype.getSurveyDataByKey = function (courseId, key, value, ignoreCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getSurveyCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_8__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            if (ignoreCache) {
                preSets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('mod_survey_get_surveys_by_courses', params, preSets).then(function (response) {
                if (response && response.surveys) {
                    var currentSurvey = response.surveys.find(function (survey) {
                        return survey[key] == value;
                    });
                    if (currentSurvey) {
                        return currentSurvey;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a survey by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId Course module ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the survey is retrieved.
     */
    AddonModSurveyProvider.prototype.getSurvey = function (courseId, cmId, ignoreCache, siteId) {
        return this.getSurveyDataByKey(courseId, 'coursemodule', cmId, ignoreCache, siteId);
    };
    /**
     * Get a survey by ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} id Survey ID.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when the survey is retrieved.
     */
    AddonModSurveyProvider.prototype.getSurveyById = function (courseId, id, ignoreCache, siteId) {
        return this.getSurveyDataByKey(courseId, 'id', id, ignoreCache, siteId);
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModSurveyProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.getSurvey(courseId, moduleId).then(function (survey) {
            var ps = [];
            // Do not invalidate activity data before getting activity info, we need it!
            ps.push(_this.invalidateSurveyData(courseId, siteId));
            ps.push(_this.invalidateQuestions(survey.id, siteId));
            return Promise.all(ps);
        }));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModSurveyProvider_1.COMPONENT, moduleId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates survey questions.
     *
     * @param {number} surveyId Survey ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the data is invalidated.
     */
    AddonModSurveyProvider.prototype.invalidateQuestions = function (surveyId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getQuestionsCacheKey(surveyId));
        });
    };
    /**
     * Invalidates survey data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModSurveyProvider.prototype.invalidateSurveyData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getSurveyCacheKey(courseId));
        });
    };
    /**
     * Report the survey as being viewed.
     *
     * @param {number} id Module ID.
     * @param {string} [name] Name of the assign.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModSurveyProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            surveyid: id
        };
        return this.logHelper.logSingle('mod_survey_view_survey', params, AddonModSurveyProvider_1.COMPONENT, id, name, 'survey', {}, siteId);
    };
    /**
     * Send survey answers. If cannot send them to Moodle, they'll be stored in offline to be sent later.
     *
     * @param  {number} surveyId  Survey ID.
     * @param  {string} name      Survey name.
     * @param  {number} courseId  Course ID the survey belongs to.
     * @param  {any[]} answers Answers.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>}    Promise resolved with boolean if success: true if answers were sent to server,
     *                           false if stored in device.
     */
    AddonModSurveyProvider.prototype.submitAnswers = function (surveyId, name, courseId, answers, siteId) {
        var _this = this;
        // Convenience function to store a survey to be synchronized later.
        var storeOffline = function () {
            return _this.surveyOffline.saveAnswers(surveyId, name, courseId, answers, siteId).then(function () {
                return false;
            });
        };
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!this.appProvider.isOnline()) {
            // App is offline, store the message.
            return storeOffline();
        }
        // If there's already answers to be sent to the server, discard it first.
        return this.surveyOffline.deleteSurveyAnswers(surveyId, siteId).then(function () {
            // Device is online, try to send them to server.
            return _this.submitAnswersOnline(surveyId, answers, siteId).then(function () {
                return true;
            }).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // It's a WebService error, the user cannot send the message so don't store it.
                    return Promise.reject(error);
                }
                // Couldn't connect to server, store in offline.
                return storeOffline();
            });
        });
    };
    /**
     * Send survey answers to Moodle.
     *
     * @param  {number} surveyId  Survey ID.
     * @param  {any[]} answers Answers.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}     Promise resolved when answers are successfully submitted. Rejected with object containing
     *                            the error message (if any) and a boolean indicating if the error was returned by WS.
     */
    AddonModSurveyProvider.prototype.submitAnswersOnline = function (surveyId, answers, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                surveyid: surveyId,
                answers: answers
            };
            return site.write('mod_survey_submit_answers', params).then(function (response) {
                if (!response.status) {
                    return Promise.reject(_this.utils.createFakeWSError(''));
                }
            });
        });
    };
    AddonModSurveyProvider.COMPONENT = 'mmaModSurvey';
    AddonModSurveyProvider = AddonModSurveyProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__offline__["a" /* AddonModSurveyOfflineProvider */], __WEBPACK_IMPORTED_MODULE_6__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModSurveyProvider);
    return AddonModSurveyProvider;
    var AddonModSurveyProvider_1;
}());

//# sourceMappingURL=survey.js.map

/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModSurveyOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service to handle Offline survey.
 */
var AddonModSurveyOfflineProvider = /** @class */ (function () {
    function AddonModSurveyOfflineProvider(logger, sitesProvider, textUtils) {
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.siteSchema = {
            name: 'AddonModSurveyOfflineProvider',
            version: 1,
            tables: [
                {
                    name: AddonModSurveyOfflineProvider_1.SURVEY_TABLE,
                    columns: [
                        {
                            name: 'surveyid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'name',
                            type: 'TEXT'
                        },
                        {
                            name: 'courseid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'userid',
                            type: 'INTEGER'
                        },
                        {
                            name: 'answers',
                            type: 'TEXT'
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER'
                        }
                    ],
                    primaryKeys: ['surveyid', 'userid']
                }
            ]
        };
        this.logger = logger.getInstance('AddonModSurveyOfflineProvider');
        this.sitesProvider.registerSiteSchema(this.siteSchema);
    }
    AddonModSurveyOfflineProvider_1 = AddonModSurveyOfflineProvider;
    /**
     * Delete a survey answers.
     *
     * @param  {number} surveyId Survey ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the answers belong to. If not defined, current user in site.
     * @return {Promise<any>}         Promise resolved if deleted, rejected if failure.
     */
    AddonModSurveyOfflineProvider.prototype.deleteSurveyAnswers = function (surveyId, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().deleteRecords(AddonModSurveyOfflineProvider_1.SURVEY_TABLE, { surveyid: surveyId, userid: userId });
        });
    };
    /**
     * Get all the stored data from all the surveys.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved with answers.
     */
    AddonModSurveyOfflineProvider.prototype.getAllData = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getAllRecords(AddonModSurveyOfflineProvider_1.SURVEY_TABLE).then(function (entries) {
                entries.forEach(function (entry) {
                    entry.answers = _this.textUtils.parseJSON(entry.answers);
                });
                return entries;
            });
        });
    };
    /**
     * Get a survey stored answers.
     *
     * @param  {number} surveyId Survey ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the answers belong to. If not defined, current user in site.
     * @return {Promise<any>}    Promise resolved with the answers.
     */
    AddonModSurveyOfflineProvider.prototype.getSurveyAnswers = function (surveyId, siteId, userId) {
        return this.getSurveyData(surveyId, siteId, userId).then(function (entry) {
            return entry.answers || [];
        }).catch(function () {
            return [];
        });
    };
    /**
     * Get a survey stored data.
     *
     * @param  {number} surveyId Survey ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @param  {number} [userId] User the answers belong to. If not defined, current user in site.
     * @return {Promise<any>}         Promise resolved with the data.
     */
    AddonModSurveyOfflineProvider.prototype.getSurveyData = function (surveyId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.getDb().getRecord(AddonModSurveyOfflineProvider_1.SURVEY_TABLE, { surveyid: surveyId, userid: userId });
        }).then(function (entry) {
            entry.answers = _this.textUtils.parseJSON(entry.answers);
            return entry;
        });
    };
    /**
     * Check if there are offline answers to send.
     *
     * @param  {number} surveyId  Survey ID.
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @param  {number} [userId]  User the answers belong to. If not defined, current user in site.
     * @return {Promise<boolean>}          Promise resolved with boolean: true if has offline answers, false otherwise.
     */
    AddonModSurveyOfflineProvider.prototype.hasAnswers = function (surveyId, siteId, userId) {
        return this.getSurveyAnswers(surveyId, siteId, userId).then(function (answers) {
            return !!answers.length;
        });
    };
    /**
     * Save answers to be sent later.
     *
     * @param  {number} surveyId  Survey ID.
     * @param  {string} name      Survey name.
     * @param  {number} courseId  Course ID the survey belongs to.
     * @param  {any[]} answers    Answers.
     * @param  {string} [siteId]  Site ID. If not defined, current site.
     * @param  {number} [userId]  User the answers belong to. If not defined, current user in site.
     * @return {Promise<any>}     Promise resolved if stored, rejected if failure.
     */
    AddonModSurveyOfflineProvider.prototype.saveAnswers = function (surveyId, name, courseId, answers, siteId, userId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var entry = {
                surveyid: surveyId,
                name: name,
                courseid: courseId,
                userid: userId,
                answers: JSON.stringify(answers),
                timecreated: new Date().getTime()
            };
            return site.getDb().insertRecord(AddonModSurveyOfflineProvider_1.SURVEY_TABLE, entry);
        });
    };
    // Variables for database.
    AddonModSurveyOfflineProvider.SURVEY_TABLE = 'addon_mod_survey_answers';
    AddonModSurveyOfflineProvider = AddonModSurveyOfflineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], AddonModSurveyOfflineProvider);
    return AddonModSurveyOfflineProvider;
    var AddonModSurveyOfflineProvider_1;
}());

//# sourceMappingURL=offline.js.map

/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModSurveySyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__offline__ = __webpack_require__(285);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__survey__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_course_providers_module_prefetch_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_course_classes_activity_sync__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__prefetch_handler__ = __webpack_require__(631);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

















/**
 * Service to sync surveys.
 */
var AddonModSurveySyncProvider = /** @class */ (function (_super) {
    __extends(AddonModSurveySyncProvider, _super);
    function AddonModSurveySyncProvider(loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, courseProvider, surveyOffline, eventsProvider, surveyProvider, utils, timeUtils, logHelper, prefetchDelegate, prefetchHandler) {
        var _this = _super.call(this, 'AddonModSurveySyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils, prefetchDelegate, prefetchHandler) || this;
        _this.courseProvider = courseProvider;
        _this.surveyOffline = surveyOffline;
        _this.eventsProvider = eventsProvider;
        _this.surveyProvider = surveyProvider;
        _this.utils = utils;
        _this.logHelper = logHelper;
        _this.componentTranslate = courseProvider.translateModuleName('survey');
        return _this;
    }
    AddonModSurveySyncProvider_1 = AddonModSurveySyncProvider;
    /**
     * Get the ID of a survey sync.
     *
     * @param  {number} surveyId Survey ID.
     * @param  {number} userId   User the answers belong to.
     * @return {string}          Sync ID.
     * @protected
     */
    AddonModSurveySyncProvider.prototype.getSyncId = function (surveyId, userId) {
        return surveyId + '#' + userId;
    };
    /**
     * Try to synchronize all the surveys in a certain site or in all sites.
     *
     * @param  {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModSurveySyncProvider.prototype.syncAllSurveys = function (siteId, force) {
        return this.syncOnSites('all surveys', this.syncAllSurveysFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all pending surveys on a site.
     *
     * @param  {string} siteId Site ID to sync.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @param {Promise<any>}     Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModSurveySyncProvider.prototype.syncAllSurveysFunc = function (siteId, force) {
        var _this = this;
        // Get all survey answers pending to be sent in the site.
        return this.surveyOffline.getAllData(siteId).then(function (entries) {
            // Sync all surveys.
            var promises = entries.map(function (entry) {
                var promise = force ? _this.syncSurvey(entry.surveyid, entry.userid, siteId) :
                    _this.syncSurveyIfNeeded(entry.surveyid, entry.userid, siteId);
                return promise.then(function (result) {
                    if (result && result.answersSent) {
                        // Sync successful, send event.
                        _this.eventsProvider.trigger(AddonModSurveySyncProvider_1.AUTO_SYNCED, {
                            surveyId: entry.surveyid,
                            userId: entry.userid,
                            warnings: result.warnings
                        }, siteId);
                    }
                });
            });
            return Promise.all(promises);
        });
    };
    /**
     * Sync a survey only if a certain time has passed since the last time.
     *
     * @param  {number} surveyId Survey ID.
     * @param  {number} userId   User the answers belong to.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the survey is synced or if it doesn't need to be synced.
     */
    AddonModSurveySyncProvider.prototype.syncSurveyIfNeeded = function (surveyId, userId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var syncId = this.getSyncId(surveyId, userId);
        return this.isSyncNeeded(syncId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncSurvey(surveyId, userId, siteId);
            }
        });
    };
    /**
     * Synchronize a survey.
     *
     * @param  {number} surveyId Survey ID.
     * @param  {number} [userId]   User the answers belong to. If not defined, current user.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModSurveySyncProvider.prototype.syncSurvey = function (surveyId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            siteId = site.getId();
            var syncId = _this.getSyncId(surveyId, userId);
            if (_this.isSyncing(syncId, siteId)) {
                // There's already a sync ongoing for this survey and user, return the promise.
                return _this.getOngoingSync(syncId, siteId);
            }
            _this.logger.debug("Try to sync survey '" + surveyId + "' for user '" + userId + "'");
            var courseId;
            var result = {
                warnings: [],
                answersSent: false
            };
            // Sync offline logs.
            var syncPromise = _this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_8__survey__["a" /* AddonModSurveyProvider */].COMPONENT, surveyId, siteId).catch(function () {
                // Ignore errors.
            }).then(function () {
                // Get answers to be sent.
                return _this.surveyOffline.getSurveyData(surveyId, siteId, userId).catch(function () {
                    // No offline data found, return empty object.
                    return {};
                });
            }).then(function (data) {
                if (!data.answers || !data.answers.length) {
                    // Nothing to sync.
                    return;
                }
                if (!_this.appProvider.isOnline()) {
                    // Cannot sync in offline.
                    return Promise.reject(null);
                }
                courseId = data.courseid;
                // Send the answers.
                return _this.surveyProvider.submitAnswersOnline(surveyId, data.answers, siteId).then(function () {
                    result.answersSent = true;
                    // Answers sent, delete them.
                    return _this.surveyOffline.deleteSurveyAnswers(surveyId, siteId, userId);
                }).catch(function (error) {
                    if (_this.utils.isWebServiceError(error)) {
                        // The WebService has thrown an error, this means that answers cannot be submitted. Delete them.
                        result.answersSent = true;
                        return _this.surveyOffline.deleteSurveyAnswers(surveyId, siteId, userId).then(function () {
                            // Answers deleted, add a warning.
                            result.warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                                component: _this.componentTranslate,
                                name: data.name,
                                error: _this.textUtils.getErrorMessageFromError(error)
                            }));
                        });
                    }
                    // Couldn't connect to server, reject.
                    return Promise.reject(error);
                });
            }).then(function () {
                if (courseId) {
                    // Data has been sent to server, update survey data.
                    return _this.courseProvider.getModuleBasicInfoByInstance(surveyId, 'survey', siteId).then(function (module) {
                        return _this.prefetchAfterUpdate(module, courseId, undefined, siteId);
                    }).catch(function () {
                        // Ignore errors.
                    });
                }
            }).then(function () {
                // Sync finished, set sync time.
                return _this.setSyncTime(syncId, siteId);
            }).then(function () {
                return result;
            });
            return _this.addOngoingSync(syncId, syncPromise, siteId);
        });
    };
    AddonModSurveySyncProvider.AUTO_SYNCED = 'addon_mod_survey_autom_synced';
    AddonModSurveySyncProvider = AddonModSurveySyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_15__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_10__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_11__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_7__offline__["a" /* AddonModSurveyOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_8__survey__["a" /* AddonModSurveyProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_12__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_13__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */], __WEBPACK_IMPORTED_MODULE_16__prefetch_handler__["a" /* AddonModSurveyPrefetchHandler */]])
    ], AddonModSurveySyncProvider);
    return AddonModSurveySyncProvider;
    var AddonModSurveySyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_14__core_course_classes_activity_sync__["a" /* CoreCourseActivitySyncBaseProvider */]));

//# sourceMappingURL=sync.js.map

/***/ }),
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmulatorHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_local_notifications__ = __webpack_require__(337);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_init__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_local_notifications__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__file_transfer__ = __webpack_require__(1014);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__capture_helper__ = __webpack_require__(342);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__constants__ = __webpack_require__(39);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/**
 * Helper service for the emulator feature. It also acts as an init handler.
 */
var CoreEmulatorHelperProvider = /** @class */ (function () {
    function CoreEmulatorHelperProvider(file, fileProvider, utils, logger, sitesProvider, localNotif, captureHelper, timeUtils, appProvider, localNotifProvider) {
        this.file = file;
        this.fileProvider = fileProvider;
        this.utils = utils;
        this.sitesProvider = sitesProvider;
        this.localNotif = localNotif;
        this.captureHelper = captureHelper;
        this.timeUtils = timeUtils;
        this.appProvider = appProvider;
        this.localNotifProvider = localNotifProvider;
        this.name = 'CoreEmulator';
        this.priority = __WEBPACK_IMPORTED_MODULE_6__providers_init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 500;
        this.blocking = true;
        // Variables for database.
        this.LAST_RECEIVED_NOTIFICATION_TABLE = 'core_emulator_last_received_notification';
        this.siteSchema = {
            name: 'CoreEmulatorHelperProvider',
            version: 1,
            tables: [
                {
                    name: this.LAST_RECEIVED_NOTIFICATION_TABLE,
                    columns: [
                        {
                            name: 'component',
                            type: 'TEXT'
                        },
                        {
                            name: 'id',
                            type: 'INTEGER',
                        },
                        {
                            name: 'timecreated',
                            type: 'INTEGER',
                        },
                    ],
                    primaryKeys: ['component']
                }
            ]
        };
        this.logger = logger.getInstance('CoreEmulatorHelper');
        sitesProvider.registerSiteSchema(this.siteSchema);
    }
    /**
     * Load the Mocks that need it.
     *
     * @return {Promise<void>} Promise resolved when loaded.
     */
    CoreEmulatorHelperProvider.prototype.load = function () {
        var _this = this;
        var promises = [];
        promises.push(this.file.load().then(function (basePath) {
            _this.fileProvider.setHTMLBasePath(basePath);
        }));
        promises.push(this.localNotif.load());
        promises.push(this.captureHelper.load());
        window.FileTransferError = __WEBPACK_IMPORTED_MODULE_11__file_transfer__["a" /* FileTransferErrorMock */];
        return this.utils.allPromises(promises);
    };
    /**
     * Check if there are new notifications, triggering a local notification if found.
     * Only for desktop apps since they don't support push notifications.
     *
     * @param  {string}   component Component to check.
     * @param  {Function} fetchFn   Function that receives a site ID and returns a Promise resolved with an array of notifications.
     * @param  {Function} getDataFn Function that receives a notification and returns a promise resolved with the title and text.
     * @param  {string}   [siteId]  Site ID to check. If not defined, check all sites.
     * @return {Promise<any>}       Promise resolved when done.
     */
    CoreEmulatorHelperProvider.prototype.checkNewNotifications = function (component, fetchFn, getDataFn, siteId) {
        var _this = this;
        if (!this.appProvider.isDesktop() || !this.localNotifProvider.isAvailable()) {
            return Promise.resolve(null);
        }
        if (!this.appProvider.isOnline()) {
            this.logger.debug('Cannot check push notifications because device is offline.');
            return Promise.reject(null);
        }
        var promise;
        if (!siteId) {
            // No site ID defined, check all sites.
            promise = this.sitesProvider.getSitesIds();
        }
        else {
            promise = Promise.resolve([siteId]);
        }
        return promise.then(function (siteIds) {
            var sitePromises = siteIds.map(function (siteId) {
                // Check new notifications for each site.
                return _this.checkNewNotificationsForSite(component, fetchFn, getDataFn, siteId);
            });
            return Promise.all(sitePromises);
        });
    };
    /**
     * Check if there are new notifications for a certain site, triggering a local notification if found.
     *
     * @param  {string}   component Component to check.
     * @param  {Function} fetchFn   Function that receives a site ID and returns a Promise resolved with an array of notifications.
     * @param  {Function} getDataFn Function that receives a notification and returns a promise resolved with the title and text.
     * @param  {string}   siteId    Site ID to check.
     * @return {Promise<any>}       Promise resolved when done.
     */
    CoreEmulatorHelperProvider.prototype.checkNewNotificationsForSite = function (component, fetchFn, getDataFn, siteId) {
        var _this = this;
        // Get the last received notification in the app.
        return this.getLastReceivedNotification(component, siteId).then(function (lastNotification) {
            // Now fetch the latest notifications from the server.
            return fetchFn(siteId).then(function (notifications) {
                if (!lastNotification || !notifications.length) {
                    // No last notification stored (first call) or no new notifications. Stop.
                    return;
                }
                var notification = notifications[0];
                if (notification.id == lastNotification.id || notification.timecreated <= lastNotification.timecreated ||
                    _this.timeUtils.timestamp() - notification.timecreated > __WEBPACK_IMPORTED_MODULE_13__constants__["a" /* CoreConstants */].SECONDS_DAY) {
                    // There are no new notifications or the newest one happened more than a day ago, stop.
                    return;
                }
                // There is a new notification, show it.
                return getDataFn(notification).then(function (titleAndText) {
                    // Set some calculated data.
                    notification.site = siteId;
                    notification.name = notification.name || notification.eventtype;
                    var localNotif = {
                        id: 1,
                        title: titleAndText.title,
                        text: titleAndText.text,
                        data: notification
                    };
                    return _this.localNotifProvider.schedule(localNotif, component, siteId);
                });
            });
        });
    };
    /**
     * Get the last notification received in a certain site for a certain component.
     *
     * @param  {string} component Component of the notification to get.
     * @param  {string} siteId    Site ID of the notification.
     * @return {Promise<any>}     Promise resolved with the notification or false if not found.
     */
    CoreEmulatorHelperProvider.prototype.getLastReceivedNotification = function (component, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.LAST_RECEIVED_NOTIFICATION_TABLE, { component: component });
        }).catch(function () {
            return false;
        });
    };
    /**
     * Store the last notification received in a certain site.
     *
     * @param  {string} component    Component of the notification to store.
     * @param  {any}    notification Notification to store.
     * @param  {string} siteId       Site ID of the notification.
     * @return {Promise<any>}        Promise resolved when done.
     */
    CoreEmulatorHelperProvider.prototype.storeLastReceivedNotification = function (component, notification, siteId) {
        var _this = this;
        if (!notification) {
            // No notification, store a fake one.
            notification = { id: -1, timecreated: 0 };
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var entry = {
                component: component,
                id: notification.id,
                timecreated: notification.timecreated,
            };
            return site.getDb().insertRecord(_this.LAST_RECEIVED_NOTIFICATION_TABLE, entry);
        });
    };
    CoreEmulatorHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_1__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_local_notifications__["a" /* LocalNotifications */],
            __WEBPACK_IMPORTED_MODULE_12__capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */]])
    ], CoreEmulatorHelperProvider);
    return CoreEmulatorHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseActivitySyncBaseProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__classes_base_sync__ = __webpack_require__(160);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Base class to create activity sync providers. It provides some common functions.
 */
var CoreCourseActivitySyncBaseProvider = /** @class */ (function (_super) {
    __extends(CoreCourseActivitySyncBaseProvider, _super);
    function CoreCourseActivitySyncBaseProvider(component, loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils, prefetchDelegate, prefetchHandler) {
        var _this = _super.call(this, component, loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils) || this;
        _this.sitesProvider = sitesProvider;
        _this.appProvider = appProvider;
        _this.syncProvider = syncProvider;
        _this.textUtils = textUtils;
        _this.translate = translate;
        _this.timeUtils = timeUtils;
        _this.prefetchDelegate = prefetchDelegate;
        _this.prefetchHandler = prefetchHandler;
        return _this;
    }
    /**
     * Conveniece function to prefetch data after an update.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID.
     * @param {RegExp} [regex] If regex matches, don't download the data. Defaults to check files.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseActivitySyncBaseProvider.prototype.prefetchAfterUpdate = function (module, courseId, regex, siteId) {
        var _this = this;
        regex = regex || /^.*files$/;
        // Get the module updates to check if the data was updated or not.
        return this.prefetchDelegate.getModuleUpdates(module, courseId, true, siteId).then(function (result) {
            if (result && result.updates && result.updates.length > 0) {
                // Only prefetch if files haven't changed.
                var shouldDownload = !result.updates.find(function (entry) {
                    return entry.name.match(regex);
                });
                if (shouldDownload) {
                    return _this.prefetchHandler.download(module, courseId);
                }
            }
        });
    };
    return CoreCourseActivitySyncBaseProvider;
}(__WEBPACK_IMPORTED_MODULE_0__classes_base_sync__["a" /* CoreSyncBaseProvider */]));

//# sourceMappingURL=activity-sync.js.map

/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBlockTimelineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_dashboard__ = __webpack_require__(370);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service that provides some features regarding course overview.
 */
var AddonBlockTimelineProvider = /** @class */ (function () {
    function AddonBlockTimelineProvider(sitesProvider, dashboardProvider) {
        this.sitesProvider = sitesProvider;
        this.dashboardProvider = dashboardProvider;
        // Cache key was maintained when moving the functions to this file. It comes from core myoverview.
        this.ROOT_CACHE_KEY = 'myoverview:';
    }
    AddonBlockTimelineProvider_1 = AddonBlockTimelineProvider;
    /**
     * Get calendar action events for the given course.
     *
     * @param {number} courseId Only events in this course.
     * @param {number} [afterEventId] The last seen event id.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{events: any[], canLoadMore: number}>} Promise resolved when the info is retrieved.
     */
    AddonBlockTimelineProvider.prototype.getActionEventsByCourse = function (courseId, afterEventId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var time = __WEBPACK_IMPORTED_MODULE_3_moment__().subtract(14, 'days').unix(), // Check two weeks ago.
            data = {
                timesortfrom: time,
                courseid: courseId,
                limitnum: AddonBlockTimelineProvider_1.EVENTS_LIMIT_PER_COURSE
            }, preSets = {
                cacheKey: _this.getActionEventsByCourseCacheKey(courseId)
            };
            if (afterEventId) {
                data.aftereventid = afterEventId;
            }
            return site.read('core_calendar_get_action_events_by_course', data, preSets).then(function (courseEvents) {
                if (courseEvents && courseEvents.events) {
                    return _this.treatCourseEvents(courseEvents, time);
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get calendar action events for the given course value WS call.
     *
     * @param {number} courseId Only events in this course.
     * @return {string} Cache key.
     */
    AddonBlockTimelineProvider.prototype.getActionEventsByCourseCacheKey = function (courseId) {
        return this.getActionEventsByCoursesCacheKey() + ':' + courseId;
    };
    /**
     * Get calendar action events for a given list of courses.
     *
     * @param {number[]} courseIds Course IDs.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{[s: string]: {events: any[], canLoadMore: number}}>} Promise resolved when the info is retrieved.
     */
    AddonBlockTimelineProvider.prototype.getActionEventsByCourses = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var time = __WEBPACK_IMPORTED_MODULE_3_moment__().subtract(14, 'days').unix(), // Check two weeks ago.
            data = {
                timesortfrom: time,
                courseids: courseIds,
                limitnum: AddonBlockTimelineProvider_1.EVENTS_LIMIT_PER_COURSE
            }, preSets = {
                cacheKey: _this.getActionEventsByCoursesCacheKey()
            };
            return site.read('core_calendar_get_action_events_by_courses', data, preSets).then(function (events) {
                if (events && events.groupedbycourse) {
                    var courseEvents_1 = {};
                    events.groupedbycourse.forEach(function (course) {
                        courseEvents_1[course.courseid] = _this.treatCourseEvents(course, time);
                    });
                    return courseEvents_1;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get calendar action events for a given list of courses value WS call.
     *
     * @return {string} Cache key.
     */
    AddonBlockTimelineProvider.prototype.getActionEventsByCoursesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'bycourse';
    };
    /**
     * Get calendar action events based on the timesort value.
     *
     * @param {number} [afterEventId] The last seen event id.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{events: any[], canLoadMore: number}>} Promise resolved when the info is retrieved.
     */
    AddonBlockTimelineProvider.prototype.getActionEventsByTimesort = function (afterEventId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var time = __WEBPACK_IMPORTED_MODULE_3_moment__().subtract(14, 'days').unix(), // Check two weeks ago.
            data = {
                timesortfrom: time,
                limitnum: AddonBlockTimelineProvider_1.EVENTS_LIMIT
            }, preSets = {
                cacheKey: _this.getActionEventsByTimesortCacheKey(afterEventId, data.limitnum),
                getCacheUsingCacheKey: true,
                uniqueCacheKey: true
            };
            if (afterEventId) {
                data.aftereventid = afterEventId;
            }
            return site.read('core_calendar_get_action_events_by_timesort', data, preSets).then(function (events) {
                if (events && events.events) {
                    var canLoadMore = events.events.length >= data.limitnum ? events.lastid : undefined;
                    // Filter events by time in case it uses cache.
                    events = events.events.filter(function (element) {
                        return element.timesort >= time;
                    });
                    return {
                        events: events,
                        canLoadMore: canLoadMore
                    };
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get prefix cache key for calendar action events based on the timesort value WS calls.
     *
     * @return {string} Cache key.
     */
    AddonBlockTimelineProvider.prototype.getActionEventsByTimesortPrefixCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'bytimesort:';
    };
    /**
     * Get cache key for get calendar action events based on the timesort value WS call.
     *
     * @param {number} [afterEventId] The last seen event id.
     * @param {number} [limit] Limit num of the call.
     * @return {string} Cache key.
     */
    AddonBlockTimelineProvider.prototype.getActionEventsByTimesortCacheKey = function (afterEventId, limit) {
        afterEventId = afterEventId || 0;
        limit = limit || 0;
        return this.getActionEventsByTimesortPrefixCacheKey() + afterEventId + ':' + limit;
    };
    /**
     * Invalidates get calendar action events for a given list of courses WS call.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonBlockTimelineProvider.prototype.invalidateActionEventsByCourses = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getActionEventsByCoursesCacheKey());
        });
    };
    /**
     * Invalidates get calendar action events based on the timesort value WS call.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonBlockTimelineProvider.prototype.invalidateActionEventsByTimesort = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getActionEventsByTimesortPrefixCacheKey());
        });
    };
    /**
     * Returns whether or not My Overview is available for a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if available, resolved with false or rejected otherwise.
     */
    AddonBlockTimelineProvider.prototype.isAvailable = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // First check if dashboard is disabled.
            if (_this.dashboardProvider.isDisabledInSite(site)) {
                return false;
            }
            return site.wsAvailable('core_calendar_get_action_events_by_courses') &&
                site.wsAvailable('core_calendar_get_action_events_by_timesort');
        });
    };
    /**
     * Handles course events, filtering and treating if more can be loaded.
     *
     * @param {any} course Object containing response course events info.
     * @param {number} timeFrom Current time to filter events from.
     * @return {{events: any[], canLoadMore: number}} Object with course events and last loaded event id if more can be loaded.
     */
    AddonBlockTimelineProvider.prototype.treatCourseEvents = function (course, timeFrom) {
        var canLoadMore = course.events.length >= AddonBlockTimelineProvider_1.EVENTS_LIMIT_PER_COURSE ? course.lastid : undefined;
        // Filter events by time in case it uses cache.
        course.events = course.events.filter(function (element) {
            return element.timesort >= timeFrom;
        });
        return {
            events: course.events,
            canLoadMore: canLoadMore
        };
    };
    AddonBlockTimelineProvider.EVENTS_LIMIT = 20;
    AddonBlockTimelineProvider.EVENTS_LIMIT_PER_COURSE = 10;
    AddonBlockTimelineProvider = AddonBlockTimelineProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_dashboard__["a" /* CoreCoursesDashboardProvider */]])
    ], AddonBlockTimelineProvider);
    return AddonBlockTimelineProvider;
    var AddonBlockTimelineProvider_1;
}());

//# sourceMappingURL=timeline.js.map

/***/ }),
/* 296 */,
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderType_CoreRichTextEditorComponent; });
/* harmony export (immutable) */ __webpack_exports__["b"] = View_CoreRichTextEditorComponent_0;
/* unused harmony export View_CoreRichTextEditorComponent_Host_0 */
/* unused harmony export CoreRichTextEditorComponentNgFactory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__ = __webpack_require__(368);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__icon_icon__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core_src_translate_pipe__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ngx_translate_core_src_translate_service__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__node_modules_ionic_angular_components_input_input_ngfactory__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ionic_angular_components_input_input__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_ionic_angular_platform_platform__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_ionic_angular_util_form__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ionic_angular_components_app_app__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_ionic_angular_components_content_content__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_ionic_angular_components_item_item__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__angular_forms__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_ionic_angular_platform_dom_controller__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__rich_text_editor__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_utils_utils__ = __webpack_require__(2);
/**
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 *
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
 * tslint:disable
 */ 























var styles_CoreRichTextEditorComponent = [];
var RenderType_CoreRichTextEditorComponent = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_29" /* ɵcrt */]({ encapsulation: 2, styles: styles_CoreRichTextEditorComponent, data: {} });

function View_CoreRichTextEditorComponent_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](402653184, 1, { editor: 0 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](402653184, 2, { textarea: 0 }), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_52" /* ɵqud */](402653184, 3, { decorate: 0 }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](3, 0, null, null, 76, "div", [], [[8, "hidden", 0]], null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](5, 0, [[1, 0], ["editor", 1]], null, 1, "div", [["class", "core-rte-editor"], ["contenteditable", "true"], ["role", "textbox"], ["tappable", ""]], [[1, "data-placeholder-text", 0]], null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](9, 0, [[3, 0], ["decorate", 1]], null, 69, "div", [["class", "core-rte-toolbar"]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](11, 0, null, null, 66, "div", [["class", "core-rte-buttons"]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](13, 0, null, null, 3, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "bold") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](14, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](15, 0, null, null, 1, "core-icon", [["name", "fa-bold"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](16, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](18, 0, null, null, 3, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "italic") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](19, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](20, 0, null, null, 1, "core-icon", [["name", "fa-italic"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](21, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](23, 0, null, null, 3, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "underline") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](24, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](25, 0, null, null, 1, "core-icon", [["name", "fa-underline"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](26, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](28, 0, null, null, 3, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "strikeThrough") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](29, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](30, 0, null, null, 1, "core-icon", [["name", "fa-strikethrough"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](31, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](33, 0, null, null, 3, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "formatBlock|<p>") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](34, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](35, 0, null, null, 1, "core-icon", [["name", "fa-paragraph"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](36, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](38, 0, null, null, 4, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "formatBlock|<h1>") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](39, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](40, 0, null, null, 1, "core-icon", [["name", "fa-header"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](41, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["1"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](44, 0, null, null, 4, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "formatBlock|<h2>") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](45, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](46, 0, null, null, 1, "core-icon", [["name", "fa-header"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](47, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["2"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](50, 0, null, null, 4, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "formatBlock|<h3>") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](51, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](52, 0, null, null, 1, "core-icon", [["name", "fa-header"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](53, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["3"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](56, 0, null, null, 3, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "insertUnorderedList") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](57, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](58, 0, null, null, 1, "core-icon", [["name", "fa-list-ul"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](59, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](61, 0, null, null, 3, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "insertOrderedList") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](62, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](63, 0, null, null, 1, "core-icon", [["name", "fa-list-ol"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](64, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](66, 0, null, null, 3, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.buttonAction($event, "removeFormat") !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](67, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](68, 0, null, null, 1, "core-icon", [["name", "fa-eraser"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](69, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](71, 0, null, null, 5, "button", [], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.toggleEditor($event) !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](72, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](73, 0, null, null, 1, "core-icon", [["name", "fa-code"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](74, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](75, null, [" ", ""])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_47" /* ɵpid */](131072, __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core_src_translate_pipe__["a" /* TranslatePipe */], [__WEBPACK_IMPORTED_MODULE_6__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */]]), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](81, 0, null, null, 17, "div", [], [[8, "hidden", 0]], null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](83, 0, null, null, 1, "ion-textarea", [["class", "core-textarea"], ["ngControl", "control"], ["role", "textbox"]], [[1, "name", 0]], [[null, "ionChange"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("ionChange" === en)) {
        var pd_0 = (_co.onChange($event) !== false);
        ad = (pd_0 && ad);
    } return ad; }, __WEBPACK_IMPORTED_MODULE_7__node_modules_ionic_angular_components_input_input_ngfactory__["b" /* View_TextInput_0 */], __WEBPACK_IMPORTED_MODULE_7__node_modules_ionic_angular_components_input_input_ngfactory__["a" /* RenderType_TextInput */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](84, 5423104, [[2, 4], ["textarea", 4]], 0, __WEBPACK_IMPORTED_MODULE_8_ionic_angular_components_input_input__["a" /* TextInput */], [__WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */], __WEBPACK_IMPORTED_MODULE_9_ionic_angular_platform_platform__["a" /* Platform */], __WEBPACK_IMPORTED_MODULE_10_ionic_angular_util_form__["a" /* Form */], __WEBPACK_IMPORTED_MODULE_11_ionic_angular_components_app_app__["a" /* App */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["V" /* Renderer */], [2, __WEBPACK_IMPORTED_MODULE_12_ionic_angular_components_content_content__["a" /* Content */]], [2, __WEBPACK_IMPORTED_MODULE_13_ionic_angular_components_item_item__["a" /* Item */]], [2, __WEBPACK_IMPORTED_MODULE_14__angular_forms__["m" /* NgControl */]], __WEBPACK_IMPORTED_MODULE_15_ionic_angular_platform_dom_controller__["a" /* DomController */]], { placeholder: [0, "placeholder"] }, { ionChange: "ionChange" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](86, 0, null, null, 11, "div", [["class", "core-rte-toolbar"]], [[8, "hidden", 0]], null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](88, 0, [[3, 0], ["decorate", 1]], null, 8, "div", [["class", "core-rte-buttons"]], null, null, null, null, null)), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n            "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](90, 0, null, null, 5, "button", [["tappable", ""]], null, [[null, "onClick"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if (("onClick" === en)) {
        var pd_0 = (_co.toggleEditor($event) !== false);
        ad = (pd_0 && ad);
    } return ad; }, null, null)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](91, 81920, null, 0, __WEBPACK_IMPORTED_MODULE_1__directives_supress_events__["a" /* CoreSupressEventsDirective */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]], null, { onClick: "onClick" }), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](92, 0, null, null, 1, "core-icon", [["name", "fa-pencil-square-o"]], null, null, null, __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["b" /* View_CoreIconComponent_0 */], __WEBPACK_IMPORTED_MODULE_2__icon_icon_ngfactory__["a" /* RenderType_CoreIconComponent */])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](93, 704512, null, 0, __WEBPACK_IMPORTED_MODULE_3__icon_icon__["a" /* CoreIconComponent */], [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular_config_config__["a" /* Config */]], { name: [0, "name"] }, null), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](94, null, [" ", ""])), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_47" /* ɵpid */](131072, __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core_src_translate_pipe__["a" /* TranslatePipe */], [__WEBPACK_IMPORTED_MODULE_6__ngx_translate_core_src_translate_service__["a" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */]]), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n        "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n    "])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n"])), (_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_55" /* ɵted */](-1, null, ["\n\n\n"]))], function (_ck, _v) { var _co = _v.component; _ck(_v, 14, 0); var currVal_2 = "fa-bold"; _ck(_v, 16, 0, currVal_2); _ck(_v, 19, 0); var currVal_3 = "fa-italic"; _ck(_v, 21, 0, currVal_3); _ck(_v, 24, 0); var currVal_4 = "fa-underline"; _ck(_v, 26, 0, currVal_4); _ck(_v, 29, 0); var currVal_5 = "fa-strikethrough"; _ck(_v, 31, 0, currVal_5); _ck(_v, 34, 0); var currVal_6 = "fa-paragraph"; _ck(_v, 36, 0, currVal_6); _ck(_v, 39, 0); var currVal_7 = "fa-header"; _ck(_v, 41, 0, currVal_7); _ck(_v, 45, 0); var currVal_8 = "fa-header"; _ck(_v, 47, 0, currVal_8); _ck(_v, 51, 0); var currVal_9 = "fa-header"; _ck(_v, 53, 0, currVal_9); _ck(_v, 57, 0); var currVal_10 = "fa-list-ul"; _ck(_v, 59, 0, currVal_10); _ck(_v, 62, 0); var currVal_11 = "fa-list-ol"; _ck(_v, 64, 0, currVal_11); _ck(_v, 67, 0); var currVal_12 = "fa-eraser"; _ck(_v, 69, 0, currVal_12); _ck(_v, 72, 0); var currVal_13 = "fa-code"; _ck(_v, 74, 0, currVal_13); var currVal_17 = _co.placeholder; _ck(_v, 84, 0, currVal_17); _ck(_v, 91, 0); var currVal_19 = "fa-pencil-square-o"; _ck(_v, 93, 0, currVal_19); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.rteEnabled; _ck(_v, 3, 0, currVal_0); var currVal_1 = _co.placeholder; _ck(_v, 5, 0, currVal_1); var currVal_14 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_56" /* ɵunv */](_v, 75, 0, __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 76).transform("core.viewcode")); _ck(_v, 75, 0, currVal_14); var currVal_15 = _co.rteEnabled; _ck(_v, 81, 0, currVal_15); var currVal_16 = _co.name; _ck(_v, 83, 0, currVal_16); var currVal_18 = !_co.editorSupported; _ck(_v, 86, 0, currVal_18); var currVal_20 = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_56" /* ɵunv */](_v, 94, 0, __WEBPACK_IMPORTED_MODULE_0__angular_core__["_44" /* ɵnov */](_v, 95).transform("core.vieweditor")); _ck(_v, 94, 0, currVal_20); }); }
function View_CoreRichTextEditorComponent_Host_0(_l) { return __WEBPACK_IMPORTED_MODULE_0__angular_core__["_57" /* ɵvid */](0, [(_l()(), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_31" /* ɵeld */](0, 0, null, null, 1, "core-rich-text-editor", [], null, null, null, View_CoreRichTextEditorComponent_0, RenderType_CoreRichTextEditorComponent)), __WEBPACK_IMPORTED_MODULE_0__angular_core__["_30" /* ɵdid */](1, 1228800, null, 0, __WEBPACK_IMPORTED_MODULE_16__rich_text_editor__["a" /* CoreRichTextEditorComponent */], [__WEBPACK_IMPORTED_MODULE_17__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_18__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_19__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_20__providers_filepool__["a" /* CoreFilepoolProvider */], [2, __WEBPACK_IMPORTED_MODULE_12_ionic_angular_components_content_content__["a" /* Content */]], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_21__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_22__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9_ionic_angular_platform_platform__["a" /* Platform */]], null, null)], null, null); }
var CoreRichTextEditorComponentNgFactory = __WEBPACK_IMPORTED_MODULE_0__angular_core__["_27" /* ɵccf */]("core-rich-text-editor", __WEBPACK_IMPORTED_MODULE_16__rich_text_editor__["a" /* CoreRichTextEditorComponent */], View_CoreRichTextEditorComponent_Host_0, { placeholder: "placeholder", control: "control", name: "name", component: "component", componentId: "componentId" }, { contentChanged: "contentChanged" }, []);

//# sourceMappingURL=rich-text-editor.ngfactory.js.map

/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDateDayOrTimePipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Filter to display a date using the day, or the time.
 *
 * This shows a short version of a date. Use this filter when you want
 * the user to visualise when the action was done relatively to today's date.
 *
 * For instance, if the action happened during this day it will display the time,
 * but when the action happened few days ago, it will display the day of the week.
 *
 * The older the date is, the more information about it will be displayed.
 *
 * This filter expects a timestamp NOT including milliseconds.
 */
var CoreDateDayOrTimePipe = /** @class */ (function () {
    function CoreDateDayOrTimePipe(logger, translate, timeUtils) {
        this.translate = translate;
        this.timeUtils = timeUtils;
        this.logger = logger.getInstance('CoreDateDayOrTimePipe');
    }
    /**
     * Format a timestamp.
     *
     * @param {number|string} timestamp The UNIX timestamp (without milliseconds).
     * @return {string} Formatted time.
     */
    CoreDateDayOrTimePipe.prototype.transform = function (timestamp) {
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        return __WEBPACK_IMPORTED_MODULE_4_moment__(timestamp * 1000).calendar(null, {
            sameDay: this.timeUtils.convertPHPToMoment(this.translate.instant('core.strftimetime')),
            lastDay: this.translate.instant('core.dflastweekdate'),
            lastWeek: this.translate.instant('core.dflastweekdate'),
            sameElse: this.timeUtils.convertPHPToMoment(this.translate.instant('core.strftimedatefullshort'))
        });
    };
    CoreDateDayOrTimePipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreDateDayOrTime',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_time__["a" /* CoreTimeUtilsProvider */]])
    ], CoreDateDayOrTimePipe);
    return CoreDateDayOrTimePipe;
}());

//# sourceMappingURL=date-day-or-time.js.map

/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModAssignSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_grades_providers_helper__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__classes_base_sync__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__assign__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__assign_offline__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__submission_delegate__ = __webpack_require__(153);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

















/**
 * Service to sync assigns.
 */
var AddonModAssignSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModAssignSyncProvider, _super);
    function AddonModAssignSyncProvider(loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, courseProvider, eventsProvider, assignProvider, assignOfflineProvider, utils, submissionDelegate, gradesHelper, timeUtils, logHelper) {
        var _this = _super.call(this, 'AddonModAssignSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils) || this;
        _this.courseProvider = courseProvider;
        _this.eventsProvider = eventsProvider;
        _this.assignProvider = assignProvider;
        _this.assignOfflineProvider = assignOfflineProvider;
        _this.utils = utils;
        _this.submissionDelegate = submissionDelegate;
        _this.gradesHelper = gradesHelper;
        _this.logHelper = logHelper;
        _this.componentTranslate = courseProvider.translateModuleName('assign');
        return _this;
    }
    AddonModAssignSyncProvider_1 = AddonModAssignSyncProvider;
    /**
     * Convenience function to get scale selected option.
     *
     * @param {string} options Possible options.
     * @param {number} selected Selected option to search.
     * @return {number} Index of the selected option.
     */
    AddonModAssignSyncProvider.prototype.getSelectedScaleId = function (options, selected) {
        var optionsList = options.split(',');
        optionsList = optionsList.map(function (value) {
            return value.trim();
        });
        optionsList.unshift('');
        var index = options.indexOf(selected) || 0;
        if (index < 0) {
            return 0;
        }
        return index;
    };
    /**
     * Check if an assignment has data to synchronize.
     *
     * @param {number} assignId Assign ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether it has data to sync.
     */
    AddonModAssignSyncProvider.prototype.hasDataToSync = function (assignId, siteId) {
        return this.assignOfflineProvider.hasAssignOfflineData(assignId, siteId);
    };
    /**
     * Try to synchronize all the assignments in a certain site or in all sites.
     *
     * @param {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} force Wether to force sync not depending on last execution.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModAssignSyncProvider.prototype.syncAllAssignments = function (siteId, force) {
        return this.syncOnSites('all assignments', this.syncAllAssignmentsFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all assignments on a site.
     *
     * @param {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @param {Promise<any>} Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModAssignSyncProvider.prototype.syncAllAssignmentsFunc = function (siteId, force) {
        var _this = this;
        // Get all assignments that have offline data.
        return this.assignOfflineProvider.getAllAssigns(siteId).then(function (assignIds) {
            // Sync all assignments that haven't been synced for a while.
            var promises = assignIds.map(function (assignId) {
                var promise = force ? _this.syncAssign(assignId, siteId) : _this.syncAssignIfNeeded(assignId, siteId);
                return promise.then(function (data) {
                    if (data && data.updated) {
                        // Sync done. Send event.
                        _this.eventsProvider.trigger(AddonModAssignSyncProvider_1.AUTO_SYNCED, {
                            assignId: assignId,
                            warnings: data.warnings
                        }, siteId);
                    }
                });
            });
            return Promise.all(promises);
        });
    };
    /**
     * Sync an assignment only if a certain time has passed since the last time.
     *
     * @param {number} assignId Assign ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void|AddonModAssignSyncResult>} Promise resolved when the assign is synced or it doesn't need to be synced.
     */
    AddonModAssignSyncProvider.prototype.syncAssignIfNeeded = function (assignId, siteId) {
        var _this = this;
        return this.isSyncNeeded(assignId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncAssign(assignId, siteId);
            }
        });
    };
    /**
     * Try to synchronize an assign.
     *
     * @param {number} assignId Assign ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<AddonModAssignSyncResult>} Promise resolved in success.
     */
    AddonModAssignSyncProvider.prototype.syncAssign = function (assignId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [], result = {
            warnings: [],
            updated: false
        };
        var assign, courseId, syncPromise;
        if (this.isSyncing(assignId, siteId)) {
            // There's already a sync ongoing for this assign, return the promise.
            return this.getOngoingSync(assignId, siteId);
        }
        // Verify that assign isn't blocked.
        if (this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_14__assign__["a" /* AddonModAssignProvider */].COMPONENT, assignId, siteId)) {
            this.logger.debug('Cannot sync assign ' + assignId + ' because it is blocked.');
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        this.logger.debug('Try to sync assign ' + assignId + ' in site ' + siteId);
        // Get offline submissions to be sent.
        promises.push(this.assignOfflineProvider.getAssignSubmissions(assignId, siteId).catch(function () {
            // No offline data found, return empty array.
            return [];
        }));
        // Get offline submission grades to be sent.
        promises.push(this.assignOfflineProvider.getAssignSubmissionsGrade(assignId, siteId).catch(function () {
            // No offline data found, return empty array.
            return [];
        }));
        // Sync offline logs.
        promises.push(this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_14__assign__["a" /* AddonModAssignProvider */].COMPONENT, assignId, siteId));
        syncPromise = Promise.all(promises).then(function (results) {
            var submissions = results[0], grades = results[1];
            if (!submissions.length && !grades.length) {
                // Nothing to sync.
                return;
            }
            else if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(null);
            }
            courseId = submissions.length > 0 ? submissions[0].courseid : grades[0].courseid;
            return _this.assignProvider.getAssignmentById(courseId, assignId, false, siteId).then(function (assignData) {
                assign = assignData;
                var promises = [];
                submissions.forEach(function (submission) {
                    promises.push(_this.syncSubmission(assign, submission, result.warnings, siteId).then(function () {
                        result.updated = true;
                    }));
                });
                grades.forEach(function (grade) {
                    promises.push(_this.syncSubmissionGrade(assign, grade, result.warnings, courseId, siteId).then(function () {
                        result.updated = true;
                    }));
                });
                return Promise.all(promises);
            }).then(function () {
                if (result.updated) {
                    // Data has been sent to server. Now invalidate the WS calls.
                    return _this.assignProvider.invalidateContent(assign.cmid, courseId, siteId).catch(function () {
                        // Ignore errors.
                    });
                }
            });
        }).then(function () {
            // Sync finished, set sync time.
            return _this.setSyncTime(assignId, siteId).catch(function () {
                // Ignore errors.
            });
        }).then(function () {
            // All done, return the result.
            return result;
        });
        return this.addOngoingSync(assignId, syncPromise, siteId);
    };
    /**
     * Synchronize a submission.
     *
     * @param {any} assign Assignment.
     * @param {any} offlineData Submission offline data.
     * @param {string[]} warnings List of warnings.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if success, rejected otherwise.
     */
    AddonModAssignSyncProvider.prototype.syncSubmission = function (assign, offlineData, warnings, siteId) {
        var _this = this;
        var userId = offlineData.userid, pluginData = {};
        var discardError, submission;
        return this.assignProvider.getSubmissionStatus(assign.id, userId, undefined, false, true, true, siteId).then(function (status) {
            var promises = [];
            submission = _this.assignProvider.getSubmissionObjectFromAttempt(assign, status.lastattempt);
            if (submission.timemodified != offlineData.onlinetimemodified) {
                // The submission was modified in Moodle, discard the submission.
                discardError = _this.translate.instant('addon.mod_assign.warningsubmissionmodified');
                return;
            }
            submission.plugins.forEach(function (plugin) {
                promises.push(_this.submissionDelegate.preparePluginSyncData(assign, submission, plugin, offlineData, pluginData, siteId));
            });
            return Promise.all(promises).then(function () {
                // Now save the submission.
                var promise;
                if (!Object.keys(pluginData).length) {
                    // Nothing to save.
                    promise = Promise.resolve();
                }
                else {
                    promise = _this.assignProvider.saveSubmissionOnline(assign.id, pluginData, siteId);
                }
                return promise.then(function () {
                    if (assign.submissiondrafts && offlineData.submitted) {
                        // The user submitted the assign manually. Submit it for grading.
                        return _this.assignProvider.submitForGradingOnline(assign.id, offlineData.submissionstatement, siteId);
                    }
                }).then(function () {
                    // Submission data sent, update cached data. No need to block the user for this.
                    _this.assignProvider.getSubmissionStatus(assign.id, userId, undefined, false, true, true, siteId);
                });
            }).catch(function (error) {
                if (error && _this.utils.isWebServiceError(error)) {
                    // A WebService has thrown an error, this means it cannot be submitted. Discard the submission.
                    discardError = _this.textUtils.getErrorMessageFromError(error);
                }
                else {
                    // Couldn't connect to server, reject.
                    return Promise.reject(error);
                }
            });
        }).then(function () {
            // Delete the offline data.
            return _this.assignOfflineProvider.deleteSubmission(assign.id, userId, siteId).then(function () {
                var promises = [];
                submission.plugins.forEach(function (plugin) {
                    promises.push(_this.submissionDelegate.deletePluginOfflineData(assign, submission, plugin, offlineData, siteId));
                });
                return Promise.all(promises);
            });
        }).then(function () {
            if (discardError) {
                // Submission was discarded, add a warning.
                var message = _this.translate.instant('core.warningofflinedatadeleted', {
                    component: _this.componentTranslate,
                    name: assign.name,
                    error: discardError
                });
                if (warnings.indexOf(message) == -1) {
                    warnings.push(message);
                }
            }
        });
    };
    /**
     * Synchronize a submission grade.
     *
     * @param {any} assign Assignment.
     * @param {any} offlineData Submission grade offline data.
     * @param {string[]} warnings List of warnings.
     * @param {number} courseId Course Id.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if success, rejected otherwise.
     */
    AddonModAssignSyncProvider.prototype.syncSubmissionGrade = function (assign, offlineData, warnings, courseId, siteId) {
        var _this = this;
        var userId = offlineData.userid;
        var discardError;
        return this.assignProvider.getSubmissionStatus(assign.id, userId, undefined, false, true, true, siteId).then(function (status) {
            var timemodified = status.feedback && (status.feedback.gradeddate || status.feedback.grade.timemodified);
            if (timemodified > offlineData.timemodified) {
                // The submission grade was modified in Moodle, discard it.
                discardError = _this.translate.instant('addon.mod_assign.warningsubmissiongrademodified');
                return;
            }
            // If grade has been modified from gradebook, do not use offline.
            return _this.gradesHelper.getGradeModuleItems(courseId, assign.cmid, userId, undefined, siteId, true).then(function (grades) {
                return _this.courseProvider.getModuleBasicGradeInfo(assign.cmid, siteId).then(function (gradeInfo) {
                    // Override offline grade and outcomes based on the gradebook data.
                    grades.forEach(function (grade) {
                        if (grade.gradedategraded >= offlineData.timemodified) {
                            if (!grade.outcomeid && !grade.scaleid) {
                                if (gradeInfo && gradeInfo.scale) {
                                    offlineData.grade = _this.getSelectedScaleId(gradeInfo.scale, grade.gradeformatted);
                                }
                                else {
                                    offlineData.grade = parseFloat(grade.gradeformatted) || null;
                                }
                            }
                            else if (grade.outcomeid && _this.assignProvider.isOutcomesEditEnabled() && gradeInfo.outcomes) {
                                gradeInfo.outcomes.forEach(function (outcome, index) {
                                    if (outcome.scale && grade.itemnumber == index) {
                                        offlineData.outcomes[grade.itemnumber] = _this.getSelectedScaleId(outcome.scale, outcome.selected);
                                    }
                                });
                            }
                        }
                    });
                });
            }).then(function () {
                // Now submit the grade.
                return _this.assignProvider.submitGradingFormOnline(assign.id, userId, offlineData.grade, offlineData.attemptnumber, offlineData.addattempt, offlineData.workflowstate, offlineData.applytoall, offlineData.outcomes, offlineData.plugindata, siteId).then(function () {
                    // Grades sent, update cached data. No need to block the user for this.
                    _this.assignProvider.getSubmissionStatus(assign.id, userId, undefined, false, true, true, siteId);
                }).catch(function (error) {
                    if (error && _this.utils.isWebServiceError(error)) {
                        // The WebService has thrown an error, this means it cannot be submitted. Discard the offline data.
                        discardError = _this.textUtils.getErrorMessageFromError(error);
                    }
                    else {
                        // Couldn't connect to server, reject.
                        return Promise.reject(error);
                    }
                });
            });
        }).then(function () {
            // Delete the offline data.
            return _this.assignOfflineProvider.deleteSubmissionGrade(assign.id, userId, siteId);
        }).then(function () {
            if (discardError) {
                // Submission grade was discarded, add a warning.
                var message = _this.translate.instant('core.warningofflinedatadeleted', {
                    component: _this.componentTranslate,
                    name: assign.name,
                    error: discardError
                });
                if (warnings.indexOf(message) == -1) {
                    warnings.push(message);
                }
            }
        });
    };
    AddonModAssignSyncProvider.AUTO_SYNCED = 'addon_mod_assign_autom_synced';
    AddonModAssignSyncProvider = AddonModAssignSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_10__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_14__assign__["a" /* AddonModAssignProvider */], __WEBPACK_IMPORTED_MODULE_15__assign_offline__["a" /* AddonModAssignOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_16__submission_delegate__["a" /* AddonModAssignSubmissionDelegate */],
            __WEBPACK_IMPORTED_MODULE_12__core_grades_providers_helper__["a" /* CoreGradesHelperProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModAssignSyncProvider);
    return AddonModAssignSyncProvider;
    var AddonModAssignSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_13__classes_base_sync__["a" /* CoreSyncBaseProvider */]));

//# sourceMappingURL=assign-sync.js.map

/***/ }),
/* 300 */,
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreAttachmentsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_fileuploader_providers_fileuploader__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_fileuploader_providers_helper__ = __webpack_require__(139);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Component to render attachments, allow adding more and delete the current ones.
 *
 * All the changes done will be applied to the "files" input array, no file will be uploaded. The component using this
 * component should be the one uploading and moving the files.
 *
 * All the files added will be copied to the app temporary folder, so they should be deleted after uploading them
 * or if the user cancels the action.
 *
 * <core-attachments [files]="files" [maxSize]="configs.maxsubmissionsizebytes" [maxSubmissions]="configs.maxfilesubmissions"
 *     [component]="component" [componentId]="assign.cmid" [acceptedTypes]="configs.filetypeslist" [allowOffline]="allowOffline">
 * </core-attachments>
 */
var CoreAttachmentsComponent = /** @class */ (function () {
    function CoreAttachmentsComponent(appProvider, domUtils, textUtils, fileUploaderProvider, translate, fileUploaderHelper) {
        this.appProvider = appProvider;
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        this.fileUploaderProvider = fileUploaderProvider;
        this.translate = translate;
        this.fileUploaderHelper = fileUploaderHelper;
    }
    /**
     * Component being initialized.
     */
    CoreAttachmentsComponent.prototype.ngOnInit = function () {
        this.maxSize = Number(this.maxSize); // Make sure it's defined and it's a number.
        this.maxSize = !isNaN(this.maxSize) && this.maxSize > 0 ? this.maxSize : -1;
        if (this.maxSize == -1) {
            this.maxSizeReadable = this.translate.instant('core.unknown');
        }
        else {
            this.maxSizeReadable = this.textUtils.bytesToSize(this.maxSize, 2);
        }
        if (typeof this.maxSubmissions == 'undefined' || this.maxSubmissions < 0) {
            this.maxSubmissionsReadable = this.translate.instant('core.unknown');
            this.unlimitedFiles = true;
        }
        else {
            this.maxSubmissionsReadable = String(this.maxSubmissions);
        }
        this.acceptedTypes = this.acceptedTypes && this.acceptedTypes.trim();
        if (this.acceptedTypes && this.acceptedTypes != '*') {
            this.fileTypes = this.fileUploaderProvider.prepareFiletypeList(this.acceptedTypes);
        }
    };
    /**
     * Add a new attachment.
     */
    CoreAttachmentsComponent.prototype.add = function () {
        var _this = this;
        var allowOffline = this.allowOffline && this.allowOffline !== 'false';
        if (!allowOffline && !this.appProvider.isOnline()) {
            this.domUtils.showErrorModal('core.fileuploader.errormustbeonlinetoupload', true);
        }
        else {
            var mimetypes = this.fileTypes && this.fileTypes.mimetypes;
            this.fileUploaderHelper.selectFile(this.maxSize, allowOffline, undefined, mimetypes).then(function (result) {
                _this.files.push(result);
            }).catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'Error selecting file.');
            });
        }
    };
    /**
     * Delete a file from the list.
     *
     * @param {number} index The index of the file.
     * @param {boolean} [askConfirm] Whether to ask confirm.
     */
    CoreAttachmentsComponent.prototype.delete = function (index, askConfirm) {
        var _this = this;
        var promise;
        if (askConfirm) {
            promise = this.domUtils.showConfirm(this.translate.instant('core.confirmdeletefile'));
        }
        else {
            promise = Promise.resolve();
        }
        promise.then(function () {
            // Remove the file from the list.
            _this.files.splice(index, 1);
        }).catch(function () {
            // User cancelled.
        });
    };
    /**
     * A file was renamed.
     *
     * @param {number} index Index of the file.
     * @param {any} data The data received.
     */
    CoreAttachmentsComponent.prototype.renamed = function (index, data) {
        this.files[index] = data.file;
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreAttachmentsComponent.prototype, "files", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreAttachmentsComponent.prototype, "maxSize", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreAttachmentsComponent.prototype, "maxSubmissions", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreAttachmentsComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreAttachmentsComponent.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreAttachmentsComponent.prototype, "allowOffline", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreAttachmentsComponent.prototype, "acceptedTypes", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreAttachmentsComponent.prototype, "required", void 0);
    CoreAttachmentsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-attachments',
            templateUrl: 'core-attachments.html'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__core_fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_6__core_fileuploader_providers_helper__["a" /* CoreFileUploaderHelperProvider */]])
    ], CoreAttachmentsComponent);
    return CoreAttachmentsComponent;
}());

//# sourceMappingURL=attachments.js.map

/***/ }),
/* 302 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreProgressBarComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(76);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to show a progress bar and its value.
 *
 * Example usage:
 * <core-progress-bar [progress]="percentage"></core-progress-bar>
 */
var CoreProgressBarComponent = /** @class */ (function () {
    function CoreProgressBarComponent(sanitizer) {
        this.sanitizer = sanitizer;
        this.textSupplied = false;
    }
    /**
     * Detect changes on input properties.
     */
    CoreProgressBarComponent.prototype.ngOnChanges = function (changes) {
        if (changes.text && typeof changes.text.currentValue != 'undefined') {
            // User provided a custom text, don't use default.
            this.textSupplied = true;
        }
        if (changes.progress) {
            // Progress has changed.
            if (typeof this.progress == 'string') {
                this.progress = parseInt(this.progress, 10);
            }
            if (this.progress < 0 || isNaN(this.progress)) {
                this.progress = -1;
            }
            if (this.progress != -1) {
                // Remove decimals.
                this.progress = Math.floor(this.progress);
                if (!this.textSupplied) {
                    this.text = String(this.progress);
                }
                this.width = this.sanitizer.bypassSecurityTrustStyle(this.progress + '%');
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreProgressBarComponent.prototype, "progress", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreProgressBarComponent.prototype, "text", void 0);
    CoreProgressBarComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-progress-bar',
            templateUrl: 'core-progress-bar.html',
            changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__["i" /* ChangeDetectionStrategy */].OnPush
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__["c" /* DomSanitizer */]])
    ], CoreProgressBarComponent);
    return CoreProgressBarComponent;
}());

//# sourceMappingURL=progress-bar.js.map

/***/ }),
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSettingsDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to interact with addons to be shown in app settings. Provides functions to register a plugin
 * and notify an update in the data.
 */
var CoreSettingsDelegate = /** @class */ (function (_super) {
    __extends(CoreSettingsDelegate, _super);
    function CoreSettingsDelegate(loggerProvider, sitesProvider, eventsProvider, utils) {
        var _this = _super.call(this, 'CoreSettingsDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.utils = utils;
        _this.siteHandlers = []; // Handlers to return.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGOUT, _this.clearSiteHandlers.bind(_this));
        return _this;
    }
    /**
     * Clear current site handlers. Reserved for core use.
     */
    CoreSettingsDelegate.prototype.clearSiteHandlers = function () {
        this.siteHandlers = [];
    };
    /**
     * Get the handlers for the current site.
     *
     * @return {CoreSettingsHandlerData[]}
     */
    CoreSettingsDelegate.prototype.getHandlers = function () {
        return this.siteHandlers;
    };
    /**
     * Update handlers Data.
     */
    CoreSettingsDelegate.prototype.updateData = function () {
        var handlersData = [];
        for (var name_1 in this.enabledHandlers) {
            var handler = this.enabledHandlers[name_1], data = handler.getDisplayData();
            handlersData.push({
                data: data,
                priority: handler.priority
            });
        }
        // Sort them by priority.
        handlersData.sort(function (a, b) {
            return b.priority - a.priority;
        });
        // Return only the display data.
        this.siteHandlers = handlersData.map(function (item) {
            return item.data;
        });
    };
    CoreSettingsDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreSettingsDelegate);
    return CoreSettingsDelegate;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 307 */,
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCommentsCommentsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_comments__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Component that displays the count of comments.
 */
var CoreCommentsCommentsComponent = /** @class */ (function () {
    function CoreCommentsCommentsComponent(navCtrl, commentsProvider, sitesProvider, eventsProvider) {
        var _this = this;
        this.navCtrl = navCtrl;
        this.commentsProvider = commentsProvider;
        this.area = '';
        this.page = 0;
        this.displaySpinner = true; // Whether to display the loading spinner.
        this.commentsLoaded = false;
        this.disabled = false;
        this.onLoading = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.disabled = this.commentsProvider.areCommentsDisabledInSite();
        // Update visibility if current site info is updated.
        this.updateSiteObserver = eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].SITE_UPDATED, function () {
            var wasDisabled = _this.disabled;
            _this.disabled = _this.commentsProvider.areCommentsDisabledInSite();
            if (wasDisabled && !_this.disabled) {
                _this.fetchData();
            }
        }, sitesProvider.getCurrentSiteId());
    }
    /**
     * View loaded.
     */
    CoreCommentsCommentsComponent.prototype.ngOnInit = function () {
        this.fetchData();
    };
    /**
     * Listen to changes.
     */
    CoreCommentsCommentsComponent.prototype.ngOnChanges = function (changes) {
        // If something change, update the fields.
        if (changes) {
            this.fetchData();
        }
    };
    CoreCommentsCommentsComponent.prototype.fetchData = function () {
        var _this = this;
        if (this.disabled) {
            return;
        }
        this.commentsLoaded = false;
        this.onLoading.emit(true);
        this.commentsProvider.getComments(this.contextLevel, this.instanceId, this.component, this.itemId, this.area, this.page)
            .then(function (comments) {
            _this.commentsCount = comments && comments.length ? comments.length : 0;
        }).catch(function () {
            _this.commentsCount = -1;
        }).finally(function () {
            _this.commentsLoaded = true;
            _this.onLoading.emit(false);
        });
    };
    /**
     * Opens the comments page.
     */
    CoreCommentsCommentsComponent.prototype.openComments = function () {
        if (!this.disabled && this.commentsCount > 0) {
            // Open a new state with the interpolated contents.
            this.navCtrl.push('CoreCommentsViewerPage', {
                contextLevel: this.contextLevel,
                instanceId: this.instanceId,
                component: this.component,
                itemId: this.itemId,
                area: this.area,
                page: this.page,
                title: this.title,
            });
        }
    };
    /**
     * Component destroyed.
     */
    CoreCommentsCommentsComponent.prototype.ngOnDestroy = function () {
        this.updateSiteObserver && this.updateSiteObserver.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCommentsCommentsComponent.prototype, "contextLevel", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreCommentsCommentsComponent.prototype, "instanceId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCommentsCommentsComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreCommentsCommentsComponent.prototype, "itemId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCommentsCommentsComponent.prototype, "area", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCommentsCommentsComponent.prototype, "page", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCommentsCommentsComponent.prototype, "title", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCommentsCommentsComponent.prototype, "displaySpinner", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreCommentsCommentsComponent.prototype, "onLoading", void 0);
    CoreCommentsCommentsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-comments',
            templateUrl: 'core-comments.html',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* NavController */], __WEBPACK_IMPORTED_MODULE_2__providers_comments__["a" /* CoreCommentsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreCommentsCommentsComponent);
    return CoreCommentsCommentsComponent;
}());

//# sourceMappingURL=comments.js.map

/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModDataSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__classes_base_sync__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__offline__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__data__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__helper__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_events__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_sync__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__core_rating_providers_sync__ = __webpack_require__(220);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

















/**
 * Service to sync databases.
 */
var AddonModDataSyncProvider = /** @class */ (function (_super) {
    __extends(AddonModDataSyncProvider, _super);
    function AddonModDataSyncProvider(sitesProvider, loggerProvider, appProvider, dataOffline, eventsProvider, dataProvider, translate, utils, courseProvider, syncProvider, textUtils, timeUtils, dataHelper, logHelper, ratingSync) {
        var _this = _super.call(this, 'AddonModDataSyncProvider', loggerProvider, sitesProvider, appProvider, syncProvider, textUtils, translate, timeUtils) || this;
        _this.sitesProvider = sitesProvider;
        _this.loggerProvider = loggerProvider;
        _this.appProvider = appProvider;
        _this.dataOffline = dataOffline;
        _this.eventsProvider = eventsProvider;
        _this.dataProvider = dataProvider;
        _this.translate = translate;
        _this.utils = utils;
        _this.textUtils = textUtils;
        _this.dataHelper = dataHelper;
        _this.logHelper = logHelper;
        _this.ratingSync = ratingSync;
        _this.componentTranslate = courseProvider.translateModuleName('data');
        return _this;
    }
    AddonModDataSyncProvider_1 = AddonModDataSyncProvider;
    /**
     * Check if a database has data to synchronize.
     *
     * @param  {number} dataId   Database ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>}         Promise resolved with boolean: true if has data to sync, false otherwise.
     */
    AddonModDataSyncProvider.prototype.hasDataToSync = function (dataId, siteId) {
        return this.dataOffline.hasOfflineData(dataId, siteId);
    };
    /**
     * Try to synchronize all the databases in a certain site or in all sites.
     *
     * @param  {string} [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} force Wether to force sync not depending on last execution.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModDataSyncProvider.prototype.syncAllDatabases = function (siteId, force) {
        return this.syncOnSites('all databases', this.syncAllDatabasesFunc.bind(this), [force], siteId);
    };
    /**
     * Sync all pending databases on a site.
     *
     * @param {string}  [siteId] Site ID to sync. If not defined, sync all sites.
     * @param {boolean} force    Wether to force sync not depending on last execution.
     * @param {Promise<any>}     Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonModDataSyncProvider.prototype.syncAllDatabasesFunc = function (siteId, force) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        // Get all data answers pending to be sent in the site.
        promises.push(this.dataOffline.getAllEntries(siteId).then(function (offlineActions) {
            var promises = {};
            // Do not sync same database twice.
            offlineActions.forEach(function (action) {
                if (typeof promises[action.dataid] != 'undefined') {
                    return;
                }
                promises[action.dataid] = force ? _this.syncDatabase(action.dataid, siteId) :
                    _this.syncDatabaseIfNeeded(action.dataid, siteId);
                promises[action.dataid].then(function (result) {
                    if (result && result.updated) {
                        // Sync done. Send event.
                        _this.eventsProvider.trigger(AddonModDataSyncProvider_1.AUTO_SYNCED, {
                            dataId: action.dataid,
                            warnings: result.warnings
                        }, siteId);
                    }
                });
            });
            // Promises will be an object so, convert to an array first;
            return Promise.all(_this.utils.objectToArray(promises));
        }));
        promises.push(this.syncRatings(undefined, force, siteId));
        return Promise.all(promises);
    };
    /**
     * Sync a database only if a certain time has passed since the last time.
     *
     * @param {number} dataId      Database ID.
     * @param {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise resolved when the data is synced or if it doesn't need to be synced.
     */
    AddonModDataSyncProvider.prototype.syncDatabaseIfNeeded = function (dataId, siteId) {
        var _this = this;
        return this.isSyncNeeded(dataId, siteId).then(function (needed) {
            if (needed) {
                return _this.syncDatabase(dataId, siteId);
            }
        });
    };
    /**
     * Synchronize a data.
     *
     * @param  {number} dataId Data ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModDataSyncProvider.prototype.syncDatabase = function (dataId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.isSyncing(dataId, siteId)) {
            // There's already a sync ongoing for this data and user, return the promise.
            return this.getOngoingSync(dataId, siteId);
        }
        // Verify that data isn't blocked.
        if (this.syncProvider.isBlocked(__WEBPACK_IMPORTED_MODULE_9__data__["a" /* AddonModDataProvider */].COMPONENT, dataId, siteId)) {
            this.logger.debug("Cannot sync database '" + dataId + "' because it is blocked.");
            return Promise.reject(this.translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }
        this.logger.debug("Try to sync data '" + dataId + "' in site " + siteId + "'");
        var courseId, data;
        var result = {
            warnings: [],
            updated: false
        };
        // Sync offline logs.
        var syncPromise = this.logHelper.syncIfNeeded(__WEBPACK_IMPORTED_MODULE_9__data__["a" /* AddonModDataProvider */].COMPONENT, dataId, siteId).catch(function () {
            // Ignore errors.
        }).then(function () {
            // Get answers to be sent.
            return _this.dataOffline.getDatabaseEntries(dataId, siteId).catch(function () {
                // No offline data found, return empty object.
                return [];
            });
        }).then(function (offlineActions) {
            if (!offlineActions.length) {
                // Nothing to sync.
                return;
            }
            if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline.
                return Promise.reject(null);
            }
            courseId = offlineActions[0].courseid;
            // Send the answers.
            return _this.dataProvider.getDatabaseById(courseId, dataId, siteId).then(function (database) {
                data = database;
                var offlineEntries = {};
                offlineActions.forEach(function (entry) {
                    if (typeof offlineEntries[entry.entryid] == 'undefined') {
                        offlineEntries[entry.entryid] = [];
                    }
                    offlineEntries[entry.entryid].push(entry);
                });
                var promises = _this.utils.objectToArray(offlineEntries).map(function (entryActions) {
                    return _this.syncEntry(data, entryActions, result, siteId);
                });
                return Promise.all(promises);
            }).then(function () {
                if (result.updated) {
                    // Data has been sent to server. Now invalidate the WS calls.
                    return _this.dataProvider.invalidateContent(data.cmid, courseId, siteId).catch(function () {
                        // Ignore errors.
                    });
                }
            });
        }).then(function () {
            // Sync finished, set sync time.
            return _this.setSyncTime(dataId, siteId);
        }).then(function () {
            return result;
        });
        return this.addOngoingSync(dataId, syncPromise, siteId);
    };
    /**
     * Synchronize an entry.
     *
     * @param {any} data Database.
     * @param {AddonModDataOfflineAction[]} entryActions  Entry actions.
     * @param {any} result Object with the result of the sync.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if success, rejected otherwise.
     */
    AddonModDataSyncProvider.prototype.syncEntry = function (data, entryActions, result, siteId) {
        var _this = this;
        var discardError, timePromise, entryId = entryActions[0].entryid, offlineId, deleted = false;
        var editAction = entryActions.find(function (action) { return action.action == 'add' || action.action == 'edit'; });
        var approveAction = entryActions.find(function (action) { return action.action == 'approve' || action.action == 'disapprove'; });
        var deleteAction = entryActions.find(function (action) { return action.action == 'delete'; });
        if (entryId > 0) {
            timePromise = this.dataProvider.getEntry(data.id, entryId, true, siteId).then(function (entry) {
                return entry.entry.timemodified;
            }).catch(function (error) {
                if (error && _this.utils.isWebServiceError(error)) {
                    // The WebService has thrown an error, this means the entry has been deleted.
                    return Promise.resolve(-1);
                }
                return Promise.reject(error);
            });
        }
        else if (editAction) {
            // New entry.
            offlineId = entryId;
            timePromise = Promise.resolve(0);
        }
        else {
            // New entry but the add action is missing, discard.
            timePromise = Promise.resolve(-1);
        }
        return timePromise.then(function (timemodified) {
            if (timemodified < 0 || timemodified >= entryActions[0].timemodified) {
                // The entry was not found in Moodle or the entry has been modified, discard the action.
                result.updated = true;
                discardError = _this.translate.instant('addon.mod_data.warningsubmissionmodified');
                return _this.dataOffline.deleteAllEntryActions(data.id, entryId, siteId);
            }
            if (deleteAction) {
                return _this.dataProvider.deleteEntryOnline(entryId, siteId).then(function () {
                    deleted = true;
                }).catch(function (error) {
                    if (error && _this.utils.isWebServiceError(error)) {
                        // The WebService has thrown an error, this means it cannot be performed. Discard.
                        discardError = _this.textUtils.getErrorMessageFromError(error);
                    }
                    else {
                        // Couldn't connect to server, reject.
                        return Promise.reject(error);
                    }
                }).then(function () {
                    // Delete the offline data.
                    result.updated = true;
                    return _this.dataOffline.deleteAllEntryActions(deleteAction.dataid, deleteAction.entryid, siteId);
                });
            }
            var editPromise;
            if (editAction) {
                editPromise = Promise.all(editAction.fields.map(function (field) {
                    // Upload Files if asked.
                    var value = _this.textUtils.parseJSON(field.value);
                    if (value.online || value.offline) {
                        var files_1 = value.online || [];
                        var fileProm = value.offline ?
                            _this.dataHelper.getStoredFiles(editAction.dataid, entryId, field.fieldid) :
                            Promise.resolve([]);
                        return fileProm.then(function (offlineFiles) {
                            files_1 = files_1.concat(offlineFiles);
                            return _this.dataHelper.uploadOrStoreFiles(editAction.dataid, 0, entryId, field.fieldid, files_1, false, siteId).then(function (filesResult) {
                                field.value = JSON.stringify(filesResult);
                            });
                        });
                    }
                })).then(function () {
                    if (editAction.action == 'add') {
                        return _this.dataProvider.addEntryOnline(editAction.dataid, editAction.fields, editAction.groupid, siteId)
                            .then(function (result) {
                            entryId = result.newentryid;
                        });
                    }
                    else {
                        return _this.dataProvider.editEntryOnline(entryId, editAction.fields, siteId);
                    }
                }).catch(function (error) {
                    if (error && _this.utils.isWebServiceError(error)) {
                        // The WebService has thrown an error, this means it cannot be performed. Discard.
                        discardError = _this.textUtils.getErrorMessageFromError(error);
                    }
                    else {
                        // Couldn't connect to server, reject.
                        return Promise.reject(error);
                    }
                }).then(function () {
                    // Delete the offline data.
                    result.updated = true;
                    return _this.dataOffline.deleteEntry(editAction.dataid, editAction.entryid, editAction.action, siteId);
                });
            }
            else {
                editPromise = Promise.resolve();
            }
            if (approveAction) {
                editPromise = editPromise.then(function () {
                    return _this.dataProvider.approveEntryOnline(entryId, approveAction.action == 'approve', siteId);
                }).catch(function (error) {
                    if (error && _this.utils.isWebServiceError(error)) {
                        // The WebService has thrown an error, this means it cannot be performed. Discard.
                        discardError = _this.textUtils.getErrorMessageFromError(error);
                    }
                    else {
                        // Couldn't connect to server, reject.
                        return Promise.reject(error);
                    }
                }).then(function () {
                    // Delete the offline data.
                    result.updated = true;
                    return _this.dataOffline.deleteEntry(approveAction.dataid, approveAction.entryid, approveAction.action, siteId);
                });
            }
            return editPromise;
        }).then(function () {
            if (discardError) {
                // Submission was discarded, add a warning.
                var message = _this.translate.instant('core.warningofflinedatadeleted', {
                    component: _this.componentTranslate,
                    name: data.name,
                    error: discardError
                });
                if (result.warnings.indexOf(message) == -1) {
                    result.warnings.push(message);
                }
            }
            // Sync done. Send event.
            _this.eventsProvider.trigger(AddonModDataSyncProvider_1.AUTO_SYNCED, {
                dataId: data.id,
                entryId: entryId,
                offlineEntryId: offlineId,
                warnings: result.warnings,
                deleted: deleted
            }, siteId);
        });
    };
    /**
     * Synchronize offline ratings.
     *
     * @param {number} [cmId] Course module to be synced. If not defined, sync all databases.
     * @param {boolean} [force] Wether to force sync not depending on last execution.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if sync is successful, rejected otherwise.
     */
    AddonModDataSyncProvider.prototype.syncRatings = function (cmId, force, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.ratingSync.syncRatings('mod_data', 'entry', 'module', cmId, 0, force, siteId).then(function (results) {
            var updated = false;
            var warnings = [];
            var promises = [];
            results.forEach(function (result) {
                promises.push(_this.dataProvider.getDatabase(result.itemSet.courseId, result.itemSet.instanceId, siteId)
                    .then(function (data) {
                    var promises = [];
                    if (result.updated.length) {
                        updated = true;
                        // Invalidate entry of updated ratings.
                        result.updated.forEach(function (itemId) {
                            promises.push(_this.dataProvider.invalidateEntryData(data.id, itemId, siteId));
                        });
                    }
                    if (result.warnings.length) {
                        result.warnings.forEach(function (warning) {
                            warnings.push(_this.translate.instant('core.warningofflinedatadeleted', {
                                component: _this.componentTranslate,
                                name: data.name,
                                error: warning
                            }));
                        });
                    }
                    return _this.utils.allPromises(promises);
                }));
            });
            return Promise.all(promises).then(function () {
                return { updated: updated, warnings: warnings };
            });
        });
    };
    AddonModDataSyncProvider.AUTO_SYNCED = 'addon_mod_data_autom_synced';
    AddonModDataSyncProvider = AddonModDataSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_8__offline__["a" /* AddonModDataOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_11__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_9__data__["a" /* AddonModDataProvider */],
            __WEBPACK_IMPORTED_MODULE_12__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_13__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_15__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__helper__["a" /* AddonModDataHelperProvider */], __WEBPACK_IMPORTED_MODULE_14__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_16__core_rating_providers_sync__["a" /* CoreRatingSyncProvider */]])
    ], AddonModDataSyncProvider);
    return AddonModDataSyncProvider;
    var AddonModDataSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_3__classes_base_sync__["a" /* CoreSyncBaseProvider */]));

//# sourceMappingURL=sync.js.map

/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Service that provides some features for folder.
 */
var AddonModFolderProvider = /** @class */ (function () {
    function AddonModFolderProvider(logger, sitesProvider, courseProvider, utils, logHelper) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.utils = utils;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModFolder:';
        this.logger = logger.getInstance('AddonModFolderProvider');
    }
    AddonModFolderProvider_1 = AddonModFolderProvider;
    /**
     * Get a folder by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId     Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the book is retrieved.
     */
    AddonModFolderProvider.prototype.getFolder = function (courseId, cmId, siteId) {
        return this.getFolderByKey(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Get a folder.
     *
     * @param {number} courseId  Course ID.
     * @param {string} key       Name of the property to check.
     * @param {any}  value     Value to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}          Promise resolved when the book is retrieved.
     */
    AddonModFolderProvider.prototype.getFolderByKey = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getFolderCacheKey(courseId),
                updateFrequency: __WEBPACK_IMPORTED_MODULE_6__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
            };
            return site.read('mod_folder_get_folders_by_courses', params, preSets).then(function (response) {
                if (response && response.folders) {
                    var currentFolder = response.folders.find(function (folder) {
                        return folder[key] == value;
                    });
                    if (currentFolder) {
                        return currentFolder;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for folder data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModFolderProvider.prototype.getFolderCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'folder:' + courseId;
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}
     */
    AddonModFolderProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var promises = [];
        promises.push(this.invalidateFolderData(courseId, siteId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates folder data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModFolderProvider.prototype.invalidateFolderData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getFolderCacheKey(courseId));
        });
    };
    /**
     * Returns whether or not getFolder WS available or not.
     *
     * @return {boolean} If WS is avalaible.
     * @since 3.3
     */
    AddonModFolderProvider.prototype.isGetFolderWSAvailable = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('mod_folder_get_folders_by_courses');
    };
    /**
     * Report a folder as being viewed.
     *
     * @param {number} id Module ID.
     * @param {string} [name] Name of the folder.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModFolderProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            folderid: id
        };
        return this.logHelper.logSingle('mod_folder_view_folder', params, AddonModFolderProvider_1.COMPONENT, id, name, 'folder', {}, siteId);
    };
    AddonModFolderProvider.COMPONENT = 'mmaModFolder';
    AddonModFolderProvider = AddonModFolderProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModFolderProvider);
    return AddonModFolderProvider;
    var AddonModFolderProvider_1;
}());

//# sourceMappingURL=folder.js.map

/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModLessonPrefetchHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_groups__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_classes_activity_prefetch_handler__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__lesson__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__lesson_sync__ = __webpack_require__(271);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * Handler to prefetch lessons.
 */
var AddonModLessonPrefetchHandler = /** @class */ (function (_super) {
    __extends(AddonModLessonPrefetchHandler, _super);
    function AddonModLessonPrefetchHandler(translate, appProvider, utils, courseProvider, filepoolProvider, sitesProvider, domUtils, modalCtrl, groupsProvider, lessonProvider, injector) {
        var _this = _super.call(this, translate, appProvider, utils, courseProvider, filepoolProvider, sitesProvider, domUtils) || this;
        _this.modalCtrl = modalCtrl;
        _this.groupsProvider = groupsProvider;
        _this.lessonProvider = lessonProvider;
        _this.injector = injector;
        _this.name = 'AddonModLesson';
        _this.modName = 'lesson';
        _this.component = __WEBPACK_IMPORTED_MODULE_11__lesson__["a" /* AddonModLessonProvider */].COMPONENT;
        // Don't check timers to decrease positives. If a user performs some action it will be reflected in other items.
        _this.updatesNames = /^configuration$|^.*files$|^grades$|^gradeitems$|^pages$|^answers$|^questionattempts$|^pagesviewed$/;
        return _this;
    }
    /**
     * Ask password.
     *
     * @param {any} info Lesson access info.
     * @return {Promise<string>} Promise resolved with the password.
     */
    AddonModLessonPrefetchHandler.prototype.askUserPassword = function (info) {
        var _this = this;
        // Create and show the modal.
        var modal = this.modalCtrl.create('AddonModLessonPasswordModalPage');
        modal.present();
        // Wait for modal to be dismissed.
        return new Promise(function (resolve, reject) {
            modal.onDidDismiss(function (password) {
                if (typeof password != 'undefined') {
                    resolve(password);
                }
                else {
                    reject(_this.domUtils.createCanceledError());
                }
            });
        });
    };
    /**
     * Get the download size of a module.
     *
     * @param {any} module Module.
     * @param {Number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<{size: number, total: boolean}>} Promise resolved with the size and a boolean indicating if it was able
     *                                                   to calculate the total size.
     */
    AddonModLessonPrefetchHandler.prototype.getDownloadSize = function (module, courseId, single) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId();
        var lesson, password, result;
        return this.lessonProvider.getLesson(courseId, module.id, false, false, siteId).then(function (lessonData) {
            lesson = lessonData;
            // Get the lesson password if it's needed.
            return _this.getLessonPassword(lesson.id, false, true, single, siteId);
        }).then(function (data) {
            password = data.password;
            lesson = data.lesson || lesson;
            // Get intro files and media files.
            var files = lesson.mediafiles || [];
            files = files.concat(_this.getIntroFilesFromInstance(module, lesson));
            result = _this.utils.sumFileSizes(files);
            // Get the pages to calculate the size.
            return _this.lessonProvider.getPages(lesson.id, password, false, false, siteId);
        }).then(function (pages) {
            pages.forEach(function (page) {
                result.size += page.filessizetotal;
            });
            return result;
        });
    };
    /**
     * Get the lesson password if needed. If not stored, it can ask the user to enter it.
     *
     * @param {number} lessonId Lesson ID.
     * @param {boolean} [forceCache] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {boolean} [askPassword] True if we should ask for password if needed, false otherwise.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{password?: string, lesson?: any, accessInfo: any}>} Promise resolved when done.
     */
    AddonModLessonPrefetchHandler.prototype.getLessonPassword = function (lessonId, forceCache, ignoreCache, askPassword, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get access information to check if password is needed.
        return this.lessonProvider.getAccessInformation(lessonId, forceCache, ignoreCache, siteId).then(function (info) {
            if (info.preventaccessreasons && info.preventaccessreasons.length) {
                var passwordNeeded = info.preventaccessreasons.length == 1 && _this.lessonProvider.isPasswordProtected(info);
                if (passwordNeeded) {
                    // The lesson requires a password. Check if there is one in DB.
                    return _this.lessonProvider.getStoredPassword(lessonId).catch(function () {
                        // No password found.
                    }).then(function (password) {
                        if (password) {
                            return _this.validatePassword(lessonId, info, password, forceCache, ignoreCache, siteId);
                        }
                        else {
                            return Promise.reject(null);
                        }
                    }).catch(function () {
                        // No password or error validating it. Ask for it if allowed.
                        if (askPassword) {
                            return _this.askUserPassword(info).then(function (password) {
                                return _this.validatePassword(lessonId, info, password, forceCache, ignoreCache, siteId);
                            });
                        }
                        // Cannot ask for password, reject.
                        return Promise.reject(info.preventaccessreasons[0].message);
                    });
                }
                else {
                    // Lesson cannot be played, reject.
                    return Promise.reject(info.preventaccessreasons[0].message);
                }
            }
            // Password not needed.
            return { accessInfo: info };
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId The course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLessonPrefetchHandler.prototype.invalidateContent = function (moduleId, courseId) {
        // Only invalidate the data that doesn't ignore cache when prefetching.
        var promises = [];
        promises.push(this.lessonProvider.invalidateLessonData(courseId));
        promises.push(this.courseProvider.invalidateModule(moduleId));
        promises.push(this.groupsProvider.invalidateActivityAllowedGroups(moduleId));
        return Promise.all(promises);
    };
    /**
     * Invalidate WS calls needed to determine module status.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when invalidated.
     */
    AddonModLessonPrefetchHandler.prototype.invalidateModule = function (module, courseId) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId();
        // Invalidate data to determine if module is downloadable.
        return this.lessonProvider.getLesson(courseId, module.id, true, false, siteId).then(function (lesson) {
            var promises = [];
            promises.push(_this.lessonProvider.invalidateLessonData(courseId, siteId));
            promises.push(_this.lessonProvider.invalidateAccessInformation(lesson.id, siteId));
            return Promise.all(promises);
        });
    };
    /**
     * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {boolean|Promise<boolean>} Whether the module can be downloaded. The promise should never be rejected.
     */
    AddonModLessonPrefetchHandler.prototype.isDownloadable = function (module, courseId) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId();
        return this.lessonProvider.getLesson(courseId, module.id, false, false, siteId).then(function (lesson) {
            // Check if there is any prevent access reason.
            return _this.lessonProvider.getAccessInformation(lesson.id, false, false, siteId).then(function (info) {
                if (!info.canviewreports && !_this.lessonProvider.isLessonOffline(lesson)) {
                    return false;
                }
                // It's downloadable if there are no prevent access reasons or there is just 1 and it's password.
                return !info.preventaccessreasons || !info.preventaccessreasons.length ||
                    (info.preventaccessreasons.length == 1 && _this.lessonProvider.isPasswordProtected(info));
            });
        });
    };
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.
     */
    AddonModLessonPrefetchHandler.prototype.isEnabled = function () {
        return this.lessonProvider.isPluginEnabled();
    };
    /**
     * Prefetch a module.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @param {string} [dirPath] Path of the directory where to store all the content files.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonPrefetchHandler.prototype.prefetch = function (module, courseId, single, dirPath) {
        return this.prefetchPackage(module, courseId, single, this.prefetchLesson.bind(this));
    };
    /**
     * Prefetch a lesson.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} single True if we're downloading a single module, false if we're downloading a whole section.
     * @param {String} siteId Site ID.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonPrefetchHandler.prototype.prefetchLesson = function (module, courseId, single, siteId) {
        var _this = this;
        var lesson, password, accessInfo;
        return this.lessonProvider.getLesson(courseId, module.id, false, true, siteId).then(function (lessonData) {
            lesson = lessonData;
            // Get the lesson password if it's needed.
            return _this.getLessonPassword(lesson.id, false, true, single, siteId);
        }).then(function (data) {
            password = data.password;
            lesson = data.lesson || lesson;
            accessInfo = data.accessInfo;
            if (_this.lessonProvider.isLessonOffline(lesson) && !_this.lessonProvider.leftDuringTimed(accessInfo)) {
                // The user didn't left during a timed session. Call launch retake to make sure there is a started retake.
                return _this.lessonProvider.launchRetake(lesson.id, password, undefined, false, siteId).then(function () {
                    var promises = [];
                    // New data generated, update the download time and refresh the access info.
                    promises.push(_this.filepoolProvider.updatePackageDownloadTime(siteId, _this.component, module.id).catch(function () {
                        // Ignore errors.
                    }));
                    promises.push(_this.lessonProvider.getAccessInformation(lesson.id, false, true, siteId).then(function (info) {
                        accessInfo = info;
                    }));
                    return Promise.all(promises);
                });
            }
        }).then(function () {
            var promises = [], retake = accessInfo.attemptscount;
            // Download intro files and media files.
            var files = lesson.mediafiles || [];
            files = files.concat(_this.getIntroFilesFromInstance(module, lesson));
            promises.push(_this.filepoolProvider.addFilesToQueue(siteId, files, _this.component, module.id));
            // Get the list of pages.
            if (_this.lessonProvider.isLessonOffline(lesson)) {
                promises.push(_this.lessonProvider.getPages(lesson.id, password, false, true, siteId).then(function (pages) {
                    var subPromises = [];
                    var hasRandomBranch = false;
                    // Get the data for each page.
                    pages.forEach(function (data) {
                        // Check if any page has a RANDOMBRANCH jump.
                        if (!hasRandomBranch) {
                            for (var i = 0; i < data.jumps.length; i++) {
                                if (data.jumps[i] == __WEBPACK_IMPORTED_MODULE_11__lesson__["a" /* AddonModLessonProvider */].LESSON_RANDOMBRANCH) {
                                    hasRandomBranch = true;
                                    break;
                                }
                            }
                        }
                        // Get the page data. We don't pass accessInfo because we don't need to calculate the offline data.
                        subPromises.push(_this.lessonProvider.getPageData(lesson, data.page.id, password, false, true, false, true, undefined, undefined, siteId).then(function (pageData) {
                            // Download the page files.
                            var pageFiles = pageData.contentfiles || [];
                            pageData.answers.forEach(function (answer) {
                                if (answer.answerfiles && answer.answerfiles.length) {
                                    pageFiles = pageFiles.concat(answer.answerfiles);
                                }
                                if (answer.responsefiles && answer.responsefiles.length) {
                                    pageFiles = pageFiles.concat(answer.responsefiles);
                                }
                            });
                            return _this.filepoolProvider.addFilesToQueue(siteId, pageFiles, _this.component, module.id);
                        }));
                    });
                    // Prefetch the list of possible jumps for offline navigation. Do it here because we know hasRandomBranch.
                    subPromises.push(_this.lessonProvider.getPagesPossibleJumps(lesson.id, false, true, siteId).catch(function (error) {
                        if (hasRandomBranch) {
                            // The WebSevice probably failed because RANDOMBRANCH aren't supported if the user hasn't seen any page.
                            return Promise.reject(_this.translate.instant('addon.mod_lesson.errorprefetchrandombranch'));
                        }
                        else {
                            return Promise.reject(error);
                        }
                    }));
                    return Promise.all(subPromises);
                }));
                // Prefetch user timers to be able to calculate timemodified in offline.
                promises.push(_this.lessonProvider.getTimers(lesson.id, false, true, siteId).catch(function () {
                    // Ignore errors.
                }));
                // Prefetch viewed pages in last retake to calculate progress.
                promises.push(_this.lessonProvider.getContentPagesViewedOnline(lesson.id, retake, false, true, siteId));
                // Prefetch question attempts in last retake for offline calculations.
                promises.push(_this.lessonProvider.getQuestionsAttemptsOnline(lesson.id, retake, false, undefined, false, true, siteId));
            }
            if (accessInfo.canviewreports) {
                // Prefetch reports data.
                promises.push(_this.groupsProvider.getActivityAllowedGroupsIfEnabled(module.id, undefined, siteId, true)
                    .then(function (groups) {
                    var subPromises = [];
                    groups.forEach(function (group) {
                        subPromises.push(_this.lessonProvider.getRetakesOverview(lesson.id, group.id, false, true, siteId));
                    });
                    // Always get group 0, even if there are no groups.
                    subPromises.push(_this.lessonProvider.getRetakesOverview(lesson.id, 0, false, true, siteId).then(function (data) {
                        if (!data || !data.students) {
                            return;
                        }
                        // Prefetch the last retake for each user.
                        var retakePromises = [];
                        data.students.forEach(function (student) {
                            if (!student.attempts || !student.attempts.length) {
                                return;
                            }
                            var lastRetake = student.attempts[student.attempts.length - 1];
                            if (!lastRetake) {
                                return;
                            }
                            retakePromises.push(_this.lessonProvider.getUserRetake(lesson.id, lastRetake.try, student.id, false, true, siteId).then(function (attempt) {
                                if (!attempt || !attempt.answerpages) {
                                    return;
                                }
                                // Download embedded files in essays.
                                var files = [];
                                attempt.answerpages.forEach(function (answerPage) {
                                    if (answerPage.page.qtype != __WEBPACK_IMPORTED_MODULE_11__lesson__["a" /* AddonModLessonProvider */].LESSON_PAGE_ESSAY) {
                                        return;
                                    }
                                    answerPage.answerdata.answers.forEach(function (answer) {
                                        files.push.apply(files, _this.domUtils.extractDownloadableFilesFromHtmlAsFakeFileObjects(answer[0]));
                                    });
                                });
                                return _this.filepoolProvider.addFilesToQueue(siteId, files, _this.component, module.id);
                            }));
                        });
                        return Promise.all(retakePromises);
                    }));
                    return Promise.all(subPromises);
                }));
            }
            return Promise.all(promises);
        });
    };
    /**
     * Validate the password.
     *
     * @param {number} lessonId Lesson ID.
     * @param {any} info Lesson access info.
     * @param {string} pwd Password to check.
     * @param {boolean} [forceCache] Whether it should return cached data. Has priority over ignoreCache.
     * @param {boolean} [ignoreCache] Whether it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{password: string, lesson: any, accessInfo: any}>} Promise resolved when done.
     */
    AddonModLessonPrefetchHandler.prototype.validatePassword = function (lessonId, info, pwd, forceCache, ignoreCache, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.lessonProvider.getLessonWithPassword(lessonId, pwd, true, forceCache, ignoreCache, siteId).then(function (lesson) {
            // Password is ok, store it and return the data.
            return _this.lessonProvider.storePassword(lesson.id, pwd, siteId).then(function () {
                return {
                    password: pwd,
                    lesson: lesson,
                    accessInfo: info
                };
            });
        });
    };
    /**
     * Sync a module.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModLessonPrefetchHandler.prototype.sync = function (module, courseId, siteId) {
        if (!this.syncProvider) {
            this.syncProvider = this.injector.get(__WEBPACK_IMPORTED_MODULE_12__lesson_sync__["a" /* AddonModLessonSyncProvider */]);
        }
        return this.syncProvider.syncLesson(module.instance, false, false, siteId);
    };
    AddonModLessonPrefetchHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ModalController */], __WEBPACK_IMPORTED_MODULE_9__providers_groups__["a" /* CoreGroupsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__lesson__["a" /* AddonModLessonProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */]])
    ], AddonModLessonPrefetchHandler);
    return AddonModLessonPrefetchHandler;
}(__WEBPACK_IMPORTED_MODULE_10__core_course_classes_activity_prefetch_handler__["a" /* CoreCourseActivityPrefetchHandlerBase */]));

//# sourceMappingURL=prefetch-handler.js.map

/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModLtiProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_providers_log_helper__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__classes_site__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Service that provides some features for LTI.
 */
var AddonModLtiProvider = /** @class */ (function () {
    function AddonModLtiProvider(fileProvider, sitesProvider, textUtils, urlUtils, utils, translate, appProvider, logHelper) {
        this.fileProvider = fileProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.urlUtils = urlUtils;
        this.utils = utils;
        this.translate = translate;
        this.appProvider = appProvider;
        this.logHelper = logHelper;
        this.ROOT_CACHE_KEY = 'mmaModLti:';
        this.LAUNCHER_FILE_NAME = 'lti_launcher.html';
    }
    AddonModLtiProvider_1 = AddonModLtiProvider;
    /**
     * Delete launcher.
     *
     * @return {Promise<any>} Promise resolved when the launcher file is deleted.
     */
    AddonModLtiProvider.prototype.deleteLauncher = function () {
        return this.fileProvider.removeFile(this.LAUNCHER_FILE_NAME);
    };
    /**
     * Generates a launcher file.
     *
     * @param {string} url Launch URL.
     * @param {AddonModLtiParam[]} params Launch params.
     * @return {Promise<string>} Promise resolved with the file URL.
     */
    AddonModLtiProvider.prototype.generateLauncher = function (url, params) {
        var _this = this;
        if (!this.fileProvider.isAvailable()) {
            return Promise.resolve(url);
        }
        // Generate a form with the params.
        var text = '<form action="' + url + '" name="ltiLaunchForm" ' +
            'method="post" encType="application/x-www-form-urlencoded">\n';
        params.forEach(function (p) {
            if (p.name == 'ext_submit') {
                text += '    <input type="submit"';
            }
            else {
                text += '    <input type="hidden" name="' + _this.textUtils.escapeHTML(p.name) + '"';
            }
            text += ' value="' + _this.textUtils.escapeHTML(p.value) + '"/>\n';
        });
        text += '</form>\n';
        // Add an in-line script to automatically submit the form.
        text += '<script type="text/javascript"> \n' +
            '    window.onload = function() { \n' +
            '        document.ltiLaunchForm.submit(); \n' +
            '    }; \n' +
            '</script> \n';
        return this.fileProvider.writeFile(this.LAUNCHER_FILE_NAME, text).then(function (entry) {
            if (_this.appProvider.isDesktop()) {
                return entry.toInternalURL();
            }
            else {
                return entry.toURL();
            }
        });
    };
    /**
     * Get a LTI.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId Course module ID.
     * @return {Promise<any>} Promise resolved when the LTI is retrieved.
     */
    AddonModLtiProvider.prototype.getLti = function (courseId, cmId) {
        var params = {
            courseids: [courseId]
        };
        var preSets = {
            cacheKey: this.getLtiCacheKey(courseId),
            updateFrequency: __WEBPACK_IMPORTED_MODULE_9__classes_site__["a" /* CoreSite */].FREQUENCY_RARELY
        };
        return this.sitesProvider.getCurrentSite().read('mod_lti_get_ltis_by_courses', params, preSets).then(function (response) {
            if (response.ltis) {
                var currentLti = response.ltis.find(function (lti) { return lti.coursemodule == cmId; });
                if (currentLti) {
                    return currentLti;
                }
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get cache key for LTI data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModLtiProvider.prototype.getLtiCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'lti:' + courseId;
    };
    /**
     * Get a LTI launch data.
     *
     * @param {number} id LTI id.
     * @return {Promise<any>} Promise resolved when the launch data is retrieved.
     */
    AddonModLtiProvider.prototype.getLtiLaunchData = function (id) {
        var params = {
            toolid: id
        };
        // Try to avoid using cache since the "nonce" parameter is set to a timestamp.
        var preSets = {
            getFromCache: false,
            saveToCache: true,
            emergencyCache: true,
            cacheKey: this.getLtiLaunchDataCacheKey(id)
        };
        return this.sitesProvider.getCurrentSite().read('mod_lti_get_tool_launch_data', params, preSets).then(function (response) {
            if (response.endpoint) {
                return response;
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get cache key for LTI launch data WS calls.
     *
     * @param {number} id LTI id.
     * @return {string} Cache key.
     */
    AddonModLtiProvider.prototype.getLtiLaunchDataCacheKey = function (id) {
        return this.ROOT_CACHE_KEY + 'launch:' + id;
    };
    /**
     * Invalidates LTI data.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLtiProvider.prototype.invalidateLti = function (courseId) {
        return this.sitesProvider.getCurrentSite().invalidateWsCacheForKey(this.getLtiCacheKey(courseId));
    };
    /**
     * Invalidates options.
     *
     * @param {number} id LTI id.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModLtiProvider.prototype.invalidateLtiLaunchData = function (id) {
        return this.sitesProvider.getCurrentSite().invalidateWsCacheForKey(this.getLtiLaunchDataCacheKey(id));
    };
    /**
     * Launch LTI.
     *
     * @param {string} url Launch URL.
     * @param {AddonModLtiParam[]} params Launch params.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModLtiProvider.prototype.launch = function (url, params) {
        var _this = this;
        if (!this.urlUtils.isHttpURL(url)) {
            return Promise.reject(this.translate.instant('addon.mod_lti.errorinvalidlaunchurl'));
        }
        // Generate launcher and open it.
        return this.generateLauncher(url, params).then(function (url) {
            _this.utils.openInApp(url);
        });
    };
    /**
     * Report the LTI as being viewed.
     *
     * @param {string} id LTI id.
     * @param {string} [name] Name of the lti.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModLtiProvider.prototype.logView = function (id, name, siteId) {
        var params = {
            ltiid: id
        };
        return this.logHelper.logSingle('mod_lti_view_lti', params, AddonModLtiProvider_1.COMPONENT, id, name, 'lti', {}, siteId);
    };
    AddonModLtiProvider.COMPONENT = 'mmaModLti';
    AddonModLtiProvider = AddonModLtiProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_8__core_course_providers_log_helper__["a" /* CoreCourseLogHelperProvider */]])
    ], AddonModLtiProvider);
    return AddonModLtiProvider;
    var AddonModLtiProvider_1;
}());

//# sourceMappingURL=lti.js.map

/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPageHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__page__ = __webpack_require__(221);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_file__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__angular_http__ = __webpack_require__(229);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service that provides some features for page.
 */
var AddonModPageHelperProvider = /** @class */ (function () {
    function AddonModPageHelperProvider(logger, domUtils, filepoolProvider, fileProvider, textUtils, http, sitesProvider) {
        this.domUtils = domUtils;
        this.filepoolProvider = filepoolProvider;
        this.fileProvider = fileProvider;
        this.textUtils = textUtils;
        this.http = http;
        this.sitesProvider = sitesProvider;
        this.logger = logger.getInstance('AddonModPageHelperProvider');
    }
    /**
     * Gets the page HTML.
     *
     * @param {any} contents The module contents.
     * @param {number} moduleId The module ID.
     * @return {Promise<string>} The HTML of the page.
     */
    AddonModPageHelperProvider.prototype.getPageHtml = function (contents, moduleId) {
        var _this = this;
        var indexUrl, promise;
        var paths = {};
        // Extract the information about paths from the module contents.
        contents.forEach(function (content) {
            var url = content.fileurl;
            if (_this.isMainPage(content)) {
                // This seems to be the most reliable way to spot the index page.
                indexUrl = url;
            }
            else {
                var key = content.filename;
                if (content.filepath !== '/') {
                    // Add the folders without the leading slash.
                    key = content.filepath.substr(1) + key;
                }
                paths[_this.textUtils.decodeURIComponent(key)] = url;
            }
        });
        // Promise handling when we are in a browser.
        if (!indexUrl) {
            // If ever that happens.
            this.logger.debug('Could not locate the index page');
            promise = Promise.reject(null);
        }
        else if (this.fileProvider.isAvailable()) {
            // The file system is available.
            promise = this.filepoolProvider.downloadUrl(this.sitesProvider.getCurrentSiteId(), indexUrl, false, __WEBPACK_IMPORTED_MODULE_5__page__["a" /* AddonModPageProvider */].COMPONENT, moduleId);
        }
        else {
            // We return the live URL.
            promise = Promise.resolve(this.sitesProvider.getCurrentSite().fixPluginfileURL(indexUrl));
        }
        return promise.then(function (url) {
            // Fetch the URL content.
            var promise = _this.http.get(url).toPromise();
            return promise.then(function (response) {
                var content = response.text();
                if (typeof content !== 'string') {
                    return Promise.reject(null);
                }
                // Now that we have the content, we update the SRC to point back to the external resource.
                // That will be caught by core-format-text.
                return _this.domUtils.restoreSourcesInHtml(content, paths);
            });
        });
    };
    /**
     * Returns whether the file is the main page of the module.
     *
     * @param {any} file An object returned from WS containing file info.
     * @return {boolean}  Whether the file is the main page or not.
     */
    AddonModPageHelperProvider.prototype.isMainPage = function (file) {
        var filename = file.filename || '', fileurl = file.fileurl || '', url = '/mod_page/content/index.html', encodedUrl = encodeURIComponent(url);
        return (filename === 'index.html' && (fileurl.indexOf(url) > 0 || fileurl.indexOf(encodedUrl) > 0));
    };
    AddonModPageHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_8__angular_http__["d" /* Http */],
            __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonModPageHelperProvider);
    return AddonModPageHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModQuizPrefetchHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_dom__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_course__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_question_providers_helper__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_classes_activity_prefetch_handler__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__quiz__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__helper__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__access_rules_delegate__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__quiz_sync__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_constants__ = __webpack_require__(39);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
















/**
 * Handler to prefetch quizzes.
 */
var AddonModQuizPrefetchHandler = /** @class */ (function (_super) {
    __extends(AddonModQuizPrefetchHandler, _super);
    function AddonModQuizPrefetchHandler(translate, appProvider, utils, courseProvider, filepoolProvider, sitesProvider, domUtils, injector, quizProvider, textUtils, quizHelper, accessRuleDelegate, questionHelper) {
        var _this = _super.call(this, translate, appProvider, utils, courseProvider, filepoolProvider, sitesProvider, domUtils) || this;
        _this.injector = injector;
        _this.quizProvider = quizProvider;
        _this.textUtils = textUtils;
        _this.quizHelper = quizHelper;
        _this.accessRuleDelegate = accessRuleDelegate;
        _this.questionHelper = questionHelper;
        _this.name = 'AddonModQuiz';
        _this.modName = 'quiz';
        _this.component = __WEBPACK_IMPORTED_MODULE_11__quiz__["a" /* AddonModQuizProvider */].COMPONENT;
        _this.updatesNames = /^configuration$|^.*files$|^grades$|^gradeitems$|^questions$|^attempts$/;
        return _this;
    }
    /**
     * Download the module.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {string} [dirPath] Path of the directory where to store all the content files.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @param {boolean} [canStart=true] If true, start a new attempt if needed.
     * @return {Promise<any>} Promise resolved when all content is downloaded.
     */
    AddonModQuizPrefetchHandler.prototype.download = function (module, courseId, dirPath, single, canStart) {
        if (canStart === void 0) { canStart = true; }
        // Same implementation for download and prefetch.
        return this.prefetch(module, courseId, single, dirPath, canStart);
    };
    /**
     * Get list of files. If not defined, we'll assume they're in module.contents.
     *
     * @param {any} module Module.
     * @param {Number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    AddonModQuizPrefetchHandler.prototype.getFiles = function (module, courseId, single) {
        var _this = this;
        return this.quizProvider.getQuiz(courseId, module.id).then(function (quiz) {
            var files = _this.getIntroFilesFromInstance(module, quiz);
            return _this.quizProvider.getUserAttempts(quiz.id, 'all', true, false, true).then(function (attempts) {
                return _this.getAttemptsFeedbackFiles(quiz, attempts).then(function (attemptFiles) {
                    return files.concat(attemptFiles);
                });
            });
        }).catch(function () {
            // Quiz not found, return empty list.
            return [];
        });
    };
    /**
     * Get the list of downloadable files on feedback attemptss.
     *
     * @param  {any}   quiz     Quiz.
     * @param  {any[]} attempts Quiz user attempts.
     * @return {Promise<any[]>} List of Files.
     */
    AddonModQuizPrefetchHandler.prototype.getAttemptsFeedbackFiles = function (quiz, attempts) {
        var _this = this;
        // We have quiz data, now we'll get specific data for each attempt.
        var promises = [], getInlineFiles = this.sitesProvider.getCurrentSite().isVersionGreaterEqualThan('3.2');
        var files = [];
        attempts.forEach(function (attempt) {
            if (_this.quizProvider.isAttemptFinished(attempt.state)) {
                // Attempt is finished, get feedback and review data.
                var attemptGrade = _this.quizProvider.rescaleGrade(attempt.sumgrades, quiz, false);
                if (typeof attemptGrade != 'undefined') {
                    promises.push(_this.quizProvider.getFeedbackForGrade(quiz.id, Number(attemptGrade), true)
                        .then(function (feedback) {
                        if (getInlineFiles && feedback.feedbackinlinefiles && feedback.feedbackinlinefiles.length) {
                            files = files.concat(feedback.feedbackinlinefiles);
                        }
                        else if (feedback.feedbacktext && !getInlineFiles) {
                            files = files.concat(_this.domUtils.extractDownloadableFilesFromHtmlAsFakeFileObjects(feedback.feedbacktext));
                        }
                    }));
                }
            }
        });
        return Promise.all(promises).then(function () {
            return files;
        });
    };
    /**
     * Gather some preflight data for an attempt. This function will start a new attempt if needed.
     *
     * @param {any} quiz Quiz.
     * @param {any} accessInfo Quiz access info returned by AddonModQuizProvider.getQuizAccessInformation.
     * @param {any} [attempt] Attempt to continue. Don't pass any value if the user needs to start a new attempt.
     * @param {boolean} [askPreflight] Whether it should ask for preflight data if needed.
     * @param {string} [modalTitle] Lang key of the title to set to preflight modal (e.g. 'addon.mod_quiz.startattempt').
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the preflight data.
     */
    AddonModQuizPrefetchHandler.prototype.getPreflightData = function (quiz, accessInfo, attempt, askPreflight, title, siteId) {
        var _this = this;
        var preflightData = {};
        var promise;
        if (askPreflight) {
            // We can ask preflight, check if it's needed and get the data.
            promise = this.quizHelper.getAndCheckPreflightData(quiz, accessInfo, preflightData, attempt, false, true, title, siteId);
        }
        else {
            // Get some fixed preflight data from access rules (data that doesn't require user interaction).
            var rules = accessInfo.activerulenames;
            promise = this.accessRuleDelegate.getFixedPreflightData(rules, quiz, preflightData, attempt, true, siteId).then(function () {
                if (!attempt) {
                    // We need to create a new attempt.
                    return _this.quizProvider.startAttempt(quiz.id, preflightData, false, siteId);
                }
            });
        }
        return promise.then(function () {
            return preflightData;
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId The course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModQuizPrefetchHandler.prototype.invalidateContent = function (moduleId, courseId) {
        return this.quizProvider.invalidateContent(moduleId, courseId);
    };
    /**
     * Invalidate WS calls needed to determine module status.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when invalidated.
     */
    AddonModQuizPrefetchHandler.prototype.invalidateModule = function (module, courseId) {
        // Invalidate the calls required to check if a quiz is downloadable.
        var promises = [];
        promises.push(this.quizProvider.invalidateQuizData(courseId));
        promises.push(this.quizProvider.invalidateUserAttemptsForUser(module.instance));
        return Promise.all(promises);
    };
    /**
     * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {boolean|Promise<boolean>} Whether the module can be downloaded. The promise should never be rejected.
     */
    AddonModQuizPrefetchHandler.prototype.isDownloadable = function (module, courseId) {
        var _this = this;
        if (this.sitesProvider.getCurrentSite().isOfflineDisabled()) {
            // Don't allow downloading the quiz if offline is disabled to prevent wasting a lot of data when opening it.
            return false;
        }
        var siteId = this.sitesProvider.getCurrentSiteId();
        return this.quizProvider.getQuiz(courseId, module.id, false, false, siteId).then(function (quiz) {
            if (quiz.allowofflineattempts !== 1 || quiz.hasquestions === 0) {
                return false;
            }
            // Not downloadable if we reached max attempts or the quiz has an unfinished attempt.
            return _this.quizProvider.getUserAttempts(quiz.id, undefined, true, false, false, siteId).then(function (attempts) {
                var isLastFinished = !attempts.length || _this.quizProvider.isAttemptFinished(attempts[attempts.length - 1].state);
                return quiz.attempts === 0 || quiz.attempts > attempts.length || !isLastFinished;
            });
        });
    };
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.
     */
    AddonModQuizPrefetchHandler.prototype.isEnabled = function () {
        return this.quizProvider.isPluginEnabled();
    };
    /**
     * Prefetch a module.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @param {string} [dirPath] Path of the directory where to store all the content files.
     * @param {boolean} [canStart=true] If true, start a new attempt if needed.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModQuizPrefetchHandler.prototype.prefetch = function (module, courseId, single, dirPath, canStart) {
        if (canStart === void 0) { canStart = true; }
        if (module.attemptFinished) {
            // Delete the value so it does not block anything if true.
            delete module.attemptFinished;
            // Quiz got synced recently and an attempt has finished. Do not prefetch.
            return Promise.resolve();
        }
        return this.prefetchPackage(module, courseId, single, this.prefetchQuiz.bind(this), undefined, canStart);
    };
    /**
     * Prefetch a quiz.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} single True if we're downloading a single module, false if we're downloading a whole section.
     * @param {String} siteId Site ID.
     * @param {boolean} canStart If true, start a new attempt if needed.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModQuizPrefetchHandler.prototype.prefetchQuiz = function (module, courseId, single, siteId, canStart) {
        var _this = this;
        var attempts, startAttempt = false, quiz, quizAccessInfo, attemptAccessInfo, preflightData;
        // Get quiz.
        return this.quizProvider.getQuiz(courseId, module.id, false, true, siteId).then(function (quizData) {
            quiz = quizData;
            var promises = [], introFiles = _this.getIntroFilesFromInstance(module, quiz);
            // Prefetch some quiz data.
            promises.push(_this.quizProvider.getQuizAccessInformation(quiz.id, false, true, siteId).then(function (info) {
                quizAccessInfo = info;
            }));
            promises.push(_this.quizProvider.getQuizRequiredQtypes(quiz.id, true, siteId));
            promises.push(_this.quizProvider.getUserAttempts(quiz.id, 'all', true, false, true, siteId).then(function (atts) {
                attempts = atts;
                return _this.getAttemptsFeedbackFiles(quiz, attempts).then(function (attemptFiles) {
                    return _this.filepoolProvider.addFilesToQueue(siteId, attemptFiles, __WEBPACK_IMPORTED_MODULE_11__quiz__["a" /* AddonModQuizProvider */].COMPONENT, module.id);
                });
            }));
            promises.push(_this.quizProvider.getAttemptAccessInformation(quiz.id, 0, false, true, siteId).then(function (info) {
                attemptAccessInfo = info;
            }));
            promises.push(_this.filepoolProvider.addFilesToQueue(siteId, introFiles, __WEBPACK_IMPORTED_MODULE_11__quiz__["a" /* AddonModQuizProvider */].COMPONENT, module.id));
            return Promise.all(promises);
        }).then(function () {
            // Check if we need to start a new attempt.
            var attempt = attempts[attempts.length - 1];
            if (!canStart && !attempt) {
                // No attempts and we won't start a new one, so we don't need preflight data.
                return;
            }
            if (canStart && (!attempt || _this.quizProvider.isAttemptFinished(attempt.state))) {
                // Check if the user can attempt the quiz.
       